<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>What I Wish I Knew When Learning Haskell 2.5 ( Stephen Diehl )</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
        
    <link href="http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,700|Source+Code+Pro" rel="stylesheet">
    <style type="text/css">
      
    </style>

          <style type="text/css">
    html { -webkit-text-size-adjust: 100%; }
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {  background-color: #f8f8f8; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ef2929; } /* Alert */
    code span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #204a87; } /* Attribute */
    code span.bn { color: #0000cf; } /* BaseN */
    code span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4e9a06; } /* Char */
    code span.cn { color: #8f5902; } /* Constant */
    code span.co { color: #8f5902; font-style: italic; } /* Comment */
    code span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
    code span.dt { color: #204a87; } /* DataType */
    code span.dv { color: #0000cf; } /* DecVal */
    code span.er { color: #a40000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #0000cf; } /* Float */
    code span.fu { color: #204a87; font-weight: bold; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #204a87; font-weight: bold; } /* Keyword */
    code span.op { color: #ce5c00; font-weight: bold; } /* Operator */
    code span.ot { color: #8f5902; } /* Other */
    code span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
    code span.sc { color: #ce5c00; font-weight: bold; } /* SpecialChar */
    code span.ss { color: #4e9a06; } /* SpecialString */
    code span.st { color: #4e9a06; } /* String */
    code span.va { color: #000000; } /* Variable */
    code span.vs { color: #4e9a06; } /* VerbatimString */
    code span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
      </style>
    
        <link rel="stylesheet" href="css/style.css" />
        <link rel="stylesheet" href="css/layout.css" />
    
          </head>

  <body itemscope itemtype="http://schema.org/TechArticle">
    <div id="sidebar-wrapper">
      <a href="http://dev.stephendiehl.com/hask/" class="logo">
        <img src="img/haskell_logo.svg" alt="Haskell Logo">
      </a>
      <button id="toggle-sidebar">
        Menu
      </button>
      <ul class="sidebar-nav">
<ul>
<li><a href="#basics" id="toc-basics">Basics</a>
<ul>
<li><a href="#what-is-haskell" id="toc-what-is-haskell">What is
Haskell?</a></li>
<li><a href="#how-to-read" id="toc-how-to-read">How to Read</a></li>
<li><a href="#ghc" id="toc-ghc">GHC</a></li>
<li><a href="#ghcup" id="toc-ghcup">ghcup</a></li>
<li><a href="#package-managers" id="toc-package-managers">Package
Managers</a></li>
<li><a href="#project-structure" id="toc-project-structure">Project
Structure</a></li>
<li><a href="#cabal" id="toc-cabal">Cabal</a></li>
<li><a href="#cabal-new-build" id="toc-cabal-new-build">Cabal
New-Build</a></li>
<li><a href="#local-packages" id="toc-local-packages">Local
Packages</a></li>
<li><a href="#version-bounds" id="toc-version-bounds">Version
Bounds</a></li>
<li><a href="#stack" id="toc-stack">Stack</a></li>
<li><a href="#hpack" id="toc-hpack">Hpack</a></li>
<li><a href="#base" id="toc-base">Base</a></li>
<li><a href="#prelude" id="toc-prelude">Prelude</a></li>
<li><a href="#modern-haskell" id="toc-modern-haskell">Modern
Haskell</a></li>
<li><a href="#flags" id="toc-flags">Flags</a></li>
<li><a href="#hackage" id="toc-hackage">Hackage</a></li>
<li><a href="#stackage" id="toc-stackage">Stackage</a></li>
<li><a href="#ghci" id="toc-ghci">GHCi</a></li>
<li><a href="#ghci.conf" id="toc-ghci.conf">.ghci.conf</a></li>
<li><a href="#editor-integration" id="toc-editor-integration">Editor
Integration</a></li>
<li><a href="#linux-packages" id="toc-linux-packages">Linux
Packages</a></li>
<li><a href="#names" id="toc-names">Names</a></li>
<li><a href="#modules" id="toc-modules">Modules</a></li>
<li><a href="#functions" id="toc-functions">Functions</a></li>
<li><a href="#types" id="toc-types">Types</a></li>
<li><a href="#type-signatures" id="toc-type-signatures">Type
Signatures</a></li>
<li><a href="#currying" id="toc-currying">Currying</a></li>
<li><a href="#algebraic-datatypes"
id="toc-algebraic-datatypes">Algebraic Datatypes</a></li>
<li><a href="#lists" id="toc-lists">Lists</a></li>
<li><a href="#pattern-matching" id="toc-pattern-matching">Pattern
Matching</a></li>
<li><a href="#guards" id="toc-guards">Guards</a></li>
<li><a href="#operators-and-sections"
id="toc-operators-and-sections">Operators and Sections</a></li>
<li><a href="#tuples" id="toc-tuples">Tuples</a></li>
<li><a href="#where-let-clauses" id="toc-where-let-clauses">Where &amp;
Let Clauses</a></li>
<li><a href="#conditionals" id="toc-conditionals">Conditionals</a></li>
<li><a href="#function-composition"
id="toc-function-composition">Function Composition</a></li>
<li><a href="#list-comprehensions" id="toc-list-comprehensions">List
Comprehensions</a></li>
<li><a href="#comments" id="toc-comments">Comments</a></li>
<li><a href="#typeclasses" id="toc-typeclasses">Typeclasses</a></li>
<li><a href="#side-effects" id="toc-side-effects">Side Effects</a></li>
<li><a href="#records" id="toc-records">Records</a></li>
<li><a href="#pragmas" id="toc-pragmas">Pragmas</a></li>
<li><a href="#newtypes" id="toc-newtypes">Newtypes</a></li>
<li><a href="#bottoms" id="toc-bottoms">Bottoms</a></li>
<li><a href="#exhaustiveness"
id="toc-exhaustiveness">Exhaustiveness</a></li>
<li><a href="#debugger" id="toc-debugger">Debugger</a></li>
<li><a href="#stack-traces" id="toc-stack-traces">Stack Traces</a></li>
<li><a href="#printf-tracing" id="toc-printf-tracing">Printf
Tracing</a></li>
<li><a href="#type-inference" id="toc-type-inference">Type
Inference</a></li>
<li><a href="#type-holes" id="toc-type-holes">Type Holes</a></li>
<li><a href="#deferred-type-errors"
id="toc-deferred-type-errors">Deferred Type Errors</a></li>
<li><a href="#name-conventions" id="toc-name-conventions">Name
Conventions</a></li>
<li><a href="#ghcid" id="toc-ghcid">ghcid</a></li>
<li><a href="#hlint" id="toc-hlint">HLint</a></li>
<li><a href="#docker-images" id="toc-docker-images">Docker
Images</a></li>
<li><a href="#continuous-integration"
id="toc-continuous-integration">Continuous Integration</a></li>
<li><a href="#ormolu" id="toc-ormolu">Ormolu</a></li>
<li><a href="#haddock" id="toc-haddock">Haddock</a></li>
<li><a href="#unsafe-functions" id="toc-unsafe-functions">Unsafe
Functions</a></li>
</ul></li>
<li><a href="#monads" id="toc-monads">Monads</a>
<ul>
<li><a href="#eightfold-path-to-monad-satori"
id="toc-eightfold-path-to-monad-satori">Eightfold Path to Monad
Satori</a></li>
<li><a href="#monad-myths" id="toc-monad-myths">Monad Myths</a></li>
<li><a href="#monad-methods" id="toc-monad-methods">Monad
Methods</a></li>
<li><a href="#monad-laws" id="toc-monad-laws">Monad Laws</a></li>
<li><a href="#do-notation" id="toc-do-notation">Do Notation</a></li>
<li><a href="#maybe-monad" id="toc-maybe-monad">Maybe Monad</a></li>
<li><a href="#list-monad" id="toc-list-monad">List Monad</a></li>
<li><a href="#io-monad" id="toc-io-monad">IO Monad</a></li>
<li><a href="#whats-the-point" id="toc-whats-the-point">What’s the
point?</a></li>
<li><a href="#reader-monad" id="toc-reader-monad">Reader Monad</a></li>
<li><a href="#writer-monad" id="toc-writer-monad">Writer Monad</a></li>
<li><a href="#state-monad" id="toc-state-monad">State Monad</a></li>
<li><a href="#why-are-monads-confusing"
id="toc-why-are-monads-confusing">Why are monads confusing?</a></li>
</ul></li>
<li><a href="#monad-transformers" id="toc-monad-transformers">Monad
Transformers</a>
<ul>
<li><a href="#mtl-transformers" id="toc-mtl-transformers">mtl /
transformers</a></li>
<li><a href="#transformers" id="toc-transformers">Transformers</a></li>
<li><a href="#basics-1" id="toc-basics-1">Basics</a></li>
<li><a href="#mtl" id="toc-mtl">mtl</a></li>
<li><a href="#readert" id="toc-readert">ReaderT</a></li>
<li><a href="#newtype-deriving" id="toc-newtype-deriving">Newtype
Deriving</a></li>
<li><a href="#efficiency" id="toc-efficiency">Efficiency</a></li>
<li><a href="#monad-morphisms" id="toc-monad-morphisms">Monad
Morphisms</a></li>
<li><a href="#effect-systems" id="toc-effect-systems">Effect
Systems</a></li>
<li><a href="#polysemy" id="toc-polysemy">Polysemy</a></li>
<li><a href="#fused-effects" id="toc-fused-effects">Fused
Effects</a></li>
</ul></li>
<li><a href="#language-extensions" id="toc-language-extensions">Language
Extensions</a>
<ul>
<li><a href="#philosophy" id="toc-philosophy">Philosophy</a></li>
<li><a href="#classes" id="toc-classes">Classes</a></li>
<li><a href="#extension-dependencies"
id="toc-extension-dependencies">Extension Dependencies</a></li>
<li><a href="#the-benign" id="toc-the-benign">The Benign</a></li>
<li><a href="#the-advanced" id="toc-the-advanced">The Advanced</a></li>
<li><a href="#the-lowlevel" id="toc-the-lowlevel">The Lowlevel</a></li>
<li><a href="#the-dangerous" id="toc-the-dangerous">The
Dangerous</a></li>
<li><a href="#nomonomorphismrestriction"
id="toc-nomonomorphismrestriction">NoMonomorphismRestriction</a></li>
<li><a href="#extendeddefaultrules"
id="toc-extendeddefaultrules">ExtendedDefaultRules</a></li>
<li><a href="#safe-haskell" id="toc-safe-haskell">Safe Haskell</a></li>
<li><a href="#partialtypesignatures"
id="toc-partialtypesignatures">PartialTypeSignatures</a></li>
<li><a href="#recursivedo" id="toc-recursivedo">RecursiveDo</a></li>
<li><a href="#applicativedo"
id="toc-applicativedo">ApplicativeDo</a></li>
<li><a href="#patternguards"
id="toc-patternguards">PatternGuards</a></li>
<li><a href="#viewpatterns" id="toc-viewpatterns">ViewPatterns</a></li>
<li><a href="#tuplesections"
id="toc-tuplesections">TupleSections</a></li>
<li><a href="#postfix-operators" id="toc-postfix-operators">Postfix
Operators</a></li>
<li><a href="#multiwayif" id="toc-multiwayif">MultiWayIf</a></li>
<li><a href="#emptycase" id="toc-emptycase">EmptyCase</a></li>
<li><a href="#lambdacase" id="toc-lambdacase">LambdaCase</a></li>
<li><a href="#numdecimals" id="toc-numdecimals">NumDecimals</a></li>
<li><a href="#packageimports"
id="toc-packageimports">PackageImports</a></li>
<li><a href="#recordwildcards"
id="toc-recordwildcards">RecordWildCards</a></li>
<li><a href="#namedfieldpuns"
id="toc-namedfieldpuns">NamedFieldPuns</a></li>
<li><a href="#patternsynonyms"
id="toc-patternsynonyms">PatternSynonyms</a></li>
<li><a href="#derivefunctor"
id="toc-derivefunctor">DeriveFunctor</a></li>
<li><a href="#derivefoldable"
id="toc-derivefoldable">DeriveFoldable</a></li>
<li><a href="#derivetraversable"
id="toc-derivetraversable">DeriveTraversable</a></li>
<li><a href="#derivegeneric"
id="toc-derivegeneric">DeriveGeneric</a></li>
<li><a href="#deriveanyclass"
id="toc-deriveanyclass">DeriveAnyClass</a></li>
<li><a href="#duplicaterecordfields"
id="toc-duplicaterecordfields">DuplicateRecordFields</a></li>
<li><a href="#overloadedlabels"
id="toc-overloadedlabels">OverloadedLabels</a></li>
<li><a href="#cpp" id="toc-cpp">CPP</a></li>
<li><a href="#typeapplications"
id="toc-typeapplications">TypeApplications</a></li>
<li><a href="#derivingvia" id="toc-derivingvia">DerivingVia</a></li>
<li><a href="#derivingstrategies"
id="toc-derivingstrategies">DerivingStrategies</a></li>
<li><a href="#historical-extensions"
id="toc-historical-extensions">Historical Extensions</a></li>
</ul></li>
<li><a href="#type-class-extensions" id="toc-type-class-extensions">Type
Class Extensions</a>
<ul>
<li><a href="#standard-hierarchy" id="toc-standard-hierarchy">Standard
Hierarchy</a></li>
<li><a href="#instance-search" id="toc-instance-search">Instance
Search</a></li>
<li><a href="#orphan-instances" id="toc-orphan-instances">Orphan
Instances</a></li>
<li><a href="#minimal-annotations" id="toc-minimal-annotations">Minimal
Annotations</a></li>
<li><a href="#typesynonyminstances"
id="toc-typesynonyminstances">TypeSynonymInstances</a></li>
<li><a href="#flexibleinstances"
id="toc-flexibleinstances">FlexibleInstances</a></li>
<li><a href="#flexiblecontexts"
id="toc-flexiblecontexts">FlexibleContexts</a></li>
<li><a href="#overlappinginstances"
id="toc-overlappinginstances">OverlappingInstances</a></li>
<li><a href="#incoherentinstances"
id="toc-incoherentinstances">IncoherentInstances</a></li>
</ul></li>
<li><a href="#laziness" id="toc-laziness">Laziness</a>
<ul>
<li><a href="#strictness" id="toc-strictness">Strictness</a></li>
<li><a href="#seq-and-whnf" id="toc-seq-and-whnf">Seq and WHNF</a></li>
<li><a href="#thunks" id="toc-thunks">Thunks</a></li>
<li><a href="#bangpatterns" id="toc-bangpatterns">BangPatterns</a></li>
<li><a href="#strictdata" id="toc-strictdata">StrictData</a></li>
<li><a href="#strict" id="toc-strict">Strict</a></li>
<li><a href="#deepseq" id="toc-deepseq">Deepseq</a></li>
<li><a href="#irrefutable-patterns"
id="toc-irrefutable-patterns">Irrefutable Patterns</a></li>
<li><a href="#the-debate" id="toc-the-debate">The Debate</a></li>
</ul></li>
<li><a href="#prelude-1" id="toc-prelude-1">Prelude</a>
<ul>
<li><a href="#what-to-avoid" id="toc-what-to-avoid">What to
Avoid?</a></li>
<li><a href="#what-should-be-in-prelude"
id="toc-what-should-be-in-prelude">What Should be in Prelude</a></li>
<li><a href="#custom-preludes" id="toc-custom-preludes">Custom
Preludes</a></li>
<li><a href="#preludes" id="toc-preludes">Preludes</a></li>
<li><a href="#protolude" id="toc-protolude">Protolude</a></li>
<li><a href="#partial-functions" id="toc-partial-functions">Partial
Functions</a></li>
<li><a href="#replacing-partiality"
id="toc-replacing-partiality">Replacing Partiality</a></li>
<li><a href="#boolean-blindness" id="toc-boolean-blindness">Boolean
Blindness</a></li>
<li><a href="#foldable-traversable"
id="toc-foldable-traversable">Foldable / Traversable</a></li>
</ul></li>
<li><a href="#strings" id="toc-strings">Strings</a>
<ul>
<li><a href="#string" id="toc-string">String</a></li>
<li><a href="#string-conversions" id="toc-string-conversions">String
Conversions</a></li>
<li><a href="#overloadedstrings"
id="toc-overloadedstrings">OverloadedStrings</a></li>
<li><a href="#text" id="toc-text">Text</a></li>
<li><a href="#text.builder" id="toc-text.builder">Text.Builder</a></li>
<li><a href="#bytestring" id="toc-bytestring">ByteString</a></li>
<li><a href="#printf" id="toc-printf">Printf</a></li>
<li><a href="#overloaded-lists" id="toc-overloaded-lists">Overloaded
Lists</a></li>
<li><a href="#regex" id="toc-regex">Regex</a></li>
<li><a href="#escaping-text" id="toc-escaping-text">Escaping
Text</a></li>
<li><a href="#string-splitting" id="toc-string-splitting">String
Splitting</a></li>
</ul></li>
<li><a href="#applicatives" id="toc-applicatives">Applicatives</a>
<ul>
<li><a href="#alternative" id="toc-alternative">Alternative</a></li>
<li><a href="#arrows" id="toc-arrows">Arrows</a></li>
<li><a href="#bifunctors" id="toc-bifunctors">Bifunctors</a></li>
<li><a href="#polyvariadic-functions"
id="toc-polyvariadic-functions">Polyvariadic Functions</a></li>
</ul></li>
<li><a href="#error-handling" id="toc-error-handling">Error Handling</a>
<ul>
<li><a href="#either-monad" id="toc-either-monad">Either Monad</a></li>
<li><a href="#exceptt" id="toc-exceptt">ExceptT</a></li>
<li><a href="#control.exception"
id="toc-control.exception">Control.Exception</a></li>
<li><a href="#exceptions" id="toc-exceptions">Exceptions</a></li>
<li><a href="#spoon" id="toc-spoon">Spoon</a></li>
</ul></li>
<li><a href="#advanced-monads" id="toc-advanced-monads">Advanced
Monads</a>
<ul>
<li><a href="#function-monad" id="toc-function-monad">Function
Monad</a></li>
<li><a href="#rws-monad" id="toc-rws-monad">RWS Monad</a></li>
<li><a href="#cont" id="toc-cont">Cont</a></li>
<li><a href="#monadplus" id="toc-monadplus">MonadPlus</a></li>
<li><a href="#monadfail" id="toc-monadfail">MonadFail</a></li>
<li><a href="#monadfix" id="toc-monadfix">MonadFix</a></li>
<li><a href="#st-monad" id="toc-st-monad">ST Monad</a></li>
<li><a href="#free-monads" id="toc-free-monads">Free Monads</a></li>
<li><a href="#indexed-monads" id="toc-indexed-monads">Indexed
Monads</a></li>
<li><a href="#lifted-base" id="toc-lifted-base">Lifted Base</a></li>
</ul></li>
<li><a href="#quantification" id="toc-quantification">Quantification</a>
<ul>
<li><a href="#universal-quantification"
id="toc-universal-quantification">Universal Quantification</a></li>
<li><a href="#free-theorems" id="toc-free-theorems">Free
Theorems</a></li>
<li><a href="#type-systems" id="toc-type-systems">Type Systems</a></li>
<li><a href="#rank-n-types" id="toc-rank-n-types">Rank-N Types</a></li>
<li><a href="#existential-quantification"
id="toc-existential-quantification">Existential Quantification</a></li>
<li><a href="#impredicative-types"
id="toc-impredicative-types">Impredicative Types</a></li>
<li><a href="#scoped-type-variables"
id="toc-scoped-type-variables">Scoped Type Variables</a></li>
</ul></li>
<li><a href="#gadts" id="toc-gadts">GADTs</a>
<ul>
<li><a href="#kind-signatures" id="toc-kind-signatures">Kind
Signatures</a></li>
<li><a href="#void" id="toc-void">Void</a></li>
<li><a href="#phantom-types" id="toc-phantom-types">Phantom
Types</a></li>
<li><a href="#typelevel-operations"
id="toc-typelevel-operations">Typelevel Operations</a></li>
</ul></li>
<li><a href="#interpreters" id="toc-interpreters">Interpreters</a>
<ul>
<li><a href="#hoas" id="toc-hoas">HOAS</a></li>
<li><a href="#phoas" id="toc-phoas">PHOAS</a></li>
<li><a href="#final-interpreters" id="toc-final-interpreters">Final
Interpreters</a></li>
<li><a href="#finally-tagless" id="toc-finally-tagless">Finally
Tagless</a></li>
<li><a href="#datatypes" id="toc-datatypes">Datatypes</a></li>
<li><a href="#f-algebras" id="toc-f-algebras">F-Algebras</a></li>
<li><a href="#recursion-schemes-the-morphism-zoo"
id="toc-recursion-schemes-the-morphism-zoo">Recursion Schemes &amp; The
Morphism Zoo</a></li>
<li><a href="#hint-and-mueval" id="toc-hint-and-mueval">Hint and
Mueval</a></li>
</ul></li>
<li><a href="#testing" id="toc-testing">Testing</a>
<ul>
<li><a href="#quickcheck" id="toc-quickcheck">QuickCheck</a></li>
<li><a href="#smallcheck" id="toc-smallcheck">SmallCheck</a></li>
<li><a href="#quickspec" id="toc-quickspec">QuickSpec</a></li>
<li><a href="#tasty" id="toc-tasty">Tasty</a></li>
<li><a href="#silently" id="toc-silently">Silently</a></li>
</ul></li>
<li><a href="#type-families" id="toc-type-families">Type Families</a>
<ul>
<li><a href="#multiparam-typeclasses"
id="toc-multiparam-typeclasses">MultiParam Typeclasses</a></li>
<li><a href="#type-families-1" id="toc-type-families-1">Type
Families</a></li>
<li><a href="#injectivity" id="toc-injectivity">Injectivity</a></li>
<li><a href="#roles" id="toc-roles">Roles</a></li>
<li><a href="#nonempty" id="toc-nonempty">NonEmpty</a></li>
<li><a href="#manual-proofs" id="toc-manual-proofs">Manual
Proofs</a></li>
<li><a href="#constraint-kinds" id="toc-constraint-kinds">Constraint
Kinds</a></li>
<li><a href="#typefamilydependencies"
id="toc-typefamilydependencies">TypeFamilyDependencies</a></li>
</ul></li>
<li><a href="#promotion" id="toc-promotion">Promotion</a>
<ul>
<li><a href="#higher-kinded-types" id="toc-higher-kinded-types">Higher
Kinded Types</a></li>
<li><a href="#kind-polymorphism" id="toc-kind-polymorphism">Kind
Polymorphism</a></li>
<li><a href="#data-kinds" id="toc-data-kinds">Data Kinds</a></li>
<li><a href="#size-indexed-vectors"
id="toc-size-indexed-vectors">Size-Indexed Vectors</a></li>
<li><a href="#typelevel-numbers" id="toc-typelevel-numbers">Typelevel
Numbers</a></li>
<li><a href="#typelevel-strings" id="toc-typelevel-strings">Typelevel
Strings</a></li>
<li><a href="#custom-errors" id="toc-custom-errors">Custom
Errors</a></li>
<li><a href="#type-equality" id="toc-type-equality">Type
Equality</a></li>
<li><a href="#proxies" id="toc-proxies">Proxies</a></li>
<li><a href="#promoted-syntax" id="toc-promoted-syntax">Promoted
Syntax</a></li>
<li><a href="#singleton-types" id="toc-singleton-types">Singleton
Types</a></li>
<li><a href="#closed-type-families" id="toc-closed-type-families">Closed
Type Families</a></li>
<li><a href="#kind-indexed-type-families"
id="toc-kind-indexed-type-families">Kind Indexed Type Families</a></li>
<li><a href="#hlists" id="toc-hlists">HLists</a></li>
<li><a href="#typelevel-dictionaries"
id="toc-typelevel-dictionaries">Typelevel Dictionaries</a></li>
<li><a href="#advanced-proofs" id="toc-advanced-proofs">Advanced
Proofs</a></li>
<li><a href="#liquid-haskell" id="toc-liquid-haskell">Liquid
Haskell</a></li>
</ul></li>
<li><a href="#generics" id="toc-generics">Generics</a>
<ul>
<li><a href="#generic" id="toc-generic">Generic</a></li>
<li><a href="#generic-deriving" id="toc-generic-deriving">Generic
Deriving</a></li>
<li><a href="#typeable" id="toc-typeable">Typeable</a></li>
<li><a href="#dynamic-types" id="toc-dynamic-types">Dynamic
Types</a></li>
<li><a href="#data" id="toc-data">Data</a></li>
<li><a href="#uniplate" id="toc-uniplate">Uniplate</a></li>
</ul></li>
<li><a href="#mathematics" id="toc-mathematics">Mathematics</a>
<ul>
<li><a href="#numeric-tower" id="toc-numeric-tower">Numeric
Tower</a></li>
<li><a href="#gmp-integers" id="toc-gmp-integers">GMP Integers</a></li>
<li><a href="#complex-numbers" id="toc-complex-numbers">Complex
Numbers</a></li>
<li><a href="#decimal-scientific-types"
id="toc-decimal-scientific-types">Decimal &amp; Scientific
Types</a></li>
<li><a href="#polynomial-arithmetic"
id="toc-polynomial-arithmetic">Polynomial Arithmetic</a></li>
<li><a href="#combinatorics"
id="toc-combinatorics">Combinatorics</a></li>
<li><a href="#number-theory" id="toc-number-theory">Number
Theory</a></li>
<li><a href="#stochastic-calculus"
id="toc-stochastic-calculus">Stochastic Calculus</a></li>
<li><a href="#differential-equations"
id="toc-differential-equations">Differential Equations</a></li>
<li><a href="#statistics-probability"
id="toc-statistics-probability">Statistics &amp; Probability</a></li>
<li><a href="#constructive-reals"
id="toc-constructive-reals">Constructive Reals</a></li>
<li><a href="#sat-solvers" id="toc-sat-solvers">SAT Solvers</a></li>
<li><a href="#smt-solvers" id="toc-smt-solvers">SMT Solvers</a></li>
</ul></li>
<li><a href="#data-structures" id="toc-data-structures">Data
Structures</a>
<ul>
<li><a href="#map" id="toc-map">Map</a></li>
<li><a href="#tree" id="toc-tree">Tree</a></li>
<li><a href="#set" id="toc-set">Set</a></li>
<li><a href="#vector" id="toc-vector">Vector</a></li>
<li><a href="#mutable-vectors" id="toc-mutable-vectors">Mutable
Vectors</a></li>
<li><a href="#unordered-containers"
id="toc-unordered-containers">Unordered Containers</a></li>
<li><a href="#hashtables" id="toc-hashtables">Hashtables</a></li>
<li><a href="#graphs" id="toc-graphs">Graphs</a></li>
<li><a href="#graph-theory" id="toc-graph-theory">Graph Theory</a></li>
<li><a href="#dlist" id="toc-dlist">DList</a></li>
<li><a href="#sequence" id="toc-sequence">Sequence</a></li>
</ul></li>
<li><a href="#ffi" id="toc-ffi">FFI</a>
<ul>
<li><a href="#pure-functions" id="toc-pure-functions">Pure
Functions</a></li>
<li><a href="#storable-arrays" id="toc-storable-arrays">Storable
Arrays</a></li>
<li><a href="#function-pointers" id="toc-function-pointers">Function
Pointers</a></li>
<li><a href="#hsc2hs" id="toc-hsc2hs">hsc2hs</a></li>
</ul></li>
<li><a href="#concurrency" id="toc-concurrency">Concurrency</a>
<ul>
<li><a href="#sparks" id="toc-sparks">Sparks</a></li>
<li><a href="#threads" id="toc-threads">Threads</a></li>
<li><a href="#ioref" id="toc-ioref">IORef</a></li>
<li><a href="#mvars" id="toc-mvars">MVars</a></li>
<li><a href="#tvar" id="toc-tvar">TVar</a></li>
<li><a href="#chans" id="toc-chans">Chans</a></li>
<li><a href="#semaphores" id="toc-semaphores">Semaphores</a></li>
<li><a href="#threadscope" id="toc-threadscope">Threadscope</a></li>
<li><a href="#strategies" id="toc-strategies">Strategies</a></li>
<li><a href="#stm" id="toc-stm">STM</a></li>
<li><a href="#monad-par" id="toc-monad-par">Monad Par</a></li>
<li><a href="#async" id="toc-async">Async</a></li>
</ul></li>
<li><a href="#parsing" id="toc-parsing">Parsing</a>
<ul>
<li><a href="#parsec" id="toc-parsec">Parsec</a></li>
<li><a href="#custom-lexer" id="toc-custom-lexer">Custom Lexer</a></li>
<li><a href="#simple-parsing" id="toc-simple-parsing">Simple
Parsing</a></li>
<li><a href="#megaparsec" id="toc-megaparsec">Megaparsec</a></li>
<li><a href="#attoparsec" id="toc-attoparsec">Attoparsec</a></li>
<li><a href="#configurator" id="toc-configurator">Configurator</a></li>
<li><a href="#optparse-applicative"
id="toc-optparse-applicative">Optparse Applicative</a></li>
<li><a href="#happy-alex" id="toc-happy-alex">Happy &amp; Alex</a></li>
</ul></li>
<li><a href="#streaming" id="toc-streaming">Streaming</a>
<ul>
<li><a href="#lazy-io" id="toc-lazy-io">Lazy IO</a></li>
<li><a href="#pipes" id="toc-pipes">Pipes</a></li>
<li><a href="#zeromq" id="toc-zeromq">ZeroMQ</a></li>
<li><a href="#conduits" id="toc-conduits">Conduits</a></li>
</ul></li>
<li><a href="#cryptography" id="toc-cryptography">Cryptography</a>
<ul>
<li><a href="#sha-hashing" id="toc-sha-hashing">SHA Hashing</a></li>
<li><a href="#password-hashing" id="toc-password-hashing">Password
Hashing</a></li>
<li><a href="#curve25519-diffie-hellman"
id="toc-curve25519-diffie-hellman">Curve25519 Diffie-Hellman</a></li>
<li><a href="#ed25519-eddsa" id="toc-ed25519-eddsa">Ed25519
EdDSA</a></li>
<li><a href="#secure-memory-handling"
id="toc-secure-memory-handling">Secure Memory Handling</a></li>
<li><a href="#aes-encryption" id="toc-aes-encryption">AES
Encryption</a></li>
<li><a href="#galois-fields" id="toc-galois-fields">Galois
Fields</a></li>
<li><a href="#elliptic-curves" id="toc-elliptic-curves">Elliptic
Curves</a></li>
<li><a href="#pairing-cryptography"
id="toc-pairing-cryptography">Pairing Cryptography</a></li>
<li><a href="#zksnarks" id="toc-zksnarks">zkSNARKs</a></li>
</ul></li>
<li><a href="#dates-and-times" id="toc-dates-and-times">Dates and
Times</a>
<ul>
<li><a href="#time" id="toc-time">time</a></li>
<li><a href="#iso8601" id="toc-iso8601">ISO8601</a></li>
</ul></li>
<li><a href="#data-formats" id="toc-data-formats">Data Formats</a>
<ul>
<li><a href="#json" id="toc-json">JSON</a></li>
<li><a href="#yaml" id="toc-yaml">Yaml</a></li>
<li><a href="#csv" id="toc-csv">CSV</a></li>
</ul></li>
<li><a href="#network-web-programming"
id="toc-network-web-programming">Network &amp; Web Programming</a>
<ul>
<li><a href="#frameworks" id="toc-frameworks">Frameworks</a></li>
<li><a href="#http-requests" id="toc-http-requests">HTTP
Requests</a></li>
<li><a href="#req" id="toc-req">Req</a></li>
<li><a href="#blaze" id="toc-blaze">Blaze</a></li>
<li><a href="#lucid" id="toc-lucid">Lucid</a></li>
<li><a href="#hastache" id="toc-hastache">Hastache</a></li>
<li><a href="#warp" id="toc-warp">Warp</a></li>
<li><a href="#scotty" id="toc-scotty">Scotty</a></li>
<li><a href="#servant" id="toc-servant">Servant</a></li>
</ul></li>
<li><a href="#databases" id="toc-databases">Databases</a>
<ul>
<li><a href="#postgres" id="toc-postgres">Postgres</a></li>
<li><a href="#sqlite" id="toc-sqlite">Sqlite</a></li>
<li><a href="#redis" id="toc-redis">Redis</a></li>
<li><a href="#acid-state" id="toc-acid-state">Acid State</a></li>
<li><a href="#selda" id="toc-selda">Selda</a></li>
</ul></li>
<li><a href="#ghc-1" id="toc-ghc-1">GHC</a>
<ul>
<li><a href="#compiler-design" id="toc-compiler-design">Compiler
Design</a></li>
<li><a href="#ghc-api" id="toc-ghc-api">GHC API</a></li>
<li><a href="#dynflags" id="toc-dynflags">DynFlags</a></li>
<li><a href="#package-databases" id="toc-package-databases">Package
Databases</a></li>
<li><a href="#hie-bios" id="toc-hie-bios">HIE Bios</a></li>
<li><a href="#abstract-syntax-tree"
id="toc-abstract-syntax-tree">Abstract Syntax Tree</a></li>
<li><a href="#parser-1" id="toc-parser-1">Parser</a></li>
<li><a href="#outputable" id="toc-outputable">Outputable</a></li>
<li><a href="#datatypes-1" id="toc-datatypes-1">Datatypes</a></li>
<li><a href="#core" id="toc-core">Core</a></li>
<li><a href="#inliner" id="toc-inliner">Inliner</a></li>
<li><a href="#primops" id="toc-primops">Primops</a></li>
<li><a href="#simd-intrinsics" id="toc-simd-intrinsics">SIMD
Intrinsics</a></li>
<li><a href="#rewrite-rules" id="toc-rewrite-rules">Rewrite
Rules</a></li>
<li><a href="#boot-libraries" id="toc-boot-libraries">Boot
Libraries</a></li>
<li><a href="#dictionaries" id="toc-dictionaries">Dictionaries</a></li>
<li><a href="#specialization"
id="toc-specialization">Specialization</a></li>
<li><a href="#static-compilation" id="toc-static-compilation">Static
Compilation</a></li>
<li><a href="#unboxed-types" id="toc-unboxed-types">Unboxed
Types</a></li>
<li><a href="#iost" id="toc-iost">IO/ST</a></li>
<li><a href="#ghc-heap-view"
id="toc-ghc-heap-view">ghc-heap-view</a></li>
<li><a href="#stg" id="toc-stg">STG</a></li>
<li><a href="#workerwrapper"
id="toc-workerwrapper">Worker/Wrapper</a></li>
<li><a href="#z-encoding" id="toc-z-encoding">Z-Encoding</a></li>
<li><a href="#cmm" id="toc-cmm">Cmm</a></li>
<li><a href="#inline-cmm" id="toc-inline-cmm">Inline CMM</a></li>
<li><a href="#optimisation" id="toc-optimisation">Optimisation</a></li>
<li><a href="#interface-files" id="toc-interface-files">Interface
Files</a></li>
<li><a href="#runtime-system" id="toc-runtime-system">Runtime
System</a></li>
</ul></li>
<li><a href="#profiling" id="toc-profiling">Profiling</a>
<ul>
<li><a href="#criterion" id="toc-criterion">Criterion</a></li>
<li><a href="#ekg" id="toc-ekg">EKG</a></li>
<li><a href="#rts-profiling" id="toc-rts-profiling">RTS
Profiling</a></li>
</ul></li>
<li><a href="#compilers" id="toc-compilers">Compilers</a>
<ul>
<li><a href="#unbound" id="toc-unbound">Unbound</a></li>
<li><a href="#unbound-generics" id="toc-unbound-generics">Unbound
Generics</a></li>
<li><a href="#pretty-printers" id="toc-pretty-printers">Pretty
Printers</a></li>
<li><a href="#prettyprinter"
id="toc-prettyprinter">prettyprinter</a></li>
<li><a href="#pretty-simple"
id="toc-pretty-simple">pretty-simple</a></li>
<li><a href="#haskeline" id="toc-haskeline">Haskeline</a></li>
<li><a href="#repline" id="toc-repline">Repline</a></li>
<li><a href="#llvm" id="toc-llvm">LLVM</a></li>
</ul></li>
<li><a href="#template-haskell" id="toc-template-haskell">Template
Haskell</a>
<ul>
<li><a href="#metaprogramming"
id="toc-metaprogramming">Metaprogramming</a></li>
<li><a href="#quasiquotation"
id="toc-quasiquotation">Quasiquotation</a></li>
<li><a href="#language-c-quote"
id="toc-language-c-quote">language-c-quote</a></li>
<li><a href="#gpu-kernels" id="toc-gpu-kernels">GPU Kernels</a></li>
<li><a href="#template-haskell-1" id="toc-template-haskell-1">Template
Haskell</a></li>
<li><a href="#antiquotation"
id="toc-antiquotation">Antiquotation</a></li>
<li><a href="#templated-type-families"
id="toc-templated-type-families">Templated Type Families</a></li>
<li><a href="#templated-type-classes"
id="toc-templated-type-classes">Templated Type Classes</a></li>
<li><a href="#multiline-strings" id="toc-multiline-strings">Multiline
Strings</a></li>
<li><a href="#path-files" id="toc-path-files">Path Files</a></li>
</ul></li>
<li><a href="#categories" id="toc-categories">Categories</a>
<ul>
<li><a href="#do-i-need-to-learn-category-theory"
id="toc-do-i-need-to-learn-category-theory">Do I need to Learn Category
Theory?</a></li>
<li><a href="#abstract-algebra" id="toc-abstract-algebra">Abstract
Algebra</a></li>
<li><a href="#categories-1" id="toc-categories-1">Categories</a></li>
<li><a href="#isomorphisms" id="toc-isomorphisms">Isomorphisms</a></li>
<li><a href="#duality" id="toc-duality">Duality</a></li>
<li><a href="#functors" id="toc-functors">Functors</a></li>
<li><a href="#natural-transformations"
id="toc-natural-transformations">Natural Transformations</a></li>
<li><a href="#kleisli-category" id="toc-kleisli-category">Kleisli
Category</a></li>
<li><a href="#monoidal-categories" id="toc-monoidal-categories">Monoidal
Categories</a></li>
<li><a href="#further-resources" id="toc-further-resources">Further
Resources</a></li>
</ul></li>
<li><a href="#source-code" id="toc-source-code">Source Code</a></li>
</ul>
      </ul>
    </div>

    <div id="main-wrapper">
      <div id="main">
        <h1 class="document-title" itemprop="name">
          What I Wish I Knew When Learning Haskell
        </h1>
        <p itemprop="version" class="document-version">
        Version
        <span class="version">2.5</span>
        </p>
<p>% What I Wish I Knew When Learning Haskell (Version 2.5) % Stephen
Diehl % February 2020</p>
<p><copyright></copyright></p>
<h2 id="version">Version</h2>
<p>This is the fifth major draft of this document since 2009.</p>
<ul class="incremental">
<li><strong><a href="http://dev.stephendiehl.com/hask/index.html">HTML Version</a></strong></li>
<li><strong><a href="http://dev.stephendiehl.com/hask/tutorial.pdf">Screen PDF</a></strong></li>
<li><strong><a href="http://dev.stephendiehl.com/hask/tutorial_print.pdf">Printable PDF</a></strong></li>
<li><strong><a href="http://dev.stephendiehl.com/hask/tutorial.epub">EPUB Version</a></strong></li>
<li><strong><a href="http://dev.stephendiehl.com/hask/tutorial.mobi">Kindle Version</a></strong></li>
</ul>
<p>Pull requests are always accepted for changes and additional content. This is a living document. The only way this document will stay up to date is through the kindness of readers like you and community patches and <a href="https://github.com/sdiehl/wiwinwlh">pull requests</a> on Github.</p>
<p>If you’d like a physical copy of the text you can either print it for yourself (see Printable PDF) or purchase one online:</p>
<ul class="incremental">
<li><a href="https://www.blurb.co.uk/b/9958091-what-i-wish-i-knew-when-learning-haskell"><strong>Blurb Publisher</strong></a></li>
</ul>
<h2 id="author">Author</h2>
<p>This text is authored by Stephen Diehl.</p>
<ul class="incremental">
<li>Web: <a href="https://www.stephendiehl.com" class="uri">https://www.stephendiehl.com</a></li>
<li>Twitter: <a href="https://twitter.com/smdiehl" class="uri">https://twitter.com/smdiehl</a></li>
<li>Github: <a href="https://github.com/sdiehl" class="uri">https://github.com/sdiehl</a></li>
</ul>
<p>Special thanks for Erik Aker for copyediting assistance.</p>
<h2 id="license">License</h2>
<p>Copyright © 2009-2020 Stephen Diehl</p>
<p>This code included in the text is dedicated to the public domain. You can copy, modify, distribute and perform the code, even for commercial purposes, all without asking permission.</p>
<p>You may distribute this text in its full form freely, but may not reauthor or sublicense this work. Any reproductions of major portions of the text must include attribution.</p>
<p>The software is provided “as is”, without warranty of any kind, express or implied, including But not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement. In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, Arising from, out of or in connection with the software or the use or other dealings in the software.</p>
<h1 id="basics">Basics</h1>
<h2 id="what-is-haskell">What is Haskell?</h2>
<p>At its heart Haskell is a lazy, functional, statically-typed
programming language with advanced type system features such as
higher-rank, higher-kinded parametric polymorphism, monadic effects,
generalized algebraic data types, ad-hoc polymorphism through type
classes, associated type families, and more. As a programming language,
Haskell pushes the frontiers of programming language design more so than
any other general purpose language while still remaining practical for
everyday use.</p>
<p>Beyond language features, Haskell remains an organic,
community-driven effort, run by its userbase instead of by corporate
influences. While there are some Haskell companies and consultancies,
most are fairly small and none have an outsized influence on the
development of the language. This is in stark contrast to ecosystems
like Java and Go where Oracle and Google dominate all development. In
fact, the Haskell community is a synthesis between multiple disciplines
of academic computer science and industrial users from large and small
firms, all of whom contribute back to the language ecosystem.</p>
<p>Originally, Haskell was borne out of academic research. Designed as
an ML dialect, it was initially inspired by an older language called
Miranda. In the early 90s, a group of academics formed the GHC committee
to pursue building a research vehicle for lazy programming languages as
a replacement for Miranda. This was a particularly in-vogue research
topic at the time and as a result the committee attracted various
talented individuals who initiated the language and ultimately laid the
foundation for modern Haskell.</p>
<p>Over the last 30 years Haskell has evolved into a mature ecosystem,
with an equally mature compiler. Even so, the language is frequently
reimagined by passionate contributors who may be furthering academic
research goals or merely contributing out of personal interest. Although
laziness was originally the major research goal, this has largely become
a quirky artifact that most users of the language are generally
uninterested in. In modern times the major themes of Haskell community
are:</p>
<ul>
<li>A vehicle for type system research</li>
<li>Experimentation in the design space of typed effect systems</li>
<li>Algebraic structures as a method of program synthesis</li>
<li>Referential transparency as a core language feature</li>
<li>Embedded domain specific languages</li>
<li>Experimentation toward practical dependent types</li>
<li>Stronger encoding of invariants through type-level programming</li>
<li>Efficient functional compiler design</li>
<li>Alternative models of parallel and concurrent programming</li>
</ul>
<p>Although these are the major research goals, Haskell is still a fully
general purpose language, and it has been applied in wildly diverse
settings from garbage trucks to cryptanalysis for the defense sector and
everything in-between. With a thriving ecosystem of industrial
applications in web development, compiler design, machine learning,
financial services, FPGA development, algorithmic trading, numerical
computing, cryptography research, and cybersecurity, the language has a
lot to offer to any field or software practitioner.</p>
<p>Haskell as an ecosystem is one that is purely organic, it takes
decades to evolve, makes mistakes and is not driven by any one ideology
or belief about the purpose of functional programming. This makes
Haskell programming simultaneously frustrating and exciting; and therein
lies the fun that has been the intellectual siren song that has drawn
many talented programmers to dabble in this beautiful language at some
point in their lives.</p>
<p>See:</p>
<ul>
<li><a href="https://dl.acm.org/doi/10.1145/1238844.1238856">A History
of Haskell</a></li>
<li><a
href="http://www.cs.nott.ac.uk/~pszgmh/appsem-slides/peytonjones.ppt?ref=driverlayer.com/web">Wearing
the Hair Shirt: A Retrospective on Haskell</a></li>
</ul>
<h2 id="how-to-read">How to Read</h2>
<p>This is a guide for working software engineers who have an interest
in Haskell but don’t know Haskell yet. I presume you know some basics
about how your operating system works, the shell, and some fundamentals
of other imperative programming languages. If you are a Python or Java
software engineer with no Haskell experience, this is the executive
summary of Haskell theory and practice for you. We’ll delve into a
little theory as needed to explain concepts but no more than necessary.
If you’re looking for a purely introductory tutorial, this probably
isn’t the right start for you, however this can be read as a companion
to other introductory texts.</p>
<p>There is no particular order to this guide, other than the first
chapter which describes how to get set up with Haskell and use the
foundational compiler and editor tooling. After that you are free to
browse the chapters in any order. Most are divided into several sections
which outline different concepts, language features or libraries.
However, the general arc of this guide bends toward more complex topics
in later chapters.</p>
<p>As there is no ordering after the first chapter I will refer to
concepts globally without introducing them first. If something doesn’t
make sense just skip it and move on. I strongly encourage you to play
around with the source code modules for yourself. Haskell cannot be
learned from an armchair; instead it can only be mastered by writing a
ton of code for yourself. GHC may initially seem like a cruel
instructor, but in time most people grow to see it as their friend.</p>
<h2 id="ghc">GHC</h2>
<p>GHC is the Glorious Glasgow Haskell Compiler. Originally written in
1989, GHC is now the de facto standard for Haskell compilers. A few
other compilers have existed along the way, but they either are quite
limited or have bit rotted over the years. At this point, GHC is a
massive compiler and it supports a wide variety of extensions. It’s also
the only reference implementation for the Haskell language and as such,
it defines what Haskell the language is by its implementation.</p>
<p>GHC is run at the command line with the command <code>ghc</code>.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc <span class="at">--version</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">The</span> Glorious Glasgow Haskell Compilation System, version 8.8.1</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc Example.hs <span class="at">-o</span> example</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc <span class="at">--make</span> Example.hs</span></code></pre></div>
<p>GHC’s runtime is written in C and uses machinery from GCC
infrastructure for its native code generator and can also use LLVM for
its native code generation. GHC is supported on the following
architectures:</p>
<ul>
<li>Linux x86</li>
<li>Linux x86_64</li>
<li>Linux PowerPC</li>
<li>NetBSD x86</li>
<li>OpenBSD x86</li>
<li>FreeBSD x86</li>
<li>MacOS X Intel</li>
<li>MacOS X PowerPC</li>
<li>Windows x86_64</li>
</ul>
<p>GHC itself depends on the following Linux packages.</p>
<ul>
<li>build-essential</li>
<li>libgmp-dev</li>
<li>libffi-dev</li>
<li>libncurses-dev</li>
<li>libtinfo5</li>
</ul>
<h2 id="ghcup">ghcup</h2>
<p>There are two major packages that need to be installed to use
Haskell:</p>
<ul>
<li>ghc</li>
<li>cabal-install</li>
</ul>
<p>GHC can be installed on Linux and Mac with <a
href="https://www.haskell.org/ghcup/">ghcup</a> by running the following
command:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> curl <span class="at">--proto</span> <span class="st">&#39;=https&#39;</span> <span class="at">--tlsv1.2</span> <span class="at">-sSf</span> https://get-ghcup.haskell.org <span class="kw">|</span> <span class="fu">sh</span></span></code></pre></div>
<p>To start the interactive user interface, run:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghcup tui</span></code></pre></div>
<p>Alternatively, to use the cli to install multiple versions of GHC,
use the <code>install</code> command.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghcup install ghc 8.6.5</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghcup install ghc 8.4.4</span></code></pre></div>
<p>To select which version of GHC is available on the PATH use the
<code>set</code> command.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghcup set ghc 8.8.1</span></code></pre></div>
<p>This can also be used to install cabal.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghcup install cabal</span></code></pre></div>
<p>To modify your shell to include ghc and cabal.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> source ~/.ghcup/env</span></code></pre></div>
<p>Or you can permanently add the following to your <code>.bashrc</code>
or <code>.zshrc</code> file:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">PATH</span><span class="op">=</span><span class="st">&quot;~/.ghcup/bin:</span><span class="va">$PATH</span><span class="st">&quot;</span></span></code></pre></div>
<h2 id="package-managers">Package Managers</h2>
<p>There are two major Haskell packaging tools: <strong>Cabal</strong>
and <strong>Stack</strong>. Both take differing views on versioning
schemes but can more or less interoperate at the package level. So, why
are there two different package managers?</p>
<p>The simplest explanation is that Haskell is an organic ecosystem with
no central authority, and as such different groups of people with
different ideas and different economic interests about optimal packaging
built their own solutions around two different models. The interests of
an organic community don’t always result in open source convergence;
however, the ecosystem has seen both package managers reach much greater
levels of stability as a result of collaboration. In this article, I
won’t offer a preference for which system to use: it is left up to the
reader to experiment and use the system which best suits your or your
company’s needs.</p>
<h2 id="project-structure">Project Structure</h2>
<p>A typical Haskell project hosted on Github or Gitlab will have
several <strong>executable</strong>, <strong>test</strong> and
<strong>library</strong> components across several subdirectories. Each
of these files will correspond to an entry in the Cabal file.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">.</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> app                          <span class="co"># Executable entry-point</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> └── Main.hs                  <span class="co"># main-is file</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> src                          <span class="co"># Library entry-point</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> └── Lib.hs                   <span class="co"># Exposed module</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> test                         <span class="co"># Test entry-point</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> └── Spec.hs                  <span class="co"># Main-is file</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> ChangeLog.md                 <span class="co"># extra-source-files</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> LICENSE                      <span class="co"># extra-source-files</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> README.md                    <span class="co"># extra-source-files</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> package.yaml                 <span class="co"># hpack configuration</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Setup.hs</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> simple.cabal                 <span class="co"># cabal configuration generated from hpack</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> stack.yaml                   <span class="co"># stack configuration</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> .hlint.yaml                  <span class="co"># hlint configuration</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="ex">└──</span> .ghci                        <span class="co"># ghci configuration</span></span></code></pre></div>
<p>More complex projects consisting of multiple modules will include
multiple project directories like those above, but these will be nested
in subfolders with a <code>cabal.project</code> or
<code>stack.yaml</code> in the root of the repository.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="bu">.</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> lib-one             <span class="co"># component1</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> lib-two             <span class="co"># component2</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> lib-three           <span class="co"># component3</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> stack.yaml          <span class="co"># stack project configuration</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="ex">└──</span> cabal.project       <span class="co"># cabal project configuration</span></span></code></pre></div>
<p>An example Cabal project file, named <code>cabal.project</code>
above, this multi-component library repository would include these
lines.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">packages</span><span class="kw">:</span><span class="at"> ./lib-one</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="at">          ./lib-two</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="at">          ./lib-three</span></span></code></pre></div>
<p>By contrast, an example Stack project <code>stack.yaml</code> for the
above multi-component library repository would be:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">resolver</span><span class="kw">:</span><span class="at"> lts-14.20</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">packages</span><span class="kw">:</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">-</span><span class="at"> </span><span class="st">&#39;lib-one&#39;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="kw">-</span><span class="at"> </span><span class="st">&#39;lib-two&#39;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="kw">-</span><span class="at"> </span><span class="st">&#39;lib-three&#39;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="fu">extra-package-dbs</span><span class="kw">:</span><span class="at"> </span><span class="kw">[]</span></span></code></pre></div>
<h2 id="cabal">Cabal</h2>
<p>Cabal is the build system for Haskell. Cabal is also the standard
build tool for Haskell source supported by GHC. Cabal can be used
simultaneously with Stack or standalone with cabal new-build.</p>
<p>To update the package index from Hackage, run:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal update</span></code></pre></div>
<p>To start a new Haskell project, run:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal init</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal configure</span></code></pre></div>
<p>This will result in a <code>.cabal</code> file being created with the
configuration options for our new project.</p>
<p>Cabal can also build dependencies in parallel by passing
<code>-j&lt;n&gt;</code> where <code>n</code> is the number of
concurrent builds.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal install <span class="at">-j4</span> <span class="at">--only-dependencies</span></span></code></pre></div>
<p>Let’s look at an example <code>.cabal</code> file. There are two main
entry points that any package may provide: a <code>library</code> and an
<code>executable</code>. Multiple executables can be defined, but only
one library. In addition, there is a special form of executable entry
point <code>Test-Suite</code>, which defines an interface for invoking
unit tests from <code>cabal</code>.</p>
<p>For a <strong>library</strong>, the <code>exposed-modules</code>
field in the <code>.cabal</code> file indicates which modules within the
package structure will be publicly visible when the package is
installed. These modules are the user-facing APIs that we wish to expose
to downstream consumers.</p>
<p>For an <strong>executable</strong>, the <code>main-is</code> field
indicates the module that exports the <code>main</code> function
responsible for running the executable logic of the application. Every
module in the package must be listed in one of
<code>other-modules</code>, <code>exposed-modules</code> or
<code>main-is</code> fields.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">name</span><span class="kw">:</span><span class="at">               mylibrary</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at">            </span><span class="fl">0.1</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="fu">cabal-version</span><span class="kw">:</span><span class="at">      &gt;= 1.10</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="fu">author</span><span class="kw">:</span><span class="at">             Paul Atreides</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="fu">license</span><span class="kw">:</span><span class="at">            MIT</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="fu">license-file</span><span class="kw">:</span><span class="at">       LICENSE</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="fu">synopsis</span><span class="kw">:</span><span class="at">           My example library.</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="fu">category</span><span class="kw">:</span><span class="at">           Math</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="fu">tested-with</span><span class="kw">:</span><span class="at">        GHC</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="fu">build-type</span><span class="kw">:</span><span class="at">         Simple</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="at">library</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">exposed-modules</span><span class="kw">:</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="at">      Library.ExampleModule1</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a><span class="at">      Library.ExampleModule2</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">build-depends</span><span class="kw">:</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="at">      base &gt;= 4 &amp;&amp; &lt; 5</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">default-language</span><span class="kw">:</span><span class="at"> Haskell2010</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ghc-options</span><span class="kw">:</span><span class="at"> -O2 -Wall -fwarn-tabs</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span class="at">executable &quot;example&quot;</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">build-depends</span><span class="kw">:</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a><span class="at">        base &gt;= 4 &amp;&amp; &lt; 5,</span></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a><span class="at">        mylibrary == 0.1</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">default-language</span><span class="kw">:</span><span class="at"> Haskell2010</span></span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">main-is</span><span class="kw">:</span><span class="at"> Main.hs</span></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a><span class="at">Test-Suite test</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">type</span><span class="kw">:</span><span class="at"> exitcode-stdio-1.0</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">main-is</span><span class="kw">:</span><span class="at"> Test.hs</span></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">default-language</span><span class="kw">:</span><span class="at"> Haskell2010</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">build-depends</span><span class="kw">:</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a><span class="at">      base &gt;= 4 &amp;&amp; &lt; 5,</span></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a><span class="at">      mylibrary == 0.1</span></span></code></pre></div>
<p>To run an “executable” under <code>cabal</code> execute the
command:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal run</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal run <span class="op">&lt;</span>name<span class="op">&gt;</span> <span class="co"># when there are several executables in a project</span></span></code></pre></div>
<p>To load the “library” into a <a href="#ghci">GHCi</a> shell under
<code>cabal</code> execute the command:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal repl</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal repl <span class="op">&lt;</span>name<span class="op">&gt;</span></span></code></pre></div>
<p>The <code>&lt;name&gt;</code> metavariable is either one of the
executable or library declarations in the <code>.cabal</code> file and
can optionally be disambiguated by the prefix
<code>exe:&lt;name&gt;</code> or <code>lib:&lt;name&gt;</code>
respectively.</p>
<p>To build the package locally into the <code>./dist/build</code>
folder, execute the <code>build</code> command:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal build</span></code></pre></div>
<p>To run the tests, our package must itself be reconfigured with the
<code>--enable-tests</code> flag and the <code>build-depends</code>
options. The <code>Test-Suite</code> must be installed manually, if not
already present.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal install <span class="at">--only-dependencies</span> <span class="at">--enable-tests</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal configure <span class="at">--enable-tests</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal test</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal test <span class="op">&lt;</span>name<span class="op">&gt;</span></span></code></pre></div>
<p>Moreover, arbitrary shell commands can be invoked with the <a
href="https://www.haskell.org/ghc/">GHC</a> environmental variables. It
is quite common to run a new bash shell with this command such that the
<code>ghc</code> and <code>ghci</code> commands use the package
environment. This can also run any system executable with the
<code>GHC_PACKAGE_PATH</code> variable set to the libraries <a
href="#package-databases">package database</a>.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal exec</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal exec bash</span></code></pre></div>
<p>The <a href="#haddock">haddock</a> documentation can be generated for
the local project by executing the <code>haddock</code> command. The
documentation will be built to the <code>./dist</code> folder.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal haddock</span></code></pre></div>
<p>When we’re finally ready to upload to Hackage ( presuming we have a
Hackage account set up ), then we can build the tarball and upload with
the following commands:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal sdist</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal upload dist/mylibrary-0.1.tar.gz</span></code></pre></div>
<p>The current state of a local build can be frozen with all current
package constraints enumerated:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal freeze</span></code></pre></div>
<p>This will create a file <code>cabal.config</code> with the constraint
set.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>constraints<span class="op">:</span> mtl <span class="op">==</span><span class="fl">2.2</span><span class="op">.</span><span class="dv">1</span>,</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>             text <span class="op">==</span><span class="fl">1.1</span><span class="op">.</span><span class="fl">1.3</span>,</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>             transformers <span class="op">==</span><span class="fl">0.4</span><span class="op">.</span><span class="fl">1.0</span></span></code></pre></div>
<p>The <code>cabal</code> configuration is stored in
<code>$HOME/.cabal/config</code> and contains various options including
credential information for Hackage upload.</p>
<p>A library can also be compiled with runtime profiling information
enabled. More on this is discussed in the section on <a
href="#concurrency">Concurrency</a> and <a
href="#profiling">Profiling</a>.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>library-profiling: True</span></code></pre></div>
<p>Another common flag to enable is <code>documentation</code> which
forces the local build of Haddock documentation, which can be useful for
offline reference. On a Linux filesystem these are built to the
<code>/usr/share/doc/ghc-doc/html/libraries/</code> directory.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>documentation: True</span></code></pre></div>
<p>Cabal can also be used to install packages globally to the system
PATH. For example the <a href="#parsec">parsec</a> package to your
system from <a href="#hackage">Hackage</a>, the upstream source of
Haskell packages, invoke the <code>install</code> command:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal install parsec <span class="at">--installdir</span><span class="op">=</span>~/.local/bin  <span class="co"># latest version</span></span></code></pre></div>
<p>To download the source for a package, we can use the <code>get</code>
command to retrieve the source from Hackage.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal get parsec    <span class="co"># fetch source</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cd parsec-3.1.5</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal configure</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal build</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal install</span></code></pre></div>
<h2 id="cabal-new-build">Cabal New-Build</h2>
<p>The interface for Cabal has seen an overhaul in the last few years
and has moved more closely towards the Nix-style of local builds. Under
the new system packages are separated into categories:</p>
<ul>
<li><strong>Local Packages</strong> - Packages are built from a
configuration file which specifies a path to a directory with a cabal
file. These can be working projects as well as all of its local
transitive dependencies.</li>
<li><strong>External Packages</strong> - External packages are packages
retrieved from either the public Hackage or a private Hackage
repository. These packages are hashed and stored locally in
<code>~/.cabal/store</code> to be reused across builds.</li>
</ul>
<p>As of Cabal 3.0 the new-build commands are the default operations for
build operations. So if you type <code>cabal build</code> using Cabal
3.0 you are already using the new-build system.</p>
<p>Historically these commands were separated into two different command
namespaces with prefixes <code>v1-</code> and <code>v2-</code>, with v1
indicating the old sandbox build system and the v2 indicating the
new-build system.</p>
<p>The new build commands are listed below:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ex">new-build</span>          Compile targets within the project.</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="ex">new-configure</span>      Add extra project configuration</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="ex">new-repl</span>           Open an interactive session for the given component.</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="ex">new-run</span>            Run an executable.</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="ex">new-test</span>           Run test-suites</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="ex">new-bench</span>          Run benchmarks</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="ex">new-freeze</span>         Freeze dependencies.</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="ex">new-haddock</span>        Build Haddock documentation</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="ex">new-exec</span>           Give a command access to the store.</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="ex">new-update</span>         Updates list of known packages.</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a><span class="ex">new-install</span>        Install packages.</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="ex">new-clean</span>          Clean the package store and remove temporary files.</span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a><span class="ex">new-sdist</span>          Generate a source distribution file <span class="er">(</span><span class="ex">.tar.gz</span><span class="kw">)</span><span class="bu">.</span></span></code></pre></div>
<p>Cabal also stores all of its build artifacts inside of a
<code>dist-newstyle</code> folder stored in the project working
directory. The compilation artifacts are of several categories.</p>
<ul>
<li><code>.hi</code> - Haskell interface modules which describe the type
information, public exports, symbol table, and other module guts of
compiled Haskell modules.</li>
<li><code>.hie</code> - An extended interface file containing module
symbol data.</li>
<li><code>.hspp</code> - A Haskell preprocessor file.</li>
<li><code>.o</code> - Compiled object files for each module. These are
emitted by the native code generator assembler.</li>
<li><code>.s</code> - Assembly language source file.</li>
<li><code>.bc</code> - Compiled LLVM bytecode file.</li>
<li><code>.ll</code> - An LLVM source file.</li>
<li><code>cabal_macros.h</code> - Contains all of the preprocessor
definitions that are accessible when using the <a href="#cpp">CPP</a>
extension.</li>
<li><code>cache</code> - Contains all artifacts generated by solving the
constraints of packages to set up a build plan. This also contains the
hash repository of all external packages.</li>
<li><code>packagedb</code> - Database of all of the cabal metadata of
all external and local packages needed to build the project. See <a
href="#package-databases">Package Databases</a>.</li>
</ul>
<p>These all get stored under the <code>dist-newstyle</code> folder
structure which is set up hierarchically under the specific CPU
architecture, GHC compiler version and finally the package version.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="ex">dist-newstyle</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> build</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> └── x86_64-linux</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>     └── ghc-8.6.5</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>         └── mypackage-0.1.0</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             ├── build</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   ├── autogen</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   │   ├── cabal_macros.h</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   │   └── Paths_mypackage.hs</span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   ├── libHSmypackage-0.1.0-inplace.a</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   ├── libHSmypackage-0.1.0-inplace-ghc8.6.5.so</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   ├── MyPackage</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   │   ├── Example.dyn_hi</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   │   ├── Example.dyn_o</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   │   ├── Example.hi</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   │   ├── Example.o</span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   ├── MyPackage.dyn_hi</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   ├── MyPackage.dyn_o</span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   ├── MyPackage.hi</span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   └── MyPackage.o</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             ├── cache</span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   ├── build</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   ├── config</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   └── registration</span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             ├── package.conf.inplace</span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   ├── package.cache</span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             │   └── package.cache.lock</span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>             └── setup-config</span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> cache</span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> ├── compiler</span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> ├── config</span>
<span id="cb32-32"><a href="#cb32-32" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> ├── elaborated-plan</span>
<span id="cb32-33"><a href="#cb32-33" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> ├── improved-plan</span>
<span id="cb32-34"><a href="#cb32-34" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> ├── plan.json</span>
<span id="cb32-35"><a href="#cb32-35" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> ├── solver-plan</span>
<span id="cb32-36"><a href="#cb32-36" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> ├── source-hashes</span>
<span id="cb32-37"><a href="#cb32-37" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> └── up-to-date</span>
<span id="cb32-38"><a href="#cb32-38" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> packagedb</span>
<span id="cb32-39"><a href="#cb32-39" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> └── ghc-8.6.5</span>
<span id="cb32-40"><a href="#cb32-40" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>     ├── package.cache</span>
<span id="cb32-41"><a href="#cb32-41" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>     ├── package.cache.lock</span>
<span id="cb32-42"><a href="#cb32-42" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span>     └── mypackage-0.1.0-inplace.conf</span>
<span id="cb32-43"><a href="#cb32-43" aria-hidden="true" tabindex="-1"></a><span class="ex">└──</span> tmp</span></code></pre></div>
<h2 id="local-packages">Local Packages</h2>
<p>Both Stack and Cabal can handle local packages built from the local
filesystem, from remote tarballs, or from remote Git repositories.</p>
<p>Inside of the <code>stack.yaml</code> simply specify the git
repository remote and the hash to pull.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">resolver</span><span class="kw">:</span><span class="at"> lts-14.20</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">packages</span><span class="kw">:</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co">  # From Git</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">git</span><span class="kw">:</span><span class="at"> https://github.com/sdiehl/protolude.git</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> f5c2bf64b147716472b039d30652846069f2fc70</span></span></code></pre></div>
<p>In Cabal to add a remote create a <code>cabal.project</code> file and
add your remote in the <code>source-repository-package</code>
section.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">packages</span><span class="kw">:</span><span class="at"> .</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="at">source-repository-package</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">type</span><span class="kw">:</span><span class="at"> git</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">location</span><span class="kw">:</span><span class="at"> https://github.com/hvr/HsYAML.git</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">tag</span><span class="kw">:</span><span class="at"> e70cf0c171c9a586b62b3f75d72f1591e4e6aaa1</span></span></code></pre></div>
<h2 id="version-bounds">Version Bounds</h2>
<p>All Haskell packages are versioned and the numerical quantities in
the version are supposed to follow the <a
href="https://pvp.haskell.org/">Package Versioning Policy</a>.</p>
<p>As packages evolve over time there are three numbers which
monotonically increase depending on what has changed in the package.</p>
<ul>
<li>Major version number</li>
<li>Minor version number</li>
<li>Patch version number</li>
</ul>
<div class="sourceCode" id="cb35"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- PVP summary:      +-+------- breaking API changes</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co">--                   | | +----- non-breaking API additions</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co">--                   | | | +--- code changes with no API change</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>version<span class="op">:</span>             <span class="fl">0.1</span><span class="op">.</span><span class="fl">0.0</span></span></code></pre></div>
<p>Every library’s cabal file will have a packages dependencies section
which will specify the external packages which the library depends on.
It will also contain the allowed versions that it is known to build
against in the <code>build-depends</code> section. The convention is to
put the upper bound to the next major unreleased version and the lower
bound at the currently used version.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>build-depends:       </span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>  base                &gt;= <span class="fl">4.6</span>  &amp;&amp; &lt;<span class="fl">4.14</span>,</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  async               &gt;= <span class="fl">2.0</span>  &amp;&amp; &lt;<span class="fl">2.3</span>,</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  deepseq             &gt;= <span class="fl">1.3</span>  &amp;&amp; &lt;<span class="fl">1.5</span>,</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>  containers          &gt;= <span class="fl">0.5</span>  &amp;&amp; &lt;<span class="fl">0.7</span>,</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>  hashable            &gt;= <span class="fl">1.2</span>  &amp;&amp; &lt;<span class="fl">1.4</span>,</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  transformers        &gt;= <span class="fl">0.2</span>  &amp;&amp; &lt;<span class="fl">0.6</span>,</span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>  text                &gt;= <span class="fl">1.2</span>  &amp;&amp; &lt;<span class="fl">1.3</span>,</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>  bytestring          &gt;= <span class="fl">0.10</span> &amp;&amp; &lt;<span class="fl">0.11</span>,</span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a>  mtl                 &gt;= <span class="fl">2.1</span>  &amp;&amp; &lt;<span class="fl">2.3</span></span></code></pre></div>
<p>Individual lines in the version specification can be dependent on
other variables in the cabal file.</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> !impl(ghc &gt;= <span class="fl">8.0</span>)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>  Build-Depends: fail &gt;= <span class="fl">4.9</span> &amp;&amp; &lt;<span class="fl">4.10</span></span></code></pre></div>
<p>Version bounds in cabal files can be managed automatically with a
tool <code>cabal-bounds</code> which can automatically generate, update
and format cabal files.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal-bounds update</span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://pvp.haskell.org/">Package Versioning
Policy</a></li>
</ul>
<h2 id="stack">Stack</h2>
<p>Stack is an alternative approach to Haskell’s package structure that
emerged in 2015. Instead of using a rolling build like <a
href="#cabal">Cabal</a>, Stack breaks up sets of packages into release
blocks that guarantee internal compatibility between sets of packages.
The package solver for Stack uses a different strategy for resolving
dependencies than cabal-install has historically used and Stack combines
this with a centralised build server called <a
href="#stackage">Stackage</a> which continuously tests the set of
packages in a resolver to ensure they build against each other.</p>
</hr>
<h4 id="install">Install</h4>
<p>To install <code>stack</code> on Linux or Mac, run:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> <span class="at">-sSL</span> https://get.haskellstack.org/ <span class="kw">|</span> <span class="fu">sh</span></span></code></pre></div>
<p>For other operating systems, see <a
href="http://docs.haskellstack.org/en/stable/install_and_upgrade/">the
official install directions</a>.</p>
<h4 id="usage">Usage</h4>
<p>Once <code>stack</code> is installed, it is possible to setup a build
environment on top of your existing project’s <code>cabal</code> file by
running:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ex">stack</span> init</span></code></pre></div>
<p>An example <code>stack.yaml</code> file for GHC 8.8.1 would look like
this:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ex">resolver:</span> lts-14.20</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="ex">flags:</span> {}</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="ex">extra-package-dbs:</span> []</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="ex">packages:</span> []</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="ex">extra-deps:</span> []</span></code></pre></div>
<p>Most of the common libraries used in everyday development are already
in the <a href="https://www.stackage.org/">Stackage</a> repository. The
<code>extra-deps</code> field can be used to add <a
href="http://hackage.haskell.org/">Hackage</a> dependencies that are not
in the Stackage repository. They are specified by the package and the
version key. For instance, the <code>zenc</code> package could be added
to <code>stack build</code> in the following way:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>extra<span class="op">-</span>deps<span class="op">:</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="op">-</span> zenc<span class="op">-</span><span class="fl">0.1</span><span class="op">.</span><span class="dv">1</span></span></code></pre></div>
<p>The <code>stack</code> command can be used to install packages and
executables into either the current build environment or the global
environment. For example, the following command installs the executable
for <code>hlint</code>, <a href="#hlint">a popular linting tool for
Haskell</a>, and places it in the PATH:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack install hlint</span></code></pre></div>
<p>To check the set of dependencies, run:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack ls dependencies</span></code></pre></div>
<p>Just as with <code>cabal</code>, the build and debug process can be
orchestrated using <code>stack</code> commands:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack build                 <span class="co"># Build a cabal target</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack repl                  <span class="co"># Launch ghci</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack ghc                   <span class="co"># Invoke the standalone compiler in stack environment</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack exec bash             <span class="co"># Execute a shell command with the stack GHC environment variables</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack build <span class="at">--file-watch</span>    <span class="co"># Build on every filesystem change</span></span></code></pre></div>
<p>To visualize the dependency graph, use the dot command piped first
into graphviz, then piped again into your favorite image viewer:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack dot <span class="at">--external</span> <span class="kw">|</span> <span class="ex">dot</span> <span class="at">-Tpng</span> <span class="kw">|</span> <span class="ex">feh</span> <span class="at">-</span></span></code></pre></div>
<h2 id="hpack">Hpack</h2>
<p>Hpack is an alternative package description language that uses a
structured YAML format to generate Cabal files. Hpack succeeds in DRYing
(Don’t Repeat Yourself) several sections of cabal files that are often
quite repetitive across large projects. Hpack uses a
<code>package.yaml</code> file which is consumed by the command line
tool <code>hpack</code>. Hpack can be integrated into Stack and will
generate resulting cabal files whenever <code>stack build</code> is
invoked on a project using a <code>package.yaml</code> file. The output
cabal file contains a hash of the input yaml file for consistency
checking.</p>
<p>A small <code>package.yaml</code> file might look something like the
following:</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="fu">name        </span><span class="kw">:</span><span class="at"> example</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a><span class="fu">version     </span><span class="kw">:</span><span class="at"> </span><span class="fl">0.1.0</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a><span class="fu">synopsis    </span><span class="kw">:</span><span class="at"> My fabulous library</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="fu">description </span><span class="kw">:</span><span class="at"> My fabulous library</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a><span class="fu">maintainer  </span><span class="kw">:</span><span class="at"> John Doe</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a><span class="fu">github      </span><span class="kw">:</span><span class="at"> john/example</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a><span class="fu">category    </span><span class="kw">:</span><span class="at"> Development</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a><span class="fu">ghc-options</span><span class="kw">:</span><span class="at"> -Wall</span></span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a><span class="fu">dependencies</span><span class="kw">:</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> base &gt;= 4.9 &amp;&amp; &lt; 5</span></span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> protolude</span></span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> deepseq</span></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> directory</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> filepath</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> text</span></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> containers</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> unordered-containers</span></span>
<span id="cb47-20"><a href="#cb47-20" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> aeson</span></span>
<span id="cb47-21"><a href="#cb47-21" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> pretty-simple</span></span>
<span id="cb47-22"><a href="#cb47-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-23"><a href="#cb47-23" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span><span class="kw">:</span></span>
<span id="cb47-24"><a href="#cb47-24" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">source-dirs</span><span class="kw">:</span><span class="at"> src</span></span>
<span id="cb47-25"><a href="#cb47-25" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">exposed-modules</span><span class="kw">:</span></span>
<span id="cb47-26"><a href="#cb47-26" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> Example</span></span>
<span id="cb47-27"><a href="#cb47-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-28"><a href="#cb47-28" aria-hidden="true" tabindex="-1"></a><span class="fu">executable</span><span class="kw">:</span></span>
<span id="cb47-29"><a href="#cb47-29" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">main</span><span class="kw">:</span><span class="at"> Main.hs</span></span>
<span id="cb47-30"><a href="#cb47-30" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">source-dirs</span><span class="kw">:</span><span class="at"> exe</span></span>
<span id="cb47-31"><a href="#cb47-31" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">dependencies</span><span class="kw">:</span></span>
<span id="cb47-32"><a href="#cb47-32" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> example</span></span>
<span id="cb47-33"><a href="#cb47-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-34"><a href="#cb47-34" aria-hidden="true" tabindex="-1"></a><span class="fu">tests</span><span class="kw">:</span></span>
<span id="cb47-35"><a href="#cb47-35" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb47-36"><a href="#cb47-36" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">main</span><span class="kw">:</span><span class="at"> Test.hs</span></span>
<span id="cb47-37"><a href="#cb47-37" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">source-dirs</span><span class="kw">:</span></span>
<span id="cb47-38"><a href="#cb47-38" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> test</span></span>
<span id="cb47-39"><a href="#cb47-39" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> src</span></span>
<span id="cb47-40"><a href="#cb47-40" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">dependencies</span><span class="kw">:</span></span>
<span id="cb47-41"><a href="#cb47-41" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> example</span></span>
<span id="cb47-42"><a href="#cb47-42" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> tasty</span></span>
<span id="cb47-43"><a href="#cb47-43" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> tasty-hunit</span></span></code></pre></div>
<h2 id="base">Base</h2>
<p>GHC itself ships with a variety of core libraries that are loaded
into all Haskell projects. The most foundational of these is
<code>base</code> which forms the foundation for all Haskell code. The
base library is split across several modules.</p>
<ul>
<li><em>Prelude</em> - The default namespace imported in every
module.</li>
<li><em>Data</em> - The simple data structures wired into the
language</li>
<li><em>Control</em> - Control flow functions</li>
<li><em>Foreign</em> - Foreign function interface</li>
<li><em>Numeric</em> - Numerical tower and arithmetic operations</li>
<li><em>System</em> - System operations for Linux/Mac/Windows</li>
<li><em>Text</em> - Basic <a href="#string">String</a> types.</li>
<li><em>Type</em> - Typelevel operations</li>
<li><em>GHC</em> - GHC Internals</li>
<li><em>Debug</em> - Debug functions</li>
<li><em>Unsafe</em> - Unsafe “backdoor” operations</li>
</ul>
<p>There have been several large changes to Base over the years which
have resulted in breaking changes that means older versions of base are
not compatible with newer versions.</p>
<ul>
<li>Monad Applicative Proposal (AMP)</li>
<li>MonadFail Proposal (MFP)</li>
<li>Semigroup Monoid Proposal (SMP)</li>
</ul>
<h2 id="prelude">Prelude</h2>
<p>The Prelude is the default standard module. The Prelude is imported
by default into all Haskell modules unless either there is an explicit
import statement for it, or the NoImplicitPrelude extension is
enabled.</p>
<p>The Prelude exports several hundred symbols that are the default
datatypes and functions for libraries that use the GHC-issued prelude.
Although the Prelude is the default import, many libraries these days do
not use the standard prelude instead choosing to roll a custom one on a
per-project basis or to use an off-the shelf prelude from Hackage.</p>
<p>The Prelude contains common datatype and classes such as <a
href="#lists">List</a>, <a href="#monads">Monad</a>, <a
href="#algebraic-datatypes">Maybe</a> and most associated functions for
manipulating these structures. These are the most foundational
programming constructs in Haskell.</p>
<h2 id="modern-haskell">Modern Haskell</h2>
<p>There are two official language standards:</p>
<ul>
<li>Haskell98</li>
<li>Haskell2010</li>
</ul>
<p>And then there is what is colloquially referred to as Modern Haskell
which is not an official language standard, but an ambiguous term to
denote the emerging way most Haskellers program with new versions of
GHC. The language features typically included in modern Haskell are not
well-defined and will vary between programmers. For instance, some
programmers prefer to stay quite close to the Haskell2010 standard and
only include a few extensions while some go all out and attempt to do
full dependent types in Haskell.</p>
<p>By contrast, the type of programming described by the phrase Modern
Haskell typically utilizes some type-level programming, as well as
flexible typeclasses, and a handful of <a
href="#language-extensions">Language Extensions</a>.</p>
<h2 id="flags">Flags</h2>
<p>GHC has a wide variety of flags that can be passed to configure
different behavior in the compiler. Enabling GHC compiler flags grants
the user more control in detecting common code errors. The most
frequently used flags are:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Flag</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>-fwarn-tabs</code></td>
<td style="text-align: left;">Emit warnings of tabs instead of spaces in
the source code</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-fwarn-unused-imports</code></td>
<td style="text-align: left;">Warn about libraries imported without
being used</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-fwarn-name-shadowing</code></td>
<td style="text-align: left;">Warn on duplicate names in nested
bindings</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>-fwarn-incomplete-uni-patterns</code></td>
<td style="text-align: left;">Emit warnings for incomplete patterns in
lambdas or pattern bindings</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>-fwarn-incomplete-patterns</code></td>
<td style="text-align: left;">Warn on non-exhaustive patterns</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>-fwarn-overlapping-patterns</code></td>
<td style="text-align: left;">Warn on pattern matching branches that
overlap</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>-fwarn-incomplete-record-updates</code></td>
<td style="text-align: left;">Warn when records are not instantiated
with all fields</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-fdefer-type-errors</code></td>
<td style="text-align: left;">Turn type errors into warnings</td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>-fwarn-missing-signatures</code></td>
<td style="text-align: left;">Warn about toplevel missing type
signatures</td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>-fwarn-monomorphism-restriction</code></td>
<td style="text-align: left;">Warn when the monomorphism restriction is
applied implicitly</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-fwarn-orphans</code></td>
<td style="text-align: left;">Warn on orphan typeclass instances</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-fforce-recomp</code></td>
<td style="text-align: left;">Force recompilation regardless of
timestamp</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-fno-code</code></td>
<td style="text-align: left;">Omit code generation, just parse and
typecheck</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-fobject-code</code></td>
<td style="text-align: left;">Generate object code</td>
</tr>
</tbody>
</table>
<p>Like most compilers, GHC takes the <code>-Wall</code> flag to enable
all warnings. However, a few of the enabled warnings are highly verbose.
For example, <code>-fwarn-unused-do-bind</code> and
<code>-fwarn-unused-matches</code> typically would not correspond to
errors or failures.</p>
<p>Any of these flags can be added to the <code>ghc-options</code>
section of a project’s <code>.cabal</code> file. For example:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>  ghc-options:</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    -fwarn-tabs</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>    -fwarn-unused-imports</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    -fwarn-missing-signatures</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    -fwarn-name-shadowing</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    -fwarn-incomplete-patterns</span></code></pre></div>
<p>The flags described above are simply the most useful. See the
official reference for the complete set of GHC’s supported flags.</p>
<p>For information on debugging GHC internals, see the <a
href="#block-diagram">commentary</a> on GHC internals.</p>
<h2 id="hackage">Hackage</h2>
<p><a href="http://hackage.haskell.org/">Hackage</a> is the upstream
source of open source Haskell packages. With Haskell’s continuing
evolution, Hackage has become many things to developers, but there seem
to be two dominant philosophies of uploaded libraries.</p>
<p><strong>A Repository for Production Libraries</strong></p>
<p>In the first philosophy, libraries exist as reliable,
community-supported building blocks for constructing higher level
functionality on top of a common, stable edifice. In development
communities where this method is the dominant philosophy, the authors of
libraries have written them as a means of packaging up their
understanding of a problem domain so that others can build on their
understanding and expertise.</p>
<p><strong>An Experimental Playground</strong></p>
<p>In contrast to the previous method of packaging, a common philosophy
in the Haskell community is that Hackage is a place to upload
experimental libraries as a means of getting community feedback and
making the code publicly available. Library authors often rationalize
putting these kinds of libraries up without documentation, often without
indication of what the library actually does or how it works. This
unfortunately means a lot of Hackage namespace has become polluted with
dead-end, bit-rotting code. Sometimes packages are also uploaded purely
for internal use within an organisation, or to accompany an academic
paper. These packages are often left undocumented as well.</p>
<p>For developers coming to Haskell from other language ecosystems that
favor the former philosophy (e.g., Python, JavaScript, Ruby), seeing
<em>thousands of libraries without the slightest hint of documentation
or description of purpose</em> can be unnerving. It is an open question
whether the current cultural state of Hackage is sustainable in light of
these philosophical differences.</p>
<p>Needless to say, there is a lot of very low-quality Haskell code and
documentation out there today, so being conservative in library
assessment is a necessary skill. That said, there are also quite a few
phenomenal libraries on Hackage that are highly curated by many
people.</p>
<p>As a general rule, if the Haddock documentation for the library does
not have a <strong>minimal working example</strong>, it is usually safe
to assume that it is an RFC-style library and probably should be avoided
for production code.</p>
<p>There are several heuristics you can use to answer the question
<strong>Should I Use this Hackage Library</strong>:</p>
<ul>
<li>Check the <strong>Uploaded</strong> to see if the author has updated
it in the last five years.</li>
<li>Check the <strong>Maintainer</strong> email address, if the author
has an academic email address and has not uploaded a package in two or
more years, it is safe to assume that this is a <em>thesis project</em>
and probably should not be used industrially.</li>
<li>Check the <strong>Modules</strong> to see if the author has included
toplevel Haddock docstrings. If the author has not included any
documentation then the library is likely of low-quality and should not
be used industrially.</li>
<li>Check the <strong>Dependencies</strong> for the bound on
<code>base</code> package. If it doesn’t include the latest base
included with the latest version of GHC then the code is likely not
actively maintained.</li>
<li>Check the reverse Hackage search to see if the package is used by
other libraries in the ecosystem. For example:
https://packdeps.haskellers.com/reverse/QuickCheck</li>
</ul>
<p>An example of a bitrotted package:</p>
<p><strong>https://hackage.haskell.org/package/numeric-quest</strong></p>
<p>An example of a well maintained package:</p>
<p><strong>https://hackage.haskell.org/package/QuickCheck</strong></p>
<h2 id="stackage">Stackage</h2>
<p>Stackage is an alternative opt-in packaging repository which mirrors
a subset of Hackage. Packages that are included in Stackage are built in
a massive continuous integration process that checks to see that given
versions link successfully against each other. This can give a higher
degree of assurance that the bounds of a given resolver ensure
compatibility.</p>
<p>Stackage releases are built nightly and there are also long-term
stable (LTS) releases. Nightly resolvers have a date convention while
LTS releases have a major and minor version. For example:</p>
<ul>
<li><code>lts-14.22</code></li>
<li><code>nightly-2020-01-30</code></li>
</ul>
<p>See:</p>
<ul>
<li><a href="https://www.stackage.org/">Stackage</a></li>
<li><a href="https://github.com/fpco/lts-haskell#readme">Stackage
FAQ</a></li>
</ul>
<h2 id="ghci">GHCi</h2>
<p>GHCi is the interactive shell for the GHC compiler. GHCi is where we
will spend most of our time in everyday development. Following is a
table of useful GHCi commands.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Command</th>
<th style="text-align: left;">Shortcut</th>
<th style="text-align: left;">Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>:reload</code></td>
<td style="text-align: left;"><code>:r</code></td>
<td style="text-align: left;">Code reload</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:type</code></td>
<td style="text-align: left;"><code>:t</code></td>
<td style="text-align: left;">Type inspection</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:kind</code></td>
<td style="text-align: left;"><code>:k</code></td>
<td style="text-align: left;">Kind inspection</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:info</code></td>
<td style="text-align: left;"><code>:i</code></td>
<td style="text-align: left;">Information</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:print</code></td>
<td style="text-align: left;"><code>:p</code></td>
<td style="text-align: left;">Print the expression</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:edit</code></td>
<td style="text-align: left;"><code>:e</code></td>
<td style="text-align: left;">Load file in system editor</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:load</code></td>
<td style="text-align: left;"><code>:l</code></td>
<td style="text-align: left;">Set the active Main module in the
REPL</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:module</code></td>
<td style="text-align: left;"><code>:m</code></td>
<td style="text-align: left;">Add modules to imports</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:add</code></td>
<td style="text-align: left;"><code>:ad</code></td>
<td style="text-align: left;">Load a file into the REPL namespace</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:instances</code></td>
<td style="text-align: left;"><code>:in</code></td>
<td style="text-align: left;">Show instances of a typeclass</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>:browse</code></td>
<td style="text-align: left;"><code>:bro</code></td>
<td style="text-align: left;">Browse all available symbols in the REPL
namespace</td>
</tr>
</tbody>
</table>
<p>The introspection commands are an essential part of debugging and
interacting with Haskell code:</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span><span class="kw">type</span> <span class="dv">3</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a</span></code></pre></div>
<div class="sourceCode" id="cb50"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind <span class="dt">Either</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Either</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span></code></pre></div>
<div class="sourceCode" id="cb51"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>info <span class="dt">Functor</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&lt;$) ::</span> a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">-- Defined in `GHC.Base&#39;</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<div class="sourceCode" id="cb52"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>i (<span class="op">:</span>)</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> [] a <span class="ot">=</span> <span class="op">...</span> <span class="op">|</span> a <span class="op">:</span> [a]       <span class="co">-- Defined in `GHC.Types&#39;</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:</span></span></code></pre></div>
<p>Querying the current state of the global environment in the shell is
also possible. For example, to view module-level bindings and types in
GHCi, run:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>browse</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span><span class="fu">show</span> bindings</span></code></pre></div>
<p>To examine module-level imports, execute:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span><span class="fu">show</span> imports</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="co">-- implicit</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Eq</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span></code></pre></div>
<p>Language extensions can be set at the repl.</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>set <span class="op">-</span><span class="dt">XNoImplicitPrelude</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>set <span class="op">-</span><span class="dt">XFlexibleContexts</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>set <span class="op">-</span><span class="dt">XFlexibleInstances</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>set <span class="op">-</span><span class="dt">XOverloadedStrings</span></span></code></pre></div>
<p>To see compiler-level flags and pragmas, use:</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>set</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>options currently set<span class="op">:</span> none<span class="op">.</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>base language is<span class="op">:</span> <span class="dt">Haskell2010</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>with the following modifiers<span class="op">:</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">-</span><span class="dt">XNoDatatypeContexts</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">-</span><span class="dt">XNondecreasingIndentation</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="dt">GHCi</span><span class="op">-</span>specific dynamic flag settings<span class="op">:</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>other dynamic, non<span class="op">-</span>language, flag settings<span class="op">:</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">-</span>fimplicit<span class="op">-</span><span class="kw">import</span>-<span class="kw">qualified</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>warning settings<span class="op">:</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>showi language</span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>base language is<span class="op">:</span> <span class="dt">Haskell2010</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>with the following modifiers<span class="op">:</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">-</span><span class="dt">XNoDatatypeContexts</span></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">-</span><span class="dt">XNondecreasingIndentation</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">-</span><span class="dt">XExtendedDefaultRules</span></span></code></pre></div>
<p>Language extensions and compiler pragmas can be set at the prompt.
See the <a href="#flags">Flag Reference</a> for the vast collection of
compiler flag options.</p>
<p>Several commands for the interactive shell have shortcuts:</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;">Function</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>+t</code></td>
<td style="text-align: left;">Show types of evaluated expressions</td>
</tr>
<tr class="even">
<td><code>+s</code></td>
<td style="text-align: left;">Show timing and memory usage</td>
</tr>
<tr class="odd">
<td><code>+m</code></td>
<td style="text-align: left;">Enable multi-line expression delimited by
<code>:{</code> and <code>:}</code>.</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb57"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>set <span class="op">+</span>t</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> []</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>[]</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="ot">it ::</span> [a]</span></code></pre></div>
<div class="sourceCode" id="cb58"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>set <span class="op">+</span>s</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="fu">foldr</span> (<span class="op">+</span>) <span class="dv">0</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">25</span>]</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="dv">325</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="ot">it ::</span> <span class="dt">Prelude.Integer</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>(<span class="fl">0.02</span> secs, <span class="dv">4900952</span> bytes)</span></code></pre></div>
<div class="sourceCode" id="cb59"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>set <span class="op">+</span>m</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>{</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:|</span> <span class="kw">let</span> foo <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:|</span>           <span class="fu">putStrLn</span> <span class="st">&quot;hello ghci&quot;</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:|</span> <span class="op">:</span>}</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> foo</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;hello ghci&quot;</span></span></code></pre></div>
<h2 id="ghci.conf">.ghci.conf</h2>
<p>The GHCi shell can be customized globally by defining a configure
file <code>ghci.conf</code> in <code>$HOME/.ghc/</code> or in the
current working directory as <code>./.ghci.conf</code>.</p>
<p>For example, we can add a command to use the <a
href="https://www.haskell.org/hoogle/">Hoogle</a> type search from
within GHCi. First, install <code>hoogle</code>:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a> <span class="co"># run one of these command</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal install hoogle</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack install hoogle</span></code></pre></div>
<p>Then, we can enable the search functionality by adding a command to
our <code>ghci.conf</code>:</p>
<div class="sourceCode" id="cb61"
data-include="src/01-basics/ghci.conf"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>set prompt <span class="st">&quot;λ: &quot;</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>def hlint <span class="fu">const</span> <span class="op">.</span> <span class="fu">return</span> <span class="op">$</span> <span class="st">&quot;:! hlint \&quot;src\&quot;&quot;</span></span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>def hoogle \s <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> <span class="st">&quot;:! hoogle --count=15 \&quot;&quot;</span> <span class="op">++</span> s <span class="op">++</span> <span class="st">&quot;\&quot;&quot;</span></span></code></pre></div>
<div class="sourceCode" id="cb62"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>hoogle (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Data.Traversable</span><span class="ot"> fmapDefault ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> t b</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Prelude</span><span class="ot"> fmap ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>It is common community tradition to set the prompt to a colored
<code>λ</code>:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>set prompt <span class="st">&quot;\ESC[38;5;208m\STXλ&gt;\ESC[m\STX &quot;</span></span></code></pre></div>
<p>GHC can also be coerced into giving slightly better error
messages:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Better errors</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>set <span class="op">-</span>ferror<span class="op">-</span>spans <span class="op">-</span>freverse<span class="op">-</span>errors <span class="op">-</span>fprint<span class="op">-</span>expanded<span class="op">-</span>synonyms</span></code></pre></div>
<p>GHCi can also use a pretty printing library to format all output,
which is often much easier to read. For example if your project is
already using the amazing <code>pretty-simple</code> library simply
include the following line in your ghci configuration.</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>set <span class="op">-</span>ignore<span class="op">-</span>package pretty<span class="op">-</span>simple <span class="op">-</span>package pretty<span class="op">-</span>simple</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>def<span class="op">!</span> pretty \ _ <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="st">&quot;:set -interactive-print Text.Pretty.Simple.pPrint&quot;</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>pretty</span></code></pre></div>
<p>And the default prelude can also be disabled and swapped for
something more sensible:</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>seti <span class="op">-</span><span class="dt">XNoImplicitPrelude</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>seti <span class="op">-</span><span class="dt">XFlexibleContexts</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>seti <span class="op">-</span><span class="dt">XFlexibleInstances</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>seti <span class="op">-</span><span class="dt">XOverloadedStrings</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Protolude</span> <span class="co">-- or any other preferred prelude</span></span></code></pre></div>
<h4 id="ghci-performance">GHCi Performance</h4>
<p>For large projects, GHCi with the default flags can use quite a bit
of memory and take a long time to compile. To speed compilation by
keeping artifacts for compiled modules around, we can enable object code
compilation instead of bytecode.</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>set <span class="op">-</span>fobject<span class="op">-</span>code</span></code></pre></div>
<p>Enabling object code compilation may complicate type inference, since
type information provided to the shell can sometimes be less informative
than source-loaded code. This underspecificity can result in breakage
with some language extensions. In that case, you can temporarily
reenable bytecode compilation on a per module basis with the
<code>-fbyte-code</code> flag.</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>set <span class="op">-</span>fbyte<span class="op">-</span>code</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>load MyModule.hs</span></code></pre></div>
<p>If all you need is to typecheck your code in the interactive shell,
then disabling code generation entirely makes reloading code almost
instantaneous:</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="op">:</span>set <span class="op">-</span>fno<span class="op">-</span>code</span></code></pre></div>
<h2 id="editor-integration">Editor Integration</h2>
<p>Haskell has a variety of editor tools that can be used to provide
interactive development feedback and functionality such as querying
types of subexpressions, linting, type checking, and code completion.
These are largely provided by the <a
href="https://github.com/haskell/haskell-ide-engine">haskell-ide-engine</a>
which serves as an editor agnostic backend that interfaces with GHC and
Cabal to query code.</p>
<p><strong>Vim</strong></p>
<ul>
<li><a
href="https://github.com/haskell/haskell-ide-engine#using-hie-with-vim-or-neovim">haskell-ide-engine</a></li>
<li><a
href="https://github.com/neovimhaskell/haskell-vim">haskell-vim</a></li>
<li><a href="https://github.com/sdiehl/vim-ormolu">vim-ormolu</a></li>
</ul>
<p><strong>Emacs</strong></p>
<ul>
<li><a
href="https://github.com/haskell/haskell-mode">haskell-mode</a></li>
<li><a
href="https://github.com/haskell/haskell-ide-engine#using-hie-with-emacs">haskell-ide-engine</a></li>
<li><a href="https://github.com/vyorkin/ormolu.el">ormolu.el</a></li>
</ul>
<p><strong>VSCode</strong></p>
<ul>
<li><a
href="https://github.com/haskell/haskell-ide-engine#using-hie-with-vs-code">haskell-ide-engine</a>
- Tab completion plugin</li>
<li><a
href="https://marketplace.visualstudio.com/items?itemName=justusadam.language-haskell">language-haskell</a>
- Syntax highlighting plugin</li>
<li><a
href="https://marketplace.visualstudio.com/items?itemName=ndmitchell.haskell-ghcid">ghcid</a>
- Interactive error reporting plugin</li>
<li><a
href="https://marketplace.visualstudio.com/items?itemName=alanz.vscode-hie-server">hie-server</a>
- Jump to definition and tag handling plugin</li>
<li><a
href="https://marketplace.visualstudio.com/items?itemName=hoovercj.haskell-linter">hlint</a>
- Linting and style-checking plugin</li>
<li><a
href="https://marketplace.visualstudio.com/items?itemName=DigitalAssetHoldingsLLC.ghcide">ghcide</a>
- Interactive completion plugin</li>
<li><a
href="https://marketplace.visualstudio.com/items?itemName=sjurmillidahl.ormolu-vscode">ormolu-vscode</a>
- Code formatting plugin</li>
</ul>
<h2 id="linux-packages">Linux Packages</h2>
<p>There are several upstream packages for Linux packages which are
released by GHC development. The key ones of note for Linux are:</p>
<ul>
<li><a href="https://downloads.haskell.org/~debian/">Debian
Packages</a></li>
<li><a href="https://launchpad.net/~hvr/+archive/ubuntu/ghc">Debian
PPA</a></li>
</ul>
<p>For scripts and operations tools, it is common to include commands to
add the following apt repositories, and then use these to install the
signed GHC and cabal-install binaries (if using Cabal as the primary
build system).</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo add-apt-repository <span class="at">-y</span> ppa:hvr/ghc</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo apt-get update</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> sudo apt-get install <span class="at">-y</span> cabal-install-3.0 ghc-8.8.1</span></code></pre></div>
<p>It is not advisable to use a Linux system package manager to manage
Haskell dependencies. Although this can be done, in practice it is
better to use Cabal or Stack to create locally isolated builds to avoid
incompatibilities.</p>
<h2 id="names">Names</h2>
<p>Names in Haskell exist within a specific namespace. Names are either
unqualified of the form:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>nub</span></code></pre></div>
<p>Or qualified by the module where they come from, such as:</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>Data.List.nub</span></code></pre></div>
<p>The major namespaces are described below with their naming
conventions</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Namespace</th>
<th style="text-align: left;">Convention</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Modules</td>
<td style="text-align: left;">Uppercase</td>
</tr>
<tr class="even">
<td style="text-align: left;">Functions</td>
<td style="text-align: left;">Lowercase</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Variables</td>
<td style="text-align: left;">Lowercase</td>
</tr>
<tr class="even">
<td style="text-align: left;">Type Variables</td>
<td style="text-align: left;">Lowercase</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Datatypes</td>
<td style="text-align: left;">Uppercase</td>
</tr>
<tr class="even">
<td style="text-align: left;">Constructors</td>
<td style="text-align: left;">Uppercase</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Typeclasses</td>
<td style="text-align: left;">Uppercase</td>
</tr>
<tr class="even">
<td style="text-align: left;">Synonyms</td>
<td style="text-align: left;">Uppercase</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Type Families</td>
<td style="text-align: left;">Uppercase</td>
</tr>
</tbody>
</table>
<h2 id="modules">Modules</h2>
<p>A module consists of a set of imports and exports and when compiled
generates an interface which is linked against other Haskell modules. A
module may reexport symbols from other modules.</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- A module starts with its export declarations of symbols declared in this file.</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">MyModule</span> (myExport1, myExport2) <span class="kw">where</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Followed by a set of imports of symbols from other files</span></span>
<span id="cb73-5"><a href="#cb73-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">OtherModule</span> (myImport1, myImport2)</span>
<span id="cb73-6"><a href="#cb73-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb73-7"><a href="#cb73-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Rest of the logic and definitions in the module follow</span></span>
<span id="cb73-8"><a href="#cb73-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- ...</span></span></code></pre></div>
<p>Modules’ dependency graphs optionally may be cyclic (i.e. they import
symbols from each other) through the use of a boot file, but this is
often best avoided if at all possible.</p>
<p>Various module import strategies exist. For instance, we may:</p>
<p>Import all symbols into the local namespace.</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span></span></code></pre></div>
<p>Import select symbols into the local namespace:</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (nub, sort)</span></code></pre></div>
<p>Import into the global namespace masking a symbol:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> <span class="kw">hiding</span> (nub)</span></code></pre></div>
<p>Import symbols qualified under <code>Data.Map</code> namespace into
the local namespace.</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span></span></code></pre></div>
<p>Import symbols qualified and reassigned to a custom namespace
(<code>M</code>, in the example below):</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span></code></pre></div>
<p>You may also dump multiple modules into the same namespace so long as
the symbols do not clash:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">M</span></span></code></pre></div>
<p>A main module is a special module which reserves the name
<code>Main</code> and has a mandatory export of type <code>IO ()</code>
which is invoked when the executable is run.. This is the entry point
from the system into a Haskell program.</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="st">&quot;Hello World!&quot;</span></span></code></pre></div>
<h2 id="functions">Functions</h2>
<p>Functions are the central construction in Haskell. A function
<code>f</code> of two arguments <code>x</code> and <code>y</code> can be
defined in a single line as the left-hand and right-hand side of an
equation:</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>f x y <span class="ot">=</span> x <span class="op">+</span> y</span></code></pre></div>
<p>This line defines a function named <code>f</code> of two arguments,
which on the right-hand side adds and yields the result. Central to the
idea of functional programming is that computational functions should
behave like mathematical functions. For instance, consider this
mathematical definition of the above Haskell function, which, aside from
the parentheses, looks the same:</p>
<p><span
class="math display"><em>f</em>(<em>x</em>, <em>y</em>) = <em>x</em> + <em>y</em></span></p>
<p>In Haskell, a function of two arguments need not necessarily be
applied to two arguments. The result of applying only the first argument
is to yield another function to which later the second argument can be
applied. For example, we can define an <code>add</code> function and
subsequently a single-argument <code>inc</code> function, by merely
pre-applying <code>1</code> to <code>add</code>:</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>inc <span class="ot">=</span> add <span class="dv">1</span></span></code></pre></div>
<div class="sourceCode" id="cb83"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> inc <span class="dv">4</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span></span></code></pre></div>
<p>In addition to named functions Haskell also has anonymous lambda
functions denoted with a backslash. For example the identity
function:</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<p>Is identical to:</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> <span class="ot">=</span> \x <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>Functions may call themselves or other functions as arguments; a
feature known as <em>higher-order functions</em>. For example the
following function applies a given argument <code>f</code>, which is
itself a function, to a value <code>x</code> twice.</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>applyTwice f x <span class="ot">=</span> f (f x)</span></code></pre></div>
<h2 id="types">Types</h2>
<p>Typed functional programming is essential to the modern Haskell
paradigm. But what are types precisely?</p>
<p>The <em>syntax</em> of a programming language is described by the
constructs that define its types, and its <em>semantics</em> are
described by the interactions among those constructs. A type system
overlays additional structure on top of the syntax that imposes
constraints on the formation of expressions based on the context in
which they occur.</p>
<p>Dynamic programming languages associate types with values <em>at
evaluation</em>, whereas statically typed languages associate types to
expressions <em>before evaluation</em>. Dynamic languages are in a sense
as statically typed as static languages, however they have a degenerate
type system with only one type.</p>
<p>The dominant philosophy in functional programming is to “make invalid
states unrepresentable” at compile-time, rather than performing massive
amounts of runtime checks. To this end Haskell has developed a rich type
system that is based on typed lambda calculus known as Girard’s System-F
(See <a href="#rank-n-types">Rank-N Types</a>) and has incrementally
added extensions to support more type-level programming over the
years.</p>
<p>The following <em>ground types</em> are quite common:</p>
<ul>
<li><code>()</code> - The unit type</li>
<li><code>Char</code> - A single unicode character (“code point”)</li>
<li><code>Text</code> - Unicode strings</li>
<li><code>Bool</code> - Boolean values</li>
<li><code>Int</code> - Machine integers</li>
<li><code>Integer</code> - GMP arbitrary precision integers</li>
<li><code>Float</code> - Machine floating point values</li>
<li><code>Double</code> - Machine double floating point values</li>
</ul>
<p><em>Parameterised types</em> consist of a type and several <em>type
parameters</em> indicated as lower case <em>type variables</em>. These
are associated with common data structures such as <a
href="#lists">lists</a> and <a href="#tuples">tuples</a>.</p>
<ul>
<li><code>[a]</code> – Homogeneous lists with elements of type
<code>a</code></li>
<li><code>(a,b)</code> – Tuple with two elements of types <code>a</code>
and <code>b</code></li>
<li><code>(a,b,c)</code> – Tuple with three elements of types
<code>a</code>, <code>b</code>, and <code>c</code></li>
</ul>
<p>The type system grows quite a bit from here, but these are the
foundational types you’ll first encounter. See the later chapters for
all types off advanced features that can be optionally turned on.</p>
<p><em>This tutorial will only cover a small amount of the theory of
type systems. For a more thorough treatment of the subject there are two
canonical texts:</em></p>
<ul>
<li>Pierce, B. C., &amp; Benjamin, C. (2002). <strong>Types and
Programming Languages</strong>. MIT Press.</li>
<li>Harper, R. (2016). <strong>Practical Foundations for Programming
Languages</strong>. Cambridge University Press.</li>
</ul>
<h2 id="type-signatures">Type Signatures</h2>
<p>A toplevel Haskell function consists of two lines. The
<em>value-level</em> definition which is a function name, followed by
its arguments on the left-hand side of the equals sign, and then the
function body which computes the value it yields on the right-hand
side:</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>myFunction x y <span class="ot">=</span> x <span class="op">^</span> <span class="dv">2</span> <span class="op">+</span> y <span class="op">^</span> <span class="dv">2</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   ^     ^ ^   ^^^^^^^^^^^^^</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   |     | |   |</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a><span class="co">--   |     | |   +-- function body</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a><span class="co">--   |     | +------ second argument</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a><span class="co">--   |     +-------- first argument </span></span>
<span id="cb87-7"><a href="#cb87-7" aria-hidden="true" tabindex="-1"></a><span class="co">--   +-------------- function</span></span></code></pre></div>
<p>The <em>type-level</em> definition is the function name followed by
the type of its arguments separated by arrows, and the final term is the
type of the entire function body, meaning the type of value yielded by
the function itself.</p>
<div class="sourceCode" id="cb88"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myFunction ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="co">--   ^          ^     ^    ^^^^^</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a><span class="co">--   |          |     |    |</span></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a><span class="co">--   |          |     |    +- return type</span></span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a><span class="co">--   |          |     +------ second argument</span></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a><span class="co">--   |          +------------ first argument </span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a><span class="co">--   +----------------------- function</span></span></code></pre></div>
<p>Here is a simple example of a function which adds two integers.</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y</span></code></pre></div>
<p>Functions are also capable of invoking other functions inside of
their function bodies:</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="ot">inc ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>inc <span class="ot">=</span> add <span class="dv">1</span></span></code></pre></div>
<p>The simplest function, called the <em>identity function</em>, is a
function which takes a single value and simply returns it back. This is
an example of a polymorphic function since it can handle values of
<em>any type</em>. The identity function works just as well over strings
as over integers.</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<p>This can alternatively be written in terms of an anonymous <em>lambda
function</em> which is a backslash followed by a space-separated list of
arguments, followed by a function body.</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> <span class="ot">=</span> \x <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>One of the big ideas in functional programming is that functions are
themselves first class values which can be passed to other functions as
arguments themselves. For example the <code>applyTwice</code> function
takes an argument <code>f</code> which is of type
(<code>a -&gt; a</code>) and it applies that function over a given value
<code>x</code> twice and yields the result. <code>applyTwice</code> is a
higher-order function which will transform one function into another
function.</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="ot">applyTwice ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>applyTwice f x <span class="ot">=</span> f (f x)</span></code></pre></div>
<p>Often to the left of a type signature you will see a big arrow
<code>=&gt;</code> which denotes a set of <strong>constraints</strong>
over the type signature. Each of these constraints will be in uppercase
and will normally mention at least one of the type variables on the
right hand side of the arrow. These constraints can mean many things but
in the simplest form they denote that a type variable must have an
implementation of a <a href="#type-classes">type class</a>. The
<code>add</code> function below operates over any two similar values
<code>x</code> and <code>y</code>, but these values must have a
numerical interface for adding them together.</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> (<span class="dt">Num</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y</span></code></pre></div>
<p>Type signatures can also appear at the value level in the form of
<em>explicit type signatures</em> which are denoted in parentheses.</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>add1 x <span class="ot">=</span> x <span class="op">+</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span></code></pre></div>
<p>These are sometimes needed to provide additional hints to the
typechecker when specific terms are ambiguous to the typechecker, or
when additional language extensions have been enabled which don’t have
precise inference methods for deducing all type variables.</p>
<h2 id="currying">Currying</h2>
<p>In other languages functions normally have an <em>arity</em> which
prescribes the number of arguments a function can take. Some languages
have fixed arity (like Fortran) others have flexible arity (like Python)
where a variable of number of arguments can be passed. Haskell follows a
very simple rule: all functions in Haskell take a single argument. For
multi-argument functions (some of which we’ve already seen), arguments
will be individually applied until the function is <em>saturated</em>
and the function body is evaluated.</p>
<p>For example, the add function from above can be partially applied to
produce an add1 function:</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y</span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span class="ot">add1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>add1 <span class="ot">=</span> add <span class="dv">1</span></span></code></pre></div>
<p>Uncurrying is the process of taking a function which takes two
arguments and transforming it into a function which takes a tuple of
arguments. The Haskell prelude includes both a curry and an uncurry
function for transforming functions into those that take multiple
arguments from those that take a tuple of arguments and vice versa:</p>
<div class="sourceCode" id="cb97"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="fu">curry</span><span class="ot"> ::</span> ((a, b) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a><span class="fu">uncurry</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a, b) <span class="ot">-&gt;</span> c</span></code></pre></div>
<p>For example, uncurry applied to the add function creates a function
that takes a tuple of integers:</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="ot">uncurryAdd ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>uncurryAdd <span class="ot">=</span> <span class="fu">uncurry</span> add</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">Int</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> uncurryAdd (<span class="dv">1</span>,<span class="dv">2</span>)</span></code></pre></div>
<h2 id="algebraic-datatypes">Algebraic Datatypes</h2>
<p>Custom datatypes in Haskell are defined with the <code>data</code>
keyword followed by the the type name, its parameters, and then a set of
<em>constructors</em>. The possible constructors are either <em>sum
types</em> or of <em>product types</em>. All datatypes in Haskell can be
expressed as sums of products. A sum type is a set of options that is
delimited by a pipe.</p>
<p>A datatype can only ever be inhabited by a single value from a sum
type and intuitively models a set of “options” a value may take. While a
product type is a combination of a set of typed values, potentially
named by record fields. For example the following are two definitions of
a Point product type, the latter with two fields <code>x</code> and
<code>y</code>.</p>
<div class="sourceCode" id="cb99"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">Point</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">Point</span> {<span class="ot"> x ::</span> <span class="dt">Int</span>,<span class="ot"> y ::</span> <span class="dt">Int</span> }</span></code></pre></div>
<p>As another example: A deck of common playing cards could be modeled
by the following set of product and sum types:</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Suit</span> <span class="ot">=</span> <span class="dt">Clubs</span> <span class="op">|</span> <span class="dt">Diamonds</span> <span class="op">|</span> <span class="dt">Hearts</span> <span class="op">|</span> <span class="dt">Spades</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Black</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Value</span> </span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Two</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Three</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Four</span></span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Five</span></span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Six</span></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Seven</span></span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Eight</span></span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Nine</span></span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Ten</span> </span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Jack</span></span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Queen</span></span>
<span id="cb100-15"><a href="#cb100-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">King</span></span>
<span id="cb100-16"><a href="#cb100-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Ace</span></span>
<span id="cb100-17"><a href="#cb100-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>A record type can use these custom datatypes to define all the
parameters that define an individual playing card.</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Card</span> <span class="ot">=</span> <span class="dt">Card</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> suit  ::</span> <span class="dt">Suit</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> color ::</span> <span class="dt">Color</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> value ::</span> <span class="dt">Value</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Some example values:</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="ot">queenDiamonds ::</span> <span class="dt">Card</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>queenDiamonds <span class="ot">=</span> <span class="dt">Card</span> <span class="dt">Diamonds</span> <span class="dt">Red</span> <span class="dt">Queen</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Alternatively </span></span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a><span class="ot">queenDiamonds ::</span> <span class="dt">Card</span></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>queenDiamonds <span class="ot">=</span> <span class="dt">Card</span> { suit <span class="ot">=</span> <span class="dt">Diamonds</span>, color <span class="ot">=</span> <span class="dt">Red</span>, value <span class="ot">=</span> <span class="dt">Queen</span> }</span></code></pre></div>
<p>The problem with the definition of this datatype is that it admits
several values which are malformed. For instance it is possible to
instantiate a <code>Card</code> with a suit <code>Hearts</code> but with
color <code>Black</code> which is an invalid value. The convention for
preventing these kind of values in Haskell is to limit the export of
constructors in a module and only provide a limited set of functions
which the module exports, which can enforce these constraints. These are
<strong>smart constructors</strong> and an extremely common pattern in
Haskell library design. For example we can export functions for building
up specific suit cards that enforce the color invariant.</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Cards</span> (<span class="dt">Card</span>, diamond, spade, heart, club) <span class="kw">where</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a><span class="ot">diamond ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Card</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>diamond <span class="ot">=</span> <span class="dt">Card</span> <span class="dt">Diamonds</span> <span class="dt">Red</span></span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a><span class="ot">spade ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Card</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>spade <span class="ot">=</span> <span class="dt">Card</span> <span class="dt">Spades</span> <span class="dt">Black</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a><span class="ot">heart ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Card</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>heart <span class="ot">=</span> <span class="dt">Card</span> <span class="dt">Hearts</span> <span class="dt">Red</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a><span class="ot">club ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Card</span></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>club <span class="ot">=</span> <span class="dt">Card</span> <span class="dt">Clubs</span> <span class="dt">Black</span></span></code></pre></div>
<p>Datatypes may also be <strong>recursive</strong>, in the sense that
they can contain themselves as fields. The most common example is a
linked list which can be defined recursively as either an empty list or
a value linked to a potentially nested version of itself.</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">List</span> a (<span class="dt">List</span> a)</span></code></pre></div>
<p>An example value would look like:</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="ot">list ::</span> <span class="dt">List</span> <span class="dt">Integer</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>list <span class="ot">=</span> <span class="dt">List</span> <span class="dv">1</span> (<span class="dt">List</span> <span class="dv">2</span> (<span class="dt">List</span> <span class="dv">3</span> <span class="dt">Nil</span>))</span></code></pre></div>
<p>Constructors for datatypes can also be defined as infix symbols. This
is somewhat rare, but is sometimes used in more math heavy libraries.
For example the constructor for our list type could be defined as the
infix operator <code>:+:</code>. When the value is printed using a Show
instance, the operator will be printed in infix form.</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> a <span class="op">:+:</span> (<span class="dt">List</span> a)</span></code></pre></div>
<h2 id="lists">Lists</h2>
<p>Linked lists or <em>cons lists</em> are a fundamental data structure
in functional programming. GHC has builtin syntactic sugar in the form
of list syntax which allows us to write lists that expand into explicit
invocations of the <em>cons</em> operator <code>(:)</code>. The operator
is right associative and an example is shown below:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="ot">=</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">2</span> <span class="op">:</span> <span class="dv">3</span> <span class="op">:</span> []      </span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="ot">=</span> <span class="dv">1</span> <span class="op">:</span> (<span class="dv">2</span> <span class="op">:</span> (<span class="dv">3</span> <span class="op">:</span> [])) <span class="co">-- with explicit parens</span></span></code></pre></div>
<p>This syntax also extends to the typelevel where lists are represented
as brackets around the type of values they contain.</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myList1 ::</span> [<span class="dt">Int</span>]</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>myList1 <span class="ot">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a><span class="ot">myList2 ::</span> [<span class="dt">Bool</span>]</span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a>myList2 <span class="ot">=</span> [<span class="dt">True</span>, <span class="dt">True</span>, <span class="dt">False</span>]</span></code></pre></div>
<p>The cons operator itself has the type signature which takes a
<em>head element</em> as its first argument and a <em>tail argument</em>
as its second.</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(:) ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>The <code>Data.List</code>module from the standard Prelude defines a
variety of utility functions for operations over linked lists. For
example the <code>length</code> function returns the integral length of
the number of elements in the linked list.</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span></span></code></pre></div>
<p>While the <code>take</code> function extracts a fixed number of
elements from the list.</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>Both of these functions are <em>pure</em> and return a new list
without modifying the underlying list passed as an argument.</p>
<p>Another function <code>iterate</code> is an example of a function
which returns an <em>infinite list</em>. It takes as its first argument
a function and then repeatedly applies that function to produce a new
element of the linked list.</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="fu">iterate</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>Consuming these infinite lists can be used as a control flow
construct to construct loops. For example instead of writing an explicit
loop, as we would in other programming languages, we instead construct a
function which generates list elements. For example producing a list
which produces subsequent powers of two:</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>powersOfTwo <span class="ot">=</span> <span class="fu">iterate</span> (<span class="dv">2</span><span class="op">*</span>) <span class="dv">1</span></span></code></pre></div>
<p>We can then use the <code>take</code> function to evaluate this
<em>lazy</em> stream to a desired depth.</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="fu">take</span> <span class="dv">15</span> powersOfTwo</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">8</span>,<span class="dv">16</span>,<span class="dv">32</span>,<span class="dv">64</span>,<span class="dv">128</span>,<span class="dv">256</span>,<span class="dv">512</span>,<span class="dv">1024</span>,<span class="dv">2048</span>,<span class="dv">4096</span>,<span class="dv">8192</span>,<span class="dv">16384</span>]</span></code></pre></div>
<p>An equivalent loop in an imperative language would look like the
following.</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> powersOfTwo(n):</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>    square_list <span class="op">=</span> [<span class="dv">1</span>]</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>,n<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>        square_list.append(<span class="dv">2</span> <span class="op">**</span> i)</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> square_list</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(powersOfTwo(<span class="dv">15</span>))</span></code></pre></div>
<h2 id="pattern-matching">Pattern Matching</h2>
<p>To unpack an algebraic datatype and extract its fields we’ll use a
built in language construction known as <em>pattern matching</em>. This
is denoted by the <code>case</code> syntax and <em>scrutinizes</em> a
specific value. A case expression will then be followed by a sequence of
<em>matches</em> which consist of a <em>pattern</em> on the left and an
arbitrary expression on the right. The left patterns will all consist of
constructors for the type of the scrutinized value and should enumerate
all possible constructors. For product type patterns that are
scrutinized a sequence of variables will bind the fields associated with
its positional location in the constructor. The types of all expressions
on the right hand side of the matches must be identical.</p>
<p>Pattern matches can be written in explicit case statements or in
toplevel functional declarations. The latter simply expands the former
in the desugaring phase of the compiler.</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Example</span> <span class="ot">=</span> <span class="dt">Example</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>example1 x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span> </span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Example</span> a b c <span class="ot">-&gt;</span> a <span class="op">+</span> b <span class="op">+</span> c</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a>example2 (<span class="dt">Example</span> a b c) <span class="ot">=</span> a <span class="op">+</span> b <span class="op">+</span>c</span></code></pre></div>
<p>Following on the playing card example in the previous section, we
could use a pattern to produce a function which scores the face value of
a playing card.</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="ot">value ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>value card <span class="ot">=</span> <span class="kw">case</span> card <span class="kw">of</span></span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Two</span>    <span class="ot">-&gt;</span> <span class="dv">2</span></span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Three</span>  <span class="ot">-&gt;</span> <span class="dv">3</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Four</span>   <span class="ot">-&gt;</span> <span class="dv">4</span></span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Five</span>   <span class="ot">-&gt;</span> <span class="dv">5</span></span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Six</span>    <span class="ot">-&gt;</span> <span class="dv">6</span></span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Seven</span>  <span class="ot">-&gt;</span> <span class="dv">7</span></span>
<span id="cb117-9"><a href="#cb117-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Eight</span>  <span class="ot">-&gt;</span> <span class="dv">8</span></span>
<span id="cb117-10"><a href="#cb117-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nine</span>   <span class="ot">-&gt;</span> <span class="dv">9</span></span>
<span id="cb117-11"><a href="#cb117-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Ten</span>    <span class="ot">-&gt;</span> <span class="dv">10</span></span>
<span id="cb117-12"><a href="#cb117-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Jack</span>   <span class="ot">-&gt;</span> <span class="dv">10</span></span>
<span id="cb117-13"><a href="#cb117-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Queen</span>  <span class="ot">-&gt;</span> <span class="dv">10</span></span>
<span id="cb117-14"><a href="#cb117-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">King</span>   <span class="ot">-&gt;</span> <span class="dv">10</span></span>
<span id="cb117-15"><a href="#cb117-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Ace</span>    <span class="ot">-&gt;</span> <span class="dv">1</span></span></code></pre></div>
<p>And we can use a double pattern match to produce a function which
determines which suit trumps another suit. For example we can introduce
an order of suits of cards where the ranking of cards proceeds (Clubs,
Diamonds, Hearts, Spaces). A <code>_</code> underscore used inside a
pattern indicates a wildcard pattern and matches against any constructor
given. This should be the last pattern used a in match list.</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="ot">suitBeats ::</span> <span class="dt">Suit</span> <span class="ot">-&gt;</span> <span class="dt">Suit</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>suitBeats <span class="dt">Clubs</span>    <span class="dt">Diamonds</span>  <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb118-3"><a href="#cb118-3" aria-hidden="true" tabindex="-1"></a>suitBeats <span class="dt">Clubs</span>    <span class="dt">Hearts</span>    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb118-4"><a href="#cb118-4" aria-hidden="true" tabindex="-1"></a>suitBeats <span class="dt">Clubs</span>    <span class="dt">Spaces</span>    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb118-5"><a href="#cb118-5" aria-hidden="true" tabindex="-1"></a>suitBeats <span class="dt">Diamonds</span> <span class="dt">Hearts</span>    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb118-6"><a href="#cb118-6" aria-hidden="true" tabindex="-1"></a>suitBeats <span class="dt">Diamonds</span> <span class="dt">Spades</span>    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb118-7"><a href="#cb118-7" aria-hidden="true" tabindex="-1"></a>suitBeats <span class="dt">Hearts</span>   <span class="dt">Spades</span>    <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb118-8"><a href="#cb118-8" aria-hidden="true" tabindex="-1"></a>suitBeats _        _         <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>And finally we can write a function which determines if another card
beats another card in terms of the two pattern matching functions above.
The following pattern match brings the values of the record into the
scope of the function body assigning to names specified in the pattern
syntax.</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="ot">beats ::</span> <span class="dt">Card</span> <span class="ot">-&gt;</span> <span class="dt">Card</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a>beats (<span class="dt">Card</span> suit1 color1 value1) (<span class="dt">Card</span> suit2 color2 value2) <span class="ot">=</span> </span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>  (suitBeats suit1 suit2) <span class="op">&amp;&amp;</span> (value1 <span class="op">&gt;</span> value2)</span></code></pre></div>
<p>Functions may also invoke themselves. This is known as
<em>recursion</em>. This is quite common in pattern matching definitions
which recursively tear down or build up data structures. This kind of
pattern is one of the defining modes of programming functionally.</p>
<p>The following two recursive pattern matches are desugared forms of
each other:</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>fib n <span class="ot">=</span> fib (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib (n<span class="op">-</span><span class="dv">2</span>)</span></code></pre></div>
<div class="sourceCode" id="cb121"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>fib m <span class="ot">=</span> <span class="kw">case</span> m <span class="kw">of</span></span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>  <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dv">0</span></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dv">1</span></span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">-&gt;</span> fib (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib(n<span class="op">-</span><span class="dv">2</span>)</span></code></pre></div>
<p>Pattern matching on lists is also an extremely common pattern. It has
special pattern syntax and the tail variable is typically pluralized. In
the following <code>x</code> denotes the head variable and
<code>xs</code> denotes the tail. For example the following function
traverses a list of integers and adds <code>(+1)</code> to each
value.</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addOne ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>addOne (x <span class="op">:</span> xs) <span class="ot">=</span> (x<span class="op">+</span><span class="dv">1</span>) <span class="op">:</span> (addOne xs)</span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>addOne [] <span class="ot">=</span> []</span></code></pre></div>
<h2 id="guards">Guards</h2>
<p>Guard statements are expressions that evaluate to boolean values that
can be used to restrict pattern matches. These occur in a pattern match
statements at the toplevel with the pipe syntax on the left indicating
the guard condition. The special <code>otherwise</code> condition is
just a renaming of the boolean value <code>True</code> exported from
Prelude.</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absolute ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>absolute n </span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> n <span class="op">&lt;</span> <span class="dv">0</span>     <span class="ot">=</span> (<span class="op">-</span>n)</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> n</span></code></pre></div>
<p>Guards can also occur in pattern case expressions.</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absoluteJust ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>absoluteJust n <span class="ot">=</span> <span class="kw">case</span> n <span class="kw">of</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> n</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> n <span class="op">&lt;</span> <span class="dv">0</span>     <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="op">-</span>n)</span>
<span id="cb124-6"><a href="#cb124-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> n</span></code></pre></div>
<h2 id="operators-and-sections">Operators and Sections</h2>
<p>An operator is a function that can be applied using infix syntax or
partially applied using a section. Operators can be defined to use any
combination of the special ASCII symbols or any unicode symbol.</p>
<p><code>!</code> <code>#</code> <code>%</code> <code>&amp;</code>
<code>*</code> <code>+</code> <code>.</code> <code>/</code>
<code>&lt;</code> <code>=</code> <code>&gt;</code> <code>?</code>
<code>@</code> <code>\</code> <code>^</code> <code>|</code>
<code>-</code> <code>~</code> <code>:</code></p>
<p>The following are reserved syntax and cannot be overloaded:</p>
<p><code>..</code> <code>:</code> <code>::</code> <code>=</code>
<code>\</code> <code>|</code> <code>&lt;-</code> <code>-&gt;</code>
<code>@</code> <code>~</code> <code>=&gt;</code></p>
<p>Operators are of one of three fixity classes.</p>
<ul>
<li>Infix - Place between expressions</li>
<li>Prefix - Placed before expressions</li>
<li>Postfix - Placed after expressions. See <a
href="#postfix-operators">Postfix Operators</a>.</li>
</ul>
<p>Expressions involving infix operators are disambiguated by the
operator’s fixity and precedence. Infix operators are either left or
right associative. Associativity determines how operators of the same
precedence are grouped in the absence of parentheses.</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">+</span> b <span class="op">+</span> c <span class="op">+</span> d   <span class="ot">=</span>   ((a <span class="op">+</span> b) <span class="op">+</span> c) <span class="op">+</span> d    <span class="co">-- left associative</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">+</span> b <span class="op">+</span> c <span class="op">+</span> d   <span class="ot">=</span>   a <span class="op">+</span> (b <span class="op">+</span> (c <span class="op">+</span> d))    <span class="co">-- right associative</span></span></code></pre></div>
<p>Precedence and associativity are denoted by fixity declarations for
the operator using either <code>infixr</code> <code>infixl</code> and
<code>infix</code>. The standard operators defined in the Prelude have
the following precedence table.</p>
<div class="sourceCode" id="cb126"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">9</span>  <span class="op">.</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">8</span>  <span class="op">^</span>, <span class="op">^^</span>, <span class="op">**</span></span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">7</span>  <span class="op">*</span>, <span class="op">/</span>, <span class="ot">`quot`</span>, <span class="ot">`rem`</span>, <span class="ot">`div`</span>, <span class="ot">`mod`</span></span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">6</span>  <span class="op">+</span>, <span class="op">-</span></span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span>  <span class="op">++</span></span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>infix  <span class="dv">4</span>  <span class="op">==</span>, <span class="op">/=</span>, <span class="op">&lt;</span>, <span class="op">&lt;=</span>, <span class="op">&gt;=</span>, <span class="op">&gt;</span></span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">3</span>  <span class="op">&amp;&amp;</span></span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">2</span>  <span class="op">||</span></span>
<span id="cb126-9"><a href="#cb126-9" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">1</span>  <span class="op">&gt;&gt;</span>, <span class="op">&gt;&gt;=</span></span>
<span id="cb126-10"><a href="#cb126-10" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">0</span>  <span class="op">$</span>, <span class="ot">`seq`</span></span></code></pre></div>
<p>Sections are written as <code>( op e )</code> or
<code>( e op )</code>. For example:</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span><span class="dv">1</span>) <span class="dv">3</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span><span class="op">+</span>) <span class="dv">3</span></span></code></pre></div>
<p>Operators written within enclosed parens are applied like traditional
functions. For example the following are equivalent:</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">+</span>) x y   <span class="ot">=</span>   x <span class="op">+</span> y</span></code></pre></div>
<h2 id="tuples">Tuples</h2>
<p>Tuples are heterogeneous structures which contain a fixed number of
values. Some simple examples are shown below:</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 2-tuple</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a><span class="ot">tuple2 ::</span> (<span class="dt">Integer</span>, <span class="dt">String</span>)</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>tuple2 <span class="ot">=</span> (<span class="dv">1</span>, <span class="st">&quot;foo&quot;</span>)</span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb129-5"><a href="#cb129-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- 3-tuple</span></span>
<span id="cb129-6"><a href="#cb129-6" aria-hidden="true" tabindex="-1"></a><span class="ot">tuple3 ::</span> (<span class="dt">Integer</span>, <span class="dt">Integer</span>, <span class="dt">Integer</span>)</span>
<span id="cb129-7"><a href="#cb129-7" aria-hidden="true" tabindex="-1"></a>tuple3 <span class="ot">=</span> (<span class="dv">10</span>, <span class="dv">20</span>, <span class="dv">30</span>)</span></code></pre></div>
<p>For two-tuples there are two functions <code>fst</code> and
<code>snd</code> which extract the left and right values
respectively.</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fst</span><span class="ot"> ::</span> (a,b) <span class="ot">-&gt;</span> a</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="fu">snd</span><span class="ot"> ::</span> (a,b) <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>GHC supports tuples to size 62.</p>
<h2 id="where-let-clauses">Where &amp; Let Clauses</h2>
<p>Haskell syntax contains two different types of declaration syntax:
<code>let</code> and <code>where</code>. A let binding is an expression
and binds anywhere in its body. For example the following let binding
declares <code>x</code> and <code>y</code> in the expression
<code>x+y</code>.</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="kw">let</span> x <span class="ot">=</span> <span class="dv">1</span>; y <span class="ot">=</span> <span class="dv">2</span> <span class="kw">in</span> (x<span class="op">+</span>y)</span></code></pre></div>
<p>A where binding is a toplevel syntax construct (i.e. not an
expression) that binds variables at the end of a function. For example
the following binds <code>x</code> and <code>y</code> in the function
body of <code>f</code> which is <code>x+y</code>.</p>
<div class="sourceCode" id="cb132"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> x<span class="op">+</span>y <span class="kw">where</span> x<span class="ot">=</span><span class="dv">1</span>; y<span class="ot">=</span><span class="dv">1</span></span></code></pre></div>
<p>Where clauses following the Haskell <em>layout rule</em> where
definitions can be listed on newlines so long as the definitions have
greater indentation than the first toplevel definition they are bound
to.</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> x<span class="op">+</span>y </span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<h2 id="conditionals">Conditionals</h2>
<p>Haskell has builtin syntax for scrutinizing boolean expressions.
These are first class expressions known as <code>if</code> statements.
An if statement is of the form
<code>if cond then trueCond else falseCond</code>. Both the
<code>True</code> and <code>False</code> statements must be present.</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absolute ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>absolute n <span class="ot">=</span> </span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> (n <span class="op">&lt;</span> <span class="dv">0</span>) </span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> (<span class="op">-</span>n) </span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> n</span></code></pre></div>
<p>If statements are just syntactic sugar for <code>case</code>
expressions over boolean values. The following example is equivalent to
the above example.</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="ot">absolute ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>absolute n <span class="ot">=</span> <span class="kw">case</span> (n <span class="op">&lt;</span> <span class="dv">0</span>) <span class="kw">of</span> </span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span>  <span class="ot">-&gt;</span> (<span class="op">-</span>n)</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span> <span class="ot">-&gt;</span> n</span></code></pre></div>
<h2 id="function-composition">Function Composition</h2>
<p>Functions are obviously at the heart of functional programming. In
mathematics function composition is an operation which takes two
functions and produces another function with the result of the first
argument function applied to the result of the second function. This is
written in mathematical notation as:</p>
<p><span class="math display"><em>g</em> ∘ <em>f</em></span></p>
<p>The two functions operate over a domain. For example <span
class="math inline"><em>X</em></span>, <span
class="math inline"><em>Y</em></span> and <span
class="math inline"><em>Z</em></span>.</p>
<p><span
class="math display"><em>f</em> : <em>X</em> → <em>Y</em>    <em>g</em> : <em>Y</em> → <em>Z</em></span></p>
<p>Or in Haskell notation:</p>
<div class="sourceCode" id="cb136"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">X</span> <span class="ot">-&gt;</span> <span class="dt">Y</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> <span class="dt">Y</span> <span class="ot">-&gt;</span> <span class="dt">Z</span></span></code></pre></div>
<p>Composition operation results in a new function:</p>
<p><span
class="math display"><em>g</em> ∘ <em>f</em> : <em>X</em> → <em>Z</em></span></p>
<p>In Haskell this operator is given special infix operator to appear
similar to the mathematical notation. Intuitively it takes two functions
of types <code>b -&gt; c</code> and <code>a -&gt; b</code> and composes
them together to produce a new function. This is the canonical example
of a higher-order function.</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">.</span> g <span class="ot">=</span> \x <span class="ot">-&gt;</span> f (g x)</span></code></pre></div>
<p>Haskell code will liberally use this operator to compose chains of
functions. For example the following composes a chain of list processing
functions <code>sort</code>, <code>filter</code> and
<code>map</code>:</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb138-1"><a href="#cb138-1" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> [<span class="dt">Integer</span>] <span class="ot">-&gt;</span> [<span class="dt">Integer</span>]</span>
<span id="cb138-2"><a href="#cb138-2" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span></span>
<span id="cb138-3"><a href="#cb138-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">sort</span></span>
<span id="cb138-4"><a href="#cb138-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> <span class="fu">filter</span> (<span class="op">&lt;</span><span class="dv">100</span>)</span>
<span id="cb138-5"><a href="#cb138-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">.</span> <span class="fu">map</span> (<span class="op">*</span><span class="dv">10</span>)</span></code></pre></div>
<p>Another common higher-order function is the <code>flip</code>
function which takes as its first argument a function of two arguments,
and reverses the order of these two arguments returning a new
function.</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb139-1"><a href="#cb139-1" aria-hidden="true" tabindex="-1"></a><span class="fu">flip</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span></code></pre></div>
<p>The most common operator in all of Haskell is the function
application operator <code>$</code>. This function is right associative
and takes the entire expression on the right hand side of the operator
and applies it to a function on the left.</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">0</span> <span class="op">$</span></span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a><span class="ot">($) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b </span></code></pre></div>
<p>This is quite often used in the pattern where the left hand side is a
composition of other functions applied to a single argument. This is
common in <em>point-free</em> style of programming which attempts to
minimize the number of input arguments in favour of pure higher order
function composition. The flipped form of this function does the
opposite and is left associative, and applies the entire left hand side
expression to a function given in the second argument to the
function.</p>
<div class="sourceCode" id="cb141"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">1</span> <span class="op">&amp;</span></span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&amp;) ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b </span></code></pre></div>
<p>For comparison consider the use of <code>$</code>, <code>&amp;</code>
and explicit parentheses.</p>
<div class="sourceCode" id="cb142"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> f1 <span class="op">.</span> f2 <span class="op">.</span> f3 <span class="op">.</span> f4 <span class="op">$</span> input <span class="co">-- with ($)</span></span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> input <span class="op">&amp;</span> f1 <span class="op">.</span> f2 <span class="op">.</span> f3 <span class="op">.</span> f4 <span class="co">-- with (&amp;)</span></span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> (f1 <span class="op">.</span> f2 <span class="op">.</span> f3 <span class="op">.</span> f4) input <span class="co">-- with explicit parens</span></span></code></pre></div>
<p>The <code>on</code> function takes a function <code>b</code> and
yields the result of applying unary function <code>u</code> to two
arguments <code>x</code> and <code>y</code>. This is a higher order
function that transforms two inputs and combines the outputs.</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb143-1"><a href="#cb143-1" aria-hidden="true" tabindex="-1"></a><span class="ot">on ::</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c </span></code></pre></div>
<p>This is used quite often in sort functions. For example we can write
a custom sort function which sorts a list of lists based on length.</p>
<div class="sourceCode" id="cb144"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> sortSize <span class="ot">=</span> sortBy (<span class="fu">compare</span> <span class="ot">`on`</span> <span class="fu">length</span>)</span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> sortSize [[<span class="dv">1</span>,<span class="dv">2</span>], [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>], [<span class="dv">1</span>]]</span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a>[[<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">2</span>],[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]]</span></code></pre></div>
<h2 id="list-comprehensions">List Comprehensions</h2>
<p>List comprehensions are a syntactic construct that first originated
in the Haskell language and has now spread to other programming
languages. List comprehensions provide a simple way of working with
lists and sequences of values that follow patterns. List comprehension
syntax consists of three components:</p>
<ul>
<li><strong>Generators</strong> - Expressions which evaluate a list of
values which are iteratively added to the result.</li>
<li><strong>Let bindings</strong> - Expressions which generate a
constant value which is scoped on each iteration.</li>
<li><strong>Guards</strong> - Expressions which generate a boolean
expression which determine whether an iteration is added to the
result.</li>
</ul>
<p>The simplest generator is simply a list itself. The following example
produces a list of integral values, each element multiplied by two.</p>
<div class="sourceCode" id="cb145"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> [<span class="dv">2</span><span class="op">*</span>x <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]]</span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a><span class="co">--        ^^^^^^^^^^^^^^^^</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a><span class="co">--            Generator</span></span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">6</span>,<span class="dv">8</span>,<span class="dv">10</span>]</span></code></pre></div>
<p>We can extend this by adding a let statement which generalizes the
multiplier on each step and binds it to a variable <code>n</code>.</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> [n<span class="op">*</span>x <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>], <span class="kw">let</span> n <span class="ot">=</span> <span class="dv">3</span>]</span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a><span class="co">--                          ^^^^^^^^^</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a><span class="co">--                          Let binding</span></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,<span class="dv">6</span>,<span class="dv">9</span>,<span class="dv">12</span>,<span class="dv">15</span>]</span></code></pre></div>
<p>And we can also restrict the set of resulting values to only the
subset of values of <code>x</code> that meet a condition. In this case
we restrict to only values of <code>x</code> which are odd.</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> [n<span class="op">*</span>x <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>], <span class="kw">let</span> n <span class="ot">=</span> <span class="dv">3</span>, <span class="fu">odd</span> x]</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a><span class="co">--                                     ^^^^^</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a><span class="co">--                                     Guard</span></span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">3</span>,<span class="dv">9</span>,<span class="dv">15</span>]</span></code></pre></div>
<p>Comprehensions with multiple generators will combine each generator
pairwise to produce the <em>cartesian product</em> of all results.</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb148-1"><a href="#cb148-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> [(x,y) <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>], y <span class="ot">&lt;-</span> [<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>]]</span>
<span id="cb148-2"><a href="#cb148-2" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">1</span>,<span class="dv">10</span>),(<span class="dv">1</span>,<span class="dv">20</span>),(<span class="dv">1</span>,<span class="dv">30</span>),(<span class="dv">2</span>,<span class="dv">10</span>),(<span class="dv">2</span>,<span class="dv">20</span>),(<span class="dv">2</span>,<span class="dv">30</span>),(<span class="dv">3</span>,<span class="dv">10</span>),(<span class="dv">3</span>,<span class="dv">20</span>),(<span class="dv">3</span>,<span class="dv">30</span>)]</span>
<span id="cb148-3"><a href="#cb148-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb148-4"><a href="#cb148-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> [(x,y,z) <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>], y <span class="ot">&lt;-</span> [<span class="dv">10</span>,<span class="dv">20</span>], z <span class="ot">&lt;-</span> [<span class="dv">100</span>,<span class="dv">200</span>]]</span>
<span id="cb148-5"><a href="#cb148-5" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">1</span>,<span class="dv">10</span>,<span class="dv">100</span>),(<span class="dv">1</span>,<span class="dv">10</span>,<span class="dv">200</span>),(<span class="dv">1</span>,<span class="dv">20</span>,<span class="dv">100</span>),(<span class="dv">1</span>,<span class="dv">20</span>,<span class="dv">200</span>),(<span class="dv">2</span>,<span class="dv">10</span>,<span class="dv">100</span>),(<span class="dv">2</span>,<span class="dv">10</span>,<span class="dv">200</span>),(<span class="dv">2</span>,<span class="dv">20</span>,<span class="dv">100</span>),(<span class="dv">2</span>,<span class="dv">20</span>,<span class="dv">200</span>)]</span></code></pre></div>
<p>Haskell has builtin comprehension syntax which is syntactic sugar for
specific methods of the <code>Enum</code> typeclass.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Syntax Sugar</th>
<th style="text-align: left;">Enum Class Method</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>[ e1.. ]</code></td>
<td style="text-align: left;"><code>enumFrom e1</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[ e1,e2.. ]</code></td>
<td style="text-align: left;"><code>enumFromThen e1 e2</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>[ e1..e3 ]</code></td>
<td style="text-align: left;"><code>enumFromTo e1 e3</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>[ e1,e2..e3 ]</code></td>
<td style="text-align: left;"><code>enumFromThenTo e1 e2 e3</code></td>
</tr>
</tbody>
</table>
<p>There is an <code>Enum</code> instance for <code>Integer</code> and
<code>Char</code> types and so we can write list comprehensions for
both, which generate ranges of values.</p>
<div class="sourceCode" id="cb149"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> [<span class="dv">1</span> <span class="op">..</span> <span class="dv">15</span>]</span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="dv">10</span>,<span class="dv">11</span>,<span class="dv">12</span>,<span class="dv">13</span>,<span class="dv">14</span>,<span class="dv">15</span>]</span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> [<span class="ch">&#39;a&#39;</span> <span class="op">..</span> <span class="ch">&#39;z&#39;</span>]</span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span></span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> [<span class="dv">1</span>,<span class="dv">3</span> <span class="op">..</span> <span class="dv">15</span>]</span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">7</span>,<span class="dv">9</span>,<span class="dv">11</span>,<span class="dv">13</span>,<span class="dv">15</span>]</span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-10"><a href="#cb149-10" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> [<span class="dv">0</span>,<span class="dv">50</span><span class="op">..</span><span class="dv">500</span>]</span>
<span id="cb149-11"><a href="#cb149-11" aria-hidden="true" tabindex="-1"></a>[<span class="dv">0</span>,<span class="dv">50</span>,<span class="dv">100</span>,<span class="dv">150</span>,<span class="dv">200</span>,<span class="dv">250</span>,<span class="dv">300</span>,<span class="dv">350</span>,<span class="dv">400</span>,<span class="dv">450</span>,<span class="dv">500</span>]</span></code></pre></div>
<p>These comprehensions can be used inside of function definitions and
reference locally bound variables. For example the
<code>factorial</code> function (written as <span
class="math inline"><em>n</em>!</span>) is defined as the product of all
positive integers up to a given value.</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a>factorial n <span class="ot">=</span> <span class="fu">product</span> [<span class="dv">1</span><span class="op">..</span>n]</span></code></pre></div>
<p>As a more complex example consider a naive prime number sieve:</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a><span class="ot">primes ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>primes <span class="ot">=</span> sieve [<span class="dv">2</span><span class="op">..</span>] </span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>    sieve (p<span class="op">:</span>xs) <span class="ot">=</span> p <span class="op">:</span> sieve [ n <span class="op">|</span> n <span class="ot">&lt;-</span> xs, n <span class="ot">`mod`</span> p <span class="op">&gt;</span> <span class="dv">0</span> ]</span></code></pre></div>
<p>And a more complex example, consider the classic FizzBuzz interview
question. This makes use of iteration and guard statements.</p>
<div class="sourceCode" id="cb152"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fizzbuzz ::</span> [<span class="dt">String</span>]</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>fizzbuzz <span class="ot">=</span> [fb x<span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">100</span>]]</span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> fb y</span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> y <span class="ot">`mod`</span> <span class="dv">15</span> <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> y <span class="ot">`mod`</span> <span class="dv">3</span>  <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb152-6"><a href="#cb152-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> y <span class="ot">`mod`</span> <span class="dv">5</span>  <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb152-7"><a href="#cb152-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> <span class="fu">show</span> y</span></code></pre></div>
<h2 id="comments">Comments</h2>
<p>Single line comments begin with double dashes <code>--</code>:</p>
<div class="sourceCode" id="cb153"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Everything should be built top-down, except the first time.</span></span></code></pre></div>
<p>Multiline comments begin with <code>{-</code> and end with
<code>-}</code>.</p>
<div class="sourceCode" id="cb154"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a><span class="co">{-</span></span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a><span class="co">The goal of computation is the emulation of our synthetic abilities, not the</span></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a><span class="co">understanding of our analytic ones.</span></span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span></code></pre></div>
<p>Comments may also add additional structure in the form of <a
href="#haddock">Haddock</a> docstrings. These comments will begin with a
pipe.</p>
<div class="sourceCode" id="cb155"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a><span class="co">{-|</span></span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a><span class="co">  Great ambition without contribution is without significance.</span></span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span></code></pre></div>
<p>Modules may also have a comment convention which describes the
individual authors, copyright and stability information in the following
form:</p>
<div class="sourceCode" id="cb156"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a><span class="co">{-|</span></span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a><span class="co">Module      : MyEnterpriseModule</span></span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a><span class="co">Description : Make it so.</span></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a><span class="co">Copyright   : (c) Jean Luc Picard</span></span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a><span class="co">License     : MIT</span></span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a><span class="co">Maintainer  : jl@enterprise.com</span></span>
<span id="cb156-7"><a href="#cb156-7" aria-hidden="true" tabindex="-1"></a><span class="co">Stability   : experimental</span></span>
<span id="cb156-8"><a href="#cb156-8" aria-hidden="true" tabindex="-1"></a><span class="co">Portability : POSIX</span></span>
<span id="cb156-9"><a href="#cb156-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-10"><a href="#cb156-10" aria-hidden="true" tabindex="-1"></a><span class="co">Description of module structure in Haddock markup style.</span></span>
<span id="cb156-11"><a href="#cb156-11" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span></code></pre></div>
<h2 id="typeclasses">Typeclasses</h2>
<p>Typeclasses are one of the core abstractions in Haskell. Just as we
wrote polymorphic functions above which operate over all given types
(the <code>id</code> function is one example), we can use typeclasses to
provide a form of bounded polymorphism which constrains type variables
to a subset of those types that implement a given class.</p>
<p>For example we can define an equality class which allows us to define
an overloaded notion of equality depending on the data structure
provided.</p>
<div class="sourceCode" id="cb157"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Equal</span> a <span class="kw">where</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  equal ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>Then we can define this typeclass over several different types. These
definitions are called <strong>typeclass instances</strong>. For example
for the <code>Bool</code> type the equality typeclass would be defined
as:</p>
<div class="sourceCode" id="cb158"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Equal</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>  equal <span class="dt">True</span> <span class="dt">True</span>   <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>  equal <span class="dt">False</span> <span class="dt">False</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>  equal <span class="dt">True</span> <span class="dt">False</span>  <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>  equal <span class="dt">False</span> <span class="dt">True</span>  <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>Over the unit type, where only a single value exists, the instance is
trivial:</p>
<div class="sourceCode" id="cb159"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Equal</span> () <span class="kw">where</span></span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a>  equal () () <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>For the Ordering type, defined as:</p>
<div class="sourceCode" id="cb160"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ordering</span> <span class="ot">=</span> <span class="dt">LT</span> <span class="op">|</span> <span class="dt">EQ</span> <span class="op">|</span> <span class="dt">GT</span></span></code></pre></div>
<p>We would have the following Equal instance:</p>
<div class="sourceCode" id="cb161"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Equal</span> <span class="dt">Ordering</span> <span class="kw">where</span></span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>  equal <span class="dt">LT</span> <span class="dt">LT</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>  equal <span class="dt">EQ</span> <span class="dt">EQ</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>  equal <span class="dt">GT</span> <span class="dt">GT</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>  equal _ _   <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>An Equal instance for a more complex data structure like the list
type relies upon the fact that the type of the elements in the list must
also have a notion of equality, so we include this as a constraint in
the typeclass context, which is written to the left of the fat arrow
<code>=&gt;</code>. With this constraint in place, we can write this
instance recursively by pattern matching on the list elements and
checking for equality all the way down the spine of the list:</p>
<div class="sourceCode" id="cb162"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Equal</span> a) <span class="ot">=&gt;</span> <span class="dt">Equal</span> [a] <span class="kw">where</span></span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a>  equal [] [] <span class="ot">=</span> <span class="dt">True</span>   <span class="co">-- Empty lists are equal</span></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a>  equal [] ys <span class="ot">=</span> <span class="dt">False</span>  <span class="co">-- Lists of unequal size are not equal</span></span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a>  equal xs [] <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- equal x y is only allowed here due to the constraint (Equal a)</span></span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a>  equal (x<span class="op">:</span>xs) (y<span class="op">:</span>ys) <span class="ot">=</span> equal x y <span class="op">&amp;&amp;</span> equal xs ys</span></code></pre></div>
<p>In the above definition, we know that we can check for equality
between individual list elements if those list elements satisfy the
Equal constraint. Knowing that they do, we can then check for equality
between two complete lists.</p>
<p>For tuples, we will also include the Equal constraint for their
elements, and we can then check each element for equality respectively.
Note that this instance includes two constraints in the context of the
typeclass, requiring that both type variables <code>a</code> and
<code>b</code> must also have an Equal instance.</p>
<div class="sourceCode" id="cb163"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Equal</span> a, <span class="dt">Equal</span> b) <span class="ot">=&gt;</span> <span class="dt">Equal</span> (a,b) <span class="kw">where</span></span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>  equal (x0, x1) (y0, y1) <span class="ot">=</span> equal x0 y0 <span class="op">&amp;&amp;</span> equal x1 y1</span></code></pre></div>
<p>The default prelude comes with a variety of typeclasses that are used
frequently and defined over many prelude types:</p>
<ul>
<li><strong>Num</strong> - Provides a basic numerical interface for
values with addition, multiplication, subtraction, and negation.</li>
<li><strong>Eq</strong> - Provides an interface for values that can be
tested for equality.</li>
<li><strong>Ord</strong> - Provides an interface for values that have a
total ordering.</li>
<li><strong>Read</strong> - Provides an interface for values that can be
read from a string.</li>
<li><strong>Show</strong> - Provides an interface for values that can be
printed to a string.</li>
<li><strong>Enum</strong> - Provides an interface for values that are
enumerable to integers.</li>
<li><strong>Semigroup</strong> - Provides an algebraic semigroup
interface.</li>
<li><strong>Functor</strong> - Provides an algebraic functor interface.
See <a href="#functors">Functors</a>.</li>
<li><strong>Monad</strong> - Provides an algebraic monad interface. See
<a href="#monads">Monads</a>.</li>
<li><strong>Category</strong> - Provides an algebraic category
interface. See <a href="#categories">Categories</a>.</li>
<li><strong>Bounded</strong> - Provides an interface for enumerable
values with bounds.</li>
<li><strong>Integral</strong> - Provides an interface for integral-like
quantities.</li>
<li><strong>Real</strong> - Provides an interface for real-like
quantities.</li>
<li><strong>Fractional</strong> - Provides an interface for
rational-like quantities.</li>
<li><strong>Floating</strong> - Provides an interface for defining
transcendental functions over real values.</li>
<li><strong>RealFrac</strong> - Provides an interface for rounding real
values.</li>
<li><strong>RealFloat</strong> - Provides an interface for working with
IEE754 operations.</li>
</ul>
<p>To see the implementation for any of these typeclasses you can run
the GHCi info command to see the methods and all instances in scope. For
example:</p>
<div class="sourceCode" id="cb164"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>info <span class="dt">Num</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a> <span class="kw">class</span> (<span class="dt">Eq</span> a, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Num</span> a <span class="kw">where</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a><span class="ot">   (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a><span class="ot">   (*) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a><span class="ot">   (-) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a><span class="ot">   negate ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a><span class="ot">   abs ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a><span class="ot">   signum ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a><span class="ot">   fromInteger ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> a</span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>         <span class="co">-- Imported from GHC.Num</span></span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a> <span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Float</span>      <span class="co">-- Imported from GHC.Float</span></span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a> <span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Double</span>     <span class="co">-- Imported from GHC.Float</span></span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a> <span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Integer</span>    <span class="co">-- Imported from GHC.Num</span></span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true" tabindex="-1"></a> <span class="kw">instance</span> <span class="dt">Num</span> <span class="dt">Int</span>        <span class="co">-- Imported from GHC.Num</span></span></code></pre></div>
<p>Many of the default classes have instances that can be derived
automatically. After the definition of a datatype you can add a
<code>deriving</code> clause which will generate the instances for this
datatype automatically. This does not work universally but for many
instances which have boilerplate definitions, GHC is quite clever and
can save you from writing quite a bit of code by hand.</p>
<p>For example for a custom list type.</p>
<div class="sourceCode" id="cb165"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a</span>
<span id="cb165-2"><a href="#cb165-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span>
<span id="cb165-3"><a href="#cb165-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Nil</span></span>
<span id="cb165-4"><a href="#cb165-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span></code></pre></div>
<h2 id="side-effects">Side Effects</h2>
<p>Contrary to a common misconception, side effects are an integral part
of Haskell programming. Probably the most interesting thing about
Haskell’s approach to side effects is that they are encoded in the type
system. This is certainly a different approach to effectful programming,
and the language has various models for modeling these effects within
the type system. These models range from using <a
href="#monads">Monads</a> to building <a
href="#algebraic-effects">algebraic models</a> of effects that draw
clear lines between effectful code and pure code. The idea of reasoning
about where effects can and cannot exist is one of the key ideas of
Haskell, but this certainly does not mean trying to avoid side effects
altogether!</p>
<p>Indeed, a Hello World program in Haskell is quite simple:</p>
<div class="sourceCode" id="cb166"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="st">&quot;Hello World&quot;</span></span></code></pre></div>
<p>Other side effects can include reading from the terminal and
prompting the user for input, such as in the complete program below:</p>
<div class="sourceCode" id="cb167"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb167-3"><a href="#cb167-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="st">&quot;Enter a number&quot;</span></span>
<span id="cb167-4"><a href="#cb167-4" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb167-5"><a href="#cb167-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (<span class="st">&quot;You entered: &quot;</span> <span class="op">++</span> n)</span></code></pre></div>
<h2 id="records">Records</h2>
<p>Records in Haskell are fundamentally broken for several reasons:</p>
<ol type="1">
<li><strong>The syntax is unconventional.</strong></li>
</ol>
<p>Most programming languages use dot or arrow syntax for field
accessors like the following:</p>
<div class="sourceCode" id="cb168"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a>person<span class="op">.</span>name</span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>person<span class="op">-&gt;</span>name</span></code></pre></div>
<p>Haskell however uses function application syntax since record
accessors are simply just functions. Instead or creating a privileged
class of names and syntax for field accessors, Haskell instead choose to
implement the simplest model and expands accessors to function during
compilation.</p>
<div class="sourceCode" id="cb169"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a>name person</span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>person {name<span class="ot">=</span><span class="st">&quot;foo&quot;</span>}</span></code></pre></div>
<ol start="2" type="1">
<li><strong>Incomplete pattern matches are implicitly generated for sums
of products.</strong></li>
</ol>
<div class="sourceCode" id="cb170"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Example</span> <span class="ot">=</span> <span class="dt">Ex1</span> {<span class="ot"> a ::</span> <span class="dt">Int</span> } <span class="op">|</span> <span class="dt">Ex2</span> {<span class="ot"> b ::</span> <span class="dt">Int</span> }</span></code></pre></div>
<p>The functions generated for <code>a</code> or <code>b</code> in both
of these cases are partial. See <a
href="#exhaustiveness">Exhaustiveness</a> checking.</p>
<ol start="3" type="1">
<li><strong>Lack of Namespacing</strong></li>
</ol>
<p>Given two records defined in the same module (or imported) GHC is
unable to (by default) disambiguate which field accessor to assign at a
callsite that uses <code>a</code>.</p>
<div class="sourceCode" id="cb171"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Example1</span> <span class="ot">=</span> <span class="dt">Ex1</span> {<span class="ot"> a ::</span> <span class="dt">Int</span> }</span>
<span id="cb171-2"><a href="#cb171-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Example2</span> <span class="ot">=</span> <span class="dt">Ex2</span> {<span class="ot"> a ::</span> <span class="dt">Int</span> }</span></code></pre></div>
<p>This can be routed around with the language extension
<code>DisambiguateRecordFields</code> but only to a certain extent. If
we want to write maximally polymorphic functions which operate over
arbitrary records which have a field <code>a</code>, then the GHC
typesystem is not able to express this without some much higher-level
magic.</p>
<h2 id="pragmas">Pragmas</h2>
<p>At the beginning of a module there is special syntax for pragmas
which direct the compiler to compile the current module in a specific
way. The most common is a language extension pragma denoted like the
following:</p>
<div class="sourceCode" id="cb172"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span></code></pre></div>
<p>These flags alter the semantics and syntax of the module in a variety
of ways. See <a href="#language-extensions">Language Extensions</a> for
more details on all of these options.</p>
<p>Additionally we can pass specific GHC flags which alter the
compilation behavior, enabling or disabling specific bespoke features
based on our needs. These include compiler warnings, optimisation flags
and extension flags.</p>
<div class="sourceCode" id="cb173"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}</span></span></code></pre></div>
<p>Warning flags allow you to inform users at compile-time with a custom
error message. Additionally you can mark a module as deprecated with a
specific replacement message.</p>
<div class="sourceCode" id="cb174"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Widget</span> <span class="ot">{-# DEPRECATED &quot;This module is deprecated.&quot; #-}</span></span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Widget</span> <span class="ot">{-# WARNING &quot;This module is dangerous.&quot; #-}</span></span></code></pre></div>
<h2 id="newtypes">Newtypes</h2>
<p>Newtypes are a form of zero-cost abstraction that allows developers
to specify compile-time names for types for which the developer wishes
to expose a more restrictive interface. They’re zero-cost because these
newtypes end up with the same underlying representation as the things
they differentiate. This allows the compiler to distinguish between
different types which are representationally identical but semantically
different.</p>
<p>For instance velocity can be represented as a scalar quantity
represented as a double but the user may not want to mix doubles with
other vector quantities. Newtypes allow us to distinguish between
scalars and vectors at compile time so that no accidental calculations
can occur.</p>
<div class="sourceCode" id="cb175"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Velocity</span> <span class="ot">=</span> <span class="dt">Velocity</span> <span class="dt">Double</span></span></code></pre></div>
<p>Most importantly these newtypes disappear during compilation and the
velocity type will be represented as simply just a machine double with
no overhead.</p>
<p>See also the section on <a href="#newtype-deriving">Newtype
Deriving</a> for a further discussion of tricks involved with handling
newtypes.</p>
<h2 id="bottoms">Bottoms</h2>
<p>The bottom is a singular value that inhabits every type. When this
value is evaluated, the semantics of Haskell no longer yield a
meaningful value. In other words, further operations on the value cannot
be defined in Haskell. A bottom value is usually written as the symbol
<a href="https://en.wikipedia.org/wiki/Up_tack">⊥</a>, ( i.e. the
compiler flipping you off ). Several ways exist to express bottoms in
Haskell code.</p>
<p>For instance, <code>undefined</code> is an easily called example of a
bottom value. This function has type <code>a</code> but lacks any type
constraints in its type signature. Thus, <code>undefined</code> is able
to stand in for any type in a function body, allowing type checking to
succeed, even if the function is incomplete or lacking a definition
entirely. The <code>undefined</code> function is extremely practical for
debugging or to accommodate writing incomplete programs.</p>
<div class="sourceCode" id="cb176"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a><span class="fu">undefined</span><span class="ot"> ::</span> a</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a><span class="ot">mean ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>mean nums <span class="ot">=</span> (total <span class="op">/</span> count) <span class="kw">where</span>            <span class="co">-- Partially defined function</span></span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a>              total <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>              count <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a><span class="ot">addThreeNums ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a>addThreeNums n m j <span class="ot">=</span> <span class="fu">undefined</span>               <span class="co">-- No function body declared at all</span></span>
<span id="cb176-11"><a href="#cb176-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-12"><a href="#cb176-12" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a <span class="ot">-&gt;</span> <span class="dt">Complicated</span> <span class="dt">Type</span></span>
<span id="cb176-13"><a href="#cb176-13" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="fu">undefined</span>                                <span class="co">-- Write tomorrow, typecheck today!</span></span>
<span id="cb176-14"><a href="#cb176-14" aria-hidden="true" tabindex="-1"></a>                                             <span class="co">-- Arbitrarily complicated types</span></span>
<span id="cb176-15"><a href="#cb176-15" aria-hidden="true" tabindex="-1"></a>                                             <span class="co">-- welcome!</span></span></code></pre></div>
<p>Another example of a bottom value comes from the evaluation of the
<code>error</code> function, which takes a <code>String</code> and
returns something that can be of any type. This property is quite
similar to <code>undefined</code>, which also can also stand in for any
type.</p>
<p>Calling <code>error</code> in a function causes the compiler to throw
an exception, halt the program, and print the specified error
message.</p>
<div class="sourceCode" id="cb177"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb177-1"><a href="#cb177-1" aria-hidden="true" tabindex="-1"></a><span class="fu">error</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a                       <span class="co">-- Takes an error message of type</span></span>
<span id="cb177-2"><a href="#cb177-2" aria-hidden="true" tabindex="-1"></a>                                           <span class="co">-- String and returns whatever type</span></span>
<span id="cb177-3"><a href="#cb177-3" aria-hidden="true" tabindex="-1"></a>                                           <span class="co">-- is needed</span></span></code></pre></div>
<p>In the <code>divByY</code> function below, passing the function
<code>0</code> as the divisor results in this function returning such an
exception.</p>
<div class="sourceCode" id="cb178"
data-include="src/01-basics/errors.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Annotated code that features use of the error function.</span></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a><span class="ot">divByY::</span> (<span class="dt">Num</span> a, <span class="dt">Eq</span> a, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a>divByY _ <span class="dv">0</span> <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Divide by zero error&quot;</span>      <span class="co">-- Dividing by 0 causes an error</span></span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a>divByY dividend divisor <span class="ot">=</span> dividend <span class="op">/</span> divisor   <span class="co">-- Handles defined division</span></span>
<span id="cb178-7"><a href="#cb178-7" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<p>A third type way to express a bottom is with an infinitely looping
term:</p>
<div class="sourceCode" id="cb179"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb179-1"><a href="#cb179-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a</span>
<span id="cb179-2"><a href="#cb179-2" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="kw">let</span> x <span class="ot">=</span> x <span class="kw">in</span> x</span></code></pre></div>
<p>Examples of actual Haskell code that use this looping syntax lives in
the source code of the <a
href="https://hackage.haskell.org/package/ghc-prim-0.4.0.0/docs/GHC-Prim.html">GHC.Prim</a>
module. These bottoms exist because the operations <a
href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#unboxed-types-and-primitive-operations">cannot
be defined in native Haskell</a>. Such operations are baked into the
compiler at a very low level. However, this module exists so that <a
href="#haddock">Haddock</a> can generate documentation for these
primitive operations, while the looping syntax serves as a placeholder
for the actual implementation of the primops.</p>
<p>Perhaps the most common introduction to bottoms is writing a partial
function that does not have <a href="#exhaustiveness">exhaustive</a>
pattern matching defined. For example, the following code has
non-exhaustive pattern matching because the <code>case</code>
expression, lacks a definition of what to do with a <code>B</code>:</p>
<div class="sourceCode" id="cb180"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">F</span> <span class="ot">=</span> <span class="dt">A</span> <span class="op">|</span> <span class="dt">B</span></span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">A</span> <span class="ot">-&gt;</span> ()</span></code></pre></div>
<p>The code snippet above is translated into the following <a
href="#core">GHC Core</a> output where the compiler will insert an
exception to account for the non-exhaustive patterns:</p>
<div class="sourceCode" id="cb181"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> x <span class="kw">of</span> _ {</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">A</span> <span class="ot">-&gt;</span> ();</span>
<span id="cb181-3"><a href="#cb181-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">B</span> <span class="ot">-&gt;</span> patError <span class="st">&quot;&lt;interactive&gt;:3:11-31|case&quot;</span></span>
<span id="cb181-4"><a href="#cb181-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>GHC can be made more vocal about incomplete patterns using the
<code>-fwarn-incomplete-patterns</code> and
<code>-fwarn-incomplete-uni-patterns</code> flags.</p>
<p>A similar situation can arise with records. Although constructing a
record with missing fields is rarely useful, it is still possible.</p>
<div class="sourceCode" id="cb182"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Foo</span> <span class="ot">=</span> <span class="dt">Foo</span> {<span class="ot"> example1 ::</span> <span class="dt">Int</span> }</span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="dt">Foo</span> {}     <span class="co">-- Record defined with a missing field</span></span></code></pre></div>
<p>When the developer omits a field’s definition, the compiler inserts
an exception in the GHC Core representation:</p>
<div class="sourceCode" id="cb183"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Foo</span> (recConError <span class="st">&quot;&lt;interactive&gt;:4:9-12|a&quot;</span>)</span></code></pre></div>
<p>Fortunately, GHC will warn us by default about missing record
fields.</p>
<p>Bottoms are used extensively throughout <a href="#prelude">the
Prelude</a>, although this fact may not be immediately apparent. The
reasons for including bottoms are either practical or historical.</p>
<p>The canonical example is the <code>head</code> function which has
type <code>[a] -&gt; a</code>. This function could not be well-typed
without the bottom.</p>
<div class="sourceCode" id="cb184"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Extract the first element of a list, which must be non-empty.</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span><span class="ot">                    ::</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> (x<span class="op">:</span>_)              <span class="ot">=</span>  x</span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> []                 <span class="ot">=</span>  <span class="fu">error</span> <span class="st">&quot;Prelude.head: empty list&quot;</span></span></code></pre></div>
<p>Some further examples of bottoms:</p>
<div class="sourceCode" id="cb185"
data-include="src/01-basics/bottoms.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Err</span></span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (head, (!!), undefined)</span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- degenerate functions</span></span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a><span class="fu">undefined</span><span class="ot"> ::</span> a</span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a><span class="fu">undefined</span> <span class="ot">=</span>  <span class="fu">error</span> <span class="st">&quot;Prelude.undefined&quot;</span></span>
<span id="cb185-8"><a href="#cb185-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-9"><a href="#cb185-9" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb185-10"><a href="#cb185-10" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> (x<span class="op">:</span>_) <span class="ot">=</span>  x</span>
<span id="cb185-11"><a href="#cb185-11" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> []    <span class="ot">=</span>  <span class="fu">error</span> <span class="st">&quot;Prelude.head: empty list&quot;</span></span>
<span id="cb185-12"><a href="#cb185-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-13"><a href="#cb185-13" aria-hidden="true" tabindex="-1"></a><span class="ot">(!!) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb185-14"><a href="#cb185-14" aria-hidden="true" tabindex="-1"></a>xs     <span class="op">!!</span> n <span class="op">|</span> n <span class="op">&lt;</span> <span class="dv">0</span> <span class="ot">=</span>  <span class="fu">error</span> <span class="st">&quot;Prelude.!!: negative index&quot;</span></span>
<span id="cb185-15"><a href="#cb185-15" aria-hidden="true" tabindex="-1"></a>[]     <span class="op">!!</span> _         <span class="ot">=</span>  <span class="fu">error</span> <span class="st">&quot;Prelude.!!: index too large&quot;</span></span>
<span id="cb185-16"><a href="#cb185-16" aria-hidden="true" tabindex="-1"></a>(x<span class="op">:</span>_)  <span class="op">!!</span> <span class="dv">0</span>         <span class="ot">=</span>  x</span>
<span id="cb185-17"><a href="#cb185-17" aria-hidden="true" tabindex="-1"></a>(_<span class="op">:</span>xs) <span class="op">!!</span> n         <span class="ot">=</span>  xs <span class="op">!!</span> (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<p>It is rare to see these partial functions thrown around carelessly in
production code because they cause the program to halt. The preferred
method for handling exceptions is to combine the use of safe variants
provided in <code>Data.Maybe</code> with the functions
<code>maybe</code> and <code>either</code>.</p>
<p>Another method is to use pattern matching, as shown in
<code>listToMaybe</code>, a safer version of <code>head</code> described
below:</p>
<div class="sourceCode" id="cb186"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a><span class="ot">listToMaybe ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>listToMaybe []     <span class="ot">=</span>  <span class="dt">Nothing</span>    <span class="co">-- An empty list returns Nothing</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a>listToMaybe (a<span class="op">:</span>_)  <span class="ot">=</span>  <span class="dt">Just</span> a     <span class="co">-- A non-empty list returns the first element</span></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>                                 <span class="co">-- wrapped in the Just context.</span></span></code></pre></div>
<p>Invoking a bottom defined in terms of <code>error</code> typically
will not generate any position information. However,
<code>assert</code>, which is used to provide assertions, can be
short-circuited to generate position information in place of either
<code>undefined</code> or <code>error</code> calls.</p>
<div class="sourceCode" id="cb187"
data-include="src/01-basics/fail.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Base</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> a</span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- *** Exception: Prelude.undefined</span></span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a><span class="ot">bar ::</span> a</span>
<span id="cb187-8"><a href="#cb187-8" aria-hidden="true" tabindex="-1"></a>bar <span class="ot">=</span> assert <span class="dt">False</span> <span class="fu">undefined</span></span>
<span id="cb187-9"><a href="#cb187-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- *** Exception: src/fail.hs:8:7-12: Assertion failed</span></span></code></pre></div>
<p>See: <a
href="https://wiki.haskell.org/Avoiding_partial_functions">Avoiding
Partial Functions</a></p>
<h2 id="exhaustiveness">Exhaustiveness</h2>
<p>Pattern matching in Haskell allows for the possibility of
non-exhaustive patterns. For example, passing Nothing to
<code>unsafe</code> will cause the program to crash at runtime. However,
this function is an otherwise valid, type-checked program.</p>
<div class="sourceCode" id="cb188"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb188-1"><a href="#cb188-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unsafe ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb188-2"><a href="#cb188-2" aria-hidden="true" tabindex="-1"></a>unsafe (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> x <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<p>Since <code>unsafe</code> takes a <code>Maybe a</code> value as its
argument, two possible values are valid input: <code>Nothing</code> and
<code>Just a</code>. Since the case of a <code>Nothing</code> was not
defined in <code>unsafe</code>, we say that the pattern matching within
that function is <em>non-exhaustive</em>. In other words, the function
does not implement appropriate handling of all valid inputs. Instead of
yielding a value, such a function will halt from an incomplete
match.</p>
<p>Partial functions from non-exhaustivity are a controversial subject,
and frequent use of non-exhaustive patterns is considered a dangerous
code smell. However, the complete removal of non-exhaustive patterns
from the language would itself be too restrictive and forbid too many
valid programs.</p>
<p>Several flags exist that we can pass to the compiler to warn us about
such patterns or forbid them entirely, either locally or globally.</p>
<div class="sourceCode" id="cb189"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> ghc <span class="op">-</span>c <span class="op">-</span><span class="dt">Wall</span> <span class="op">-</span><span class="dt">Werror</span> A.hs</span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>A.hs<span class="op">:</span><span class="dv">3</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Warning</span><span class="op">:</span> <span class="dt">Pattern</span> match(es) are non<span class="op">-</span>exhaustive</span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>             <span class="dt">In</span> an equation for <span class="ot">`unsafe&#39;: Patterns not matched: Nothing</span></span></code></pre></div>
<p>The <code>-Wall</code> or <code>-fwarn-incomplete-patterns</code>
flag can also be added on a per-module basis by using the
<code>OPTIONS_GHC</code> <a
href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/glasgow_exts.html#rewrite-rules">pragma</a>.</p>
<div class="sourceCode" id="cb190"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -Wall #-}</span></span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -fwarn-incomplete-patterns #-}</span></span></code></pre></div>
<p>A more subtle case of non-exhaustivity is the use of implicit pattern
matching with a single <em>uni-pattern</em> in a lambda expression. In a
manner similar to the <code>unsafe</code> function above, a uni-pattern
cannot handle all types of valid input. For instance, the function
<code>boom</code> will fail when given a Nothing, even though the type
of the lambda expression’s argument is a <code>Maybe a</code>.</p>
<div class="sourceCode" id="cb191"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a>boom <span class="ot">=</span> \(<span class="dt">Just</span> a) <span class="ot">-&gt;</span> something</span></code></pre></div>
<p>Non-exhaustivity arising from uni-patterns in lambda expressions
occurs frequently in <code>let</code> or <code>do</code>-blocks after
desugaring, because such code is translated into lambda expressions
similar to <code>boom</code>.</p>
<div class="sourceCode" id="cb192"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a>boom2 <span class="ot">=</span> <span class="kw">let</span></span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> a <span class="ot">=</span> something</span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>boom3 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> a <span class="ot">&lt;-</span> something</span></code></pre></div>
<p>GHC can warn about these cases of non-exhaustivity with the
<code>-fwarn-incomplete-uni-patterns</code> flag.</p>
<p>Generally speaking, any non-trivial program will use some measure of
partial functions. It is simply a fact. Thus, there exist obligations
for the programmer that cannot be manifested in the Haskell type
system.</p>
<h2 id="debugger">Debugger</h2>
<p>Since GHC version 6.8.1, a built-in debugger has been available,
although its use is somewhat rare. Debugging uncaught exceptions is in a
similar style to debugging segfaults with gdb. Breakpoints can be set
with <code>:break</code> and the call stack stepped through with
<code>:forward</code> and <code>:back</code>.</p>
<div class="sourceCode" id="cb193"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb193-1"><a href="#cb193-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>set <span class="op">-</span>fbreak<span class="op">-</span>on<span class="op">-</span>exception  <span class="co">-- Sets option for evaluation to stop on exception</span></span>
<span id="cb193-2"><a href="#cb193-2" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span><span class="fu">break</span> <span class="dv">2</span> <span class="dv">15</span>                <span class="co">-- Sets a break point at line 2, column 15</span></span>
<span id="cb193-3"><a href="#cb193-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>trace main                <span class="co">-- Run a function to generate a sequence of evaluation steps</span></span>
<span id="cb193-4"><a href="#cb193-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>hist                      <span class="co">-- Step back from a breakpoint through previous evaluation steps</span></span>
<span id="cb193-5"><a href="#cb193-5" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>back                      <span class="co">-- Step backwards a single step at a time through the history</span></span>
<span id="cb193-6"><a href="#cb193-6" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>forward                   <span class="co">-- Step forward a single step at a time through the history</span></span></code></pre></div>
<h2 id="stack-traces">Stack Traces</h2>
<p>With <a
href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/profiling.html">runtime
profiling enabled</a>, <a href="https://www.haskell.org/ghc/">GHC</a>
can also print a stack trace when a diverging bottom term (error,
undefined) is hit. This action, though, requires a special flag and
profiling to be enabled, both of which are disabled by default. So, for
example:</p>
<div class="sourceCode" id="cb194"
data-include="src/01-basics/stacktrace.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Exception</span></span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> g x</span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a>g x <span class="ot">=</span> <span class="fu">error</span> (<span class="fu">show</span> x)</span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> try (evaluate (f ()))<span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">SomeException</span> ())</span></code></pre></div>
<div class="sourceCode" id="cb195"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> ghc <span class="op">-</span><span class="dt">O0</span> <span class="op">-</span>rtsopts<span class="ot">=</span><span class="fu">all</span> <span class="op">-</span>prof <span class="op">-</span>auto<span class="op">-</span><span class="fu">all</span> <span class="co">--make stacktrace.hs</span></span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a><span class="op">./</span>stacktrace <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span>xc</span></code></pre></div>
<p>And indeed, the runtime tells us that the exception occurred in the
function <code>g</code> and enumerates the call stack.</p>
<div class="sourceCode" id="cb196"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a><span class="op">***</span> <span class="dt">Exception</span> (reporting due to <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span>xc)<span class="op">:</span> (<span class="dt">THUNK_2_0</span>), stack trace<span class="op">:</span></span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a>  Main.g,</span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a>  called from Main.f,</span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a>  called from Main.main,</span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true" tabindex="-1"></a>  called from <span class="dt">Main.CAF</span></span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">--&gt;</span> evaluated by<span class="op">:</span> Main.main,</span>
<span id="cb196-7"><a href="#cb196-7" aria-hidden="true" tabindex="-1"></a>  called from <span class="dt">Main.CAF</span></span></code></pre></div>
<p>It is best to run this code without optimizations applied
<code>-O0</code> so as to preserve the original call stack as
represented in the source. With optimizations applied, GHC will
rearrange the program in rather drastic ways, resulting in what may be
an entirely different call stack.</p>
<h2 id="printf-tracing">Printf Tracing</h2>
<p>Since Haskell is a pure language it has the unique property that most
code is introspectable on its own. As such, using printf to display the
state of the program at critical times throughout execution is often
unnecessary because we can simply open <a href="#ghci">GHCi</a> and test
the function. Nevertheless, Haskell does come with an unsafe
<code>trace</code> function which can be used to perform arbitrary print
statements outside of the IO monad. You can place these statements
wherever you like in your code without without IO restrictions.</p>
<div class="sourceCode" id="cb197"
data-include="src/01-basics/trace.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Debug.Trace</span></span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Int</span></span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> trace <span class="st">&quot;impure print&quot;</span> <span class="dv">1</span></span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-6"><a href="#cb197-6" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Int</span></span>
<span id="cb197-7"><a href="#cb197-7" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> traceShow <span class="st">&quot;tracing&quot;</span> <span class="dv">2</span></span>
<span id="cb197-8"><a href="#cb197-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-9"><a href="#cb197-9" aria-hidden="true" tabindex="-1"></a><span class="ot">example3 ::</span> [<span class="dt">Int</span>]</span>
<span id="cb197-10"><a href="#cb197-10" aria-hidden="true" tabindex="-1"></a>example3 <span class="ot">=</span> [trace <span class="st">&quot;will not be called&quot;</span> <span class="dv">3</span>]</span>
<span id="cb197-11"><a href="#cb197-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-12"><a href="#cb197-12" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb197-13"><a href="#cb197-13" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb197-14"><a href="#cb197-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> example1</span>
<span id="cb197-15"><a href="#cb197-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> example2</span>
<span id="cb197-16"><a href="#cb197-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="fu">length</span> example3</span>
<span id="cb197-17"><a href="#cb197-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- impure print</span></span>
<span id="cb197-18"><a href="#cb197-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1</span></span>
<span id="cb197-19"><a href="#cb197-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- &quot;tracing&quot;</span></span>
<span id="cb197-20"><a href="#cb197-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- 2</span></span>
<span id="cb197-21"><a href="#cb197-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1</span></span></code></pre></div>
<div class="alert alert-danger">
<p>Trace uses <code>unsafePerformIO</code> under the hood and should
<strong>not</strong> be used in production code.</p>
</div>
<p>In addition to the <code>trace</code> function, several monadic
<code>trace</code> variants are quite common.</p>
<div class="sourceCode" id="cb198"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb198-1"><a href="#cb198-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Printf</span></span>
<span id="cb198-2"><a href="#cb198-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Debug.Trace</span></span>
<span id="cb198-3"><a href="#cb198-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-4"><a href="#cb198-4" aria-hidden="true" tabindex="-1"></a><span class="ot">traceM ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb198-5"><a href="#cb198-5" aria-hidden="true" tabindex="-1"></a>traceM string <span class="ot">=</span> trace string <span class="op">$</span> <span class="fu">return</span> ()</span>
<span id="cb198-6"><a href="#cb198-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-7"><a href="#cb198-7" aria-hidden="true" tabindex="-1"></a><span class="ot">traceShowM ::</span> (<span class="dt">Show</span> a, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m ()</span>
<span id="cb198-8"><a href="#cb198-8" aria-hidden="true" tabindex="-1"></a>traceShowM <span class="ot">=</span> traceM <span class="op">.</span> <span class="fu">show</span></span>
<span id="cb198-9"><a href="#cb198-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb198-10"><a href="#cb198-10" aria-hidden="true" tabindex="-1"></a><span class="ot">tracePrintfM ::</span> (<span class="dt">Monad</span> m, <span class="dt">PrintfArg</span> a) <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m ()</span>
<span id="cb198-11"><a href="#cb198-11" aria-hidden="true" tabindex="-1"></a>tracePrintfM s <span class="ot">=</span> traceM <span class="op">.</span> printf s</span></code></pre></div>
<h2 id="type-inference">Type Inference</h2>
<p>While inference in Haskell is usually complete, there are cases where
the principal type cannot be inferred. Three common cases are:</p>
<ul>
<li>Reduced polymorphism due to <em>mutually recursive binding
groups</em></li>
<li>Undecidability due to <em>polymorphic recursion</em></li>
<li>Reduced polymorphism due to the <em>monomorphism
restriction</em></li>
</ul>
<p>In each of these cases, Haskell needs a hint from the programmer,
which may be provided by adding explicit type signatures.</p>
<h4 id="mutually-recursive-binding-groups">Mutually Recursive Binding
Groups</h4>
<div class="sourceCode" id="cb199"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> <span class="fu">const</span> x g</span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a>g y <span class="ot">=</span> f <span class="ch">&#39;A&#39;</span></span></code></pre></div>
<p>In this case, the inferred type signatures are correct in their
usage, but they don’t represent the most general signatures. When GHC
analyzes the module it analyzes the dependencies of expressions on each
other, groups them together, and applies substitutions from unification
across mutually defined groups. As such the inferred types may not be
the most general types possible, and an explicit signature may be
desired.</p>
<div class="sourceCode" id="cb200"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Inferred types</span></span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span></span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> t <span class="ot">-&gt;</span> <span class="dt">Char</span></span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Most general types</span></span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> a <span class="ot">-&gt;</span> <span class="dt">Char</span></span></code></pre></div>
<h4 id="polymorphic-recursion">Polymorphic recursion</h4>
<div class="sourceCode" id="cb201"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Leaf</span> <span class="op">|</span> <span class="dt">Bin</span> a (<span class="dt">Tree</span> (a, a))</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>size <span class="dt">Leaf</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>size (<span class="dt">Bin</span> _ t) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> size t</span></code></pre></div>
<p>In the second case, recursion is polymorphic because the inferred
type variable <code>a</code> in <code>size</code> spans two possible
types (<code>a</code> and <code>(a,a)</code>). These two types won’t
pass the occurs-check of the typechecker and it yields an incorrect
inferred type:</p>
<div class="sourceCode" id="cb202"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Occurs</span> check<span class="op">:</span> cannot construct the infinite <span class="kw">type</span><span class="op">:</span> t0 <span class="ot">=</span> (t0, t0)</span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Expected</span> <span class="kw">type</span><span class="op">:</span> <span class="dt">Tree</span> t0</span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Actual</span> <span class="kw">type</span><span class="op">:</span> <span class="dt">Tree</span> (t0, t0)</span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">In</span> the first argument <span class="kw">of</span> <span class="ot">`size&#39;, namely `</span>t&#39;</span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">In</span> the second argument <span class="kw">of</span> <span class="ot">`(*)&#39;, namely `</span>size t&#39;</span>
<span id="cb202-6"><a href="#cb202-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">In</span> the second argument <span class="kw">of</span> <span class="ot">`(+)&#39;, namely `</span><span class="dv">2</span> <span class="op">*</span> size t&#39;</span></code></pre></div>
<p>Simply adding an explicit type signature corrects this. Type
inference using polymorphic recursion is undecidable in the general
case.</p>
<div class="sourceCode" id="cb203"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a><span class="ot">size ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a>size <span class="dt">Leaf</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>size (<span class="dt">Bin</span> _ t) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> size t</span></code></pre></div>
<p>See: <a
href="https://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-880004.5">Static
Semantics of Function and Pattern Bindings</a></p>
<h4 id="monomorphism-restriction">Monomorphism Restriction</h4>
<p>Finally <em>Monomorphism restriction</em> is a builtin typing rule.
By default, it is turned on when compiling and off in GHCi. The
practical effect of this rule is that types inferred for functions
without explicit type signatures may be more specific than expected.
This is because GHC will sometimes reduce a general type, such as
<code>Num</code> to a default type, such as <code>Double</code>. This
can be seen in the following example in GHCi:</p>
<div class="sourceCode" id="cb204"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb204-1"><a href="#cb204-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>set <span class="op">+</span>t</span>
<span id="cb204-2"><a href="#cb204-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-3"><a href="#cb204-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="dv">3</span></span>
<span id="cb204-4"><a href="#cb204-4" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span>
<span id="cb204-5"><a href="#cb204-5" aria-hidden="true" tabindex="-1"></a><span class="ot">it ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a</span>
<span id="cb204-6"><a href="#cb204-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-7"><a href="#cb204-7" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> default (<span class="dt">Double</span>)</span>
<span id="cb204-8"><a href="#cb204-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb204-9"><a href="#cb204-9" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="dv">3</span></span>
<span id="cb204-10"><a href="#cb204-10" aria-hidden="true" tabindex="-1"></a><span class="fl">3.0</span></span>
<span id="cb204-11"><a href="#cb204-11" aria-hidden="true" tabindex="-1"></a><span class="ot">it ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a</span></code></pre></div>
<p>This rule may be deactivated with the
<code>NoMonomorphicRestriction</code> extension, see <a
href="#nomonomorphicrestriction">below</a>.</p>
<p>See:</p>
<ul>
<li><a
href="https://wiki.haskell.org/Monomorphism_restriction">Monomorphism
Restriction</a></li>
</ul>
<h2 id="type-holes">Type Holes</h2>
<p>Since the release of GHC 7.8, type holes allow underscores as
stand-ins for actual values. They may be used either in declarations or
in type signatures.</p>
<p>Type holes are useful in debugging incomplete programs. By placing an
underscore on any value on the right hand-side of a declaration, <a
href="https://www.haskell.org/ghc/">GHC</a> will throw an error during
type-checking. The error message describes which values may legally fill
the type hole.</p>
<div class="sourceCode" id="cb205"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a>head&#39; <span class="ot">=</span> <span class="fu">head</span> _</span></code></pre></div>
<div class="sourceCode" id="cb206"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a><span class="ex">typedhole.hs:3:14:</span> error:</span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">•</span> Found hole: _ :: <span class="pp">[</span><span class="ss">a</span><span class="pp">]</span></span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a>      <span class="ex">Where:</span> ‘a’ is a rigid type variable bound by</span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a>               <span class="ex">the</span> inferred type of head<span class="st">&#39; :: a at typedhole.hs:3:1</span></span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true" tabindex="-1"></a><span class="st">    • In the first argument of ‘head’, namely ‘_’</span></span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true" tabindex="-1"></a><span class="st">      In the expression: head _</span></span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true" tabindex="-1"></a><span class="st">      In an equation for ‘head&#39;</span>’: head<span class="st">&#39; = head _</span></span>
<span id="cb206-8"><a href="#cb206-8" aria-hidden="true" tabindex="-1"></a><span class="st">    • Relevant bindings include head&#39;</span> :: a <span class="er">(</span><span class="ex">bound</span> at typedhole.hs:3:1<span class="kw">)</span></span></code></pre></div>
<p>GHC has rightly suggested that the expression needed to finish the
program is <code>xs :: [a]</code>.</p>
<p>The same hole technique can be applied at the toplevel for
signatures:</p>
<div class="sourceCode" id="cb207"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="ot">const&#39; ::</span> _</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>const&#39; x y <span class="ot">=</span> x</span></code></pre></div>
<div class="sourceCode" id="cb208"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a><span class="ex">typedhole.hs:5:11:</span> error:</span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">•</span> Found type wildcard ‘_’ standing for ‘t <span class="at">-</span><span class="op">&gt;</span> t1 <span class="at">-</span><span class="op">&gt;</span> t’</span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a>      <span class="ex">Where:</span> ‘t1’ is a rigid type variable bound by</span>
<span id="cb208-4"><a href="#cb208-4" aria-hidden="true" tabindex="-1"></a>               <span class="ex">the</span> inferred type of const<span class="st">&#39; :: t -&gt; t1 -&gt; t at typedhole.hs:6:1</span></span>
<span id="cb208-5"><a href="#cb208-5" aria-hidden="true" tabindex="-1"></a><span class="st">             ‘t’ is a rigid type variable bound by</span></span>
<span id="cb208-6"><a href="#cb208-6" aria-hidden="true" tabindex="-1"></a><span class="st">               the inferred type of const&#39;</span> :: t <span class="at">-</span><span class="op">&gt;</span> t1 <span class="at">-</span><span class="op">&gt;</span> t at typedhole.hs:6:1</span>
<span id="cb208-7"><a href="#cb208-7" aria-hidden="true" tabindex="-1"></a>      <span class="ex">To</span> use the inferred type, enable PartialTypeSignatures</span>
<span id="cb208-8"><a href="#cb208-8" aria-hidden="true" tabindex="-1"></a>    <span class="ex">•</span> In the type signature:</span>
<span id="cb208-9"><a href="#cb208-9" aria-hidden="true" tabindex="-1"></a>        <span class="ex">const</span><span class="st">&#39; :: _</span></span>
<span id="cb208-10"><a href="#cb208-10" aria-hidden="true" tabindex="-1"></a><span class="st">    • Relevant bindings include</span></span>
<span id="cb208-11"><a href="#cb208-11" aria-hidden="true" tabindex="-1"></a><span class="st">        const&#39;</span> :: t <span class="at">-</span><span class="op">&gt;</span> t1 <span class="at">-</span><span class="op">&gt;</span> t <span class="er">(</span><span class="ex">bound</span> at typedhole.hs:6:1<span class="kw">)</span></span></code></pre></div>
<p>Pattern wildcards can also be given explicit names so that GHC will
use the names when reporting the inferred type in the resulting
message.</p>
<div class="sourceCode" id="cb209"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> _a <span class="ot">-&gt;</span> _a</span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a>foo _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<div class="sourceCode" id="cb210"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="ex">typedhole.hs:9:9:</span> error:</span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">•</span> Couldn<span class="st">&#39;t match expected type ‘_a’ with actual type ‘Bool’</span></span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a><span class="st">      ‘_a’ is a rigid type variable bound by</span></span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a><span class="st">        the type signature for:</span></span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a><span class="st">          foo :: forall _a. _a -&gt; _a</span></span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a><span class="st">        at typedhole.hs:8:8</span></span>
<span id="cb210-7"><a href="#cb210-7" aria-hidden="true" tabindex="-1"></a><span class="st">    • In the expression: False</span></span>
<span id="cb210-8"><a href="#cb210-8" aria-hidden="true" tabindex="-1"></a><span class="st">      In an equation for ‘foo’: foo _ = False</span></span>
<span id="cb210-9"><a href="#cb210-9" aria-hidden="true" tabindex="-1"></a><span class="st">    • Relevant bindings include</span></span>
<span id="cb210-10"><a href="#cb210-10" aria-hidden="true" tabindex="-1"></a><span class="st">        foo :: _a -&gt; _a (bound at typedhole.hs:9:1)</span></span></code></pre></div>
<p>The same wildcards can be used in type contexts to dump out inferred
type class constraints:</p>
<div class="sourceCode" id="cb211"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="ot">succ&#39; ::</span> _ <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a>succ&#39; x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span></span></code></pre></div>
<div class="sourceCode" id="cb212"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a><span class="ex">typedhole.hs:11:10:</span> error:</span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Found</span> constraint wildcard ‘_’ standing for ‘Num a’</span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">To</span> use the inferred type, enable PartialTypeSignatures</span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a>    <span class="ex">In</span> the type signature:</span>
<span id="cb212-5"><a href="#cb212-5" aria-hidden="true" tabindex="-1"></a>      <span class="ex">succ</span><span class="st">&#39; :: _ =&gt; a -&gt; a</span></span></code></pre></div>
<p>When the flag <code>-XPartialTypeSignatures</code> is passed to GHC
and the inferred type is unambiguous, GHC will let us leave the holes in
place and the compilation will proceed with a warning instead of an
error.</p>
<div class="sourceCode" id="cb213"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a><span class="ex">typedhole.hs:3:10:</span> Warning:</span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Found</span> hole ‘_’ with type: w_</span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Where:</span> ‘w_’ is a rigid type variable bound by</span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a>                <span class="ex">the</span> inferred type of succ<span class="st">&#39; :: w_ -&gt; w_1 -&gt; w_ at foo.hs:4:1</span></span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a><span class="st">    In the type signature for ‘succ&#39;</span>’: _ <span class="at">-</span><span class="op">&gt;</span> _ <span class="at">-</span><span class="op">&gt;</span> _</span></code></pre></div>
<h2 id="deferred-type-errors">Deferred Type Errors</h2>
<p>Since the release of version 7.8, <a
href="https://www.haskell.org/ghc/">GHC</a> supports the option of
treating type errors as runtime errors. With this option enabled,
programs will run, but they will fail when a mistyped expression is
evaluated. This feature is enabled with the
<code>-fdefer-type-errors</code> flag in three ways: at the module
level, when compiled from the command line, or inside of a <a
href="#ghci">GHCi</a> interactive session.</p>
<p>For instance, the program below will compile:</p>
<div class="sourceCode" id="cb214"
data-include="src/01-basics/defer.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -fdefer-type-errors #-}</span> <span class="co">-- Enable deferred type</span></span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a>                                        <span class="co">-- errors at module level</span></span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a><span class="ot">x ::</span> ()</span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="fu">print</span> <span class="dv">3</span></span>
<span id="cb214-6"><a href="#cb214-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-7"><a href="#cb214-7" aria-hidden="true" tabindex="-1"></a><span class="ot">y ::</span> <span class="dt">Char</span></span>
<span id="cb214-8"><a href="#cb214-8" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb214-9"><a href="#cb214-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-10"><a href="#cb214-10" aria-hidden="true" tabindex="-1"></a><span class="ot">z ::</span> <span class="dt">Int</span></span>
<span id="cb214-11"><a href="#cb214-11" aria-hidden="true" tabindex="-1"></a>z <span class="ot">=</span> <span class="dv">0</span> <span class="op">+</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb214-12"><a href="#cb214-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-13"><a href="#cb214-13" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb214-14"><a href="#cb214-14" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb214-15"><a href="#cb214-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> x</span></code></pre></div>
<p>However, when a pathological term is evaluated at runtime, we’ll see
a message like this:</p>
<div class="sourceCode" id="cb215"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="ex">defer:</span> defer.hs:4:5:</span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Couldn</span><span class="st">&#39;t match expected type ‘()’ with actual type ‘IO ()’</span></span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a><span class="st">    In the expression: print 3</span></span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a><span class="st">    In an equation for ‘x’: x = print 3</span></span>
<span id="cb215-5"><a href="#cb215-5" aria-hidden="true" tabindex="-1"></a><span class="st">(deferred type error)</span></span></code></pre></div>
<p>This error tells us that while <code>x</code> has a declared type of
<code>()</code>, the body of the function <code>print 3</code> has a
type of <code>IO ()</code>. However, if the term is never evaluated, GHC
will not throw an exception.</p>
<h2 id="name-conventions">Name Conventions</h2>
<p>Haskell uses short variable names as a convention. This is offputting
at first but after you read enough Haskell, it ceases to be a problem.
In addition there are several ad-hoc conventions that are typically
adopted</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Variable</th>
<th style="text-align: left;">Convention</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>a,b,c..</code></td>
<td style="text-align: left;">Type level variable</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>x,y,z..</code></td>
<td style="text-align: left;">Value variables</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>f,g,h..</code></td>
<td style="text-align: left;">Higher order function values</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>x,y</code></td>
<td style="text-align: left;">List head values</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>xs,ys</code></td>
<td style="text-align: left;">List tail values</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>m</code></td>
<td style="text-align: left;">Monadic type variable</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>t</code></td>
<td style="text-align: left;">Monad transformer variable</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>e</code></td>
<td style="text-align: left;">Exception value</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>s</code></td>
<td style="text-align: left;">Monad state value</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>r</code></td>
<td style="text-align: left;">Monad reader value</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>t</code></td>
<td style="text-align: left;">Foldable or Traversable type variable</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>f</code></td>
<td style="text-align: left;">Functor or applicative type variable</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>mX</code></td>
<td style="text-align: left;">Maybe variable</td>
</tr>
</tbody>
</table>
<p>Functions that end with a tick (like <code>fold'</code>) are
typically strict variants of a default lazy function.</p>
<div class="sourceCode" id="cb216"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldl&#39; ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>Functions that end with a _ (like <code>map_</code>) are typically
variants of a function which discards the output and returns void.</p>
<div class="sourceCode" id="cb217"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM_</span><span class="ot"> ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>Variables that are pluralized <code>xs</code>, <code>ys</code>
typically refer to list tails.</p>
<div class="sourceCode" id="cb218"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb218-1"><a href="#cb218-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">++</span>) []     ys <span class="ot">=</span> ys</span>
<span id="cb218-2"><a href="#cb218-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">++</span>) (x<span class="op">:</span>xs) ys <span class="ot">=</span> x <span class="op">:</span> xs <span class="op">++</span> ys</span></code></pre></div>
<p>Records that do not export their accessors will sometimes prefix them
with underscores. These are sometimes interpreted by Template Haskell
logic to produce derived field accessors.</p>
<div class="sourceCode" id="cb219"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">Point</span></span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> _x ::</span> <span class="dt">Int</span></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _y ::</span> <span class="dt">Int</span></span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Predicates will often prefix their function names with
<code>is</code>, as in <code>isPositive</code>.</p>
<div class="sourceCode" id="cb220"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb220-1"><a href="#cb220-1" aria-hidden="true" tabindex="-1"></a>isPositive <span class="ot">=</span> (<span class="op">&gt;</span><span class="dv">0</span>)</span></code></pre></div>
<p>Functions which result in an Applicative or Monad type will often
suffix their name with a A for Applicative or M for Monad. For
example:</p>
<div class="sourceCode" id="cb221"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m r</span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a><span class="ot">liftA ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>Functions which have <em>chirality</em> in which they traverse a data
structure (i.e. left-to-right or right-to-left) will often suffix the
name with L or R for their iteration pattern. This is useful because
often times these type signatures are identical.</p>
<div class="sourceCode" id="cb222"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb222-1"><a href="#cb222-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mapAccumL ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> (a, c)) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> (a, t c)</span>
<span id="cb222-2"><a href="#cb222-2" aria-hidden="true" tabindex="-1"></a><span class="ot">mapAccumR ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> (a, c)) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> t b <span class="ot">-&gt;</span> (a, t c)</span></code></pre></div>
<p>Functions working with mutable structures or monadic state will often
adopt the following naming conventions:</p>
<div class="sourceCode" id="cb223"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a>newX      <span class="co">-- Create a new mutable X structure</span></span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a>writeX    <span class="co">-- Write to an existing mutable X structure</span></span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a>setX      <span class="co">-- Set the value of an existing mutable X structure</span></span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a>modifyX   <span class="co">-- Apply a function over existing mutable X structure</span></span></code></pre></div>
<p>Functions that are prefixed with <code>with</code> typically take a
value as their first argument and a function as their second argument
returning the value with the function applied over some substructure as
the result.</p>
<div class="sourceCode" id="cb224"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a><span class="ot">withBool ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a) <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span></code></pre></div>
<h2 id="ghcid">ghcid</h2>
<p><a href="https://github.com/ndmitchell/ghcid">ghcid</a> is a
lightweight IDE hook that allows continuous feedback whenever code is
updated. It can be run from the command line in the root of the
<code>cabal</code> project directory by specifying a command to run
(e.g. <code>ghci</code>, <code>cabal repl</code>, or
<code>stack repl</code>).</p>
<div class="sourceCode" id="cb225"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb225-1"><a href="#cb225-1" aria-hidden="true" tabindex="-1"></a><span class="ex">ghcid</span> <span class="at">--command</span><span class="op">=</span><span class="st">&quot;cabal repl&quot;</span>   <span class="co"># Run cabal repl under ghcid</span></span>
<span id="cb225-2"><a href="#cb225-2" aria-hidden="true" tabindex="-1"></a><span class="ex">ghcid</span> <span class="at">--command</span><span class="op">=</span><span class="st">&quot;stack repl&quot;</span>   <span class="co"># Run stack repl under ghcid</span></span>
<span id="cb225-3"><a href="#cb225-3" aria-hidden="true" tabindex="-1"></a><span class="ex">ghcid</span> <span class="at">--command</span><span class="op">=</span><span class="st">&quot;ghci baz.hs&quot;</span>  <span class="co"># Open baz.hs under ghcid</span></span></code></pre></div>
<p>When a Haskell module is loaded into <code>ghcid</code>, the code is
evaluated in order to provide the user with any errors or warnings that
would happen at compile time. When the developer edits and saves code
loaded into <code>ghcid</code>, the program automatically reloads and
evaluates the code for errors and warnings.</p>
<h2 id="hlint">HLint</h2>
<p>HLint is a source linter for Haskell that provides a variety of hints
on code improvements. It can be customised and configured with custom
rules, on a per-project basis. HLint is configured through a
<code>hlint.yaml</code> file placed in the root of a project. To
generate the default configuration run:</p>
<div class="sourceCode" id="cb226"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a><span class="ex">hlint</span> <span class="at">--default</span> <span class="op">&gt;</span> .hlint.yaml</span></code></pre></div>
<p>Custom errors can be added to this file in order to match and suggest
custom changes of code from the left hand side match to the right hand
side replacement:</p>
<div class="sourceCode" id="cb227"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a><span class="fu">error</span><span class="kw">:</span><span class="at"> </span><span class="kw">{</span><span class="fu">lhs</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;foo x&quot;</span><span class="kw">,</span><span class="at"> </span><span class="fu">rhs</span><span class="kw">:</span><span class="at"> bar x</span><span class="kw">}</span></span></code></pre></div>
<p>HLint’s default is to warn on all possible failures. These can be
disabled globally by adding ignore pragmas.</p>
<div class="sourceCode" id="cb228"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ignore</span><span class="kw">:</span><span class="at"> </span><span class="kw">{</span><span class="fu">name</span><span class="kw">:</span><span class="at"> Use let</span><span class="kw">}</span></span></code></pre></div>
<p>Or within specific modules by specifying the <code>within</code>
option.</p>
<div class="sourceCode" id="cb229"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ignore</span><span class="kw">:</span><span class="at"> </span><span class="kw">{</span><span class="fu">name</span><span class="kw">:</span><span class="at"> Use let</span><span class="kw">,</span><span class="at"> </span><span class="fu">within</span><span class="kw">:</span><span class="at"> MyModule</span><span class="kw">}</span></span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://github.com/ndmitchell/hlint">HLint Github</a></li>
</ul>
<h2 id="docker-images">Docker Images</h2>
<p>Haskell has stable Docker images that are widely used for deployments
across Kubernetes and Docker environments. The two Dockerhub
repositories of note are:</p>
<ul>
<li><a href="https://hub.docker.com/_/haskell/">Official Haskell
Images</a></li>
<li><a href="https://hub.docker.com/r/fpco/haskell/">Stack LTS
Images</a></li>
</ul>
<p>To import the official Haskell images with <code>ghc</code> and
<code>cabal-install</code> include the following preamble in your
Dockerfile with your desired GHC version.</p>
<pre class="docker"><code>FROM haskell:8.8.1</code></pre>
<p>To import the stack images include the following preamble in your
Dockerfile with your desired Stack resolver replaced.</p>
<pre class="docker"><code>FROM fpco/stack-build:lts-14.0</code></pre>
<h2 id="continuous-integration">Continuous Integration</h2>
<p>These days it is quite common to use cloud hosted continuous
integration systems to test code from version control systems. There are
many community contributed build scripts for different service
providers, including the following:</p>
<ul>
<li><a
href="https://github.com/haskell-CI/haskell-ci/blob/master/.travis.yml">Travis
CI for Cabal</a></li>
<li><a href="https://docs.haskellstack.org/en/stable/travis_ci/">Travis
CI for Stack</a></li>
<li><a
href="https://github.com/composewell/packcheck/blob/master/.circleci/config.yml">Circle
CI for Cabal &amp; Stack</a></li>
<li><a
href="https://gist.github.com/mstksg/11f753d891cee5980326a8ea8c865233">Github
Actions for Cabal &amp; Stack</a></li>
</ul>
<p>See also the official CI repository:</p>
<ul>
<li><a
href="https://github.com/haskell-CI/haskell-ci">haskell-ci</a></li>
</ul>
<h2 id="ormolu">Ormolu</h2>
<p>Ormolu is an opinionated Haskell source formatter that produces a
canonical way of rendering the Haskell abstract syntax tree to text.
This ensures that code shared amongst teams and checked into version
control conforms to a single universal standard for whitespace and
lexeme placing. This is similar to tools in other languages such as
<code>go fmt</code>.</p>
<p>For example running <code>ormolu example.hs --inplace</code> on the
following module:</p>
<div class="sourceCode" id="cb232"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Unformatted</span></span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a>  (a,b)</span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Int</span></span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span>  <span class="dv">42</span></span>
<span id="cb232-7"><a href="#cb232-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-8"><a href="#cb232-8" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">Int</span></span>
<span id="cb232-9"><a href="#cb232-9" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> a<span class="op">+</span> a</span></code></pre></div>
<p>Will rerender the file as:</p>
<div class="sourceCode" id="cb233"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Unformatted</span></span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a>  ( a,</span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a>    b,</span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb233-5"><a href="#cb233-5" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb233-6"><a href="#cb233-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-7"><a href="#cb233-7" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Int</span></span>
<span id="cb233-8"><a href="#cb233-8" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dv">42</span></span>
<span id="cb233-9"><a href="#cb233-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-10"><a href="#cb233-10" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">Int</span></span>
<span id="cb233-11"><a href="#cb233-11" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> a <span class="op">+</span> a</span></code></pre></div>
<p>Ormolu can be installed via a variety of mechanisms.</p>
<div class="sourceCode" id="cb234"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> stack install ormolu <span class="at">--resolver</span><span class="op">=</span>lts-14.14   <span class="co"># via stack</span></span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal new-install ormolu <span class="at">--installdir</span><span class="op">=</span>/home/user/.local/bin <span class="co"># via cabal</span></span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> nix-build <span class="at">-A</span> ormolu   <span class="co"># via nix</span></span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://github.com/tweag/ormolu">ormolu</a></li>
</ul>
<h2 id="haddock">Haddock</h2>
<p><a href="https://www.haskell.org/haddock/#Overview">Haddock</a> is
the automatic documentation generation tool for Haskell source code, and
it integrates with the usual <code>cabal</code> toolchain. In this
section, we will explore how to document code so that Haddock can
generate documentation successfully.</p>
<p>Several frequent comment patterns are used to document code for
Haddock. The first of these methods uses <code>-- |</code> to delineate
the beginning of a comment:</p>
<div class="sourceCode" id="cb235"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Documentation for f</span></span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>Multiline comments are also possible:</p>
<div class="sourceCode" id="cb236"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Multiline documentation for the function</span></span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- f with multiple arguments.</span></span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> <span class="dt">Functor</span> f</span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a>     <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b)  <span class="co">-- ^ function</span></span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> f a       <span class="co">-- ^ input</span></span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> f b       <span class="co">-- ^ output</span></span></code></pre></div>
<p><code>-- ^</code> is used to comment Constructors or Record
fields:</p>
<div class="sourceCode" id="cb237"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> a b</span>
<span id="cb237-2"><a href="#cb237-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">A</span> a <span class="co">-- ^ Documentation for A</span></span>
<span id="cb237-3"><a href="#cb237-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">B</span> b <span class="co">-- ^ Documentation for B</span></span>
<span id="cb237-4"><a href="#cb237-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb237-5"><a href="#cb237-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">R</span> a b <span class="ot">=</span> <span class="dt">R</span></span>
<span id="cb237-6"><a href="#cb237-6" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> f1 ::</span> a <span class="co">-- ^ Documentation for the field f1</span></span>
<span id="cb237-7"><a href="#cb237-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> f2 ::</span> b <span class="co">-- ^ Documentation for the field f2</span></span>
<span id="cb237-8"><a href="#cb237-8" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Elements within a module (i.e. values, types, classes) can be
hyperlinked by enclosing the identifier in single quotes:</p>
<div class="sourceCode" id="cb238"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> a b</span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">A</span> a <span class="co">-- ^ Documentation for &#39;A&#39;</span></span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">B</span> b <span class="co">-- ^ Documentation for &#39;B&#39;</span></span></code></pre></div>
<p>Modules themselves can be referenced by enclosing them in double
quotes:</p>
<div class="sourceCode" id="cb239"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Here we use the &quot;Data.Text&quot; library and import</span></span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- the &#39;Data.Text.pack&#39; function.</span></span></code></pre></div>
<p><code>haddock</code> also allows the user to include blocks of code
within the generated documentation. Two methods of demarcating the code
blocks exist in <code>haddock</code>. For example, enclosing a code
snippet in <code>@</code> symbols marks it as a code block:</p>
<div class="sourceCode" id="cb240"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | An example of a code block.</span></span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- @</span></span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true" tabindex="-1"></a><span class="co">--    f x = f (f x)</span></span>
<span id="cb240-5"><a href="#cb240-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- @</span></span></code></pre></div>
<p>Similarly, it is possible to use bird tracks (<code>&gt;</code>) in a
comment line to set off a code block.</p>
<div class="sourceCode" id="cb241"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A similar code block example that uses bird tracks (i.e. &#39;&gt;&#39;)</span></span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt; f x = f (f x)</span></span></code></pre></div>
<p>Snippets of interactive shell sessions can also be included in
<code>haddock</code> documentation. In order to denote the beginning of
code intended to be run in a REPL, the <code>&gt;&gt;&gt;</code> symbol
is used:</p>
<div class="sourceCode" id="cb242"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Example of an interactive shell session embedded within documentation</span></span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb242-3"><a href="#cb242-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- &gt;&gt;&gt; factorial 5</span></span>
<span id="cb242-4"><a href="#cb242-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- 120</span></span></code></pre></div>
<p>Headers for specific blocks can be added by prefacing the comment in
the module block with a <code>*</code>:</p>
<div class="sourceCode" id="cb243"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb243-1"><a href="#cb243-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Foo</span> (</span>
<span id="cb243-2"><a href="#cb243-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- * My Header</span></span>
<span id="cb243-3"><a href="#cb243-3" aria-hidden="true" tabindex="-1"></a>  example1,</span>
<span id="cb243-4"><a href="#cb243-4" aria-hidden="true" tabindex="-1"></a>  example2</span>
<span id="cb243-5"><a href="#cb243-5" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<p>Sections can also be delineated by <code>$</code> blocks that pertain
to references in the body of the module:</p>
<div class="sourceCode" id="cb244"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Foo</span> (</span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- $section1</span></span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a>  example1,</span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true" tabindex="-1"></a>  example2</span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb244-6"><a href="#cb244-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-7"><a href="#cb244-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- $section1</span></span>
<span id="cb244-8"><a href="#cb244-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Here is the documentation section that describes the symbols</span></span>
<span id="cb244-9"><a href="#cb244-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- &#39;example1&#39; and &#39;example2&#39;.</span></span></code></pre></div>
<p>Links can be added with the following syntax:</p>
<div class="sourceCode" id="cb245"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>url text<span class="op">&gt;</span></span></code></pre></div>
<p>Images can also be included, so long as the path is either absolute
or relative to the directory in which <code>haddock</code> is run.</p>
<div class="sourceCode" id="cb246"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;&lt;</span>diagram<span class="op">.</span>png title<span class="op">&gt;&gt;</span></span></code></pre></div>
<p><code>haddock</code> options can also be specified with pragmas in
the source, either at the module or project level.</p>
<div class="sourceCode" id="cb247"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_HADDOCK show-extensions, ignore-exports #-}</span></span></code></pre></div>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Option</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">ignore-exports</td>
<td style="text-align: left;">Ignores the export list and includes all
signatures in scope.</td>
</tr>
<tr class="even">
<td style="text-align: left;">not-home</td>
<td style="text-align: left;">Module will not be considered in the root
documentation.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">show-extensions</td>
<td style="text-align: left;">Annotates the documentation with the
language extensions used.</td>
</tr>
<tr class="even">
<td style="text-align: left;">hide</td>
<td style="text-align: left;">Forces the module to be hidden from
Haddock.</td>
</tr>
<tr class="odd">
<td style="text-align: left;">prune</td>
<td style="text-align: left;">Omits definitions with no
annotations.</td>
</tr>
</tbody>
</table>
<h2 id="unsafe-functions">Unsafe Functions</h2>
<p>As everyone eventually finds out there are several functions within
the implementation of GHC (not the Haskell language) that can be used to
subvert the type-system; these functions are marked with the prefix
<code>unsafe</code>. Unsafe functions exist only for when one can
manually prove the soundness of an expression but can’t express this
property in the type-system, or externalities to Haskell.</p>
<div class="sourceCode" id="cb248"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unsafeCoerce ::</span> a <span class="ot">-&gt;</span> b         <span class="co">-- Unsafely coerce anything into anything</span></span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a><span class="ot">unsafePerformIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> a   <span class="co">-- Unsafely run IO action outside of IO</span></span></code></pre></div>
<div class="alert alert-danger">
<p>Using these functions to subvert the Haskell typesystem will cause
all measure of undefined behavior with unimaginable pain and suffering,
and so they are <span style="font-weight: bold">strongly
discouraged</span>. When initially starting out with Haskell there are
no legitimate reasons to use these functions at all.</p>
</div>
<hr/>
<h1 id="monads">Monads</h1>
<p>Monads form one of the core components for constructing Haskell
programs. In their most general form monads are an algebraic building
block that can give rise to ways of structuring control flow, handling
data structures and orchestrating logic. Monads are a very general
algebraic way of structuring code and have a certain reputation for
being confusing. However their power and flexibility have become
foundational to the way modern Haskell programs are structured.</p>
<p>There is a singular truth to keep in mind when learning monads.</p>
<blockquote>
<p>A monad is just its algebraic laws. Nothing more, nothing less.</p>
</blockquote>
<h2 id="eightfold-path-to-monad-satori">Eightfold Path to Monad
Satori</h2>
<p>Much ink has been spilled waxing lyrical about the supposed mystique
of monads. Instead, I suggest a path to enlightenment:</p>
<ol type="1">
<li>Don’t read the monad tutorials.</li>
<li>No really, don’t read the monad tutorials.</li>
<li>Learn about the Haskell typesystem.</li>
<li>Learn what a typeclass is.</li>
<li>Read the <a
href="http://wiki.haskell.org/Typeclassopedia">Typeclassopedia</a>.</li>
<li>Read the monad definitions.</li>
<li>Use monads in real code.</li>
<li>Don’t write monad-analogy tutorials.</li>
</ol>
<p>In other words, the only path to understanding monads is to read the
fine source, fire up GHC, and write some code. Analogies and metaphors
will not lead to understanding.</p>
<h2 id="monad-myths">Monad Myths</h2>
<p>The following are all <strong>false</strong>:</p>
<ul>
<li>Monads are impure.</li>
<li>Monads are about effects.</li>
<li>Monads are about state.</li>
<li>Monads are about imperative sequencing.</li>
<li>Monads are about IO.</li>
<li>Monads are dependent on laziness.</li>
<li>Monads are a “back-door” in the language to perform
side-effects.</li>
<li>Monads are an embedded imperative language inside Haskell.</li>
<li>Monads require knowing abstract mathematics.</li>
<li>Monads are unique to Haskell.</li>
</ul>
<h2 id="monad-methods">Monad Methods</h2>
<p>Monads are not complicated. They are implemented as a typeclass with
two methods, <code>return</code> and <code>(&gt;&gt;=)</code>
(pronounced “bind”). In order to implement a Monad instance, these two
functions must be defined:</p>
<div class="sourceCode" id="cb249"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb249-1"><a href="#cb249-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb249-2"><a href="#cb249-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  return ::</span> a <span class="ot">-&gt;</span> m a    <span class="co">-- N.B. &#39;m&#39; refers to a type constructor</span></span>
<span id="cb249-3"><a href="#cb249-3" aria-hidden="true" tabindex="-1"></a>                        <span class="co">-- (e.g., Maybe, Either, etc.) that</span></span>
<span id="cb249-4"><a href="#cb249-4" aria-hidden="true" tabindex="-1"></a>                        <span class="co">-- implements the Monad typeclass</span></span>
<span id="cb249-5"><a href="#cb249-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb249-6"><a href="#cb249-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;=)  ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>The first type signature in the Monad class definition is for
<code>return</code>. Any preconceptions one might have for the word
“return” should be discarded. It has an entirely different meaning in
the context of Haskell and acts very differently than in languages such
as C, Python, or Java. Instead of being the final arbiter of what value
a function produces, <code>return</code> in Haskell injects a value of
type <code>a</code> into a monadic context (e.g., Maybe, Either, etc.),
which is denoted as <code>m a</code>.</p>
<p>The other function essential to implementing a Monad instance is
<code>(&gt;&gt;=)</code>. This infix function takes two arguments. On
its left side is a value with type <code>m a</code>, while on the right
side is a function with type <code>(a -&gt; m b)</code>. The bind
operation results in a final value of type <code>m b</code>.</p>
<p>A third, auxiliary function (<code>(&gt;&gt;)</code>) is defined in
terms of the bind operation that discards its argument.</p>
<div class="sourceCode" id="cb250"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;</span> k <span class="ot">=</span> m <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> k</span></code></pre></div>
<p>This definition says that (&gt;&gt;) has a left and right argument
which are monadic with types <code>m a</code> and <code>m b</code>
respectively, while the infix function yields a value of type
<code>m b</code>. The actual implementation of (&gt;&gt;) says that when
<code>m</code> is passed to <code>(&gt;&gt;)</code> with <code>k</code>
on the right, the value <code>k</code> will always be yielded.</p>
<h2 id="monad-laws">Monad Laws</h2>
<p>In addition to specific implementations of <code>(&gt;&gt;=)</code>
and <code>return</code>, all monad instances must satisfy three
laws.</p>
<p><strong>Law 1</strong></p>
<p>The first law says that when <code>return a</code> is passed through
<code>(&gt;&gt;=)</code> into a function <code>f</code>, this expression
is exactly equivalent to <code>f a</code>.</p>
<div class="sourceCode" id="cb251"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> a <span class="op">&gt;&gt;=</span> f ≡ f a    <span class="co">-- N.B. &#39;a&#39; refers to a value, not a type</span></span></code></pre></div>
<p>In discussing the next two laws, we’ll refer to a value
<code>m</code>. This notation is shorthand for a value wrapped in a
monadic context. Such a value has type <code>m a</code>, and could be
represented more concretely by values like <code>Nothing</code>,
<code>Just x</code>, or <code>Right x</code>. It is important to note
that some of these concrete instantiations of the value <code>m</code>
have multiple components. In discussing the second and third monad laws,
we’ll see some examples of how this plays out.</p>
<p><strong>Law 2</strong></p>
<p>The second law states that a monadic value <code>m</code> passed
through <code>(&gt;&gt;=)</code> into <code>return</code> is exactly
equivalent to itself. In other words, using bind to pass a monadic value
to <code>return</code> does not change the initial value.</p>
<div class="sourceCode" id="cb252"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb252-1"><a href="#cb252-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;=</span> <span class="fu">return</span> ≡ m        <span class="co">-- &#39;m&#39; here refers to a value that has type &#39;m a&#39;</span></span></code></pre></div>
<p>A more explicit way to write the second Monad law exists. In this
following example code, the first expression shows how the second law
applies to values represented by <a
href="https://wiki.haskell.org/Constructor#Type_constructor">non-nullary</a>
type constructors. The second snippet shows how a value represented by a
nullary type constructor works within the context of the second law.</p>
<div class="sourceCode" id="cb253"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a>(<span class="dt">SomeMonad</span> val) <span class="op">&gt;&gt;=</span> <span class="fu">return</span> ≡ <span class="dt">SomeMonad</span> val  <span class="co">-- &#39;SomeMonad val&#39; has type &#39;m a&#39; just</span></span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a>                                            <span class="co">-- like &#39;m&#39; from the first example of the</span></span>
<span id="cb253-3"><a href="#cb253-3" aria-hidden="true" tabindex="-1"></a>                                            <span class="co">-- second law</span></span>
<span id="cb253-4"><a href="#cb253-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb253-5"><a href="#cb253-5" aria-hidden="true" tabindex="-1"></a><span class="dt">NullaryMonadType</span> <span class="op">&gt;&gt;=</span> <span class="fu">return</span> ≡ <span class="dt">NullaryMonadType</span></span></code></pre></div>
<p><strong>Law 3</strong></p>
<p>While the first two laws are relatively clear, the third law may be
more difficult to understand. This law states that when a monadic value
<code>m</code> is passed through <code>(&gt;&gt;=)</code> to the
function <code>f</code> and then the result of that expression is passed
to <code>&gt;&gt;= g</code>, the entire expression is exactly equivalent
to passing <code>m</code> to a lambda expression that takes one
parameter <code>x</code> and outputs the function <code>f</code> applied
to <code>x</code>. By the definition of bind, <code>f x</code>
<em>must</em> return a value wrapped in the <em>same</em> monad. Because
of this property, the resultant value of that expression can be passed
through <code>(&gt;&gt;=)</code> to the function <code>g</code>, which
also returns a monadic value.</p>
<div class="sourceCode" id="cb254"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a>(m <span class="op">&gt;&gt;=</span> f) <span class="op">&gt;&gt;=</span> g ≡ m <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> f x <span class="op">&gt;&gt;=</span> g)  <span class="co">-- Like in the last law, &#39;m&#39; has</span></span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a>                                           <span class="co">-- has type &#39;m a&#39;. The functions &#39;f&#39;</span></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a>                                           <span class="co">-- and &#39;g&#39; have types &#39;(a -&gt; m b)&#39;</span></span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a>                                           <span class="co">-- and &#39;(b -&gt; m c)&#39; respectively</span></span></code></pre></div>
<p>Again, it is possible to write this law with more explicit code. Like
in the explicit examples for law 2, <code>m</code> has been replaced by
<code>SomeMonad val</code> in order to be make it clear that there can
be multiple components to a monadic value. Although little has changed
in the code, it is easier to see that value –namely, <code>val</code>–
corresponds to the <code>x</code> in the lambda expression. After
<code>SomeMonad val</code> is passed through <code>(&gt;&gt;=)</code> to
<code>f</code>, the function <code>f</code> operates on <code>val</code>
and returns a result still wrapped in the <code>SomeMonad</code> type
constructor. We can call this new value <code>SomeMonad newVal</code>.
Since it is still wrapped in the monadic context,
<code>SomeMonad newVal</code> can thus be passed through the bind
operation into the function <code>g</code>.</p>
<div class="sourceCode" id="cb255"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a>((<span class="dt">SomeMonad</span> val) <span class="op">&gt;&gt;=</span> f) <span class="op">&gt;&gt;=</span> g ≡ (<span class="dt">SomeMonad</span> val) <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> f x <span class="op">&gt;&gt;=</span> g)</span></code></pre></div>
<p>Monad law summary: Law 1 and 2 are identity laws (left and right
identity respectively) and law 3 is the associativity law. Together they
ensure that Monads can be composed and ‘do the right thing’.</p>
<p>See:</p>
<ul>
<li><a href="http://wiki.haskell.org/Monad_laws">Monad Laws</a></li>
</ul>
<h2 id="do-notation">Do Notation</h2>
<p>Monadic syntax in Haskell is written in a sugared form, known as
<code>do</code> notation. The advantages of this special syntax are that
it is easier to write and often easier to read, and it is entirely
equivalent to simply applying the monad operations. The desugaring is
defined recursively by the rules:</p>
<div class="sourceCode" id="cb256"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> { a <span class="ot">&lt;-</span> f ; m } ≡ f <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> <span class="kw">do</span> { m }  <span class="co">-- bind &#39;f&#39; to a, proceed to desugar</span></span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true" tabindex="-1"></a>                                          <span class="co">-- &#39;m&#39;</span></span>
<span id="cb256-3"><a href="#cb256-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-4"><a href="#cb256-4" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> { f ; m } ≡ f <span class="op">&gt;&gt;</span> <span class="kw">do</span> { m }              <span class="co">-- evaluate &#39;f&#39;, then proceed to</span></span>
<span id="cb256-5"><a href="#cb256-5" aria-hidden="true" tabindex="-1"></a>                                          <span class="co">-- desugar  m</span></span>
<span id="cb256-6"><a href="#cb256-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-7"><a href="#cb256-7" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> { m } ≡ m</span></code></pre></div>
<p>Thus, through the application of the desugaring rules, the following
expressions are equivalent:</p>
<div class="sourceCode" id="cb257"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb257-1"><a href="#cb257-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span></span>
<span id="cb257-2"><a href="#cb257-2" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> f                               <span class="co">-- f, g, and h are bound to the names a,</span></span>
<span id="cb257-3"><a href="#cb257-3" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> g                               <span class="co">-- b, and c. These names are then passed</span></span>
<span id="cb257-4"><a href="#cb257-4" aria-hidden="true" tabindex="-1"></a>  c <span class="ot">&lt;-</span> h                               <span class="co">-- to &#39;return&#39; to ensure that all values</span></span>
<span id="cb257-5"><a href="#cb257-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (a, b, c)                     <span class="co">-- are wrapped in the appropriate monadic</span></span>
<span id="cb257-6"><a href="#cb257-6" aria-hidden="true" tabindex="-1"></a>                                       <span class="co">-- context</span></span>
<span id="cb257-7"><a href="#cb257-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-8"><a href="#cb257-8" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> {                                   <span class="co">-- N.B. &#39;{}&#39;  and &#39;;&#39; characters are</span></span>
<span id="cb257-9"><a href="#cb257-9" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> f;                              <span class="co">--  rarely used in do-notation</span></span>
<span id="cb257-10"><a href="#cb257-10" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> g;</span>
<span id="cb257-11"><a href="#cb257-11" aria-hidden="true" tabindex="-1"></a>  c <span class="ot">&lt;-</span> h;</span>
<span id="cb257-12"><a href="#cb257-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (a, b, c)</span>
<span id="cb257-13"><a href="#cb257-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb257-14"><a href="#cb257-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb257-15"><a href="#cb257-15" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span></span>
<span id="cb257-16"><a href="#cb257-16" aria-hidden="true" tabindex="-1"></a>  g <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span></span>
<span id="cb257-17"><a href="#cb257-17" aria-hidden="true" tabindex="-1"></a>    h <span class="op">&gt;&gt;=</span> \c <span class="ot">-&gt;</span></span>
<span id="cb257-18"><a href="#cb257-18" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> (a, b, c)</span></code></pre></div>
<p>If one were to write the bind operator as an uncurried function
(which is not how Haskell uses it) the same desugaring might look
something like the following chain of nested binds with lambdas.</p>
<div class="sourceCode" id="cb258"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a>bindMonad(f, lambda a<span class="op">:</span></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a>  bindMonad(g, lambda b<span class="op">:</span></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true" tabindex="-1"></a>    bindMonad(h, lambda c<span class="op">:</span></span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true" tabindex="-1"></a>      returnMonad (a,b,c))))</span></code></pre></div>
<p>In the do-notation, the <a href="#laws">monad laws</a> from above are
equivalently written:</p>
<p><strong>Law 1</strong></p>
<div class="sourceCode" id="cb259"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb259-1"><a href="#cb259-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> y <span class="ot">&lt;-</span> <span class="fu">return</span> x</span>
<span id="cb259-2"><a href="#cb259-2" aria-hidden="true" tabindex="-1"></a>     f y</span>
<span id="cb259-3"><a href="#cb259-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb259-4"><a href="#cb259-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="kw">do</span> f x</span></code></pre></div>
<p><strong>Law 2</strong></p>
<div class="sourceCode" id="cb260"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> x <span class="ot">&lt;-</span> m</span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a>     <span class="fu">return</span> x</span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="kw">do</span> m</span></code></pre></div>
<p><strong>Law 3</strong></p>
<div class="sourceCode" id="cb261"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb261-1"><a href="#cb261-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> b <span class="ot">&lt;-</span> <span class="kw">do</span> a <span class="ot">&lt;-</span> m</span>
<span id="cb261-2"><a href="#cb261-2" aria-hidden="true" tabindex="-1"></a>             f a</span>
<span id="cb261-3"><a href="#cb261-3" aria-hidden="true" tabindex="-1"></a>     g b</span>
<span id="cb261-4"><a href="#cb261-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-5"><a href="#cb261-5" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="kw">do</span> a <span class="ot">&lt;-</span> m</span>
<span id="cb261-6"><a href="#cb261-6" aria-hidden="true" tabindex="-1"></a>     b <span class="ot">&lt;-</span> f a</span>
<span id="cb261-7"><a href="#cb261-7" aria-hidden="true" tabindex="-1"></a>     g b</span>
<span id="cb261-8"><a href="#cb261-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb261-9"><a href="#cb261-9" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="kw">do</span> a <span class="ot">&lt;-</span> m</span>
<span id="cb261-10"><a href="#cb261-10" aria-hidden="true" tabindex="-1"></a>     <span class="kw">do</span> b <span class="ot">&lt;-</span> f a</span>
<span id="cb261-11"><a href="#cb261-11" aria-hidden="true" tabindex="-1"></a>        g b</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14">Haskell
2010: Do Expressions</a></li>
</ul>
<h2 id="maybe-monad">Maybe Monad</h2>
<p>The <em>Maybe</em> monad is the simplest first example of a monad
instance. The Maybe monad models a computation which may fail to yield a
value at any point during computation.</p>
<p>The Maybe type has two value constructors. The first,
<code>Just</code>, is a unary constructor representing a successful
computation, while the second, <code>Nothing</code>, is a nullary
constructor that represents failure.</p>
<div class="sourceCode" id="cb262"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre></div>
<p>The monad instance describes the implementation of
<code>(&gt;&gt;=)</code> for <code>Maybe</code> by pattern matching on
the possible inputs that could be passed to the bind operation (i.e.,
<code>Nothing</code> or <code>Just x</code>). The instance declaration
also provides an implementation of <code>return</code>, which in this
case is simply <code>Just</code>.</p>
<div class="sourceCode" id="cb263"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb263-1"><a href="#cb263-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb263-2"><a href="#cb263-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Just</span> x) <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> k x            <span class="co">-- &#39;k&#39; is a function with type  (a -&gt; Maybe b)</span></span>
<span id="cb263-3"><a href="#cb263-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span>  <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb263-4"><a href="#cb263-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb263-5"><a href="#cb263-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="ot">=</span> <span class="dt">Just</span>                   <span class="co">-- Just&#39;s type signature is (a -&gt; Maybe a), in</span></span>
<span id="cb263-6"><a href="#cb263-6" aria-hidden="true" tabindex="-1"></a>                                  <span class="co">-- other words, extremely similar to the</span></span>
<span id="cb263-7"><a href="#cb263-7" aria-hidden="true" tabindex="-1"></a>                                  <span class="co">-- type of &#39;return&#39; in the typeclass</span></span>
<span id="cb263-8"><a href="#cb263-8" aria-hidden="true" tabindex="-1"></a>                                  <span class="co">-- declaration above.</span></span></code></pre></div>
<p>The following code shows some simple operations to do within the
Maybe monad.</p>
<div class="sourceCode" id="cb264"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Just</span> <span class="dv">3</span>) <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> <span class="fu">return</span> (x <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Just 4</span></span></code></pre></div>
<p>In the above example, the value <code>Just 3</code> is passed via
<code>(&gt;&gt;=)</code> to the lambda function
<code>\x -&gt; return (x + 1)</code>. <code>x</code> refers to the
<code>Int</code> portion of <code>Just 3</code>, and we can use
<code>x</code> in the second half of the lambda expression,
<code>return (x + 1)</code> which evaluates to <code>Just 4</code>,
indicating a successful computation.</p>
<p>In the second example, the value <code>Nothing</code> is passed via
<code>(&gt;&gt;=)</code> to the same lambda function as in the previous
example. However, according to the <code>Maybe</code> Monad instance,
whenever <code>Nothing</code> is bound to a function, the expression’s
result will be <code>Nothing</code>.</p>
<div class="sourceCode" id="cb265"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span> <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> <span class="fu">return</span> (x <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Nothing</span></span></code></pre></div>
<p>Here, <code>return</code> is applied to <code>4</code> and results in
<code>Just 4</code>.</p>
<div class="sourceCode" id="cb266"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb266-1"><a href="#cb266-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb266-2"><a href="#cb266-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Just 4</span></span></code></pre></div>
<p>The next code examples show the use of <code>do</code> notation
within the Maybe monad to do addition that might fail. Desugared
examples are provided as well.</p>
<div class="sourceCode" id="cb267"
data-include="src/02-monads/maybe.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> <span class="dt">Just</span> <span class="dv">3</span> <span class="co">-- Bind 3 to name a</span></span>
<span id="cb267-4"><a href="#cb267-4" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> <span class="dt">Just</span> <span class="dv">4</span> <span class="co">-- Bind 4 to name b</span></span>
<span id="cb267-5"><a href="#cb267-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> a <span class="op">+</span> b <span class="co">-- Evaluate (a + b), then use &#39;return&#39; to ensure</span></span>
<span id="cb267-6"><a href="#cb267-6" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- the result is in the Maybe monad in order to</span></span>
<span id="cb267-7"><a href="#cb267-7" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- satisfy the type signature</span></span>
<span id="cb267-8"><a href="#cb267-8" aria-hidden="true" tabindex="-1"></a>      <span class="co">-- Just 7</span></span>
<span id="cb267-9"><a href="#cb267-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-10"><a href="#cb267-10" aria-hidden="true" tabindex="-1"></a><span class="ot">desugared1 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb267-11"><a href="#cb267-11" aria-hidden="true" tabindex="-1"></a>desugared1 <span class="ot">=</span> <span class="dt">Just</span> <span class="dv">3</span> <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> <span class="co">-- This example is the desugared</span></span>
<span id="cb267-12"><a href="#cb267-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> <span class="dv">4</span> <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span> <span class="co">-- equivalent to example1</span></span>
<span id="cb267-13"><a href="#cb267-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> a <span class="op">+</span> b</span>
<span id="cb267-14"><a href="#cb267-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-15"><a href="#cb267-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- Just 7</span></span>
<span id="cb267-16"><a href="#cb267-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-17"><a href="#cb267-17" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb267-18"><a href="#cb267-18" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb267-19"><a href="#cb267-19" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> <span class="dt">Just</span> <span class="dv">3</span> <span class="co">-- Bind 3 to name a</span></span>
<span id="cb267-20"><a href="#cb267-20" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> <span class="dt">Nothing</span> <span class="co">-- Bind Nothing to name b</span></span>
<span id="cb267-21"><a href="#cb267-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> a <span class="op">+</span> b</span>
<span id="cb267-22"><a href="#cb267-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-23"><a href="#cb267-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- Nothing</span></span>
<span id="cb267-24"><a href="#cb267-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-25"><a href="#cb267-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- This result might be somewhat surprising, since</span></span>
<span id="cb267-26"><a href="#cb267-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- addition within the Maybe monad can actually</span></span>
<span id="cb267-27"><a href="#cb267-27" aria-hidden="true" tabindex="-1"></a><span class="co">-- return &#39;Nothing&#39;. This result occurs because one</span></span>
<span id="cb267-28"><a href="#cb267-28" aria-hidden="true" tabindex="-1"></a><span class="co">-- of the values, Nothing, indicates computational</span></span>
<span id="cb267-29"><a href="#cb267-29" aria-hidden="true" tabindex="-1"></a><span class="co">-- failure. Since the computation failed at one</span></span>
<span id="cb267-30"><a href="#cb267-30" aria-hidden="true" tabindex="-1"></a><span class="co">-- step within the process, the whole computation</span></span>
<span id="cb267-31"><a href="#cb267-31" aria-hidden="true" tabindex="-1"></a><span class="co">-- fails, leaving us with &#39;Nothing&#39; as the final</span></span>
<span id="cb267-32"><a href="#cb267-32" aria-hidden="true" tabindex="-1"></a><span class="co">-- result.</span></span>
<span id="cb267-33"><a href="#cb267-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb267-34"><a href="#cb267-34" aria-hidden="true" tabindex="-1"></a><span class="ot">desugared2 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb267-35"><a href="#cb267-35" aria-hidden="true" tabindex="-1"></a>desugared2 <span class="ot">=</span> <span class="dt">Just</span> <span class="dv">3</span> <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span> <span class="co">-- This example is the desugared</span></span>
<span id="cb267-36"><a href="#cb267-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span> <span class="co">-- equivalent to example2</span></span>
<span id="cb267-37"><a href="#cb267-37" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> a <span class="op">+</span> b</span>
<span id="cb267-38"><a href="#cb267-38" aria-hidden="true" tabindex="-1"></a><span class="co">-- Nothing</span></span></code></pre></div>
<h2 id="list-monad">List Monad</h2>
<p>The <em>List</em> monad is the second simplest example of a monad
instance. As always, this monad implements both <code>(&gt;&gt;=)</code>
and <code>return</code>.</p>
<div class="sourceCode" id="cb268"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span></span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a>  m <span class="op">&gt;&gt;=</span> f   <span class="ot">=</span>  <span class="fu">concat</span> (<span class="fu">map</span> f m)          <span class="co">-- &#39;m&#39; is a list</span></span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> x  <span class="ot">=</span>  [x]</span></code></pre></div>
<p>The definition of bind says that when the list <code>m</code> is
bound to a function <code>f</code>, the result is a concatenation of
<code>map f</code> over the list <code>m</code>. The <code>return</code>
method simply takes a single value <code>x</code> and injects into a
singleton list <code>[x]</code>.</p>
<p>In order to demonstrate the <code>List</code> monad’s methods, we
will define two values: <code>m</code> and <code>f</code>.
<code>m</code> is a simple list, while <code>f</code> is a function that
takes a single <code>Int</code> and returns a two element list
<code>[1, 0]</code>.</p>
<div class="sourceCode" id="cb269"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a><span class="ot">m ::</span> [<span class="dt">Int</span>]</span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true" tabindex="-1"></a>m <span class="ot">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>]</span>
<span id="cb269-3"><a href="#cb269-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb269-4"><a href="#cb269-4" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb269-5"><a href="#cb269-5" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> \x <span class="ot">-&gt;</span> [<span class="dv">1</span>,<span class="dv">0</span>]               <span class="co">-- &#39;f&#39; always returns [1, 0]</span></span></code></pre></div>
<p>When applied to bind, evaluation proceeds as follows:</p>
<div class="sourceCode" id="cb270"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;=</span> f</span>
<span id="cb270-2"><a href="#cb270-2" aria-hidden="true" tabindex="-1"></a><span class="op">==&gt;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>] <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> [<span class="dv">1</span>,<span class="dv">0</span>]</span>
<span id="cb270-3"><a href="#cb270-3" aria-hidden="true" tabindex="-1"></a><span class="op">==&gt;</span> <span class="fu">concat</span> (<span class="fu">map</span> (\x <span class="ot">-&gt;</span> [<span class="dv">1</span>,<span class="dv">0</span>]) [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>])</span>
<span id="cb270-4"><a href="#cb270-4" aria-hidden="true" tabindex="-1"></a><span class="op">==&gt;</span> <span class="fu">concat</span> ([[<span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">0</span>],[<span class="dv">1</span>,<span class="dv">0</span>]])</span>
<span id="cb270-5"><a href="#cb270-5" aria-hidden="true" tabindex="-1"></a><span class="op">==&gt;</span> [<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">0</span>]</span></code></pre></div>
<p>The list comprehension syntax in Haskell can be implemented in terms
of the list monad. List comprehensions can be considered syntactic sugar
for more obviously monadic implementations. Examples <code>a</code> and
<code>b</code> illustrate these use cases.</p>
<p>The first example (<code>a</code>) illustrates how to write a list
comprehension. Although the syntax looks strange at first, there are
elements of it that may look familiar. For instance, the use of
<code>&lt;-</code> is just like bind in a <code>do</code> notation: It
binds an element of a list to a name. However, one major difference is
apparent: <code>a</code> seems to lack a call to <code>return</code>.
Not to worry, though, the <code>[]</code> fills this role. This syntax
can be easily desugared by the compiler to an explicit invocation of
<code>return</code>. Furthermore, it serves to remind the user that the
computation takes place in the List monad.</p>
<div class="sourceCode" id="cb271"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> [</span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true" tabindex="-1"></a>      f x y <span class="op">|</span>        <span class="co">-- Corresponds to &#39;f x y&#39; in example b</span></span>
<span id="cb271-3"><a href="#cb271-3" aria-hidden="true" tabindex="-1"></a>      x <span class="ot">&lt;-</span> xs,</span>
<span id="cb271-4"><a href="#cb271-4" aria-hidden="true" tabindex="-1"></a>      y <span class="ot">&lt;-</span> ys,</span>
<span id="cb271-5"><a href="#cb271-5" aria-hidden="true" tabindex="-1"></a>      x <span class="op">==</span> y         <span class="co">-- Corresponds to &#39;guard $ x == y&#39; in example b</span></span>
<span id="cb271-6"><a href="#cb271-6" aria-hidden="true" tabindex="-1"></a>    ]</span></code></pre></div>
<p>The second example (<code>b</code>) shows the list comprehension
above rewritten with <code>do</code> notation:</p>
<div class="sourceCode" id="cb272"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Identical to `a`</span></span>
<span id="cb272-2"><a href="#cb272-2" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb272-3"><a href="#cb272-3" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> xs</span>
<span id="cb272-4"><a href="#cb272-4" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> ys</span>
<span id="cb272-5"><a href="#cb272-5" aria-hidden="true" tabindex="-1"></a>  guard <span class="op">$</span> x <span class="op">==</span> y     <span class="co">-- Corresponds to &#39;x == y&#39; in example a</span></span>
<span id="cb272-6"><a href="#cb272-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> f x y     <span class="co">-- Corresponds to the &#39;[]&#39; and &#39;f x y&#39; in example a</span></span></code></pre></div>
<p>The final examples are further illustrations of the List monad. The
functions below each return a list of 3-tuples which contain the
possible combinations of the three lists that get bound the names
<code>a</code>, <code>b</code>, and <code>c</code>. N.B.: Only values in
the list bound to <code>a</code> can be used in <code>a</code> position
of the tuple; the same fact holds true for the lists bound to
<code>b</code> and <code>c</code>.</p>
<div class="sourceCode" id="cb273"
data-include="src/02-monads/list.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> [<span class="dv">1</span>,<span class="dv">2</span>]</span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> [<span class="dv">10</span>,<span class="dv">20</span>]</span>
<span id="cb273-5"><a href="#cb273-5" aria-hidden="true" tabindex="-1"></a>  c <span class="ot">&lt;-</span> [<span class="dv">100</span>,<span class="dv">200</span>]</span>
<span id="cb273-6"><a href="#cb273-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (a,b,c)</span>
<span id="cb273-7"><a href="#cb273-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]</span></span>
<span id="cb273-8"><a href="#cb273-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-9"><a href="#cb273-9" aria-hidden="true" tabindex="-1"></a><span class="ot">desugared ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb273-10"><a href="#cb273-10" aria-hidden="true" tabindex="-1"></a>desugared <span class="ot">=</span> [<span class="dv">1</span>, <span class="dv">2</span>] <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span></span>
<span id="cb273-11"><a href="#cb273-11" aria-hidden="true" tabindex="-1"></a>              [<span class="dv">10</span>, <span class="dv">20</span>] <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span></span>
<span id="cb273-12"><a href="#cb273-12" aria-hidden="true" tabindex="-1"></a>                [<span class="dv">100</span>, <span class="dv">200</span>] <span class="op">&gt;&gt;=</span> \c <span class="ot">-&gt;</span></span>
<span id="cb273-13"><a href="#cb273-13" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">return</span> (a, b, c)</span>
<span id="cb273-14"><a href="#cb273-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]</span></span></code></pre></div>
<h2 id="io-monad">IO Monad</h2>
<p>Perhaps the most (in)famous example in Haskell of a type that forms a
monad is <code>IO</code>. A value of type <code>IO a</code> is a
computation which, when performed, does some I/O before returning a
value of type <code>a</code>. These computations are called <a
href="https://wiki.haskell.org/Introduction_to_Haskell_IO/Actions">actions</a>.
IO actions executed in <code>main</code> are the means by which a
program can operate on or access information from the external world. IO
actions allow the program to do many things, including, but not limited
to:</p>
<ul>
<li>Print a <code>String</code> to the terminal</li>
<li>Read and parse input from the terminal</li>
<li>Read from or write to a file on the system</li>
<li>Establish an <code>ssh</code> connection to a remote computer</li>
<li>Take input from a radio antenna for signal processing</li>
<li>Launch the missiles.</li>
</ul>
<p>Conceptualizing I/O as a monad enables the developer to access
information from outside the program, but also to use pure functions to
operate on that information as data. The following examples will show
how we can use IO actions and <code>IO</code> values to receive input
from stdin and print to stdout.</p>
<p>Perhaps the most immediately useful function for doing I/O in Haskell
is <code>putStrLn</code>. This function takes a <code>String</code> and
returns an <code>IO ()</code>. Calling it from <code>main</code> will
result in the <code>String</code> being printed to stdout followed by a
newline character.</p>
<div class="sourceCode" id="cb274"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb274-1"><a href="#cb274-1" aria-hidden="true" tabindex="-1"></a><span class="fu">putStrLn</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>Here is some code that prints a couple of lines to the terminal. The
first invocation of <code>putStrLn</code> is executed, causing the
<code>String</code> to be printed to stdout. The result is bound to a
lambda expression that discards its argument, and then the next
<code>putStrLn</code> is executed.</p>
<div class="sourceCode" id="cb275"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;Vesihiisi sihisi hississäään.&quot;</span> <span class="op">&gt;&gt;=</span></span>
<span id="cb275-3"><a href="#cb275-3" aria-hidden="true" tabindex="-1"></a>         \_ <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;Or in English: &#39;The water devil was hissing in her elevator&#39;.&quot;</span></span>
<span id="cb275-4"><a href="#cb275-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-5"><a href="#cb275-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Sugared code, written with do notation</span></span>
<span id="cb275-6"><a href="#cb275-6" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb275-7"><a href="#cb275-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span> <span class="fu">putStrLn</span> <span class="st">&quot;Vesihiisi sihisi hississäään.&quot;</span></span>
<span id="cb275-8"><a href="#cb275-8" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;Or in English: &#39;The water devil was hissing in her elevator&#39;.&quot;</span></span></code></pre></div>
<p>Another useful function is <code>getLine</code> which has type
<code>IO String</code>. This function gets a line of input from stdin.
The developer can then bind this line to a name in order to operate on
the value within the program.</p>
<div class="sourceCode" id="cb276"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb276-1"><a href="#cb276-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getLine</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">String</span></span></code></pre></div>
<p>The code below demonstrates a simple combination of these two
functions as well as desugaring <code>IO</code> code. First,
<code>putStrLn</code> prints a <code>String</code> to stdout to ask the
user to supply their name, with the result being bound to a lambda that
discards it argument. Then, <code>getLine</code> is executed, supplying
a prompt to the user for entering their name. Next, the resultant
<code>IO String</code> is bound to <code>name</code> and passed to
<code>putStrLn</code>. Finally, the program prints the name to the
terminal.</p>
<div class="sourceCode" id="cb277"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span> <span class="fu">putStrLn</span> <span class="st">&quot;What is your name: &quot;</span></span>
<span id="cb277-3"><a href="#cb277-3" aria-hidden="true" tabindex="-1"></a>          name <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb277-4"><a href="#cb277-4" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> name</span></code></pre></div>
<p>The next code block is the <em>desugared equivalent</em> of the
previous example where the uses of <code>(&gt;&gt;=)</code> are made
explicit.</p>
<div class="sourceCode" id="cb278"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb278-1"><a href="#cb278-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb278-2"><a href="#cb278-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;What is your name:&quot;</span> <span class="op">&gt;&gt;=</span></span>
<span id="cb278-3"><a href="#cb278-3" aria-hidden="true" tabindex="-1"></a>       \_    <span class="ot">-&gt;</span> <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span></span>
<span id="cb278-4"><a href="#cb278-4" aria-hidden="true" tabindex="-1"></a>       \name <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> name</span></code></pre></div>
<p>Our final example executes in the same way as the previous two
examples. This example, though, uses the special <code>(&gt;&gt;)</code>
<a href="#monadic-methods">operator</a> to take the place of binding a
result to the lambda that discards its argument.</p>
<div class="sourceCode" id="cb279"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;What is your name: &quot;</span> <span class="op">&gt;&gt;</span> (<span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> (\name <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> name))</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="http://www.haskell.org/onlinereport/haskell2010/haskellch7.html">Haskell
2010: Basic/Input Output</a></li>
</ul>
<h2 id="whats-the-point">What’s the point?</h2>
<p>Although it is difficult, if not impossible, to touch, see, or
otherwise physically interact with a monad, this construct has some very
interesting implications for programmers. For instance, consider the
non-intuitive fact that we now have a uniform interface for talking
about three very different, but foundational ideas for programming:
<em>Failure</em>, <em>Collections</em> and <em>Effects</em>.</p>
<p>Let’s write down a new function called <code>sequence</code> which
folds a function <code>mcons</code> over a list of monadic computations.
We can think of <code>mcons</code> as analogous to the list constructor
(i.e. <code>(a : b : [])</code>) except it pulls the two list elements
out of two monadic values (<code>p</code>,<code>q</code>) by means of
bind. The bound values are then joined with the list constructor
<code>:</code>, before finally being rewrapped in the appropriate
monadic context with <code>return</code>.</p>
<div class="sourceCode" id="cb280"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb280-1"><a href="#cb280-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span><span class="ot"> ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> [m a] <span class="ot">-&gt;</span> m [a]</span>
<span id="cb280-2"><a href="#cb280-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span> <span class="ot">=</span> <span class="fu">foldr</span> mcons (<span class="fu">return</span> [])</span>
<span id="cb280-3"><a href="#cb280-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb280-4"><a href="#cb280-4" aria-hidden="true" tabindex="-1"></a><span class="ot">mcons ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m t <span class="ot">-&gt;</span> m [t] <span class="ot">-&gt;</span> m [t]</span>
<span id="cb280-5"><a href="#cb280-5" aria-hidden="true" tabindex="-1"></a>mcons p q <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb280-6"><a href="#cb280-6" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> p          <span class="co">-- &#39;x&#39; refers to a singleton value</span></span>
<span id="cb280-7"><a href="#cb280-7" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> q          <span class="co">-- &#39;y&#39; refers to a list. Because of this fact, &#39;x&#39; can be</span></span>
<span id="cb280-8"><a href="#cb280-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (x<span class="op">:</span>y)    <span class="co">--  prepended to it</span></span></code></pre></div>
<p>What does this function mean in terms of each of the monads discussed
above?</p>
<p><strong>Maybe</strong></p>
<p>For the Maybe monad, sequencing a list of values within the
<code>Maybe</code> <a href="#maybe">context</a> allows us to collect the
results of a series of computations which can possibly fail. However,
<code>sequence</code> yields the aggregated values only if each
computation succeeds. In other words, if even one of the
<code>Maybe</code> values in the initial list passed to
<code>sequence</code>is a <code>Nothing</code>, the result of evaluating
<code>sequence</code> for the whole list will also be
<code>Nothing</code>.</p>
<div class="sourceCode" id="cb281"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span><span class="ot"> ::</span> [<span class="dt">Maybe</span> a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [a]</span></code></pre></div>
<div class="sourceCode" id="cb282"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span> [<span class="dt">Just</span> <span class="dv">3</span>, <span class="dt">Just</span> <span class="dv">4</span>]</span>
<span id="cb282-2"><a href="#cb282-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Just [3,4]</span></span>
<span id="cb282-3"><a href="#cb282-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb282-4"><a href="#cb282-4" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span> [<span class="dt">Just</span> <span class="dv">3</span>, <span class="dt">Just</span> <span class="dv">4</span>, <span class="dt">Nothing</span>]     <span class="co">-- Since one of the results is Nothing,</span></span>
<span id="cb282-5"><a href="#cb282-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Nothing                             -- the whole computation fails</span></span></code></pre></div>
<p><strong>List</strong></p>
<p>The bind operation for the <a href="#list">list monad</a> forms the
pairwise list of elements from the two operands. Thus, folding the binds
contained in <code>mcons</code> over a list of lists with
<code>sequence</code> implements the general Cartesian product for an
arbitrary number of lists.</p>
<div class="sourceCode" id="cb283"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span><span class="ot"> ::</span> [[a]] <span class="ot">-&gt;</span> [[a]]</span></code></pre></div>
<div class="sourceCode" id="cb284"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span> [[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">10</span>,<span class="dv">20</span>,<span class="dv">30</span>]]</span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- [[1,10],[1,20],[1,30],[2,10],[2,20],[2,30],[3,10],[3,20],[3,30]]</span></span></code></pre></div>
<p><strong>IO</strong></p>
<p>Applying <code>sequence</code> within the <a href="#io">IO
context</a> results in still a different result. The function takes a
list of IO actions, performs them sequentially, and then gives back the
list of resulting values in the order sequenced.</p>
<div class="sourceCode" id="cb285"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span><span class="ot"> ::</span> [<span class="dt">IO</span> a] <span class="ot">-&gt;</span> <span class="dt">IO</span> [a]</span></code></pre></div>
<div class="sourceCode" id="cb286"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span> [<span class="fu">getLine</span>, <span class="fu">getLine</span>, <span class="fu">getLine</span>]</span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- a                                  -- a, b, and 9 are the inputs given by the</span></span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- b                                  -- user at the prompt</span></span>
<span id="cb286-4"><a href="#cb286-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- 9</span></span>
<span id="cb286-5"><a href="#cb286-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- [&quot;a&quot;, &quot;b&quot;, &quot;9&quot;]                    -- All inputs are returned in a list as</span></span>
<span id="cb286-6"><a href="#cb286-6" aria-hidden="true" tabindex="-1"></a>                                      <span class="co">-- an IO [String].</span></span></code></pre></div>
<p>So there we have it, three fundamental concepts of computation that
are normally defined independently of each other actually all share this
similar structure. This unifying pattern can be abstracted out and
reused to build higher abstractions that work for all current and future
implementations. If you want a motivating reason for understanding
monads, this is it! These insights are the essence of what I wish I knew
about monads looking back.</p>
<p>See:</p>
<ul>
<li><a
href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Monad.html#g:4">Control.Monad</a></li>
</ul>
<h2 id="reader-monad">Reader Monad</h2>
<p>The reader monad lets us access shared immutable state within a
monadic context.</p>
<div class="sourceCode" id="cb287"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ask ::</span> <span class="dt">Reader</span> r r</span>
<span id="cb287-2"><a href="#cb287-2" aria-hidden="true" tabindex="-1"></a><span class="ot">asks ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a</span>
<span id="cb287-3"><a href="#cb287-3" aria-hidden="true" tabindex="-1"></a><span class="ot">local ::</span> (r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a</span>
<span id="cb287-4"><a href="#cb287-4" aria-hidden="true" tabindex="-1"></a><span class="ot">runReader ::</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a</span></code></pre></div>
<div class="sourceCode" id="cb288"
data-include="src/02-monads/reader.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Reader</span></span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-3"><a href="#cb288-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MyContext</span> <span class="ot">=</span> <span class="dt">MyContext</span></span>
<span id="cb288-4"><a href="#cb288-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> foo ::</span> <span class="dt">String</span></span>
<span id="cb288-5"><a href="#cb288-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> bar ::</span> <span class="dt">Int</span></span>
<span id="cb288-6"><a href="#cb288-6" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb288-7"><a href="#cb288-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-8"><a href="#cb288-8" aria-hidden="true" tabindex="-1"></a><span class="ot">computation ::</span> <span class="dt">Reader</span> <span class="dt">MyContext</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)</span>
<span id="cb288-9"><a href="#cb288-9" aria-hidden="true" tabindex="-1"></a>computation <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb288-10"><a href="#cb288-10" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> asks bar</span>
<span id="cb288-11"><a href="#cb288-11" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> asks foo</span>
<span id="cb288-12"><a href="#cb288-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> n <span class="op">&gt;</span> <span class="dv">0</span></span>
<span id="cb288-13"><a href="#cb288-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="fu">return</span> (<span class="dt">Just</span> x)</span>
<span id="cb288-14"><a href="#cb288-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="fu">return</span> <span class="dt">Nothing</span></span>
<span id="cb288-15"><a href="#cb288-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-16"><a href="#cb288-16" aria-hidden="true" tabindex="-1"></a><span class="ot">ex1 ::</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb288-17"><a href="#cb288-17" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> runReader computation <span class="op">$</span> <span class="dt">MyContext</span> <span class="st">&quot;hello&quot;</span> <span class="dv">1</span></span>
<span id="cb288-18"><a href="#cb288-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-19"><a href="#cb288-19" aria-hidden="true" tabindex="-1"></a><span class="ot">ex2 ::</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb288-20"><a href="#cb288-20" aria-hidden="true" tabindex="-1"></a>ex2 <span class="ot">=</span> runReader computation <span class="op">$</span> <span class="dt">MyContext</span> <span class="st">&quot;haskell&quot;</span> <span class="dv">0</span></span></code></pre></div>
<p>A simple implementation of the Reader monad:</p>
<div class="sourceCode" id="cb289"
data-include="src/02-monads/reader_impl.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb289-1"><a href="#cb289-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Reader</span> r a <span class="ot">=</span> <span class="dt">Reader</span> {<span class="ot"> runReader ::</span> r <span class="ot">-&gt;</span> a }</span>
<span id="cb289-2"><a href="#cb289-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-3"><a href="#cb289-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> r) <span class="kw">where</span></span>
<span id="cb289-4"><a href="#cb289-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Reader</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> a</span>
<span id="cb289-5"><a href="#cb289-5" aria-hidden="true" tabindex="-1"></a>  m <span class="op">&gt;&gt;=</span> k  <span class="ot">=</span> <span class="dt">Reader</span> <span class="op">$</span> \r <span class="ot">-&gt;</span> runReader (k (runReader m r)) r</span>
<span id="cb289-6"><a href="#cb289-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-7"><a href="#cb289-7" aria-hidden="true" tabindex="-1"></a><span class="ot">ask ::</span> <span class="dt">Reader</span> a a</span>
<span id="cb289-8"><a href="#cb289-8" aria-hidden="true" tabindex="-1"></a>ask <span class="ot">=</span> <span class="dt">Reader</span> <span class="fu">id</span></span>
<span id="cb289-9"><a href="#cb289-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-10"><a href="#cb289-10" aria-hidden="true" tabindex="-1"></a><span class="ot">asks ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a</span>
<span id="cb289-11"><a href="#cb289-11" aria-hidden="true" tabindex="-1"></a>asks f <span class="ot">=</span> <span class="dt">Reader</span> f</span>
<span id="cb289-12"><a href="#cb289-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb289-13"><a href="#cb289-13" aria-hidden="true" tabindex="-1"></a><span class="ot">local ::</span> (r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> <span class="dt">Reader</span> r a</span>
<span id="cb289-14"><a href="#cb289-14" aria-hidden="true" tabindex="-1"></a>local f m <span class="ot">=</span> <span class="dt">Reader</span> <span class="op">$</span> runReader m <span class="op">.</span> f</span></code></pre></div>
<h2 id="writer-monad">Writer Monad</h2>
<p>The writer monad lets us emit a lazy stream of values from within a
monadic context.</p>
<div class="sourceCode" id="cb290"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tell ::</span> w <span class="ot">-&gt;</span> <span class="dt">Writer</span> w ()</span>
<span id="cb290-2"><a href="#cb290-2" aria-hidden="true" tabindex="-1"></a><span class="ot">execWriter ::</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> w</span>
<span id="cb290-3"><a href="#cb290-3" aria-hidden="true" tabindex="-1"></a><span class="ot">runWriter ::</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> (a, w)</span></code></pre></div>
<div class="sourceCode" id="cb291"
data-include="src/02-monads/writer.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb291-1"><a href="#cb291-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Writer</span></span>
<span id="cb291-2"><a href="#cb291-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-3"><a href="#cb291-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MyWriter</span> <span class="ot">=</span> <span class="dt">Writer</span> [<span class="dt">Int</span>] <span class="dt">String</span></span>
<span id="cb291-4"><a href="#cb291-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-5"><a href="#cb291-5" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">MyWriter</span></span>
<span id="cb291-6"><a href="#cb291-6" aria-hidden="true" tabindex="-1"></a>example  <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb291-7"><a href="#cb291-7" aria-hidden="true" tabindex="-1"></a>  tell [<span class="dv">1</span><span class="op">..</span><span class="dv">3</span>]</span>
<span id="cb291-8"><a href="#cb291-8" aria-hidden="true" tabindex="-1"></a>  tell [<span class="dv">3</span><span class="op">..</span><span class="dv">5</span>]</span>
<span id="cb291-9"><a href="#cb291-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb291-10"><a href="#cb291-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb291-11"><a href="#cb291-11" aria-hidden="true" tabindex="-1"></a><span class="ot">output ::</span> (<span class="dt">String</span>, [<span class="dt">Int</span>])</span>
<span id="cb291-12"><a href="#cb291-12" aria-hidden="true" tabindex="-1"></a>output <span class="ot">=</span> runWriter example</span>
<span id="cb291-13"><a href="#cb291-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- (&quot;foo&quot;, [1, 2, 3, 3, 4, 5])</span></span></code></pre></div>
<p>A simple implementation of the Writer monad:</p>
<div class="sourceCode" id="cb292"
data-include="src/02-monads/writer_impl.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span></span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Writer</span> w a <span class="ot">=</span> <span class="dt">Writer</span> {<span class="ot"> runWriter ::</span> (a, w) }</span>
<span id="cb292-4"><a href="#cb292-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-5"><a href="#cb292-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> w <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Writer</span> w) <span class="kw">where</span></span>
<span id="cb292-6"><a href="#cb292-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">Writer</span> (a, <span class="fu">mempty</span>)</span>
<span id="cb292-7"><a href="#cb292-7" aria-hidden="true" tabindex="-1"></a>  m <span class="op">&gt;&gt;=</span> k  <span class="ot">=</span> <span class="dt">Writer</span> <span class="op">$</span> <span class="kw">let</span></span>
<span id="cb292-8"><a href="#cb292-8" aria-hidden="true" tabindex="-1"></a>      (a, w)  <span class="ot">=</span> runWriter m</span>
<span id="cb292-9"><a href="#cb292-9" aria-hidden="true" tabindex="-1"></a>      (b, w&#39;) <span class="ot">=</span> runWriter (k a)</span>
<span id="cb292-10"><a href="#cb292-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">in</span> (b, w <span class="ot">`mappend`</span> w&#39;)</span>
<span id="cb292-11"><a href="#cb292-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-12"><a href="#cb292-12" aria-hidden="true" tabindex="-1"></a><span class="ot">execWriter ::</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> w</span>
<span id="cb292-13"><a href="#cb292-13" aria-hidden="true" tabindex="-1"></a>execWriter m <span class="ot">=</span> <span class="fu">snd</span> (runWriter m)</span>
<span id="cb292-14"><a href="#cb292-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-15"><a href="#cb292-15" aria-hidden="true" tabindex="-1"></a><span class="ot">tell ::</span> w <span class="ot">-&gt;</span> <span class="dt">Writer</span> w ()</span>
<span id="cb292-16"><a href="#cb292-16" aria-hidden="true" tabindex="-1"></a>tell w <span class="ot">=</span> <span class="dt">Writer</span> ((), w)</span></code></pre></div>
<p>This implementation is lazy, so some care must be taken that one
actually wants to only generate a stream of thunks. Most often the lazy
writer is not suitable for use, instead implement the equivalent
structure by embedding some <a
href="https://en.wikipedia.org/wiki/Monomial">monomial</a> object inside
a StateT monad, or using the strict version.</p>
<div class="sourceCode" id="cb293"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Writer.Strict</span></span></code></pre></div>
<h2 id="state-monad">State Monad</h2>
<p>The state monad allows functions within a stateful monadic context to
access and modify shared state.</p>
<div class="sourceCode" id="cb294"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb294-1"><a href="#cb294-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runState  ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb294-2"><a href="#cb294-2" aria-hidden="true" tabindex="-1"></a><span class="ot">evalState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb294-3"><a href="#cb294-3" aria-hidden="true" tabindex="-1"></a><span class="ot">execState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</span></code></pre></div>
<div class="sourceCode" id="cb295"
data-include="src/02-monads/state.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span></span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">State</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb295-4"><a href="#cb295-4" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb295-5"><a href="#cb295-5" aria-hidden="true" tabindex="-1"></a>  put <span class="dv">3</span></span>
<span id="cb295-6"><a href="#cb295-6" aria-hidden="true" tabindex="-1"></a>  modify (<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb295-7"><a href="#cb295-7" aria-hidden="true" tabindex="-1"></a>  get</span>
<span id="cb295-8"><a href="#cb295-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb295-9"><a href="#cb295-9" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb295-10"><a href="#cb295-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> execState test <span class="dv">0</span></span></code></pre></div>
<p>The state monad is often mistakenly described as being impure, but it
is in fact entirely pure and the same effect could be achieved by
explicitly passing state. A simple implementation of the State monad
takes only a few lines:</p>
<div class="sourceCode" id="cb296"
data-include="src/02-monads/state_impl.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb296-1"><a href="#cb296-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> {<span class="ot"> runState ::</span> s <span class="ot">-&gt;</span> (a,s) }</span>
<span id="cb296-2"><a href="#cb296-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb296-3"><a href="#cb296-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb296-4"><a href="#cb296-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb296-5"><a href="#cb296-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb296-6"><a href="#cb296-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">State</span> act <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span></span>
<span id="cb296-7"><a href="#cb296-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (a, s&#39;) <span class="ot">=</span> act s</span>
<span id="cb296-8"><a href="#cb296-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> runState (k a) s&#39;</span>
<span id="cb296-9"><a href="#cb296-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb296-10"><a href="#cb296-10" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">State</span> s s</span>
<span id="cb296-11"><a href="#cb296-11" aria-hidden="true" tabindex="-1"></a>get <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (s, s)</span>
<span id="cb296-12"><a href="#cb296-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb296-13"><a href="#cb296-13" aria-hidden="true" tabindex="-1"></a><span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s ()</span>
<span id="cb296-14"><a href="#cb296-14" aria-hidden="true" tabindex="-1"></a>put s <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> ((), s)</span>
<span id="cb296-15"><a href="#cb296-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb296-16"><a href="#cb296-16" aria-hidden="true" tabindex="-1"></a><span class="ot">modify ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">State</span> s ()</span>
<span id="cb296-17"><a href="#cb296-17" aria-hidden="true" tabindex="-1"></a>modify f <span class="ot">=</span> get <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span> put (f x)</span>
<span id="cb296-18"><a href="#cb296-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb296-19"><a href="#cb296-19" aria-hidden="true" tabindex="-1"></a><span class="ot">evalState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb296-20"><a href="#cb296-20" aria-hidden="true" tabindex="-1"></a>evalState act <span class="ot">=</span> <span class="fu">fst</span> <span class="op">.</span> runState act</span>
<span id="cb296-21"><a href="#cb296-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb296-22"><a href="#cb296-22" aria-hidden="true" tabindex="-1"></a><span class="ot">execState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s</span>
<span id="cb296-23"><a href="#cb296-23" aria-hidden="true" tabindex="-1"></a>execState act <span class="ot">=</span> <span class="fu">snd</span> <span class="op">.</span> runState act</span></code></pre></div>
<h2 id="why-are-monads-confusing">Why are monads confusing?</h2>
<p>So many monad tutorials have been written that it begs the question:
what makes monads so difficult when first learning Haskell? I
hypothesize there are three aspects to why this is so:</p>
<ol type="1">
<li><em>There are several levels of indirection with
desugaring.</em></li>
</ol>
<p>A lot of the Haskell we write is radically rearranged and transformed
into an entirely new form under the hood.</p>
<p>Most monad tutorials will not manually expand out the do-sugar. This
leaves the beginner thinking that monads are a way of dropping into a
pseudo-imperative language inside of pure code and further fuels the
misconception that specific instances like IO describe monads in their
<em>full generality</em>. When in fact the IO monad is only one among
many instances.</p>
<div class="sourceCode" id="cb297"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb297-3"><a href="#cb297-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> x</span>
<span id="cb297-4"><a href="#cb297-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ()</span></code></pre></div>
<p>Being able to manually desugar is crucial to understanding.</p>
<div class="sourceCode" id="cb298"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb298-1"><a href="#cb298-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span></span>
<span id="cb298-2"><a href="#cb298-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span></span>
<span id="cb298-3"><a href="#cb298-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> x <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></span>
<span id="cb298-4"><a href="#cb298-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> ()</span></code></pre></div>
<ol start="2" type="1">
<li><em>Infix operators for higher order functions are not common in
other languages.</em></li>
</ol>
<div class="sourceCode" id="cb299"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>On the left hand side of the operator we have an <code>m a</code> and
on the right we have <code>a -&gt; m b</code>. Thus, this operator is
asymmetric, utilizing a monadic value on the left and a higher order
function on the right. Although some languages do have infix operators
that are themselves higher order functions, it is still a rather rare
occurrence.</p>
<p>Thus, with a function desugared, it can be confusing that
<code>(&gt;&gt;=)</code> operator is in fact building up a much larger
function by composing functions together.</p>
<div class="sourceCode" id="cb300"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span></span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> \x <span class="ot">-&gt;</span></span>
<span id="cb300-3"><a href="#cb300-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> x <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span></span>
<span id="cb300-4"><a href="#cb300-4" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> ()</span></code></pre></div>
<p>Written in prefix form, it becomes a little bit more digestible.</p>
<div class="sourceCode" id="cb301"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb301-1"><a href="#cb301-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span></span>
<span id="cb301-2"><a href="#cb301-2" aria-hidden="true" tabindex="-1"></a>  (<span class="op">&gt;&gt;=</span>) <span class="fu">getLine</span> (\x <span class="ot">-&gt;</span></span>
<span id="cb301-3"><a href="#cb301-3" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&gt;&gt;=</span>) (<span class="fu">putStrLn</span> x) (\_ <span class="ot">-&gt;</span></span>
<span id="cb301-4"><a href="#cb301-4" aria-hidden="true" tabindex="-1"></a>          <span class="fu">return</span> ()</span>
<span id="cb301-5"><a href="#cb301-5" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb301-6"><a href="#cb301-6" aria-hidden="true" tabindex="-1"></a>  )</span></code></pre></div>
<p>Perhaps even removing the operator entirely might be more intuitive
coming from other languages.</p>
<div class="sourceCode" id="cb302"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> bind <span class="fu">getLine</span> (\x <span class="ot">-&gt;</span> bind (<span class="fu">putStrLn</span> x) (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> ()))</span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb302-3"><a href="#cb302-3" aria-hidden="true" tabindex="-1"></a>    bind x y <span class="ot">=</span> x <span class="op">&gt;&gt;=</span> y</span></code></pre></div>
<ol start="3" type="1">
<li><em>Ad-hoc polymorphism is not commonplace in other
languages.</em></li>
</ol>
<p>Haskell’s implementation of overloading can be unintuitive if one is
not familiar with type inference. Indeed, newcomers to Haskell often
believe they can gain an intuition for monads in a way that will unify
their understanding of <em>all monads</em>. This is a fallacy, however,
because any particular monad instance is merely an
<strong>instantiation</strong> of the monad typeclass functions
implemented <em>for that particular type</em>.</p>
<p>This is all abstracted away from the user, but the
<code>(&gt;&gt;=)</code> or <code>bind</code> function is really a
function of 3 arguments with the extra typeclass dictionary argument
(<code>$dMonad</code>) implicitly threaded around.</p>
<div class="sourceCode" id="cb303"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a>main <span class="op">$</span>dMonad <span class="ot">=</span> bind <span class="op">$</span>dMonad <span class="fu">getLine</span> (\x <span class="ot">-&gt;</span> bind <span class="op">$</span>dMonad (<span class="fu">putStrLn</span> x) (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span>dMonad ()))</span></code></pre></div>
<p>In general, this is true for all typeclasses in Haskell and it’s true
here as well, except in the case where the parameter of the monad class
is unified (through inference) with a concrete class instance.</p>
<p>Now, all of these transformations are trivial once we understand
them, they’re just typically not discussed. In my opinion the
fundamental fallacy of monad tutorials is not that intuition for monads
is hard to convey (nor are metaphors required!), but that novices often
come to monads with an incomplete understanding of points (1), (2), and
(3) and then trip on the simple fact that monads are the first example
of a Haskell construct that is the confluence of all three.</p>
<p>Thus we make monads more difficult than they need to be. At the end
of the day they are simple algebraic critters.</p>
<hr/>
<h1 id="monad-transformers">Monad Transformers</h1>
<h2 id="mtl-transformers">mtl / transformers</h2>
<p>The descriptions of Monads in the previous chapter are a bit of a
white lie. Modern Haskell monad libraries typically use a more general
form of these, written in terms of monad transformers which allow us to
compose monads together to form <strong>composite monads</strong>.</p>
<p>Imagine if you had an application that wanted to deal with a Maybe
monad wrapped inside a State Monad, all wrapped inside the IO monad.
This is the problem that monad transformers solve, a problem of
composing different monads. At their core, monad transformers allow us
to nest monadic computations in a stack with an interface to exchange
values between the levels, called lift:</p>
<div class="sourceCode" id="cb304"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lift ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadTrans</span> t) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</span></code></pre></div>
<p>In production code, the monads mentioned previously may actually be
their more general transformer form composed with the
<code>Identity</code> monad.</p>
<div class="sourceCode" id="cb305"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">State</span>  s <span class="ot">=</span> <span class="dt">StateT</span>  s <span class="dt">Identity</span></span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Writer</span> w <span class="ot">=</span> <span class="dt">WriterT</span> w <span class="dt">Identity</span></span>
<span id="cb305-3"><a href="#cb305-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Reader</span> r <span class="ot">=</span> <span class="dt">ReaderT</span> r <span class="dt">Identity</span></span></code></pre></div>
<p>The following table shows the relationships between these forms:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Monad</th>
<th style="text-align: left;">Transformer</th>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Transformed Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Maybe</td>
<td style="text-align: left;">MaybeT</td>
<td style="text-align: left;"><code>Maybe a</code></td>
<td style="text-align: left;"><code>m (Maybe a)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Reader</td>
<td style="text-align: left;">ReaderT</td>
<td style="text-align: left;"><code>r -&gt; a</code></td>
<td style="text-align: left;"><code>r -&gt; m a</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Writer</td>
<td style="text-align: left;">WriterT</td>
<td style="text-align: left;"><code>(a,w)</code></td>
<td style="text-align: left;"><code>m (a,w)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">State</td>
<td style="text-align: left;">StateT</td>
<td style="text-align: left;"><code>s -&gt; (a,s)</code></td>
<td style="text-align: left;"><code>s -&gt; m (a,s)</code></td>
</tr>
</tbody>
</table>
<p>Just as the base monad class has laws, monad transformers also have
several laws:</p>
<p><strong>Law #1</strong></p>
<div class="sourceCode" id="cb306"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a>lift <span class="op">.</span> <span class="fu">return</span> <span class="ot">=</span> <span class="fu">return</span></span></code></pre></div>
<p><strong>Law #2</strong></p>
<div class="sourceCode" id="cb307"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a>lift (m <span class="op">&gt;&gt;=</span> f) <span class="ot">=</span> lift m <span class="op">&gt;&gt;=</span> (lift <span class="op">.</span> f)</span></code></pre></div>
<p>Or equivalently:</p>
<p><strong>Law #1</strong></p>
<div class="sourceCode" id="cb308"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a>  lift (<span class="fu">return</span> x)</span>
<span id="cb308-2"><a href="#cb308-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb308-3"><a href="#cb308-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="fu">return</span> x</span></code></pre></div>
<p><strong>Law #2</strong></p>
<div class="sourceCode" id="cb309"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> x <span class="ot">&lt;-</span> lift m</span>
<span id="cb309-2"><a href="#cb309-2" aria-hidden="true" tabindex="-1"></a>     lift (f x)</span>
<span id="cb309-3"><a href="#cb309-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-4"><a href="#cb309-4" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> lift <span class="op">$</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> m</span>
<span id="cb309-5"><a href="#cb309-5" aria-hidden="true" tabindex="-1"></a>            f x</span></code></pre></div>
<p>It’s useful to remember that transformers compose <em>outside-in</em>
but are <em>unrolled inside out</em>.</p>
<h2 id="transformers">Transformers</h2>
<p>The lift definition provided above comes from the
<code>transformers</code> library along with an IO-specialized form
called <code>liftIO</code>:</p>
<div class="sourceCode" id="cb310"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lift ::</span> (<span class="dt">Monad</span> m, <span class="dt">MonadTrans</span> t) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a><span class="ot">liftIO ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>These definitions rely on the following typeclass definitions, which
describe composing one monad with another monad (the “t” is the
transformed second monad):</p>
<div class="sourceCode" id="cb311"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb311-1"><a href="#cb311-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">MonadTrans</span> t <span class="kw">where</span></span>
<span id="cb311-2"><a href="#cb311-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    lift ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</span>
<span id="cb311-3"><a href="#cb311-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb311-4"><a href="#cb311-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadIO</span> m <span class="kw">where</span></span>
<span id="cb311-5"><a href="#cb311-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    liftIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb311-6"><a href="#cb311-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb311-7"><a href="#cb311-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadIO</span> <span class="dt">IO</span> <span class="kw">where</span></span>
<span id="cb311-8"><a href="#cb311-8" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<h2 id="basics-1">Basics</h2>
<p>The most basic use requires us to use the T-variants for each of the
monad transformers in the outer layers and to explicitly
<code>lift</code> and <code>return</code> values between the layers.
Monads have kind <code>(* -&gt; *)</code>, so monad transformers which
take monads to monads have
<code>((* -&gt; *) -&gt; * -&gt; *)</code>:</p>
<div class="sourceCode" id="cb312"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Monad</span> (<span class="ot">m ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>)</span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true" tabindex="-1"></a><span class="dt">MonadTrans</span> (<span class="ot">t ::</span> (<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>)</span></code></pre></div>
<p>For example, if we wanted to form a composite computation using both
the Reader and Maybe monads, using <code>MonadTrans</code> we could use
Maybe inside of a <code>ReaderT</code> to form
<code>ReaderT t Maybe a</code>.</p>
<div class="sourceCode" id="cb313"
data-include="src/03-monad-transformers/transformer.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb313-1"><a href="#cb313-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Reader</span></span>
<span id="cb313-2"><a href="#cb313-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-3"><a href="#cb313-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> [(<span class="dt">String</span>, <span class="dt">Int</span>)]</span>
<span id="cb313-4"><a href="#cb313-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Eval</span> a <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="dt">Env</span> <span class="dt">Maybe</span> a</span>
<span id="cb313-5"><a href="#cb313-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-6"><a href="#cb313-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb313-7"><a href="#cb313-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Val</span> <span class="dt">Int</span></span>
<span id="cb313-8"><a href="#cb313-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb313-9"><a href="#cb313-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Var</span> <span class="dt">String</span></span>
<span id="cb313-10"><a href="#cb313-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb313-11"><a href="#cb313-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-12"><a href="#cb313-12" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> <span class="dt">Int</span></span>
<span id="cb313-13"><a href="#cb313-13" aria-hidden="true" tabindex="-1"></a>eval ex <span class="ot">=</span> <span class="kw">case</span> ex <span class="kw">of</span></span>
<span id="cb313-14"><a href="#cb313-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-15"><a href="#cb313-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Val</span> n <span class="ot">-&gt;</span> <span class="fu">return</span> n</span>
<span id="cb313-16"><a href="#cb313-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-17"><a href="#cb313-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Add</span> x y <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb313-18"><a href="#cb313-18" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> eval x</span>
<span id="cb313-19"><a href="#cb313-19" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">&lt;-</span> eval y</span>
<span id="cb313-20"><a href="#cb313-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (a<span class="op">+</span>b)</span>
<span id="cb313-21"><a href="#cb313-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-22"><a href="#cb313-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb313-23"><a href="#cb313-23" aria-hidden="true" tabindex="-1"></a>    env <span class="ot">&lt;-</span> ask</span>
<span id="cb313-24"><a href="#cb313-24" aria-hidden="true" tabindex="-1"></a>    val <span class="ot">&lt;-</span> lift (<span class="fu">lookup</span> x env)</span>
<span id="cb313-25"><a href="#cb313-25" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> val</span>
<span id="cb313-26"><a href="#cb313-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-27"><a href="#cb313-27" aria-hidden="true" tabindex="-1"></a><span class="ot">env ::</span> <span class="dt">Env</span></span>
<span id="cb313-28"><a href="#cb313-28" aria-hidden="true" tabindex="-1"></a>env <span class="ot">=</span> [(<span class="st">&quot;x&quot;</span>, <span class="dv">2</span>), (<span class="st">&quot;y&quot;</span>, <span class="dv">5</span>)]</span>
<span id="cb313-29"><a href="#cb313-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-30"><a href="#cb313-30" aria-hidden="true" tabindex="-1"></a><span class="ot">ex1 ::</span> <span class="dt">Eval</span> <span class="dt">Int</span></span>
<span id="cb313-31"><a href="#cb313-31" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> eval (<span class="dt">Add</span> (<span class="dt">Val</span> <span class="dv">2</span>) (<span class="dt">Add</span> (<span class="dt">Val</span> <span class="dv">1</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)))</span>
<span id="cb313-32"><a href="#cb313-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb313-33"><a href="#cb313-33" aria-hidden="true" tabindex="-1"></a>example1,<span class="ot"> example2 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb313-34"><a href="#cb313-34" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> runReaderT ex1 env</span>
<span id="cb313-35"><a href="#cb313-35" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> runReaderT ex1 []</span></code></pre></div>
<p>The fundamental limitation of this approach is that we find ourselves
<code>lift.lift.lift</code>ing and <code>return.return.return</code>ing
a lot.</p>
<h2 id="mtl">mtl</h2>
<p>The mtl library is the most commonly used interface for these monad
tranformers, but mtl depends on the transformers library from which it
generalizes the “basic” monads described above into more general
transformers, such as the following:</p>
<div class="sourceCode" id="cb314"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s (<span class="dt">StateT</span> s m)</span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadReader</span> r (<span class="dt">ReaderT</span> r m)</span>
<span id="cb314-3"><a href="#cb314-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monoid</span> w, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadWriter</span> w (<span class="dt">WriterT</span> w m)</span></code></pre></div>
<p>This solves the “lift.lift.lifting” problem introduced by
transformers.</p>
<h2 id="readert">ReaderT</h2>
<p>By way of an example there exist three possible forms of the Reader
monad. The first is the primitive version which no longer exists, but
which is useful for understanding the underlying ideas. The other two
are the <em>transformers</em> and <em>mtl</em> variants.</p>
<p><em>Reader</em></p>
<div class="sourceCode" id="cb315"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb315-1"><a href="#cb315-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Reader</span> r a <span class="ot">=</span> <span class="dt">Reader</span> {<span class="ot"> runReader ::</span> r <span class="ot">-&gt;</span> a }</span>
<span id="cb315-2"><a href="#cb315-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb315-3"><a href="#cb315-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadReader</span> r (<span class="dt">Reader</span> r) <span class="kw">where</span></span>
<span id="cb315-4"><a href="#cb315-4" aria-hidden="true" tabindex="-1"></a>  ask       <span class="ot">=</span> <span class="dt">Reader</span> <span class="fu">id</span></span>
<span id="cb315-5"><a href="#cb315-5" aria-hidden="true" tabindex="-1"></a>  local f m <span class="ot">=</span> <span class="dt">Reader</span> (runReader m <span class="op">.</span> f)</span></code></pre></div>
<p><em>ReaderT</em></p>
<div class="sourceCode" id="cb316"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ReaderT</span> r m a <span class="ot">=</span> <span class="dt">ReaderT</span> {<span class="ot"> runReaderT ::</span> r <span class="ot">-&gt;</span> m a }</span>
<span id="cb316-2"><a href="#cb316-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-3"><a href="#cb316-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ReaderT</span> r m) <span class="kw">where</span></span>
<span id="cb316-4"><a href="#cb316-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> <span class="fu">return</span> a</span>
<span id="cb316-5"><a href="#cb316-5" aria-hidden="true" tabindex="-1"></a>  m <span class="op">&gt;&gt;=</span> k  <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="op">$</span> \r <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb316-6"><a href="#cb316-6" aria-hidden="true" tabindex="-1"></a>      a <span class="ot">&lt;-</span> runReaderT m r</span>
<span id="cb316-7"><a href="#cb316-7" aria-hidden="true" tabindex="-1"></a>      runReaderT (k a) r</span>
<span id="cb316-8"><a href="#cb316-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-9"><a href="#cb316-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">ReaderT</span> r) <span class="kw">where</span></span>
<span id="cb316-10"><a href="#cb316-10" aria-hidden="true" tabindex="-1"></a>    lift m <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> m</span></code></pre></div>
<p><em>MonadReader</em></p>
<div class="sourceCode" id="cb317"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadReader</span> r m <span class="op">|</span> m <span class="ot">-&gt;</span> r <span class="kw">where</span></span>
<span id="cb317-2"><a href="#cb317-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ask   ::</span> m r</span>
<span id="cb317-3"><a href="#cb317-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  local ::</span> (r <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a</span>
<span id="cb317-4"><a href="#cb317-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-5"><a href="#cb317-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadReader</span> r (<span class="dt">ReaderT</span> r m) <span class="kw">where</span></span>
<span id="cb317-6"><a href="#cb317-6" aria-hidden="true" tabindex="-1"></a>  ask       <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="fu">return</span></span>
<span id="cb317-7"><a href="#cb317-7" aria-hidden="true" tabindex="-1"></a>  local f m <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="op">$</span> \r <span class="ot">-&gt;</span> runReaderT m (f r)</span></code></pre></div>
<p>So, hypothetically the three variants of ask would be:</p>
<div class="sourceCode" id="cb318"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ask ::</span> <span class="dt">Reader</span> r r</span>
<span id="cb318-2"><a href="#cb318-2" aria-hidden="true" tabindex="-1"></a><span class="ot">ask ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> r m r</span>
<span id="cb318-3"><a href="#cb318-3" aria-hidden="true" tabindex="-1"></a><span class="ot">ask ::</span> <span class="dt">MonadReader</span> r m <span class="ot">=&gt;</span> m r</span></code></pre></div>
<p>In practice the <code>mtl</code> variant is the one commonly used in
Modern Haskell.</p>
<h2 id="newtype-deriving">Newtype Deriving</h2>
<p>Newtype deriving is a common technique used in combination with the
<code>mtl</code> library and as such we will discuss its use for
transformers in this section.</p>
<p>As discussed in the <a href="#newtypes">newtypes</a> section,
newtypes let us reference a data type with a single constructor as a new
distinct type, with no runtime overhead from boxing, unlike an algebraic
datatype with a single constructor. Newtype wrappers around strings and
numeric types can often drastically reduce accidental errors.</p>
<p>Consider the case of using a newtype to distinguish between two
different text blobs with different semantics. Both have the same
runtime representation as a text object, but are distinguished
statically, so that plaintext can not be accidentally interchanged with
encrypted text.</p>
<div class="sourceCode" id="cb319"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Plaintext</span> <span class="ot">=</span> <span class="dt">Plaintext</span> <span class="dt">Text</span></span>
<span id="cb319-2"><a href="#cb319-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Cryptotext</span> <span class="ot">=</span> <span class="dt">Cryptotext</span> <span class="dt">Text</span></span>
<span id="cb319-3"><a href="#cb319-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-4"><a href="#cb319-4" aria-hidden="true" tabindex="-1"></a><span class="ot">encrypt ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Plaintext</span> <span class="ot">-&gt;</span> <span class="dt">Cryptotext</span></span>
<span id="cb319-5"><a href="#cb319-5" aria-hidden="true" tabindex="-1"></a><span class="ot">decrypt ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Cryptotext</span> <span class="ot">-&gt;</span> <span class="dt">Plaintext</span></span></code></pre></div>
<p>This is a surprisingly powerful tool as the Haskell compiler will
refuse to compile any function which treats Cryptotext as Plaintext or
vice versa!</p>
<p>The other common use case is using newtypes to derive logic for
deriving custom monad transformers in our business logic. Using
<code>-XGeneralizedNewtypeDeriving</code> we can recover the
functionality of instances of the underlying types composed in our
transformer stack.</p>
<div class="sourceCode" id="cb320"
data-include="src/03-monad-transformers/newtype.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb320-1"><a href="#cb320-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb320-2"><a href="#cb320-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-3"><a href="#cb320-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Quantity</span> v a <span class="ot">=</span> <span class="dt">Quantity</span> a</span>
<span id="cb320-4"><a href="#cb320-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Num</span>, <span class="dt">Show</span>)</span>
<span id="cb320-5"><a href="#cb320-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-6"><a href="#cb320-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Haskeller</span></span>
<span id="cb320-7"><a href="#cb320-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Haskellers</span> <span class="ot">=</span> <span class="dt">Quantity</span> <span class="dt">Haskeller</span> <span class="dt">Int</span></span>
<span id="cb320-8"><a href="#cb320-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-9"><a href="#cb320-9" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dt">Quantity</span> <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Haskellers</span></span>
<span id="cb320-10"><a href="#cb320-10" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="dt">Quantity</span> <span class="dv">6</span><span class="ot"> ::</span> <span class="dt">Haskellers</span></span>
<span id="cb320-11"><a href="#cb320-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-12"><a href="#cb320-12" aria-hidden="true" tabindex="-1"></a><span class="ot">totalHaskellers ::</span> <span class="dt">Haskellers</span></span>
<span id="cb320-13"><a href="#cb320-13" aria-hidden="true" tabindex="-1"></a>totalHaskellers <span class="ot">=</span> a <span class="op">+</span> b</span>
<span id="cb320-14"><a href="#cb320-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-15"><a href="#cb320-15" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Velocity</span> <span class="ot">=</span> <span class="dt">Velocity</span> {<span class="ot"> unVelocity ::</span> <span class="dt">Double</span> }</span>
<span id="cb320-16"><a href="#cb320-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb320-17"><a href="#cb320-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-18"><a href="#cb320-18" aria-hidden="true" tabindex="-1"></a><span class="ot">v ::</span> <span class="dt">Velocity</span></span>
<span id="cb320-19"><a href="#cb320-19" aria-hidden="true" tabindex="-1"></a>v <span class="ot">=</span> <span class="dt">Velocity</span> <span class="fl">2.718</span></span>
<span id="cb320-20"><a href="#cb320-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-21"><a href="#cb320-21" aria-hidden="true" tabindex="-1"></a><span class="ot">x ::</span> <span class="dt">Double</span></span>
<span id="cb320-22"><a href="#cb320-22" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="fl">2.718</span></span>
<span id="cb320-23"><a href="#cb320-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb320-24"><a href="#cb320-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- Type error is caught at compile time even though</span></span>
<span id="cb320-25"><a href="#cb320-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- they are the same value at runtime!</span></span>
<span id="cb320-26"><a href="#cb320-26" aria-hidden="true" tabindex="-1"></a>err <span class="ot">=</span> v <span class="op">+</span> x</span></code></pre></div>
<div class="sourceCode" id="cb321"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> <span class="ot">`Double&#39; with `</span><span class="dt">Velocity&#39;</span></span>
<span id="cb321-2"><a href="#cb321-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Expected</span> <span class="kw">type</span><span class="op">:</span> <span class="dt">Velocity</span></span>
<span id="cb321-3"><a href="#cb321-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Actual</span> <span class="kw">type</span><span class="op">:</span> <span class="dt">Double</span></span>
<span id="cb321-4"><a href="#cb321-4" aria-hidden="true" tabindex="-1"></a><span class="dt">In</span> the second argument <span class="kw">of</span> <span class="ot">`(+)&#39;, namely `</span>x&#39;</span>
<span id="cb321-5"><a href="#cb321-5" aria-hidden="true" tabindex="-1"></a><span class="dt">In</span> the expression<span class="op">:</span> v <span class="op">+</span> x</span></code></pre></div>
<p>Using newtype deriving with the mtl library typeclasses we can
produce flattened transformer types that don’t require explicit lifting
in the transform stack. For example, here is a little stack machine
involving the Reader, Writer and State monads.</p>
<div class="sourceCode" id="cb322"
data-include="src/03-monad-transformers/newtype_deriving.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb322-2"><a href="#cb322-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-3"><a href="#cb322-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Reader</span></span>
<span id="cb322-4"><a href="#cb322-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Writer</span></span>
<span id="cb322-5"><a href="#cb322-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span></span>
<span id="cb322-6"><a href="#cb322-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-7"><a href="#cb322-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Stack</span>   <span class="ot">=</span> [<span class="dt">Int</span>]</span>
<span id="cb322-8"><a href="#cb322-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Output</span>  <span class="ot">=</span> [<span class="dt">Int</span>]</span>
<span id="cb322-9"><a href="#cb322-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Program</span> <span class="ot">=</span> [<span class="dt">Instr</span>]</span>
<span id="cb322-10"><a href="#cb322-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-11"><a href="#cb322-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">VM</span> a <span class="ot">=</span> <span class="dt">ReaderT</span> <span class="dt">Program</span> (<span class="dt">WriterT</span> <span class="dt">Output</span> (<span class="dt">State</span> <span class="dt">Stack</span>)) a</span>
<span id="cb322-12"><a href="#cb322-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-13"><a href="#cb322-13" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Comp</span> a <span class="ot">=</span> <span class="dt">Comp</span> {<span class="ot"> unComp ::</span> <span class="dt">VM</span> a }</span>
<span id="cb322-14"><a href="#cb322-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadReader</span> <span class="dt">Program</span>, <span class="dt">MonadWriter</span> <span class="dt">Output</span>, <span class="dt">MonadState</span> <span class="dt">Stack</span>)</span>
<span id="cb322-15"><a href="#cb322-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-16"><a href="#cb322-16" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Instr</span> <span class="ot">=</span> <span class="dt">Push</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">Pop</span> <span class="op">|</span> <span class="dt">Puts</span></span>
<span id="cb322-17"><a href="#cb322-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-18"><a href="#cb322-18" aria-hidden="true" tabindex="-1"></a><span class="ot">evalInstr ::</span> <span class="dt">Instr</span> <span class="ot">-&gt;</span> <span class="dt">Comp</span> ()</span>
<span id="cb322-19"><a href="#cb322-19" aria-hidden="true" tabindex="-1"></a>evalInstr instr <span class="ot">=</span> <span class="kw">case</span> instr <span class="kw">of</span></span>
<span id="cb322-20"><a href="#cb322-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Pop</span>    <span class="ot">-&gt;</span> modify <span class="fu">tail</span></span>
<span id="cb322-21"><a href="#cb322-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Push</span> n <span class="ot">-&gt;</span> modify (n<span class="op">:</span>)</span>
<span id="cb322-22"><a href="#cb322-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Puts</span>   <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb322-23"><a href="#cb322-23" aria-hidden="true" tabindex="-1"></a>    tos <span class="ot">&lt;-</span> gets <span class="fu">head</span></span>
<span id="cb322-24"><a href="#cb322-24" aria-hidden="true" tabindex="-1"></a>    tell [tos]</span>
<span id="cb322-25"><a href="#cb322-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-26"><a href="#cb322-26" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Comp</span> ()</span>
<span id="cb322-27"><a href="#cb322-27" aria-hidden="true" tabindex="-1"></a>eval <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb322-28"><a href="#cb322-28" aria-hidden="true" tabindex="-1"></a>  instr <span class="ot">&lt;-</span> ask</span>
<span id="cb322-29"><a href="#cb322-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> instr <span class="kw">of</span></span>
<span id="cb322-30"><a href="#cb322-30" aria-hidden="true" tabindex="-1"></a>    []     <span class="ot">-&gt;</span> <span class="fu">return</span> ()</span>
<span id="cb322-31"><a href="#cb322-31" aria-hidden="true" tabindex="-1"></a>    (i<span class="op">:</span>is) <span class="ot">-&gt;</span> evalInstr i <span class="op">&gt;&gt;</span> local (<span class="fu">const</span> is) eval</span>
<span id="cb322-32"><a href="#cb322-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-33"><a href="#cb322-33" aria-hidden="true" tabindex="-1"></a><span class="ot">execVM ::</span> <span class="dt">Program</span> <span class="ot">-&gt;</span> <span class="dt">Output</span></span>
<span id="cb322-34"><a href="#cb322-34" aria-hidden="true" tabindex="-1"></a>execVM <span class="ot">=</span> <span class="fu">flip</span> evalState [] <span class="op">.</span> execWriterT <span class="op">.</span> runReaderT (unComp eval)</span>
<span id="cb322-35"><a href="#cb322-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-36"><a href="#cb322-36" aria-hidden="true" tabindex="-1"></a><span class="ot">program ::</span> <span class="dt">Program</span></span>
<span id="cb322-37"><a href="#cb322-37" aria-hidden="true" tabindex="-1"></a>program <span class="ot">=</span> [</span>
<span id="cb322-38"><a href="#cb322-38" aria-hidden="true" tabindex="-1"></a>     <span class="dt">Push</span> <span class="dv">42</span>,</span>
<span id="cb322-39"><a href="#cb322-39" aria-hidden="true" tabindex="-1"></a>     <span class="dt">Push</span> <span class="dv">27</span>,</span>
<span id="cb322-40"><a href="#cb322-40" aria-hidden="true" tabindex="-1"></a>     <span class="dt">Puts</span>,</span>
<span id="cb322-41"><a href="#cb322-41" aria-hidden="true" tabindex="-1"></a>     <span class="dt">Pop</span>,</span>
<span id="cb322-42"><a href="#cb322-42" aria-hidden="true" tabindex="-1"></a>     <span class="dt">Puts</span>,</span>
<span id="cb322-43"><a href="#cb322-43" aria-hidden="true" tabindex="-1"></a>     <span class="dt">Pop</span></span>
<span id="cb322-44"><a href="#cb322-44" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb322-45"><a href="#cb322-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-46"><a href="#cb322-46" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb322-47"><a href="#cb322-47" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">mapM_</span> <span class="fu">print</span> <span class="op">$</span> execVM program</span></code></pre></div>
<p>Pattern matching on a newtype constructor compiles into nothing. For
example the<code>extractB</code> function below does not scrutinize the
<code>MkB</code> constructor like <code>extractA</code> does, because
<code>MkB</code> does not exist at runtime; it is purely a compile-time
construct.</p>
<div class="sourceCode" id="cb323"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb323-1"><a href="#cb323-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">A</span> <span class="ot">=</span> <span class="dt">MkA</span> <span class="dt">Int</span></span>
<span id="cb323-2"><a href="#cb323-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">B</span> <span class="ot">=</span> <span class="dt">MkB</span> <span class="dt">Int</span></span>
<span id="cb323-3"><a href="#cb323-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb323-4"><a href="#cb323-4" aria-hidden="true" tabindex="-1"></a><span class="ot">extractA ::</span> <span class="dt">A</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb323-5"><a href="#cb323-5" aria-hidden="true" tabindex="-1"></a>extractA (<span class="dt">MkA</span> x) <span class="ot">=</span> x</span>
<span id="cb323-6"><a href="#cb323-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb323-7"><a href="#cb323-7" aria-hidden="true" tabindex="-1"></a><span class="ot">extractB ::</span> <span class="dt">B</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb323-8"><a href="#cb323-8" aria-hidden="true" tabindex="-1"></a>extractB (<span class="dt">MkB</span> x) <span class="ot">=</span> x</span></code></pre></div>
<h2 id="efficiency">Efficiency</h2>
<p>The second monad transformer law guarantees that sequencing
consecutive lift operations is semantically equivalent to lifting the
results into the outer monad.</p>
<div class="sourceCode" id="cb324"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> x <span class="ot">&lt;-</span> lift m  <span class="op">==</span>  lift <span class="op">$</span> <span class="kw">do</span> x <span class="ot">&lt;-</span> m</span>
<span id="cb324-2"><a href="#cb324-2" aria-hidden="true" tabindex="-1"></a>   lift (f x)                 f x</span></code></pre></div>
<p>Although they are guaranteed to yield the same result, the operation
of lifting the results between the monad levels is not without cost and
crops up frequently when working with the monad traversal and looping
functions. For example, all three of the functions on the left below are
less efficient than the right hand side which performs the bind in the
base monad instead of lifting on each iteration.</p>
<div class="sourceCode" id="cb325"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb325-1"><a href="#cb325-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Less Efficient      More Efficient</span></span>
<span id="cb325-2"><a href="#cb325-2" aria-hidden="true" tabindex="-1"></a>forever (lift m)    <span class="op">==</span> lift (forever m)</span>
<span id="cb325-3"><a href="#cb325-3" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM_</span> (lift <span class="op">.</span> f) xs <span class="op">==</span> lift (<span class="fu">mapM_</span> f xs)</span>
<span id="cb325-4"><a href="#cb325-4" aria-hidden="true" tabindex="-1"></a>forM_ xs (lift <span class="op">.</span> f) <span class="op">==</span> lift (forM_ xs f)</span></code></pre></div>
<h2 id="monad-morphisms">Monad Morphisms</h2>
<p>Although the base monad transformer package provides a
<code>MonadTrans</code> class for lifting to another monad:</p>
<div class="sourceCode" id="cb326"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb326-1"><a href="#cb326-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lift ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> t m a</span></code></pre></div>
<p>But oftentimes we need to work with and manipulate our monad
transformer stack to either produce new transformers, modify existing
ones or extend an upstream library with new layers. The
<code>mmorph</code> library provides the capacity to compose monad
morphism transformation directly on transformer stacks. This is achieved
primarily by use of the <code>hoist</code> function which maps a
function from a base monad into a function over a transformed monad.</p>
<div class="sourceCode" id="cb327"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb327-1"><a href="#cb327-1" aria-hidden="true" tabindex="-1"></a><span class="ot">hoist ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (<span class="kw">forall</span> a<span class="op">.</span> m a <span class="ot">-&gt;</span> n a) <span class="ot">-&gt;</span> t m b <span class="ot">-&gt;</span> t n b</span></code></pre></div>
<p>Hoist takes a <em>monad morphism</em> (a mapping from a
<code>m a</code> to a <code>n a</code>) and applies in on the inner
value monad of a transformer stack, transforming the value under the
outer layer.</p>
<p>The monad morphism <code>generalize</code> takes an Identity monad
into any another monad <code>m</code>.</p>
<div class="sourceCode" id="cb328"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb328-1"><a href="#cb328-1" aria-hidden="true" tabindex="-1"></a><span class="ot">generalize ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>For example, it generalizes <code>State s a</code> (which is
<code>StateT s Identity a</code>) to <code>StateT s m a</code>.</p>
<p>So we can generalize an existing transformer to lift an IO layer onto
it.</p>
<div class="sourceCode" id="cb329"
data-include="src/10-advanced-monads/mmorph.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb329-1"><a href="#cb329-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span></span>
<span id="cb329-2"><a href="#cb329-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Morph</span></span>
<span id="cb329-3"><a href="#cb329-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-4"><a href="#cb329-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Eval</span> a <span class="ot">=</span> <span class="dt">State</span> [<span class="dt">Int</span>] a</span>
<span id="cb329-5"><a href="#cb329-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-6"><a href="#cb329-6" aria-hidden="true" tabindex="-1"></a><span class="ot">runEval ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Eval</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb329-7"><a href="#cb329-7" aria-hidden="true" tabindex="-1"></a>runEval <span class="ot">=</span> <span class="fu">flip</span> evalState</span>
<span id="cb329-8"><a href="#cb329-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-9"><a href="#cb329-9" aria-hidden="true" tabindex="-1"></a><span class="ot">pop ::</span> <span class="dt">Eval</span> <span class="dt">Int</span></span>
<span id="cb329-10"><a href="#cb329-10" aria-hidden="true" tabindex="-1"></a>pop <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb329-11"><a href="#cb329-11" aria-hidden="true" tabindex="-1"></a>  top <span class="ot">&lt;-</span> gets <span class="fu">head</span></span>
<span id="cb329-12"><a href="#cb329-12" aria-hidden="true" tabindex="-1"></a>  modify <span class="fu">tail</span></span>
<span id="cb329-13"><a href="#cb329-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> top</span>
<span id="cb329-14"><a href="#cb329-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-15"><a href="#cb329-15" aria-hidden="true" tabindex="-1"></a><span class="ot">push ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Eval</span> ()</span>
<span id="cb329-16"><a href="#cb329-16" aria-hidden="true" tabindex="-1"></a>push x <span class="ot">=</span> modify (x<span class="op">:</span>)</span>
<span id="cb329-17"><a href="#cb329-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-18"><a href="#cb329-18" aria-hidden="true" tabindex="-1"></a><span class="ot">ev1 ::</span> <span class="dt">Eval</span> <span class="dt">Int</span></span>
<span id="cb329-19"><a href="#cb329-19" aria-hidden="true" tabindex="-1"></a>ev1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb329-20"><a href="#cb329-20" aria-hidden="true" tabindex="-1"></a>  push <span class="dv">3</span></span>
<span id="cb329-21"><a href="#cb329-21" aria-hidden="true" tabindex="-1"></a>  push <span class="dv">4</span></span>
<span id="cb329-22"><a href="#cb329-22" aria-hidden="true" tabindex="-1"></a>  pop</span>
<span id="cb329-23"><a href="#cb329-23" aria-hidden="true" tabindex="-1"></a>  pop</span>
<span id="cb329-24"><a href="#cb329-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb329-25"><a href="#cb329-25" aria-hidden="true" tabindex="-1"></a><span class="ot">ev2  ::</span> <span class="dt">StateT</span> [<span class="dt">Int</span>] <span class="dt">IO</span> ()</span>
<span id="cb329-26"><a href="#cb329-26" aria-hidden="true" tabindex="-1"></a>ev2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb329-27"><a href="#cb329-27" aria-hidden="true" tabindex="-1"></a>  result <span class="ot">&lt;-</span> hoist generalize ev1</span>
<span id="cb329-28"><a href="#cb329-28" aria-hidden="true" tabindex="-1"></a>  liftIO <span class="op">$</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Result: &quot;</span> <span class="op">++</span> <span class="fu">show</span> result</span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://hackage.haskell.org/package/mmorph">mmorph</a></li>
</ul>
<h2 id="effect-systems">Effect Systems</h2>
<p>The mtl model has several properties which make it suboptimal from a
theoretical perspective. Although it is used widely in production
Haskell we will discuss its shortcomings and some future models called
<em>effect systems</em>.</p>
<p><strong>Extensibility</strong></p>
<p>When you add a new custom transformer inside of our business logic
we’ll typically have to derive a large number of boilerplate instances
to compose it inside of existing mtl transformer stack. For example
adding <code>MonadReader</code> instance for <span
class="math inline"><em>n</em></span> number of undecidable instances
that do nothing but mostly lifts. You can see this massive boilerplate
all over the design of the <code>mtl</code> library and its transitive
dependencies.</p>
<div class="sourceCode" id="cb330"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb330-1"><a href="#cb330-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadReader</span> r m <span class="ot">=&gt;</span> <span class="dt">MonadReader</span> r (<span class="dt">ExceptT</span> e m) <span class="kw">where</span></span>
<span id="cb330-2"><a href="#cb330-2" aria-hidden="true" tabindex="-1"></a>    ask   <span class="ot">=</span> lift ask</span>
<span id="cb330-3"><a href="#cb330-3" aria-hidden="true" tabindex="-1"></a>    local <span class="ot">=</span> mapExceptT <span class="op">.</span> local</span>
<span id="cb330-4"><a href="#cb330-4" aria-hidden="true" tabindex="-1"></a>    reader <span class="ot">=</span> lift <span class="op">.</span> reader</span>
<span id="cb330-5"><a href="#cb330-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-6"><a href="#cb330-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadReader</span> r m <span class="ot">=&gt;</span> <span class="dt">MonadReader</span> r (<span class="dt">IdentityT</span> m) <span class="kw">where</span></span>
<span id="cb330-7"><a href="#cb330-7" aria-hidden="true" tabindex="-1"></a>    ask   <span class="ot">=</span> lift ask</span>
<span id="cb330-8"><a href="#cb330-8" aria-hidden="true" tabindex="-1"></a>    local <span class="ot">=</span> mapIdentityT <span class="op">.</span> local</span>
<span id="cb330-9"><a href="#cb330-9" aria-hidden="true" tabindex="-1"></a>    reader <span class="ot">=</span> lift <span class="op">.</span> reader</span>
<span id="cb330-10"><a href="#cb330-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-11"><a href="#cb330-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- Same for ListT, MaybeT, ...</span></span>
<span id="cb330-12"><a href="#cb330-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb330-13"><a href="#cb330-13" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>This is called the <em><span
class="math inline"><em>n</em><sup>2</sup></span> instance problem</em>
or the <em>instance boilerplate problem</em> and remains an open problem
of mtl.</p>
<p><strong>Composing Transformers</strong></p>
<p>Effects don’t generally commute from a theoretical perspective and as
such monad transformer composition is not in general commutative. For
example stacking <code>State</code> and <code>Except</code> is not
commutative:</p>
<div class="sourceCode" id="cb331"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb331-1"><a href="#cb331-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stateExcept ::</span> <span class="dt">StateT</span> s (<span class="dt">Except</span> e) a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Either</span> e (a, s)</span>
<span id="cb331-2"><a href="#cb331-2" aria-hidden="true" tabindex="-1"></a>stateExcept m s <span class="ot">=</span> runExcept (runStateT m s)</span>
<span id="cb331-3"><a href="#cb331-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb331-4"><a href="#cb331-4" aria-hidden="true" tabindex="-1"></a><span class="ot">exceptState ::</span> <span class="dt">ExceptT</span> e (<span class="dt">State</span> s) a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (<span class="dt">Either</span> e a, s)</span>
<span id="cb331-5"><a href="#cb331-5" aria-hidden="true" tabindex="-1"></a>exceptState m s <span class="ot">=</span> runState (runExceptT m) s</span></code></pre></div>
<p>In addition, the standard method of deriving mtl classes for a
transformer stack breaks down when using transformer stacks with the
same monad at different layers of the stack. For example stacking
multiple <code>State</code> transformers is a pattern that shows up
quite frequently.</p>
<div class="sourceCode" id="cb332"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb332-1"><a href="#cb332-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Example</span> <span class="ot">=</span> <span class="dt">StateT</span> <span class="dt">Int</span> (<span class="dt">State</span> <span class="dt">String</span>)</span>
<span id="cb332-2"><a href="#cb332-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">MonadState</span> <span class="dt">Int</span>)</span></code></pre></div>
<p>In order to get around this you would have to handwrite the instances
for this transformer stack and manually lift anytime you perform a State
action. This is a suboptimal design and difficult to route around
without massive boilerplate.</p>
<p>While these problems exist, most users of mtl don’t implement new
transformers at all and can get by. However in recent years there have
been written many other libraries that have explored the design space of
alternative effect modeling systems. These systems are still quite early
compared to the <code>mtl</code> but some are able to avoid some of the
shortcomings of <code>mtl</code> in favour of newer algebraic models of
effects. The two most commonly used libraries are:</p>
<ul>
<li><code>polysemy</code></li>
<li><code>fused-effects</code></li>
</ul>
<h2 id="polysemy">Polysemy</h2>
<p>Polysemy is a new effect system library based on the free-monad
approach to modeling effects. The library uses modern type system
features to model effects on top of a <code>Sem</code> monad. The monad
will have a members constraint type which constrains a parameter
<code>r</code> by a type-level list of effects in the given unit of
computation.</p>
<div class="sourceCode" id="cb333"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb333-1"><a href="#cb333-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Members</span> [ <span class="op">..</span> effects <span class="op">..</span> ] <span class="ot">=&gt;</span> <span class="dt">Sem</span> r a</span></code></pre></div>
<p>For example we seamlessly mix and match error handling, tracing, and
stateful updates inside of one computation without the need to create a
layered monad. This would look something like the following:</p>
<div class="sourceCode" id="cb334"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb334-1"><a href="#cb334-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Members</span> &#39;[<span class="dt">Trace</span>, <span class="dt">State</span> <span class="dt">Example</span>, <span class="dt">Error</span> <span class="dt">MyError</span>] r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r ()</span></code></pre></div>
<p>These effects can then be evaluated using an interpreter function
which unrolls and potentially evaluates the effects of the
<code>Sem</code> free monad. Some of these interpreters for tracing,
state and error are similar to the evaluations for monad transformers
but evaluate one layer of type-level list of the <em>effect
stack</em>.</p>
<div class="sourceCode" id="cb335"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb335-1"><a href="#cb335-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runError ::</span> <span class="dt">Sem</span> (<span class="dt">Error</span> e &#39;<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (<span class="dt">Either</span> e a)</span>
<span id="cb335-2"><a href="#cb335-2" aria-hidden="true" tabindex="-1"></a><span class="ot">runState ::</span> s <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">State</span> s &#39;<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (s, a)</span>
<span id="cb335-3"><a href="#cb335-3" aria-hidden="true" tabindex="-1"></a><span class="ot">runTraceList ::</span> <span class="dt">Sem</span> (<span class="dt">Trace</span> &#39;<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ([<span class="dt">String</span>], a)</span></code></pre></div>
<p>The resulting <code>Sem</code> monad with a single field can then be
lowered into a single resulting monad such as IO or Either.</p>
<div class="sourceCode" id="cb336"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb336-1"><a href="#cb336-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runFinal ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Sem</span> &#39;[<span class="dt">Final</span> m] a <span class="ot">-&gt;</span> m a</span>
<span id="cb336-2"><a href="#cb336-2" aria-hidden="true" tabindex="-1"></a><span class="ot">embedToFinal ::</span> (<span class="dt">Member</span> (<span class="dt">Final</span> m) r, <span class="dt">Functor</span> m) <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">Embed</span> m &#39;<span class="op">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span></code></pre></div>
<p>The library provides rich set of of effects that can replace many
uses of monad transformers.</p>
<ul>
<li><code>Polysemy.Async</code> - Asynchronous computations</li>
<li><code>Polysemy.AtomicState</code> - Atomic operations</li>
<li><code>Polysemy.Error</code> - Error handling</li>
<li><code>Polysemy.Fail</code> - Computations that fail</li>
<li><code>Polysemy.IO</code> - Monadic IO</li>
<li><code>Polysemy.Input</code> - Input effects</li>
<li><code>Polysemy.Output</code> - Output effects</li>
<li><code>Polysemy.NonDet</code> - Non-determinism effect</li>
<li><code>Polysemy.Reader</code> - Contextual state a la Reader
monad</li>
<li><code>Polysemy.Resource</code> - Resources with finalizers</li>
<li><code>Polysemy.State</code> - Stateful effects</li>
<li><code>Polysemy.Trace</code> - Tracing effect</li>
<li><code>Polysemy.Writer</code> - Accumulation effect a la Writer
monad</li>
</ul>
<p>For example for a simple stateful computation with only a single
effect.</p>
<div class="sourceCode" id="cb337"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb337-1"><a href="#cb337-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Example</span> <span class="ot">=</span> <span class="dt">Example</span> {<span class="ot"> x ::</span> <span class="dt">Int</span>,<span class="ot"> y ::</span> <span class="dt">Int</span> }</span>
<span id="cb337-2"><a href="#cb337-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb337-3"><a href="#cb337-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb337-4"><a href="#cb337-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Stateful update to Example datastructure.</span></span>
<span id="cb337-5"><a href="#cb337-5" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Member</span> (<span class="dt">State</span> <span class="dt">Example</span>) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb337-6"><a href="#cb337-6" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb337-7"><a href="#cb337-7" aria-hidden="true" tabindex="-1"></a>  modify <span class="op">$</span> \s <span class="ot">-&gt;</span> s {x <span class="ot">=</span> <span class="dv">1</span>}</span>
<span id="cb337-8"><a href="#cb337-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> ()</span>
<span id="cb337-9"><a href="#cb337-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb337-10"><a href="#cb337-10" aria-hidden="true" tabindex="-1"></a><span class="ot">runExample1 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb337-11"><a href="#cb337-11" aria-hidden="true" tabindex="-1"></a>runExample1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb337-12"><a href="#cb337-12" aria-hidden="true" tabindex="-1"></a>  (result, _) <span class="ot">&lt;-</span></span>
<span id="cb337-13"><a href="#cb337-13" aria-hidden="true" tabindex="-1"></a>    runFinal</span>
<span id="cb337-14"><a href="#cb337-14" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> embedToFinal <span class="op">@</span><span class="dt">IO</span></span>
<span id="cb337-15"><a href="#cb337-15" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> runState (<span class="dt">Example</span> <span class="dv">0</span> <span class="dv">0</span>) example1</span>
<span id="cb337-16"><a href="#cb337-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> result</span></code></pre></div>
<p>And a more complex example which combines multiple effects:</p>
<div class="sourceCode" id="cb338"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb338-1"><a href="#cb338-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Polysemy</span></span>
<span id="cb338-2"><a href="#cb338-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Polysemy.Error</span></span>
<span id="cb338-3"><a href="#cb338-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Polysemy.State</span></span>
<span id="cb338-4"><a href="#cb338-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Polysemy.Trace</span></span>
<span id="cb338-5"><a href="#cb338-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb338-6"><a href="#cb338-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MyError</span> <span class="ot">=</span> <span class="dt">MyError</span></span>
<span id="cb338-7"><a href="#cb338-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb338-8"><a href="#cb338-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb338-9"><a href="#cb338-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Stateful update to Example datastructure, with errors and tracing.</span></span>
<span id="cb338-10"><a href="#cb338-10" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Members</span> &#39;[<span class="dt">Trace</span>, <span class="dt">State</span> <span class="dt">Example</span>, <span class="dt">Error</span> <span class="dt">MyError</span>] r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r ()</span>
<span id="cb338-11"><a href="#cb338-11" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb338-12"><a href="#cb338-12" aria-hidden="true" tabindex="-1"></a>  modify <span class="op">$</span> \s <span class="ot">-&gt;</span> s {x <span class="ot">=</span> <span class="dv">1</span>, y <span class="ot">=</span> <span class="dv">2</span>}</span>
<span id="cb338-13"><a href="#cb338-13" aria-hidden="true" tabindex="-1"></a>  trace <span class="st">&quot;foo&quot;</span></span>
<span id="cb338-14"><a href="#cb338-14" aria-hidden="true" tabindex="-1"></a>  throw <span class="dt">MyError</span></span>
<span id="cb338-15"><a href="#cb338-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> ()</span>
<span id="cb338-16"><a href="#cb338-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb338-17"><a href="#cb338-17" aria-hidden="true" tabindex="-1"></a><span class="ot">runExample2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb338-18"><a href="#cb338-18" aria-hidden="true" tabindex="-1"></a>runExample2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb338-19"><a href="#cb338-19" aria-hidden="true" tabindex="-1"></a>  result <span class="ot">&lt;-</span></span>
<span id="cb338-20"><a href="#cb338-20" aria-hidden="true" tabindex="-1"></a>    runFinal</span>
<span id="cb338-21"><a href="#cb338-21" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> embedToFinal <span class="op">@</span><span class="dt">IO</span></span>
<span id="cb338-22"><a href="#cb338-22" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> errorToIOFinal <span class="op">@</span><span class="dt">MyError</span></span>
<span id="cb338-23"><a href="#cb338-23" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> runState (<span class="dt">Example</span> <span class="dv">0</span> <span class="dv">0</span>)</span>
<span id="cb338-24"><a href="#cb338-24" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span> traceToIO example2</span>
<span id="cb338-25"><a href="#cb338-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> result</span></code></pre></div>
<p>Polysemy will require the following language extensions to
operate:</p>
<div class="sourceCode" id="cb339"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb339-1"><a href="#cb339-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb339-2"><a href="#cb339-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb339-3"><a href="#cb339-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb339-4"><a href="#cb339-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb339-5"><a href="#cb339-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb339-6"><a href="#cb339-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb339-7"><a href="#cb339-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb339-8"><a href="#cb339-8" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span></code></pre></div>
<p>The use of free-monads is not entirely without cost, and there are
experimental GHC plugins which can abstract away some of the overhead
from the effect stack. Code thats makes use of polysemy should enable
the following GHC flags to enable aggressive typeclass
specialisation:</p>
<ul>
<li><code>-flate-specialise</code></li>
<li><code>-fspecialise-aggressively</code></li>
</ul>
<h2 id="fused-effects">Fused Effects</h2>
<p>Fused-effects is an alternative approach to effect systems based on
an algebraic effects model. Unlike polysemy, fused-effects does not use
a free monad as an intermediate form. Fused-effects has competitive
performance compared with mtl and doesn’t require additional GHC plugins
or extension compiler fusion rules to optimise away the abstraction
overhead.</p>
<p>The <code>fused-effects</code> library exposes a constraint kind
called <code>Has</code> which annotates a type signature that contains
effectful logic. In this signature <code>m</code> is called the
<strong>carrier</strong> for the <code>sig</code> <strong>effect
signature</strong> containing the <code>eff</code> effect.</p>
<div class="sourceCode" id="cb340"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb340-1"><a href="#cb340-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Has</span> eff sig m <span class="ot">=</span> (<span class="dt">Members</span> eff sig, <span class="dt">Algebra</span> sig m)</span></code></pre></div>
<p>For example the traditional State effect is modeled by the following
datatype with three parameters. The <code>s</code> parameter is the
state object, the <code>m</code> is the effect parameter. This exposes
the same interface as <code>Control.Monad.State</code> except for the
<code>Has</code> constraint instead.</p>
<div class="sourceCode" id="cb341"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb341-1"><a href="#cb341-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">State</span> s m k</span>
<span id="cb341-2"><a href="#cb341-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Get</span> (s <span class="ot">-&gt;</span> m k)</span>
<span id="cb341-3"><a href="#cb341-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Put</span> s (m k)</span>
<span id="cb341-4"><a href="#cb341-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Functor</span>)</span>
<span id="cb341-5"><a href="#cb341-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb341-6"><a href="#cb341-6" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">Has</span> (<span class="dt">State</span> s) sig m <span class="ot">=&gt;</span> m s</span>
<span id="cb341-7"><a href="#cb341-7" aria-hidden="true" tabindex="-1"></a><span class="ot">put ::</span> <span class="dt">Has</span> (<span class="dt">State</span> s) sig m <span class="ot">=&gt;</span> s <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>The <code>Carrier</code> for the State effect is defined as
<code>StateC</code> and the evaluators for the state carrier are defined
in the same interface as <code>mtl</code> except they evaluate into a
result containing the effect parameter <code>m</code>.</p>
<div class="sourceCode" id="cb342"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb342-1"><a href="#cb342-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">StateC</span> s m a <span class="ot">=</span> <span class="dt">StateC</span> (s <span class="ot">-&gt;</span> m (s, a))</span>
<span id="cb342-2"><a href="#cb342-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Functor</span>)</span>
<span id="cb342-3"><a href="#cb342-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb342-4"><a href="#cb342-4" aria-hidden="true" tabindex="-1"></a><span class="ot">runState ::</span> s <span class="ot">-&gt;</span> <span class="dt">StateC</span> s m a <span class="ot">-&gt;</span> m (s, a)</span></code></pre></div>
<p>The evaluators for the effect lift monadic actions from an effectful
computation.</p>
<div class="sourceCode" id="cb343"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb343-1"><a href="#cb343-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runM ::</span> <span class="dt">LiftC</span> m a <span class="ot">-&gt;</span> m a</span>
<span id="cb343-2"><a href="#cb343-2" aria-hidden="true" tabindex="-1"></a><span class="ot">run ::</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Fused-effects requires the following language extensions to
operate.</p>
<div class="sourceCode" id="cb344"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb344-1"><a href="#cb344-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb344-2"><a href="#cb344-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb344-3"><a href="#cb344-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb344-4"><a href="#cb344-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span></code></pre></div>
<p><strong>Minimal Example</strong></p>
<p>A minimal example using the <code>State</code> effect to track
stateful updates to a single integral value.</p>
<div class="sourceCode" id="cb345"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb345-1"><a href="#cb345-1" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Has</span> (<span class="dt">State</span> <span class="dt">Integer</span>) sig m <span class="ot">=&gt;</span> m <span class="dt">Integer</span></span>
<span id="cb345-2"><a href="#cb345-2" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb345-3"><a href="#cb345-3" aria-hidden="true" tabindex="-1"></a>  modify (<span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb345-4"><a href="#cb345-4" aria-hidden="true" tabindex="-1"></a>  modify (<span class="op">*</span> <span class="dv">10</span>)</span>
<span id="cb345-5"><a href="#cb345-5" aria-hidden="true" tabindex="-1"></a>  get</span></code></pre></div>
<p>The evaluation of this monadic state block results in a
<code>m Integer</code> with the Algebra and Effect context. This can
then be evaluated into either <code>Identity</code> or <code>IO</code>
using <code>run</code>.</p>
<div class="sourceCode" id="cb346"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb346-1"><a href="#cb346-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ex1 ::</span> (<span class="dt">Algebra</span> sig m, <span class="dt">Effect</span> sig) <span class="ot">=&gt;</span> m <span class="dt">Integer</span></span>
<span id="cb346-2"><a href="#cb346-2" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> evalState (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Integer</span>) example1</span>
<span id="cb346-3"><a href="#cb346-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb346-4"><a href="#cb346-4" aria-hidden="true" tabindex="-1"></a><span class="ot">run1 ::</span> <span class="dt">Identity</span> <span class="dt">Integer</span></span>
<span id="cb346-5"><a href="#cb346-5" aria-hidden="true" tabindex="-1"></a>run1 <span class="ot">=</span> runM ex1</span>
<span id="cb346-6"><a href="#cb346-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb346-7"><a href="#cb346-7" aria-hidden="true" tabindex="-1"></a><span class="ot">run2 ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></span>
<span id="cb346-8"><a href="#cb346-8" aria-hidden="true" tabindex="-1"></a>run2 <span class="ot">=</span> runM ex1</span></code></pre></div>
<p><strong>Composite Effects</strong></p>
<p>Consider a more complex example which combines exceptions with
<code>Throw</code> effect with <code>State</code>. Importantly note that
functions <code>runThrow</code> and <code>evalState</code> cannot infer
the state type from the signature alone and thus require additional
annotations. This differs from <code>mtl</code> which typically has more
optimal inference.</p>
<div class="sourceCode" id="cb347"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb347-1"><a href="#cb347-1" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span></span>
<span id="cb347-2"><a href="#cb347-2" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">Has</span> (<span class="dt">State</span> (<span class="dt">Double</span>, <span class="dt">Double</span>)) sig m,</span>
<span id="cb347-3"><a href="#cb347-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Has</span> (<span class="dt">Throw</span> <span class="dt">ArithException</span>) sig m</span>
<span id="cb347-4"><a href="#cb347-4" aria-hidden="true" tabindex="-1"></a>  ) <span class="ot">=&gt;</span></span>
<span id="cb347-5"><a href="#cb347-5" aria-hidden="true" tabindex="-1"></a>  m <span class="dt">Double</span></span>
<span id="cb347-6"><a href="#cb347-6" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb347-7"><a href="#cb347-7" aria-hidden="true" tabindex="-1"></a>  (a, b) <span class="ot">&lt;-</span> get</span>
<span id="cb347-8"><a href="#cb347-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> b <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb347-9"><a href="#cb347-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> throwError <span class="dt">DivideByZero</span></span>
<span id="cb347-10"><a href="#cb347-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="fu">pure</span> (a <span class="op">/</span> b)</span>
<span id="cb347-11"><a href="#cb347-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-12"><a href="#cb347-12" aria-hidden="true" tabindex="-1"></a><span class="ot">ex2 ::</span> (<span class="dt">Algebra</span> sig m, <span class="dt">Effect</span> sig) <span class="ot">=&gt;</span> m (<span class="dt">Either</span> <span class="dt">ArithException</span> <span class="dt">Double</span>)</span>
<span id="cb347-13"><a href="#cb347-13" aria-hidden="true" tabindex="-1"></a>ex2 <span class="ot">=</span> runThrow <span class="op">$</span> evalState (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Double</span>, <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Double</span>) example2</span>
<span id="cb347-14"><a href="#cb347-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb347-15"><a href="#cb347-15" aria-hidden="true" tabindex="-1"></a><span class="ot">ex3 ::</span> (<span class="dt">Algebra</span> sig m, <span class="dt">Effect</span> sig) <span class="ot">=&gt;</span> m (<span class="dt">Either</span> <span class="dt">ArithException</span> <span class="dt">Double</span>)</span>
<span id="cb347-16"><a href="#cb347-16" aria-hidden="true" tabindex="-1"></a>ex3 <span class="ot">=</span> evalState (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Double</span>, <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Double</span>) (runThrow example2)</span></code></pre></div>
<hr/>
<h1 id="language-extensions">Language Extensions</h1>
<h2 id="philosophy">Philosophy</h2>
<p>Haskell takes a drastically different approach to language design
than most other languages as a result of being the synthesis of input
from industrial and academic users. GHC allows the core language itself
to be extended with a vast range of opt-in flags which change the
semantics of the language on a per-module or per-project basis. While
this does add a lot of complexity at first, it also adds a level of
power and flexibility for the language to evolve at a pace that is
unrivaled in the broader space of programming language design.</p>
<h2 id="classes">Classes</h2>
<p>It’s important to distinguish between different classes of GHC
language extensions: <em>general</em> and <em>specialized</em>.</p>
<p>The inherent problem with classifying extensions into general and
specialized categories is that it is a subjective classification.
Haskellers who do theorem proving research will have a very different
interpretation of Haskell than people who do web programming. Thus, we
will use the following classifications:</p>
<ul>
<li><em>Benign</em> implies both that importing the extension won’t
change the semantics of the module if not used and that enabling it
makes it no easier to shoot yourself in the foot.</li>
<li><em>Historical</em> implies that one shouldn’t use this extension,
it is in GHC purely for backwards compatibility. Sometimes these are
dangerous to enable.</li>
<li><em>Steals syntax</em> means that enabling this extension causes
certain code, that is valid in vanilla Haskell, to be no longer be
accepted. For example, <code>f $(a)</code> is the same as
<code>f $ (a)</code> in Haskell98, but <code>TemplateHaskell</code> will
interpret <code>$(a)</code> as a splice.</li>
</ul>
<p><extensions></extensions></p>
<table class="table-striped">
  <tr class="striped-header">
    <td></td>
    <td>Benign</td>
    <td>Historical</td>
    <td>Steals Syntax</td>
    <td>Use</td>
    <td>Use</td>
    <td>GHC Reference</td>
    <td>Reference</td>
  </tr>
  <tr>
    <td>AllowAmbiguousTypes</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#ambiguity">
    Ref</a></td>
    <td></td>
  </tr>
  <tr>
    <td>Arrows</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/arrow-notation.html">
    Ref</a></td>
    <td><a href="#arrows">Arrows</a></td>
  </tr>
  <tr>
    <td>AutoDeriveTypeable</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#auto-derive-typeable">
    Ref</a></td>
  </tr>
  <tr>
    <td>BangPatterns</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Strictness Annotation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/bang-patterns.html">
    Ref</a></td>
    <td><a href="#strictness-annotations">Strictness Annotations</a></td>
  </tr>
  <tr>
    <td>ApplicativeDo</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html#ffi-capi">Ref</a></td>
    <td><a href="#applicative-do">Applicative Do</td>
  </tr>
  <tr>
    <td>CApiFFI</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html#ffi-capi">Ref</a></td>
  </tr>
  <tr>
    <td>ConstrainedClassMethods</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#class-method-types">
    Ref</a></td>
  </tr>
  <tr>
    <td>ConstraintKinds</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/constraint-kind.html">
    Ref</a></td>
    <td><a href="#constraint-kinds">Constraint Kinds</a></td>
  </tr>
  <tr>
    <td>CPP</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Preprocessor</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/options-phases.html#c-pre-processor">
    Ref</a></td>
    <td><a href="#cpp">Cpp</a></td>
  </tr>
  <tr>
    <td>DataKinds</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/promotion.html">Ref</a></td>
    <td><a href="#data-kinds">Data Kinds</a></td>
  </tr>
  <tr>
    <td>DatatypeContexts</td>
    <td></td>
    <td>✓</td>
    <td></td>
    <td>Deprecated</td>
    <td>Deprecated</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#datatype-contexts">
    Ref</a></td>
  </tr>
  <tr>
    <td>DefaultSignatures</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Generic Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#class-default-signatures">
    Ref</a></td>
    <td><a href="#generic">Generic</a></td>
  </tr>
  <tr>
    <td>DeriveAnyClass</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/deriving.html#derive-any-class">
    Ref</a></td>
  </tr>
  <tr>
    <td>DeriveDataTypeable</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable">
    Ref</a></td>
    <td><a href="#typeable">Typeable</a></td>
  </tr>
  <tr>
    <td>DeriveFoldable</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable">
    Ref</a></td>
    <td><a href="#foldable-traversable">Foldable / Traversable</a></td>
  </tr>
  <tr>
    <td>DeriveFunctor</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable">
    Ref</a></td>
  </tr>
  <tr>
    <td>DeriveGeneric</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable">
    Ref</a></td>
    <td><a href="#generic">Generic</a></td>
  </tr>
  <tr>
    <td>DeriveLift</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable">
    Ref</a></td>
    <td><a href="#template-haskell">Template Haskell</a></td>
  </tr>
  <tr>
    <td>DeriveTraversable</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Deriving</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#deriving-typeable">
    Ref</a></td>
  </tr>
  <tr>
    <td>DisambiguateRecordFields</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#disambiguate-fields">
    Ref</a></td>
  </tr>
  <tr>
    <td>DuplicateRecordFields</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#disambiguate-fields">
    Ref</a></td>
    <td><a href="#duplicaterecordfields">DuplicateRecordFields</a></td>
  </tr>
  <tr>
    <td>DoRec</td>
    <td></td>
    <td>✓</td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#recursive-do-notation">
    Ref</a></td>
    <td><a href="#recursive-do">Recursive Do</a></td>
  </tr>
  <tr>
    <td>EmptyCase</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#empty-case">
    Ref</a></td>
    <td><a href="#emptycase">EmptyCase</a></td>
  </tr>
  <tr>
    <td>EmptyDataDecls</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#nullary-types">
    Ref</a></td>
    <td><a href="#void">Void</a></td>
  </tr>
  <tr>
    <td>ExistentialQuantification</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#existential-quantification">
    Ref</a></td>
    <td><a href="#existential-quantification">Existential Quantification</a></td>
  </tr>
  <tr>
    <td>ExplicitForAll</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#explicit-foralls">
    Ref</a></td>
    <td><a href="#universal-quantification">Universal Quantification</a></td>
  </tr>
  <tr>
    <td>ExplicitNamespaces</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#explicit-namespaces">
    Ref</a></td>
  </tr>
  <tr>
    <td>ExtendedDefaultRules</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/interactive-evaluation.html#extended-default-rules">
    Ref</a></td>
  </tr>
  <tr>
    <td>FlexibleContexts</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#flexible-contexts">
    Ref</a></td>
    <td><a href="#flexiblecontexts">Flexible Contexts</a></td>
  </tr>
  <tr>
    <td>FlexibleInstances</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#instance-rules">
    Ref</a></td>
    <td><a href="#flexibleinstances">Flexible Instances</a></td>
  </tr>
  <tr>
    <td>ForeignFunctionInterface</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html">Ref</a></td>
    <td><a href="#ffi">FFI</a></td>
  </tr>
  <tr>
    <td>FunctionalDependencies</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#functional-dependencies">
    Ref</a></td>
    <td><a href="#multiparam-typeclasses">Multiparam Typeclasses</a></td>
  </tr>
  <tr>
    <td>GADTs</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#gadt">
    Ref</a></td>
    <td><a href="#gadts">GADTs</a></td>
  </tr>
  <tr>
    <td>GADTSyntax</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#gadt-style">
    Ref</a></td>
    <td><a href="#gadts">GADTs</a></td>
  </tr>
  <tr>
    <td>GeneralizedNewtypeDeriving</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#newtype-deriving">
    Ref</a></td>
    <td><a href="#newtype-deriving">Newtype Deriving</a></td>
  </tr>
  <tr>
    <td>GHCForeignImportPrim</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html#ffi-prim">Ref</a></td>
    <td><a href="#cmm">Cmm</a></td>
  </tr>
  <tr>
    <td>ImplicitParams</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#implicit-parameters">
    Ref</a></td>
  </tr>
  <tr>
    <td>ImpredicativeTypes</td>
    <td></td>
    <td>✓</td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#impredicative-polymorphism">
    Ref</a></td>
    <td><a href="#impredicative-types">Impredicative Types</a></td>
  </tr>
  <tr>
    <td>IncoherentInstances</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#instance-overlap">
    Ref</a></td>
    <td><a href="#incoherentinstances">Incoherent Instances</a></td>
  </tr>
  <tr>
    <td>InstanceSigs</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#instance-sigs">
    Ref</a></td>
  </tr>
  <tr>
    <td>InterruptibleFFI</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/ffi.html#ffi-interruptible">
    Ref</a></td>
    <td><a href="#ffi">FFI</td>
  </tr>
  <tr>
    <td>KindSignatures</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#kinding">
    Ref</a></td>
    <td><a href="#kind-signatures">Kind Signatures</td>
  </tr>
  <tr>
    <td>LambdaCase</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#lambda-case">
    Ref</a></td>
    <td><a href="#lambdacase">Lambda Case</a></td>
  </tr>
  <tr>
    <td>LiberalTypeSynonyms</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#type-synonyms">
    Ref</a></td>
  </tr>
  <tr>
    <td>MagicHash</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>GHC Internals</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#magic-hash">
    Ref</a></td>
    <td><a href="#unboxed-types">Unboxed Types</a></td>
  </tr>
  <tr>
    <td>MonadComprehensions</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#monad-comprehensions">
    Ref</a></td>
  </tr>
  <tr>
    <td>MonoLocalBinds</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#mono-local-binds">
    Ref</a></td>
  </tr>
  <tr>
    <td>MonoPatBinds</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.6.3/html/users_guide/monomorphism.html">Ref</a></td>
  </tr>
  <tr>
    <td>MultiParamTypeClasses</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#multi-param-type-classes">
    Ref</a></td>
    <td><a href="#multiparam-typeclasses">Multiparam Typeclasses</a></td>
  </tr>
  <tr>
    <td>MultiWayIf</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#multi-way-if">
    Ref</a></td>
    <td><a href="#multiwayif">MultiWawyIf</a></td>
  </tr>
  <tr>
    <td>NamedFieldPuns</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#record-puns">
    Ref</a></td>
    <td><a href="#namedfieldpuns">Named Field Puns</a></td>
  </tr>
  <tr>
    <td>NegativeLiterals</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#negative-literals">
    Ref</a></td>
  </tr>
  <tr>
    <td>NoImplicitPrelude</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Import Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#rebindable-syntax">
    Ref</a></td>
    <td><a href="#custom-prelude">Custom Prelude</a></td>
  </tr>
  <tr>
    <td>NoMonomorphismRestriction</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#monomorphism">
    Ref</a></td>
    <td><a href="#monomorphism-restriction">Monomorphism Restriction</a></td>
  </tr>
  <tr>
    <td>NPlusKPatterns</td>
    <td></td>
    <td>✓</td>
    <td>✓</td>
    <td>Deprecated</td>
    <td>Deprecated</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#n-k-patterns">
    Ref</a></td>
  </tr>
  <tr>
    <td>NullaryTypeClasses</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#nullary-type-classes">
    Ref</a></td>
    <td><a href="#multiparam-typeclasses">Multiparam Typeclasses</a></td>
  </tr>
  <tr>
    <td>NumDecimals</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#num-decimals">
    Ref</a></td>
    <td><a href="#numdecimals">NumDecimals</a></td>
  </tr>
  <tr>
    <td>OverlappingInstances</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#instance-overlap">
    Ref</a></td>
    <td><a href="#overlappinginstances">Overlapping Instances</a></td>
  </tr>
  <tr>
    <td>OverloadedLabels</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Type Disambiguation</td>
    <td><a href= "">
    Ref</a></td>
    <td><a href="#overloadedlabels">Overloaded Labels</a></td>
  </tr>
  <tr>
    <td>OverloadedRecordFields</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href= "">
    Ref</a></td>
    <td><a href="#overloadedlabels">Overloaded Labels</a></td>
  </tr>
  <tr>
    <td>OverloadedLists</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#overloaded-lists">
    Ref</a></td>
    <td><a href="#overloaded-lists">Overloaded Lists</a></td>
  </tr>
  <tr>
    <td>OverloadedStrings</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#overloaded-strings">
    Ref</a></td>
    <td><a href="#string">Overloaded Strings</a></td>
  </tr>
  <tr>
    <td>PackageImports</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Import Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#package-imports">
    Ref</a></td>
    <td><a href="#package-imports">Package Imports</a></td>
  </tr>
  <tr>
    <td>ParallelArrays</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Data Parallel Haskell</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/lang-parallel.html">
    Ref</a></td>
  </tr>
  <tr>
    <td>ParallelListComp</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#parallel-list-comprehensions">
    Ref</a></td>
  </tr>
  <tr>
    <td>PartialTypeSignatures</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Interactive Typing</td>
    <td><a href=
    "https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/partial-type-signatures.html">Ref
    </a></td>
    <td><a href="#partial-type-signatures">Partial Type Signatures</a></td>
  </tr>
  <tr>
    <td>PatternGuards</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#pattern-guards">
    Ref</a></td>
    <td><a href="#pattern-guards">Pattern Guards</a></td>
  </tr>
  <tr>
    <td>PatternSynonyms</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#pattern-synonyms">
    Ref</a></td>
    <td><a href="#patternsynonyms">Pattern Synonyms</a></td>
  </tr>
  <tr>
    <td>PolyKinds</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/kind-polymorphism.html">
    Ref</a></td>
    <td><a href="#kind-polymorphism">Kind Polymorphism</a></td>
  </tr>
  <tr>
    <td>PolymorphicComponents</td>
    <td></td>
    <td>✓</td>
    <td></td>
    <td>Specialized</td>
    <td>Deprecated</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#universal-quantification">
    Ref</a></td>
  </tr>
  <tr>
    <td>PostfixOperators</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#postfix-operators">
    Ref</a></td>
  </tr>
  <tr>
    <td>QuasiQuotes</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Metaprogramming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/template-haskell.html#th-quasiquotation">
    Ref</a></td>
    <td><a href="#quasiquotation">QuasiQuotation</a></td>
  </tr>
  <tr>
    <td>Rank2Types</td>
    <td></td>
    <td>✓</td>
    <td></td>
    <td>Specialized</td>
    <td>Historical Artifact</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#universal-quantification">
    Ref</a></td>
    <td><a href="#rank-n-types">Rank N Types</a></td>
  </tr>
  <tr>
    <td>RankNTypes</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#universal-quantification">
    Ref</a></td>
    <td><a href="#rank-n-types">Rank N Types</a></td>
  </tr>
  <tr>
    <td>RebindableSyntax</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Metaprogramming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#rebindable-syntax">
    Ref</a></td>
    <td><a href="#indexed-monads">Indexed Monads</a></td>
  </tr>
  <tr>
    <td>RecordWildCards</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#record-wildcards">
    Ref</a></td>
    <td><a href="#recordwildcards">Record Wildcards</a></td>
  </tr>
  <tr>
    <td>RecursiveDo</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#recursive-do-notation">
    Ref</a></td>
    <td><a href="#monadfix">MonadFix</a></td>
  </tr>
  <tr>
    <td>RelaxedPolyRec</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#typing-binds">
    Ref</a></td>
  </tr>
  <tr>
    <td>RoleAnnotations</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Type Disambiguation</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/roles.html">Ref</a></td>
    <td><a href="#roles">Roles</a></td>
  </tr>
  <tr>
    <td>Safe</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Security Auditing</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/safe-haskell.html">Ref</a></td>
    <td><a href="#safe-haskell">Safe Haskell</a></td>
  </tr>
  <tr>
    <td>SafeImports</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Security Auditing</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/safe-haskell.html">Ref</a></td>
    <td><a href="#safe-haskell">Safe Haskell</a></td>
  </tr>
  <tr>
    <td>ScopedTypeVariables</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/other-type-extensions.html#scoped-type-variables">
    Ref</a></td>
    <td><a href="#scoped-type-variables">Scoped Type Variables</a></td>
  </tr>
  <tr>
    <td>StandaloneDeriving</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#stand-alone-deriving">
    Ref</a></td>
  </tr>
  <tr>
    <td>StaticPointers</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Distributed Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/deriving.html#stand-alone-deriving">
    Ref</a></td>
  </tr>
  <tr>
    <td>Strict</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Strictness Annotations</td>
    <td><a href=
    "https://downloads.haskell.org/~ghc/master/users-guide//glasgow_exts.html#ghc-flag--XStrict" >
    Ref</a></td>
    <td><a href="#strict-haskell">Strict Haskell</a></td>
  </tr>
  <tr>
    <td>StrictData</td>
    <td></td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Strictness Annotations</td>
    <td><a href=
    "https://downloads.haskell.org/~ghc/master/users-guide//glasgow_exts.html#ghc-flag--XStrict" >
    Ref</a></td>
    <td><a href="#strict-haskell">Strict Haskell</a></td>
  </tr>
  <tr>
    <td>TemplateHaskell</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Metaprogramming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/template-haskell.html">
    Ref</a></td>
    <td><a href="#template-haskell">Template Haskell</a></td>
  </tr>
  <tr>
    <td>TraditionalRecordSyntax</td>
    <td></td>
    <td>✓</td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Historical Artifact</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#traditional-record-syntax">
    Ref</a></td>
    <td><a href="#historical-extensions">Historical Extensions</a></td>
  </tr>
  <tr>
    <td>TransformListComp</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#generalised-list-comprehensions">
    Ref</a></td>
  </tr>
  <tr>
    <td>Trustworthy</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Security Auditing</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/safe-haskell.html">Ref</a></td>
    <td><a href="#safe-haskell">Safe Haskell</a></td>
  </tr>
  <tr>
    <td>TupleSections</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#tuple-sections">
    Ref</a></td>
    <td><a href="#tuplesections">Tuple Sections</a></td>
  </tr>
  <tr>
    <td>TypeApplications</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-families.html">
    Ref</a></td>
  </tr>
  <tr>
    <td>TypeFamilies</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-families.html">
    Ref</a></td>
    <td><a href="#type-families">Type Families</a></td>
  </tr>
  <tr>
    <td>TypeHoles</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Interactive Typing</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/typed-holes.html">Ref</a></td>
    <td><a href="#type-holes">Type Holes</a></td>
  </tr>
  <tr>
    <td>TypeInType</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href="">Ref</a></td>
  </tr>
  <tr>
    <td>TypeOperators</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/data-type-extensions.html#type-operators">
    Ref</a></td>
    <td><a href="#manual-proofs">Manual Proofs</a></td>
  </tr>
  <tr>
    <td>TypeSynonymInstances</td>
    <td>✓</td>
    <td></td>
    <td></td>
    <td>General</td>
    <td>Typeclass Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#flexible-instance-head">
    Ref</a></td>
    <td><a href="#typesynonyminstances">Type Synonym Instances</a></td>
  </tr>
  <tr>
    <td>UnboxedTuples</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/primitives.html#unboxed-tuples">
    Ref</a></td>
  </tr>
  <tr>
    <td>UndecidableInstances</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Typelevel Programming</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/type-class-extensions.html#undecidable-instances">
    Ref</a></td>
    <td><a href="#multiparam-typeclasses">Multiparam Typeclasses</a></td>
  </tr>
  <tr>
    <td>UnicodeSyntax</td>
    <td></td>
    <td></td>
    <td>✓</td>
    <td>Specialized</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#unicode-syntax">
    Ref</a></td>
  </tr>
  <tr>
    <td>UnliftedFFITypes</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>FFI</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/primitives.html">Ref</a></td>
    <td><a href="#cmm">Cmm</a></td>
  </tr>
  <tr>
    <td>Unsafe</td>
    <td></td>
    <td></td>
    <td></td>
    <td>Specialized</td>
    <td>Security Auditing</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/safe-haskell.html">Ref</a></td>
    <td><a href="#safe-haskell">Safe Haskell</a></td>
  </tr>
  <tr>
    <td>ViewPatterns</td>
    <td>✓</td>
    <td></td>
    <td>✓</td>
    <td>General</td>
    <td>Syntax Extension</td>
    <td><a href=
    "http://www.haskell.org/ghc/docs/7.8.4/html/users_guide/syntax-extns.html#view-patterns">
    Ref</a></td>
    <td><a href="#viewpatterns">View Patterns</a></td>
  </tr>
</table>
<p>The golden source of truth for language extensions is the official
GHC user’s guide which contains a plethora of information on the details
of these extensions.</p>
<p>See: <a
href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/lang.html">GHC
Extension Reference</a></p>
<h2 id="extension-dependencies">Extension Dependencies</h2>
<p>Some language extensions will implicitly enable other language
extensions for their operation. The table below shows the dependencies
between various extensions and which sets are implied.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Extension</th>
<th style="text-align: left;">Implies</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">TypeFamilyDependencies</td>
<td style="text-align: left;">TypeFamilies</td>
</tr>
<tr class="even">
<td style="text-align: left;">TypeInType</td>
<td style="text-align: left;">PolyKinds, DataKinds, KindSignatures</td>
</tr>
<tr class="odd">
<td style="text-align: left;">PolyKinds</td>
<td style="text-align: left;">KindSignatures</td>
</tr>
<tr class="even">
<td style="text-align: left;">ScopedTypeVariables</td>
<td style="text-align: left;">ExplicitForAll</td>
</tr>
<tr class="odd">
<td style="text-align: left;">RankNTypes</td>
<td style="text-align: left;">ExplicitForAll</td>
</tr>
<tr class="even">
<td style="text-align: left;">ImpredicativeTypes</td>
<td style="text-align: left;">RankNTypes</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TemplateHaskell</td>
<td style="text-align: left;">TemplateHaskellQuotes</td>
</tr>
<tr class="even">
<td style="text-align: left;">Strict</td>
<td style="text-align: left;">StrictData</td>
</tr>
<tr class="odd">
<td style="text-align: left;">RebindableSyntax</td>
<td style="text-align: left;">NoImplicitPrelude</td>
</tr>
<tr class="even">
<td style="text-align: left;">TypeOperators</td>
<td style="text-align: left;">ExplicitNamespaces</td>
</tr>
<tr class="odd">
<td style="text-align: left;">LiberalTypeSynonyms</td>
<td style="text-align: left;">ExplicitForAll</td>
</tr>
<tr class="even">
<td style="text-align: left;">ExistentialQuantification</td>
<td style="text-align: left;">ExplicitForAll</td>
</tr>
<tr class="odd">
<td style="text-align: left;">GADTs</td>
<td style="text-align: left;">MonoLocalBinds, GADTSyntax</td>
</tr>
<tr class="even">
<td style="text-align: left;">DuplicateRecordFields</td>
<td style="text-align: left;">DisambiguateRecordFields</td>
</tr>
<tr class="odd">
<td style="text-align: left;">RecordWildCards</td>
<td style="text-align: left;">DisambiguateRecordFields</td>
</tr>
<tr class="even">
<td style="text-align: left;">DeriveTraversable</td>
<td style="text-align: left;">DeriveFoldable, DeriveFunctor</td>
</tr>
<tr class="odd">
<td style="text-align: left;">MultiParamTypeClasses</td>
<td style="text-align: left;">ConstrainedClassMethods</td>
</tr>
<tr class="even">
<td style="text-align: left;">DerivingVia</td>
<td style="text-align: left;">DerivingStrategies</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FunctionalDependencies</td>
<td style="text-align: left;">MultiParamTypeClasses</td>
</tr>
<tr class="even">
<td style="text-align: left;">FlexibleInstances</td>
<td style="text-align: left;">TypeSynonymInstances</td>
</tr>
<tr class="odd">
<td style="text-align: left;">TypeFamilies</td>
<td style="text-align: left;">MonoLocalBinds, KindSignatures,
ExplicitNamespaces</td>
</tr>
<tr class="even">
<td style="text-align: left;">IncoherentInstances</td>
<td style="text-align: left;">OverlappingInstances</td>
</tr>
</tbody>
</table>
<h2 id="the-benign">The Benign</h2>
<p>It’s not obvious which extensions are the most common but it’s fairly
safe to say that these extensions are benign and are safely used
extensively:</p>
<ul>
<li><a href="#custom-preludes">NoImplicitPrelude</a></li>
<li><a href="#overloadedstrings">OverloadedStrings</a></li>
<li><a href="#lambdacase">LambdaCase</a></li>
<li><a href="#flexiblecontexts">FlexibleContexts</a></li>
<li><a href="#flexibleinstances">FlexibleInstances</a></li>
<li><a href="#newtype-deriving">GeneralizedNewtypeDeriving</a></li>
<li><a href="#typesynonyminstances">TypeSynonymInstances</a></li>
<li><a href="#multiParam-typeclasses">MultiParamTypeClasses</a></li>
<li><a href="#multiParam-typeclasses">FunctionalDependencies</a></li>
<li><a
href="#monomorphism-restriction">NoMonomorphismRestriction</a></li>
<li><a href="#gadts">GADTs</a></li>
<li><a href="#bangpatterns">BangPatterns</a></li>
<li><a href="#derivegeneric">DeriveGeneric</a></li>
<li><a href="#deriveanyclass">DeriveAnyClass</a></li>
<li><a href="#derivingstrategies">DerivingStrategies</a></li>
<li><a href="#scoped-type-variables">ScopedTypeVariables</a></li>
</ul>
<h2 id="the-advanced">The Advanced</h2>
<p>These extensions are typically used by advanced projects that push
the limits of what is possible with Haskell to enforce complex
invariants and very type-safe APIs.</p>
<ul>
<li><a href="#promotion">PolyKinds</a></li>
<li><a href="#promotion">DataKinds</a></li>
<li><a href="#derivingvia">DerivingVia</a></li>
<li><a href="#gadts">GADTs</a></li>
<li>RankNTypes</li>
<li><a href="#quantification">ExistentialQuantification</a></li>
<li><a href="#type-families">TypeFamilies</a></li>
<li><a href="#promoted-syntax">TypeOperators</a></li>
<li><a href="#promoted-syntax">TypeApplications</a></li>
<li>UndecidableInstances</li>
</ul>
<h2 id="the-lowlevel">The Lowlevel</h2>
<p>These extensions are typically used by low-level libraries that are
striving for optimal performance or need to integrate with foreign
functions and native code. Most of these are used to manipulate base
machine types and interface directly with the low-level byte
representations of data structures.</p>
<ul>
<li><a href="#cpp">CPP</a></li>
<li><a href="#bangpatterns">BangPatterns</a></li>
<li><a href="#cpp">CApiFFI</a></li>
<li><a href="#strict">Strict</a></li>
<li><a href="#strictdata">StrictData</a></li>
<li><a href="#roles">RoleAnnotations</a></li>
<li><a href="#ffi">ForeignFunctionInterface</a></li>
<li><a href="#ffi">InterruptibleFFI</a></li>
<li><a href="#ffi">UnliftedFFITypes</a></li>
<li><a href="#primops">MagicHash</a></li>
<li><a href="#unboxed-types">UnboxedSums</a></li>
<li><a href="#unboxed-types">UnboxedTuples</a></li>
</ul>
<h2 id="the-dangerous">The Dangerous</h2>
<p>GHC’s typechecker sometimes casually tells us to enable language
extensions when it can’t solve certain problems. Unless you know what
you’re doing, these extensions almost always indicate a design flaw and
shouldn’t be turned on to remedy the error at hand, as much as GHC might
suggest otherwise!</p>
<ul>
<li>AllowAmbiguousTypes</li>
<li>DatatypeContexts</li>
<li><a href="#multiparam-typeclasses">OverlappingInstances</a></li>
<li><a href="#incoherentinstances">IncoherentInstances</a></li>
<li><a href="#impredicative-types">ImpredicativeTypes</a></li>
</ul>
<h2 id="nomonomorphismrestriction">NoMonomorphismRestriction</h2>
<p>The NoMonomorphismRestriction allows us to disable the monomorphism
restriction typing rule GHC uses by default. See <a
href="#monomorphism-restriction">monomorphism restriction</a>.</p>
<p>For example, if we load the following module into GHCi</p>
<div class="sourceCode" id="cb348"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb348-1"><a href="#cb348-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Bad</span> (foo,bar) <span class="kw">where</span></span>
<span id="cb348-2"><a href="#cb348-2" aria-hidden="true" tabindex="-1"></a>foo x y <span class="ot">=</span> x <span class="op">+</span> y</span>
<span id="cb348-3"><a href="#cb348-3" aria-hidden="true" tabindex="-1"></a>bar <span class="ot">=</span> foo <span class="dv">1</span></span></code></pre></div>
<p>And then we attempt to call the function <code>bar</code> with a
Double, we get a type error:</p>
<div class="sourceCode" id="cb349"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb349-1"><a href="#cb349-1" aria-hidden="true" tabindex="-1"></a><span class="ex">λ:</span> bar 1.1</span>
<span id="cb349-2"><a href="#cb349-2" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;</span>:2:5: <span class="ex">error:</span></span>
<span id="cb349-3"><a href="#cb349-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">•</span> No instance for <span class="er">(</span><span class="ex">Fractional</span> Integer<span class="kw">)</span></span>
<span id="cb349-4"><a href="#cb349-4" aria-hidden="true" tabindex="-1"></a>      <span class="ex">arising</span> from the literal ‘1.1’</span>
<span id="cb349-5"><a href="#cb349-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">•</span> In the first argument of ‘bar’, namely ‘1.1’</span>
<span id="cb349-6"><a href="#cb349-6" aria-hidden="true" tabindex="-1"></a>      <span class="ex">In</span> the expression: bar 1.1</span>
<span id="cb349-7"><a href="#cb349-7" aria-hidden="true" tabindex="-1"></a>      <span class="ex">In</span> an equation for ‘it’: it = bar 1.1</span></code></pre></div>
<p>The problem is that GHC has inferred an overly specific type:</p>
<div class="sourceCode" id="cb350"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb350-1"><a href="#cb350-1" aria-hidden="true" tabindex="-1"></a><span class="ex">λ:</span> :t bar</span>
<span id="cb350-2"><a href="#cb350-2" aria-hidden="true" tabindex="-1"></a><span class="ex">bar</span> :: Integer <span class="at">-</span><span class="op">&gt;</span> Integer</span></code></pre></div>
<p>We can prevent GHC from specializing the type with this
extension:</p>
<div class="sourceCode" id="cb351"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb351-1"><a href="#cb351-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span></span>
<span id="cb351-2"><a href="#cb351-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb351-3"><a href="#cb351-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Good</span> (foo,bar) <span class="kw">where</span></span>
<span id="cb351-4"><a href="#cb351-4" aria-hidden="true" tabindex="-1"></a>foo x y <span class="ot">=</span> x <span class="op">+</span> y</span>
<span id="cb351-5"><a href="#cb351-5" aria-hidden="true" tabindex="-1"></a>bar <span class="ot">=</span> foo <span class="dv">1</span></span></code></pre></div>
<p>Now everything will work as expected:</p>
<div class="sourceCode" id="cb352"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb352-1"><a href="#cb352-1" aria-hidden="true" tabindex="-1"></a><span class="ex">λ:</span> :t bar</span>
<span id="cb352-2"><a href="#cb352-2" aria-hidden="true" tabindex="-1"></a><span class="ex">bar</span> :: Num a =<span class="op">&gt;</span> a <span class="at">-</span><span class="op">&gt;</span> a</span></code></pre></div>
<h2 id="extendeddefaultrules">ExtendedDefaultRules</h2>
<p>In the absence of explicit type signatures, Haskell normally resolves
ambiguous literals using several defaulting rules. When an ambiguous
literal is typechecked, if at least one of its typeclass constraints is
numeric and all of its classes are standard library classes, the
module’s default list is consulted, and the first type from the list
that will satisfy the context of the type variable is instantiated. For
instance, given the following default rules</p>
<div class="sourceCode" id="cb353"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb353-1"><a href="#cb353-1" aria-hidden="true" tabindex="-1"></a>default (<span class="dt">C1</span> a,<span class="op">...</span>,<span class="dt">Cn</span> a)</span></code></pre></div>
<p>The following set of heuristics is used to determine what to
instantiate the ambiguous type variable to.</p>
<ol type="1">
<li>The type variable <code>a</code> appears in no other
constraints</li>
<li>All the classes <code>Ci</code> are standard.</li>
<li>At least one of the classes <code>Ci</code> is numerical.</li>
</ol>
<p>The standard <code>default</code> definition is implicitly defined as
<code>(Integer, Double)</code></p>
<p>This is normally fine, but sometimes we’d like more granular control
over defaulting. The <code>-XExtendedDefaultRules</code> loosens the
restriction that we’re constrained with working on Numerical typeclasses
and the constraint that we can only work with standard library classes.
For example, if we’d like to have our string literals (using
<code>-XOverloadedStrings</code>) automatically default to the more
efficient <code>Text</code> implementation instead of
<code>String</code> we can twiddle the flag and GHC will perform the
right substitution without the need for an explicit annotation on every
string literal.</p>
<div class="sourceCode" id="cb354"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb354-1"><a href="#cb354-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb354-2"><a href="#cb354-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExtendedDefaultRules #-}</span></span>
<span id="cb354-3"><a href="#cb354-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb354-4"><a href="#cb354-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb354-5"><a href="#cb354-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb354-6"><a href="#cb354-6" aria-hidden="true" tabindex="-1"></a>default (<span class="dt">T.Text</span>)</span>
<span id="cb354-7"><a href="#cb354-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb354-8"><a href="#cb354-8" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="st">&quot;foo&quot;</span></span></code></pre></div>
<p>For code typed at the GHCi prompt, the
<code>-XExtendedDefaultRules</code> flag is always on, and cannot be
switched off.</p>
<p>See: <a href="#monomorphism-restriction">Monomorphism
Restriction</a></p>
<h2 id="safe-haskell">Safe Haskell</h2>
<p>The Safe Haskell language extensions allow us to restrict the use of
unsafe language features using <code>-XSafe</code> which restricts the
import of modules which are themselves marked as Safe. It also forbids
the use of certain language extensions (<code>-XTemplateHaskell</code>)
which can be used to produce unsafe code. The primary use case of these
extensions is security auditing of codebases for compliance
purposes.</p>
<div class="sourceCode" id="cb355"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb355-1"><a href="#cb355-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE Safe #-}</span></span>
<span id="cb355-2"><a href="#cb355-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE Trustworthy #-}</span></span></code></pre></div>
<div class="sourceCode" id="cb356"
data-include="src/04-extensions/safe.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb356-1"><a href="#cb356-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE Safe #-}</span></span>
<span id="cb356-2"><a href="#cb356-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb356-3"><a href="#cb356-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Unsafe.Coerce</span></span>
<span id="cb356-4"><a href="#cb356-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO.Unsafe</span></span>
<span id="cb356-5"><a href="#cb356-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb356-6"><a href="#cb356-6" aria-hidden="true" tabindex="-1"></a><span class="ot">bad1 ::</span> <span class="dt">String</span></span>
<span id="cb356-7"><a href="#cb356-7" aria-hidden="true" tabindex="-1"></a>bad1 <span class="ot">=</span> unsafePerformIO <span class="fu">getLine</span></span>
<span id="cb356-8"><a href="#cb356-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb356-9"><a href="#cb356-9" aria-hidden="true" tabindex="-1"></a><span class="ot">bad2 ::</span> a</span>
<span id="cb356-10"><a href="#cb356-10" aria-hidden="true" tabindex="-1"></a>bad2 <span class="ot">=</span> unsafeCoerce <span class="fl">3.14</span> ()</span></code></pre></div>
<div class="sourceCode" id="cb357"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb357-1"><a href="#cb357-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Unsafe.Coerce</span><span class="op">:</span> <span class="dt">Can&#39;t</span> be safely imported<span class="op">!</span></span>
<span id="cb357-2"><a href="#cb357-2" aria-hidden="true" tabindex="-1"></a><span class="dt">The</span> <span class="kw">module</span> itself isn&#39;t safe<span class="op">.</span></span></code></pre></div>
<p>See: <a href="https://ghc.haskell.org/trac/ghc/wiki/SafeHaskell">Safe
Haskell</a></p>
<h2 id="partialtypesignatures">PartialTypeSignatures</h2>
<p>Normally a function is either given a full explicit type signature or
none at all. The partial type signature extension allows something in
between.</p>
<p>Partial types may be used to avoid writing uninteresting pieces of
the signature, which can be convenient in development:</p>
<div class="sourceCode" id="cb358"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb358-1"><a href="#cb358-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PartialTypeSignatures #-}</span></span>
<span id="cb358-2"><a href="#cb358-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb358-3"><a href="#cb358-3" aria-hidden="true" tabindex="-1"></a><span class="ot">triple ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> _</span>
<span id="cb358-4"><a href="#cb358-4" aria-hidden="true" tabindex="-1"></a>triple i <span class="ot">=</span> (i,i,i)</span></code></pre></div>
<p>If the <code>-Wpartial-type-signatures</code> GHC option is set,
partial types will still trigger warnings.</p>
<p>See:</p>
<ul>
<li><a
href="https://ghc.haskell.org/trac/ghc/wiki/PartialTypeSignatures">Partial
Type Signatures</a></li>
</ul>
<h2 id="recursivedo">RecursiveDo</h2>
<p>Recursive do notation allows for the use of self-reference
expressions on both sides of a monadic bind. For instance the following
example uses lazy evaluation to generate an infinite list. This is
sometimes used to instantiate a cyclic datatype inside a monadic context
where the datatype needs to hold a reference to itself.</p>
<div class="sourceCode" id="cb359"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb359-1"><a href="#cb359-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecursiveDo #-}</span></span>
<span id="cb359-2"><a href="#cb359-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb359-3"><a href="#cb359-3" aria-hidden="true" tabindex="-1"></a><span class="ot">justOnes ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]</span>
<span id="cb359-4"><a href="#cb359-4" aria-hidden="true" tabindex="-1"></a>justOnes <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb359-5"><a href="#cb359-5" aria-hidden="true" tabindex="-1"></a>  rec xs <span class="ot">&lt;-</span> <span class="dt">Just</span> (<span class="dv">1</span><span class="op">:</span>xs)</span>
<span id="cb359-6"><a href="#cb359-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="fu">map</span> <span class="fu">negate</span> xs)</span></code></pre></div>
<p>See: <a
href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#the-recursive-do-notation">Recursive
Do Notation</a></p>
<h2 id="applicativedo">ApplicativeDo</h2>
<p>By default GHC desugars do-notation to use implicit invocations of
bind and return. With normal monad sugar the following…</p>
<div class="sourceCode" id="cb360"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb360-1"><a href="#cb360-1" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (a, b, c)</span>
<span id="cb360-2"><a href="#cb360-2" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb360-3"><a href="#cb360-3" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> f</span>
<span id="cb360-4"><a href="#cb360-4" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> g</span>
<span id="cb360-5"><a href="#cb360-5" aria-hidden="true" tabindex="-1"></a>  c <span class="ot">&lt;-</span> h</span>
<span id="cb360-6"><a href="#cb360-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (a, b, c)</span></code></pre></div>
<p>… desugars into:</p>
<div class="sourceCode" id="cb361"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb361-1"><a href="#cb361-1" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (a, b, c)</span>
<span id="cb361-2"><a href="#cb361-2" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span></span>
<span id="cb361-3"><a href="#cb361-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span></span>
<span id="cb361-4"><a href="#cb361-4" aria-hidden="true" tabindex="-1"></a>  g <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span></span>
<span id="cb361-5"><a href="#cb361-5" aria-hidden="true" tabindex="-1"></a>    h <span class="op">&gt;&gt;=</span> \c <span class="ot">-&gt;</span></span>
<span id="cb361-6"><a href="#cb361-6" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> (a, b, c)</span></code></pre></div>
<p>With <code>ApplicativeDo</code> this instead desugars into use of
applicative combinators and a laxer Applicative constraint.</p>
<div class="sourceCode" id="cb362"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb362-1"><a href="#cb362-1" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> m (a, b, c)</span>
<span id="cb362-2"><a href="#cb362-2" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb362-3"><a href="#cb362-3" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> f</span>
<span id="cb362-4"><a href="#cb362-4" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> g</span>
<span id="cb362-5"><a href="#cb362-5" aria-hidden="true" tabindex="-1"></a>  c <span class="ot">&lt;-</span> h</span>
<span id="cb362-6"><a href="#cb362-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (a, b, c)</span></code></pre></div>
<p>Which is equivalent to the traditional notation.</p>
<div class="sourceCode" id="cb363"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb363-1"><a href="#cb363-1" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> m (a, b, c)</span>
<span id="cb363-2"><a href="#cb363-2" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> (,,) <span class="op">&lt;$&gt;</span> f <span class="op">&lt;*&gt;</span> g <span class="op">&lt;*&gt;</span> h</span></code></pre></div>
<h2 id="patternguards">PatternGuards</h2>
<p>Pattern guards are an extension to the pattern matching syntax. Given
a <code>&lt;-</code> pattern qualifier, the right hand side is evaluated
and matched against the pattern on the left. If the match fails then the
whole guard fails and the next equation is tried. If it succeeds, then
the appropriate binding takes place, and the next qualifier is
matched.</p>
<div class="sourceCode" id="cb364"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb364-1"><a href="#cb364-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PatternGuards #-}</span></span>
<span id="cb364-2"><a href="#cb364-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb364-3"><a href="#cb364-3" aria-hidden="true" tabindex="-1"></a>combine env x y</span>
<span id="cb364-4"><a href="#cb364-4" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span> <span class="dt">Just</span> a <span class="ot">&lt;-</span> <span class="fu">lookup</span> x env</span>
<span id="cb364-5"><a href="#cb364-5" aria-hidden="true" tabindex="-1"></a>   , <span class="dt">Just</span> b <span class="ot">&lt;-</span> <span class="fu">lookup</span> y env</span>
<span id="cb364-6"><a href="#cb364-6" aria-hidden="true" tabindex="-1"></a>   <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> a <span class="op">+</span> b</span>
<span id="cb364-7"><a href="#cb364-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb364-8"><a href="#cb364-8" aria-hidden="true" tabindex="-1"></a>   <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<h2 id="viewpatterns">ViewPatterns</h2>
<p>View patterns are like pattern guards that can be nested inside of
other patterns. They are a convenient way of pattern-matching against
values of algebraic data types.</p>
<div class="sourceCode" id="cb365"
data-include="src/04-extensions/views.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb365-1"><a href="#cb365-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ViewPatterns #-}</span></span>
<span id="cb365-2"><a href="#cb365-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span></span>
<span id="cb365-3"><a href="#cb365-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb365-4"><a href="#cb365-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Safe</span></span>
<span id="cb365-5"><a href="#cb365-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb365-6"><a href="#cb365-6" aria-hidden="true" tabindex="-1"></a><span class="ot">lookupDefault ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [(a,b)] <span class="ot">-&gt;</span> b</span>
<span id="cb365-7"><a href="#cb365-7" aria-hidden="true" tabindex="-1"></a>lookupDefault k _ (<span class="fu">lookup</span> k <span class="ot">-&gt;</span> <span class="dt">Just</span> s) <span class="ot">=</span> s</span>
<span id="cb365-8"><a href="#cb365-8" aria-hidden="true" tabindex="-1"></a>lookupDefault _ d _ <span class="ot">=</span> d</span>
<span id="cb365-9"><a href="#cb365-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb365-10"><a href="#cb365-10" aria-hidden="true" tabindex="-1"></a><span class="ot">headTup ::</span> (a, [t]) <span class="ot">-&gt;</span> [t]</span>
<span id="cb365-11"><a href="#cb365-11" aria-hidden="true" tabindex="-1"></a>headTup (headMay <span class="op">.</span> <span class="fu">snd</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> n) <span class="ot">=</span> [n]</span>
<span id="cb365-12"><a href="#cb365-12" aria-hidden="true" tabindex="-1"></a>headTup _ <span class="ot">=</span> []</span>
<span id="cb365-13"><a href="#cb365-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb365-14"><a href="#cb365-14" aria-hidden="true" tabindex="-1"></a><span class="ot">headNil ::</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb365-15"><a href="#cb365-15" aria-hidden="true" tabindex="-1"></a>headNil (headMay <span class="ot">-&gt;</span> <span class="dt">Just</span> x) <span class="ot">=</span> [x]</span>
<span id="cb365-16"><a href="#cb365-16" aria-hidden="true" tabindex="-1"></a>headNil _ <span class="ot">=</span> []</span></code></pre></div>
<h2 id="tuplesections">TupleSections</h2>
<p>The TupleSections syntax extension allows tuples to be constructed
similar to how operator sections. With this extension enabled, tuples of
arbitrary size can be “partially” specified with commas and values given
for specific positions in the tuple. For example for a 2-tuple:</p>
<div class="sourceCode" id="cb366"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb366-1"><a href="#cb366-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TupleSections #-}</span></span>
<span id="cb366-2"><a href="#cb366-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb366-3"><a href="#cb366-3" aria-hidden="true" tabindex="-1"></a><span class="ot">first ::</span> a <span class="ot">-&gt;</span> (a, <span class="dt">Bool</span>)</span>
<span id="cb366-4"><a href="#cb366-4" aria-hidden="true" tabindex="-1"></a>first <span class="ot">=</span> (,<span class="dt">True</span>)</span>
<span id="cb366-5"><a href="#cb366-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb366-6"><a href="#cb366-6" aria-hidden="true" tabindex="-1"></a><span class="ot">second ::</span> a <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, a)</span>
<span id="cb366-7"><a href="#cb366-7" aria-hidden="true" tabindex="-1"></a>second <span class="ot">=</span> (<span class="dt">True</span>,)</span></code></pre></div>
<p>An example for a 7-tuple where three values are specified in the
section.</p>
<div class="sourceCode" id="cb367"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb367-1"><a href="#cb367-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> t <span class="ot">-&gt;</span> t1 <span class="ot">-&gt;</span> t2 <span class="ot">-&gt;</span> t3 <span class="ot">-&gt;</span> (t, (), t1, (), (), t2, t3)</span>
<span id="cb367-2"><a href="#cb367-2" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> (,(),,(),(),,)</span></code></pre></div>
<h2 id="postfix-operators">Postfix Operators</h2>
<p>The postfix operators extensions allows user-defined operators that
are placed after expressions. For example, using this extension, we
could define a postfix factorial function.</p>
<div class="sourceCode" id="cb368"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb368-1"><a href="#cb368-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PostfixOperators #-}</span></span>
<span id="cb368-2"><a href="#cb368-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb368-3"><a href="#cb368-3" aria-hidden="true" tabindex="-1"></a><span class="ot">(!) ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb368-4"><a href="#cb368-4" aria-hidden="true" tabindex="-1"></a>(<span class="op">!</span>) n <span class="ot">=</span> <span class="fu">product</span> [<span class="dv">1</span><span class="op">..</span>n]</span>
<span id="cb368-5"><a href="#cb368-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb368-6"><a href="#cb368-6" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">Integer</span></span>
<span id="cb368-7"><a href="#cb368-7" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> (<span class="dv">52</span><span class="op">!</span>)</span></code></pre></div>
<h2 id="multiwayif">MultiWayIf</h2>
<p>Multi-way if expands traditional if statements to allow pattern match
conditions that are equivalent to a chain of if-then-else statements.
This allows us to write “pattern matching predicates” on a value. This
alters the syntax of Haskell language.</p>
<div class="sourceCode" id="cb369"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb369-1"><a href="#cb369-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiWayIf #-}</span></span>
<span id="cb369-2"><a href="#cb369-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb369-3"><a href="#cb369-3" aria-hidden="true" tabindex="-1"></a><span class="ot">bmiTell ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb369-4"><a href="#cb369-4" aria-hidden="true" tabindex="-1"></a>bmiTell bmi <span class="ot">=</span> <span class="kw">if</span></span>
<span id="cb369-5"><a href="#cb369-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> bmi <span class="op">&lt;=</span> <span class="fl">18.5</span> <span class="ot">-&gt;</span> <span class="st">&quot;Underweight.&quot;</span></span>
<span id="cb369-6"><a href="#cb369-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> bmi <span class="op">&lt;=</span> <span class="fl">25.0</span> <span class="ot">-&gt;</span> <span class="st">&quot;Average weight.&quot;</span></span>
<span id="cb369-7"><a href="#cb369-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> bmi <span class="op">&lt;=</span> <span class="fl">30.0</span> <span class="ot">-&gt;</span> <span class="st">&quot;Overweight.&quot;</span></span>
<span id="cb369-8"><a href="#cb369-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span>   <span class="ot">-&gt;</span> <span class="st">&quot;Clinically overweight.&quot;</span></span></code></pre></div>
<h2 id="emptycase">EmptyCase</h2>
<p>GHC normally requires at least one pattern branch in a case
statement; this restriction can be relaxed with the
<code>EmptyCase</code> language extension. The case statement then
immediately yields a <code>Non-exhaustive patterns in case</code> if
evaluated. For example, the following will compile using this language
pragma:</p>
<div class="sourceCode" id="cb370"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb370-1"><a href="#cb370-1" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> <span class="kw">case</span> <span class="kw">of</span></span></code></pre></div>
<h2 id="lambdacase">LambdaCase</h2>
<p>For case statements, the language extension <code>LambdaCase</code>
allows the elimination of redundant free variables introduced purely for
the case of pattern matching on.</p>
<p>Without <em>LambdaCase</em>:</p>
<div class="sourceCode" id="cb371"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb371-1"><a href="#cb371-1" aria-hidden="true" tabindex="-1"></a>\temp <span class="ot">-&gt;</span> <span class="kw">case</span> temp <span class="kw">of</span></span>
<span id="cb371-2"><a href="#cb371-2" aria-hidden="true" tabindex="-1"></a>  p1 <span class="ot">-&gt;</span> <span class="dv">32</span></span>
<span id="cb371-3"><a href="#cb371-3" aria-hidden="true" tabindex="-1"></a>  p2 <span class="ot">-&gt;</span> <span class="dv">32</span></span></code></pre></div>
<p>With <em>LambdaCase</em>:</p>
<div class="sourceCode" id="cb372"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb372-1"><a href="#cb372-1" aria-hidden="true" tabindex="-1"></a>\<span class="kw">case</span></span>
<span id="cb372-2"><a href="#cb372-2" aria-hidden="true" tabindex="-1"></a>  p1 <span class="ot">-&gt;</span> <span class="dv">32</span></span>
<span id="cb372-3"><a href="#cb372-3" aria-hidden="true" tabindex="-1"></a>  p2 <span class="ot">-&gt;</span> <span class="dv">32</span></span></code></pre></div>
<div class="sourceCode" id="cb373"
data-include="src/04-extensions/lambdacase.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb373-1"><a href="#cb373-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE LambdaCase #-}</span></span>
<span id="cb373-2"><a href="#cb373-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-3"><a href="#cb373-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Exp</span> a</span>
<span id="cb373-4"><a href="#cb373-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Lam</span> a (<span class="dt">Exp</span> a)</span>
<span id="cb373-5"><a href="#cb373-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Var</span> a</span>
<span id="cb373-6"><a href="#cb373-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> (<span class="dt">Exp</span> a) (<span class="dt">Exp</span> a)</span>
<span id="cb373-7"><a href="#cb373-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb373-8"><a href="#cb373-8" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">Exp</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb373-9"><a href="#cb373-9" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> \<span class="kw">case</span></span>
<span id="cb373-10"><a href="#cb373-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lam</span> a b <span class="ot">-&gt;</span> a</span>
<span id="cb373-11"><a href="#cb373-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> a   <span class="ot">-&gt;</span> a</span>
<span id="cb373-12"><a href="#cb373-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">App</span> a b <span class="ot">-&gt;</span> example a</span></code></pre></div>
<h2 id="numdecimals">NumDecimals</h2>
<p>The extension <code>NumDecimals</code> allows the use of exponential
notation for integral literals that are not necessarily floats. Without
it, any use of exponential notation induces a Fractional class
constraint.</p>
<div class="sourceCode" id="cb374"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb374-1"><a href="#cb374-1" aria-hidden="true" tabindex="-1"></a><span class="ot">googol ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a</span>
<span id="cb374-2"><a href="#cb374-2" aria-hidden="true" tabindex="-1"></a>googol <span class="ot">=</span> <span class="fl">1e100</span></span></code></pre></div>
<div class="sourceCode" id="cb375"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb375-1"><a href="#cb375-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NumDecimals #-}</span></span>
<span id="cb375-2"><a href="#cb375-2" aria-hidden="true" tabindex="-1"></a><span class="ot">googol ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a</span>
<span id="cb375-3"><a href="#cb375-3" aria-hidden="true" tabindex="-1"></a>googol <span class="ot">=</span> <span class="fl">1e100</span></span></code></pre></div>
<h2 id="packageimports">PackageImports</h2>
<p>The syntax language extension <code>PackageImports</code> allows us
to disambiguate hierarchical package names by their respective package
key. This is useful in the case where you have two imported packages
that expose the same module. In practice most of the common libraries
have taken care to avoid conflicts in the namespace and this is not
usually a problem in most modern Haskell.</p>
<p>For example we could explicitly ask GHC to resolve that
<code>Control.Monad.Error</code> package be drawn from the
<code>mtl</code> library.</p>
<div class="sourceCode" id="cb376"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb376-1"><a href="#cb376-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> &quot;mtl&quot; <span class="dt">Control.Monad.Error</span> <span class="kw">as</span> <span class="dt">Error</span></span>
<span id="cb376-2"><a href="#cb376-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> &quot;mtl&quot; <span class="dt">Control.Monad.State</span> <span class="kw">as</span> <span class="dt">State</span></span>
<span id="cb376-3"><a href="#cb376-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> &quot;mtl&quot; <span class="dt">Control.Monad.Reader</span> <span class="kw">as</span> <span class="dt">Reader</span></span></code></pre></div>
<h2 id="recordwildcards">RecordWildCards</h2>
<p>Record wild cards allow us to expand out the names of a record as
variables scoped as the labels of the record implicitly. The extension
can be used to extract variables names into a scope and/or to assign to
variables in a record drawing(<strong>?</strong>), aligning the record’s
labels with the variables in scope for the assignment. The syntax
introduced is the <code>{..}</code> pattern selector as in the following
example:</p>
<div class="sourceCode" id="cb377"
data-include="src/04-extensions/wildcards_update.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb377-1"><a href="#cb377-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb377-2"><a href="#cb377-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb377-3"><a href="#cb377-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb377-4"><a href="#cb377-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span></span>
<span id="cb377-5"><a href="#cb377-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb377-6"><a href="#cb377-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span>  <span class="dt">Example</span> <span class="ot">=</span> <span class="dt">Example</span></span>
<span id="cb377-7"><a href="#cb377-7" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> e1 ::</span> <span class="dt">Int</span></span>
<span id="cb377-8"><a href="#cb377-8" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> e2 ::</span> <span class="dt">Text</span></span>
<span id="cb377-9"><a href="#cb377-9" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> e3 ::</span> <span class="dt">Text</span></span>
<span id="cb377-10"><a href="#cb377-10" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb377-11"><a href="#cb377-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb377-12"><a href="#cb377-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Extracting from a record using wildcards.</span></span>
<span id="cb377-13"><a href="#cb377-13" aria-hidden="true" tabindex="-1"></a><span class="ot">scope ::</span> <span class="dt">Example</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Text</span>, <span class="dt">Text</span>)</span>
<span id="cb377-14"><a href="#cb377-14" aria-hidden="true" tabindex="-1"></a>scope <span class="dt">Example</span> {<span class="op">..</span>} <span class="ot">=</span> (e1, e2, e3)</span>
<span id="cb377-15"><a href="#cb377-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb377-16"><a href="#cb377-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- Assign to a record using wildcards.</span></span>
<span id="cb377-17"><a href="#cb377-17" aria-hidden="true" tabindex="-1"></a><span class="ot">assign ::</span> <span class="dt">Example</span></span>
<span id="cb377-18"><a href="#cb377-18" aria-hidden="true" tabindex="-1"></a>assign <span class="ot">=</span> <span class="dt">Example</span> {<span class="op">..</span>}</span>
<span id="cb377-19"><a href="#cb377-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb377-20"><a href="#cb377-20" aria-hidden="true" tabindex="-1"></a>    (e1, e2, e3) <span class="ot">=</span> (<span class="dv">1</span>, <span class="st">&quot;Kirk&quot;</span>, <span class="st">&quot;Picard&quot;</span>)</span></code></pre></div>
<h2 id="namedfieldpuns">NamedFieldPuns</h2>
<p><code>NamedFieldPuns</code> provides alternative syntax for accessing
record fields in a pattern match.</p>
<div class="sourceCode" id="cb378"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb378-1"><a href="#cb378-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">D</span> <span class="ot">=</span> <span class="dt">D</span> {<span class="ot">a ::</span> <span class="dt">Int</span>,<span class="ot"> b ::</span> <span class="dt">Int</span>}</span>
<span id="cb378-2"><a href="#cb378-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb378-3"><a href="#cb378-3" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb378-4"><a href="#cb378-4" aria-hidden="true" tabindex="-1"></a>f <span class="dt">D</span> {a, b} <span class="ot">=</span> a <span class="op">-</span> b</span>
<span id="cb378-5"><a href="#cb378-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb378-6"><a href="#cb378-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Order doesn&#39;t matter</span></span>
<span id="cb378-7"><a href="#cb378-7" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> <span class="dt">D</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb378-8"><a href="#cb378-8" aria-hidden="true" tabindex="-1"></a>g <span class="dt">D</span> {b, a} <span class="ot">=</span> a <span class="op">-</span> b</span></code></pre></div>
<h2 id="patternsynonyms">PatternSynonyms</h2>
<p>Suppose we were writing a typechecker, and we needed to parse type
signatures. One common solution would to include a <code>TArr</code> to
pattern match on type function signatures. Even though, technically it
could be written in terms of more basic application of the
<code>(-&gt;)</code> constructor.</p>
<div class="sourceCode" id="cb379"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb379-1"><a href="#cb379-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Type</span></span>
<span id="cb379-2"><a href="#cb379-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">TVar</span> <span class="dt">TVar</span></span>
<span id="cb379-3"><a href="#cb379-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TCon</span> <span class="dt">TyCon</span></span>
<span id="cb379-4"><a href="#cb379-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TApp</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb379-5"><a href="#cb379-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TArr</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb379-6"><a href="#cb379-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>With pattern synonyms we can eliminate the extraneous constructor
without losing the convenience of pattern matching on arrow types. We
introduce a new pattern using the <code>pattern</code> keyword.</p>
<div class="sourceCode" id="cb380"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb380-1"><a href="#cb380-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PatternSynonyms #-}</span></span>
<span id="cb380-2"><a href="#cb380-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb380-3"><a href="#cb380-3" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">TArr</span> t1 t2 <span class="ot">=</span> <span class="dt">TApp</span> (<span class="dt">TApp</span> (<span class="dt">TCon</span> <span class="st">&quot;(-&gt;)&quot;</span>) t1) t2</span></code></pre></div>
<p>So now we can write a deconstructor and constructor for the arrow
type very naturally.</p>
<div class="sourceCode" id="cb381"
data-include="src/04-extensions/patterns.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb381-1"><a href="#cb381-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PatternSynonyms #-}</span></span>
<span id="cb381-2"><a href="#cb381-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-3"><a href="#cb381-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (foldl1&#39;)</span>
<span id="cb381-4"><a href="#cb381-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-5"><a href="#cb381-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Name</span>  <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb381-6"><a href="#cb381-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">TVar</span>  <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb381-7"><a href="#cb381-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">TyCon</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb381-8"><a href="#cb381-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-9"><a href="#cb381-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Type</span></span>
<span id="cb381-10"><a href="#cb381-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">TVar</span> <span class="dt">TVar</span></span>
<span id="cb381-11"><a href="#cb381-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TCon</span> <span class="dt">TyCon</span></span>
<span id="cb381-12"><a href="#cb381-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TApp</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb381-13"><a href="#cb381-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb381-14"><a href="#cb381-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-15"><a href="#cb381-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-16"><a href="#cb381-16" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">TArr</span> t1 t2 <span class="ot">=</span> <span class="dt">TApp</span> (<span class="dt">TApp</span> (<span class="dt">TCon</span> <span class="st">&quot;(-&gt;)&quot;</span>) t1) t2</span>
<span id="cb381-17"><a href="#cb381-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-18"><a href="#cb381-18" aria-hidden="true" tabindex="-1"></a><span class="ot">tapp ::</span> <span class="dt">TyCon</span> <span class="ot">-&gt;</span> [<span class="dt">Type</span>] <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb381-19"><a href="#cb381-19" aria-hidden="true" tabindex="-1"></a>tapp tcon args <span class="ot">=</span> <span class="fu">foldl</span> <span class="dt">TApp</span> (<span class="dt">TCon</span> tcon) args</span>
<span id="cb381-20"><a href="#cb381-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-21"><a href="#cb381-21" aria-hidden="true" tabindex="-1"></a><span class="ot">arr ::</span> [<span class="dt">Type</span>] <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb381-22"><a href="#cb381-22" aria-hidden="true" tabindex="-1"></a>arr ts <span class="ot">=</span> foldl1&#39; (\t1 t2 <span class="ot">-&gt;</span> tapp <span class="st">&quot;(-&gt;)&quot;</span> [t1, t2]) ts</span>
<span id="cb381-23"><a href="#cb381-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-24"><a href="#cb381-24" aria-hidden="true" tabindex="-1"></a><span class="ot">elimTArr ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> [<span class="dt">Type</span>]</span>
<span id="cb381-25"><a href="#cb381-25" aria-hidden="true" tabindex="-1"></a>elimTArr (<span class="dt">TArr</span> (<span class="dt">TArr</span> t1 t2) t3) <span class="ot">=</span> t1 <span class="op">:</span> t2 <span class="op">:</span> elimTArr t3</span>
<span id="cb381-26"><a href="#cb381-26" aria-hidden="true" tabindex="-1"></a>elimTArr (<span class="dt">TArr</span> t1 t2) <span class="ot">=</span> t1 <span class="op">:</span> elimTArr t2</span>
<span id="cb381-27"><a href="#cb381-27" aria-hidden="true" tabindex="-1"></a>elimTArr t <span class="ot">=</span> [t]</span>
<span id="cb381-28"><a href="#cb381-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-29"><a href="#cb381-29" aria-hidden="true" tabindex="-1"></a><span class="co">-- (-&gt;) a ((-&gt;) b a)</span></span>
<span id="cb381-30"><a href="#cb381-30" aria-hidden="true" tabindex="-1"></a><span class="co">-- a -&gt; b -&gt; a</span></span>
<span id="cb381-31"><a href="#cb381-31" aria-hidden="true" tabindex="-1"></a><span class="ot">to ::</span> <span class="dt">Type</span></span>
<span id="cb381-32"><a href="#cb381-32" aria-hidden="true" tabindex="-1"></a>to <span class="ot">=</span> arr [<span class="dt">TVar</span> <span class="st">&quot;a&quot;</span>, <span class="dt">TVar</span> <span class="st">&quot;b&quot;</span>, <span class="dt">TVar</span> <span class="st">&quot;a&quot;</span>]</span>
<span id="cb381-33"><a href="#cb381-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb381-34"><a href="#cb381-34" aria-hidden="true" tabindex="-1"></a><span class="ot">from ::</span> [<span class="dt">Type</span>]</span>
<span id="cb381-35"><a href="#cb381-35" aria-hidden="true" tabindex="-1"></a>from <span class="ot">=</span> elimTArr to</span></code></pre></div>
<p>Pattern synonyms can be exported from a module like any other
definition by prefixing them with the prefix <code>pattern</code>.</p>
<div class="sourceCode" id="cb382"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb382-1"><a href="#cb382-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">MyModule</span> (</span>
<span id="cb382-2"><a href="#cb382-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">pattern</span> <span class="dt">Elt</span></span>
<span id="cb382-3"><a href="#cb382-3" aria-hidden="true" tabindex="-1"></a>) <span class="kw">where</span></span>
<span id="cb382-4"><a href="#cb382-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb382-5"><a href="#cb382-5" aria-hidden="true" tabindex="-1"></a><span class="kw">pattern</span> <span class="dt">Elt</span> <span class="ot">=</span> [a]</span></code></pre></div>
<ul>
<li><a
href="http://mpickering.github.io/posts/2015-12-12-pattern-synonyms-8.html">Pattern
Synonyms in GHC 8</a></li>
</ul>
<h2 id="derivefunctor">DeriveFunctor</h2>
<p>Many instances of functors over datatypes with parameters and trivial
constructors are the result of trivially applying a function over the
single constructor’s argument. GHC can derive this boilerplate
automatically in deriving clauses if <code>DeriveFunctor</code> is
enabled.</p>
<div class="sourceCode" id="cb383"
data-include="src/04-extensions/derive_functor.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb383-1"><a href="#cb383-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb383-2"><a href="#cb383-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb383-3"><a href="#cb383-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Node</span> a [<span class="dt">Tree</span> a]</span>
<span id="cb383-4"><a href="#cb383-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb383-5"><a href="#cb383-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb383-6"><a href="#cb383-6" aria-hidden="true" tabindex="-1"></a><span class="ot">tree ::</span> <span class="dt">Tree</span> <span class="dt">Int</span></span>
<span id="cb383-7"><a href="#cb383-7" aria-hidden="true" tabindex="-1"></a>tree <span class="ot">=</span> <span class="fu">fmap</span> (<span class="op">+</span><span class="dv">1</span>) (<span class="dt">Node</span> <span class="dv">1</span> [<span class="dt">Node</span> <span class="dv">2</span> [], <span class="dt">Node</span> <span class="dv">3</span> []])</span></code></pre></div>
<h2 id="derivefoldable">DeriveFoldable</h2>
<p>Similar to how Functors can be automatically derived, many instances
of Foldable for types of kind <code>* -&gt; *</code> have instances that
derive the functions:</p>
<ul>
<li><code>foldMap</code></li>
<li><code>foldr</code></li>
<li><code>null</code></li>
</ul>
<p>For instance if we have a custom rose tree and binary tree
implementation we can automatically derive the fold functions for these
datatypes automatically for us.</p>
<div class="sourceCode" id="cb384"
data-include="src/04-extensions/folding.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb384-1"><a href="#cb384-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFoldable #-}</span></span>
<span id="cb384-2"><a href="#cb384-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb384-3"><a href="#cb384-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RoseTree</span> a</span>
<span id="cb384-4"><a href="#cb384-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">RoseTree</span> a [<span class="dt">RoseTree</span> a]</span>
<span id="cb384-5"><a href="#cb384-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Foldable</span>)</span>
<span id="cb384-6"><a href="#cb384-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb384-7"><a href="#cb384-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a</span>
<span id="cb384-8"><a href="#cb384-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Leaf</span> a</span>
<span id="cb384-9"><a href="#cb384-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Branch</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> a)</span>
<span id="cb384-10"><a href="#cb384-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Foldable</span>)</span></code></pre></div>
<p>These will generate the following instances:</p>
<div class="sourceCode" id="cb385"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb385-1"><a href="#cb385-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">RoseTree</span> <span class="kw">where</span></span>
<span id="cb385-2"><a href="#cb385-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span> f z (<span class="dt">RoseTree</span> a1 a2)</span>
<span id="cb385-3"><a href="#cb385-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> f a1 ((\ b3 b4 <span class="ot">-&gt;</span> <span class="fu">foldr</span> (\ b1 b2 <span class="ot">-&gt;</span> <span class="fu">foldr</span> f b2 b1) b4 b3) a2 z)</span>
<span id="cb385-4"><a href="#cb385-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldMap</span> f (<span class="dt">RoseTree</span> a1 a2)</span>
<span id="cb385-5"><a href="#cb385-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="fu">mappend</span> (f a1) (<span class="fu">foldMap</span> (<span class="fu">foldMap</span> f) a2)</span>
<span id="cb385-6"><a href="#cb385-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">null</span> (<span class="dt">RoseTree</span> _ _) <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb385-7"><a href="#cb385-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb385-8"><a href="#cb385-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Tree</span> <span class="kw">where</span></span>
<span id="cb385-9"><a href="#cb385-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span> f z (<span class="dt">Leaf</span> a1) <span class="ot">=</span> f a1 z</span>
<span id="cb385-10"><a href="#cb385-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldr</span> f z (<span class="dt">Branch</span> a1 a2)</span>
<span id="cb385-11"><a href="#cb385-11" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> (\ b1 b2 <span class="ot">-&gt;</span> <span class="fu">foldr</span> f b2 b1) a1 ((\ b3 b4 <span class="ot">-&gt;</span> <span class="fu">foldr</span> f b4 b3) a2 z)</span>
<span id="cb385-12"><a href="#cb385-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldMap</span> f (<span class="dt">Leaf</span> a1) <span class="ot">=</span> f a1</span>
<span id="cb385-13"><a href="#cb385-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldMap</span> f (<span class="dt">Branch</span> a1 a2) <span class="ot">=</span> <span class="fu">mappend</span> (<span class="fu">foldMap</span> f a1) (<span class="fu">foldMap</span> f a2)</span>
<span id="cb385-14"><a href="#cb385-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">null</span> (<span class="dt">Leaf</span> _) <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb385-15"><a href="#cb385-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">null</span> (<span class="dt">Branch</span> a1 a2) <span class="ot">=</span> (<span class="op">&amp;&amp;</span>) (<span class="fu">null</span> a1) (<span class="fu">null</span> a2)</span></code></pre></div>
<h2 id="derivetraversable">DeriveTraversable</h2>
<p>Just as with Functor and Foldable, many <code>Traversable</code>
instances for single-paramater datatypes of kind <code>* -&gt; *</code>
have trivial implementations of the <code>traverse</code> function which
can also be derived automatically. By enabling
<code>DeriveTraversable</code> we can use stock deriving to derive these
instances for us.</p>
<div class="sourceCode" id="cb386"
data-include="src/04-extensions/derive_traversable.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb386-1"><a href="#cb386-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveTraversable #-}</span></span>
<span id="cb386-2"><a href="#cb386-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PartialTypeSignatures #-}</span></span>
<span id="cb386-3"><a href="#cb386-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb386-4"><a href="#cb386-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb386-5"><a href="#cb386-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Node</span> a [<span class="dt">Tree</span> a]</span>
<span id="cb386-6"><a href="#cb386-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span>
<span id="cb386-7"><a href="#cb386-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb386-8"><a href="#cb386-8" aria-hidden="true" tabindex="-1"></a><span class="ot">tree ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]</span>
<span id="cb386-9"><a href="#cb386-9" aria-hidden="true" tabindex="-1"></a>tree <span class="ot">=</span> <span class="fu">foldMap</span> go (<span class="dt">Node</span> [<span class="dv">1</span>] [<span class="dt">Node</span> [<span class="dv">2</span>] [], <span class="dt">Node</span> [<span class="dv">3</span>,<span class="dv">4</span>] []])</span>
<span id="cb386-10"><a href="#cb386-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb386-11"><a href="#cb386-11" aria-hidden="true" tabindex="-1"></a>    go [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb386-12"><a href="#cb386-12" aria-hidden="true" tabindex="-1"></a>    go xs <span class="ot">=</span> <span class="dt">Just</span> xs</span></code></pre></div>
<h2 id="derivegeneric">DeriveGeneric</h2>
<p>Data types in Haskell can derived by GHC with the DeriveGenerics
extension which is able to define the entire structure of the Generic
instance and associated type families. See <a
href="#generics">Generics</a> for more details on what these types
mean.</p>
<p>For example the simple custom List type deriving Generic:</p>
<div class="sourceCode" id="cb387"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb387-1"><a href="#cb387-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb387-2"><a href="#cb387-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb387-3"><a href="#cb387-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb387-4"><a href="#cb387-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb387-5"><a href="#cb387-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a</span>
<span id="cb387-6"><a href="#cb387-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span>
<span id="cb387-7"><a href="#cb387-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Nil</span> <span class="kw">deriving</span></span>
<span id="cb387-8"><a href="#cb387-8" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Generic</span>)</span></code></pre></div>
<p>Will generate the following <code>Generic</code> instance:</p>
<div class="sourceCode" id="cb388"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb388-1"><a href="#cb388-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Generic</span> (<span class="dt">List</span> a) <span class="kw">where</span></span>
<span id="cb388-2"><a href="#cb388-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span></span>
<span id="cb388-3"><a href="#cb388-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Rep</span> (<span class="dt">List</span> a) <span class="ot">=</span></span>
<span id="cb388-4"><a href="#cb388-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">D1</span></span>
<span id="cb388-5"><a href="#cb388-5" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">&#39;MetaData</span> <span class="st">&quot;List&quot;</span> <span class="st">&quot;Ghci3&quot;</span> <span class="st">&quot;MyModule&quot;</span> <span class="dt">&#39;False</span>)</span>
<span id="cb388-6"><a href="#cb388-6" aria-hidden="true" tabindex="-1"></a>        ( <span class="dt">C1</span></span>
<span id="cb388-7"><a href="#cb388-7" aria-hidden="true" tabindex="-1"></a>            (<span class="dt">&#39;MetaCons</span> <span class="st">&quot;Cons&quot;</span> <span class="dt">&#39;PrefixI</span> <span class="dt">&#39;False</span>)</span>
<span id="cb388-8"><a href="#cb388-8" aria-hidden="true" tabindex="-1"></a>            ( <span class="dt">S1</span></span>
<span id="cb388-9"><a href="#cb388-9" aria-hidden="true" tabindex="-1"></a>                ( <span class="dt">&#39;MetaSel</span></span>
<span id="cb388-10"><a href="#cb388-10" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">&#39;Nothing</span></span>
<span id="cb388-11"><a href="#cb388-11" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">&#39;NoSourceUnpackedness</span></span>
<span id="cb388-12"><a href="#cb388-12" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">&#39;NoSourceStrictness</span></span>
<span id="cb388-13"><a href="#cb388-13" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">&#39;DecidedLazy</span></span>
<span id="cb388-14"><a href="#cb388-14" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb388-15"><a href="#cb388-15" aria-hidden="true" tabindex="-1"></a>                (<span class="dt">Rec0</span> a)</span>
<span id="cb388-16"><a href="#cb388-16" aria-hidden="true" tabindex="-1"></a>                <span class="op">:*:</span> <span class="dt">S1</span></span>
<span id="cb388-17"><a href="#cb388-17" aria-hidden="true" tabindex="-1"></a>                      ( <span class="dt">&#39;MetaSel</span></span>
<span id="cb388-18"><a href="#cb388-18" aria-hidden="true" tabindex="-1"></a>                          <span class="dt">&#39;Nothing</span></span>
<span id="cb388-19"><a href="#cb388-19" aria-hidden="true" tabindex="-1"></a>                          <span class="dt">&#39;NoSourceUnpackedness</span></span>
<span id="cb388-20"><a href="#cb388-20" aria-hidden="true" tabindex="-1"></a>                          <span class="dt">&#39;NoSourceStrictness</span></span>
<span id="cb388-21"><a href="#cb388-21" aria-hidden="true" tabindex="-1"></a>                          <span class="dt">&#39;DecidedLazy</span></span>
<span id="cb388-22"><a href="#cb388-22" aria-hidden="true" tabindex="-1"></a>                      )</span>
<span id="cb388-23"><a href="#cb388-23" aria-hidden="true" tabindex="-1"></a>                      (<span class="dt">Rec0</span> (<span class="dt">List</span> a))</span>
<span id="cb388-24"><a href="#cb388-24" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb388-25"><a href="#cb388-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">:+:</span> <span class="dt">C1</span> (<span class="dt">&#39;MetaCons</span> <span class="st">&quot;Nil&quot;</span> <span class="dt">&#39;PrefixI</span> <span class="dt">&#39;False</span>) <span class="dt">U1</span></span>
<span id="cb388-26"><a href="#cb388-26" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb388-27"><a href="#cb388-27" aria-hidden="true" tabindex="-1"></a>  from x <span class="ot">=</span> <span class="dt">M1</span></span>
<span id="cb388-28"><a href="#cb388-28" aria-hidden="true" tabindex="-1"></a>      ( <span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb388-29"><a href="#cb388-29" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Cons</span> g1 g2 <span class="ot">-&gt;</span> <span class="dt">L1</span> (<span class="dt">M1</span> ((<span class="op">:*:</span>) (<span class="dt">M1</span> (<span class="dt">K1</span> g1)) (<span class="dt">M1</span> (<span class="dt">K1</span> g2))))</span>
<span id="cb388-30"><a href="#cb388-30" aria-hidden="true" tabindex="-1"></a>          <span class="dt">Nil</span> <span class="ot">-&gt;</span> <span class="dt">R1</span> (<span class="dt">M1</span> <span class="dt">U1</span>)</span>
<span id="cb388-31"><a href="#cb388-31" aria-hidden="true" tabindex="-1"></a>      )</span>
<span id="cb388-32"><a href="#cb388-32" aria-hidden="true" tabindex="-1"></a>  to (<span class="dt">M1</span> x) <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb388-33"><a href="#cb388-33" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">L1</span> (<span class="dt">M1</span> ((<span class="op">:*:</span>) (<span class="dt">M1</span> (<span class="dt">K1</span> g1)) (<span class="dt">M1</span> (<span class="dt">K1</span> g2))))) <span class="ot">-&gt;</span> <span class="dt">Cons</span> g1 g2</span>
<span id="cb388-34"><a href="#cb388-34" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">R1</span> (<span class="dt">M1</span> <span class="dt">U1</span>)) <span class="ot">-&gt;</span> <span class="dt">Nil</span></span></code></pre></div>
<h2 id="deriveanyclass">DeriveAnyClass</h2>
<p>With <code>-XDeriveAnyClass</code> we can derive any class. The
deriving logic generates an instance declaration for the type with no
explicitly-defined methods or with all instances having a specific
default implementation given. These are used extensively with <a
href="#generics">Generics</a> when instances provide empty <a
href="#minimal-annotations">Minimal Annotations</a> which are all
derived from generic logic.</p>
<p>A contrived example of a class with an empty minimal set might be the
following:</p>
<div class="sourceCode" id="cb389"
data-include="src/04-extensions/derive_any.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb389-1"><a href="#cb389-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DefaultSignatures #-}</span></span>
<span id="cb389-2"><a href="#cb389-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveAnyClass #-}</span></span>
<span id="cb389-3"><a href="#cb389-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb389-4"><a href="#cb389-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">MinimalClass</span> a <span class="kw">where</span></span>
<span id="cb389-5"><a href="#cb389-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  const1 ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb389-6"><a href="#cb389-6" aria-hidden="true" tabindex="-1"></a>  default<span class="ot"> const1 ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb389-7"><a href="#cb389-7" aria-hidden="true" tabindex="-1"></a>  const1 _ <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb389-8"><a href="#cb389-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb389-9"><a href="#cb389-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  const2 ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb389-10"><a href="#cb389-10" aria-hidden="true" tabindex="-1"></a>  default<span class="ot"> const2 ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb389-11"><a href="#cb389-11" aria-hidden="true" tabindex="-1"></a>  const2 _ <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb389-12"><a href="#cb389-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb389-13"><a href="#cb389-13" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Example</span> <span class="ot">=</span> <span class="dt">Example</span></span>
<span id="cb389-14"><a href="#cb389-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">MinimalClass</span>)</span>
<span id="cb389-15"><a href="#cb389-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb389-16"><a href="#cb389-16" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb389-17"><a href="#cb389-17" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb389-18"><a href="#cb389-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (const1 <span class="dt">Example</span>)</span>
<span id="cb389-19"><a href="#cb389-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (const2 <span class="dt">Example</span>)</span></code></pre></div>
<h2 id="duplicaterecordfields">DuplicateRecordFields</h2>
<p>GHC 8.0 introduced the <code>DuplicateRecordFields</code> extensions
which loosens GHC’s restriction on records in the same module with
identical accessors. The precise type that is being projected into is
now deferred to the callsite.</p>
<div class="sourceCode" id="cb390"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb390-1"><a href="#cb390-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DuplicateRecordFields #-}</span></span>
<span id="cb390-2"><a href="#cb390-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb390-3"><a href="#cb390-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Person</span> <span class="ot">=</span> <span class="dt">Person</span> {<span class="ot"> id ::</span> <span class="dt">Int</span> }</span>
<span id="cb390-4"><a href="#cb390-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Animal</span> <span class="ot">=</span> <span class="dt">Animal</span> {<span class="ot"> id ::</span> <span class="dt">Int</span> }</span>
<span id="cb390-5"><a href="#cb390-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vegetable</span> <span class="ot">=</span> <span class="dt">Vegetable</span> {<span class="ot"> id ::</span> <span class="dt">Int</span> }</span>
<span id="cb390-6"><a href="#cb390-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb390-7"><a href="#cb390-7" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> (<span class="dt">Person</span>, <span class="dt">Animal</span>, <span class="dt">Vegetable</span>)</span>
<span id="cb390-8"><a href="#cb390-8" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> (<span class="dt">Person</span> {<span class="fu">id</span> <span class="ot">=</span> <span class="dv">1</span>}, <span class="dt">Animal</span> {<span class="fu">id</span> <span class="ot">=</span> <span class="dv">2</span>}, <span class="dt">Vegetable</span> {<span class="fu">id</span> <span class="ot">=</span> <span class="dv">3</span>})</span></code></pre></div>
<p>Using just <code>DuplicateRecordFields</code>, projection is still
not supported so the following will not work.</p>
<div class="sourceCode" id="cb391"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb391-1"><a href="#cb391-1" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb391-2"><a href="#cb391-2" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> (<span class="fu">id</span> (<span class="dt">Person</span> <span class="dv">1</span>), <span class="fu">id</span> (<span class="dt">Animal</span> <span class="dv">2</span>), <span class="fu">id</span> (<span class="dt">Animal</span> <span class="dv">3</span>))</span></code></pre></div>
<h2 id="overloadedlabels">OverloadedLabels</h2>
<p>GHC 8.0 also introduced the <code>OverloadedLabels</code> extension
which allows a limited form of polymorphism over labels that share the
same name.</p>
<p>To work with overloaded label types we also need to enable several
language extensions that allow us to use the promoted strings and
multiparam typeclasses that underlay its implementation.</p>
<div class="sourceCode" id="cb392"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb392-1"><a href="#cb392-1" aria-hidden="true" tabindex="-1"></a><span class="ot">extract ::</span> <span class="dt">IsLabel</span> <span class="st">&quot;id&quot;</span> t <span class="ot">=&gt;</span> t</span>
<span id="cb392-2"><a href="#cb392-2" aria-hidden="true" tabindex="-1"></a>extract <span class="ot">=</span> <span class="op">#</span>id</span></code></pre></div>
<div class="sourceCode" id="cb393"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb393-1"><a href="#cb393-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedLabels #-}</span></span>
<span id="cb393-2"><a href="#cb393-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb393-3"><a href="#cb393-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb393-4"><a href="#cb393-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DuplicateRecordFields #-}</span></span>
<span id="cb393-5"><a href="#cb393-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span></span>
<span id="cb393-6"><a href="#cb393-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb393-7"><a href="#cb393-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Records</span> (<span class="dt">HasField</span>(..))  <span class="co">-- Since base 4.10.0.0</span></span>
<span id="cb393-8"><a href="#cb393-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.OverloadedLabels</span> (<span class="dt">IsLabel</span>(..))</span>
<span id="cb393-9"><a href="#cb393-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb393-10"><a href="#cb393-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">S</span> <span class="ot">=</span> <span class="dt">MkS</span> {<span class="ot"> foo ::</span> <span class="dt">Int</span> }</span>
<span id="cb393-11"><a href="#cb393-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span> x y z <span class="ot">=</span> <span class="kw">forall</span> b <span class="op">.</span> <span class="dt">MkT</span> {<span class="ot"> foo ::</span> y,<span class="ot"> bar ::</span> b }</span>
<span id="cb393-12"><a href="#cb393-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb393-13"><a href="#cb393-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">HasField</span> x r a <span class="ot">=&gt;</span> <span class="dt">IsLabel</span> x (r <span class="ot">-&gt;</span> a) <span class="kw">where</span></span>
<span id="cb393-14"><a href="#cb393-14" aria-hidden="true" tabindex="-1"></a>  fromLabel <span class="ot">=</span> getField</span>
<span id="cb393-15"><a href="#cb393-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb393-16"><a href="#cb393-16" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb393-17"><a href="#cb393-17" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb393-18"><a href="#cb393-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (<span class="op">#</span>foo (<span class="dt">MkS</span> <span class="dv">42</span>))</span>
<span id="cb393-19"><a href="#cb393-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (<span class="op">#</span>foo (<span class="dt">MkT</span> <span class="dt">True</span> <span class="dt">False</span>))</span></code></pre></div>
<p>This is used in more advanced libraries like <a
href="#selda">Selda</a> which do object relational mapping between
Haskell datatype fields and database columns.</p>
<p>See:</p>
<ul>
<li><a
href="http://www.well-typed.com/blog/2015/03/overloadedrecordfields-revived/">OverloadedRecordFields
revived</a></li>
</ul>
<h2 id="cpp">CPP</h2>
<p>The C++ preprocessor is the fallback whenever we really need to
separate out logic that has to span multiple versions of GHC and
language changes while maintaining backwards compatibility. It can
dispatch on the version of GHC being used to compile a module.</p>
<div class="sourceCode" id="cb394"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb394-1"><a href="#cb394-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE CPP #-}</span></span>
<span id="cb394-2"><a href="#cb394-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb394-3"><a href="#cb394-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#if (__GLASGOW_HASKELL__ &gt; 710)</span></span>
<span id="cb394-4"><a href="#cb394-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Imports for GHC 7.10.x</span></span>
<span id="cb394-5"><a href="#cb394-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span>
<span id="cb394-6"><a href="#cb394-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Imports for other GHC</span></span>
<span id="cb394-7"><a href="#cb394-7" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p>It can also demarcate code based on the operating system compiled
on.</p>
<div class="sourceCode" id="cb395"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb395-1"><a href="#cb395-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE CPP #-}</span></span>
<span id="cb395-2"><a href="#cb395-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb395-3"><a href="#cb395-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#ifdef OS_Linux</span></span>
<span id="cb395-4"><a href="#cb395-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Linux specific logic</span></span>
<span id="cb395-5"><a href="#cb395-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#else</span></span>
<span id="cb395-6"><a href="#cb395-6" aria-hidden="true" tabindex="-1"></a><span class="pp"># ifdef OS_Win32</span></span>
<span id="cb395-7"><a href="#cb395-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Windows specific logic</span></span>
<span id="cb395-8"><a href="#cb395-8" aria-hidden="true" tabindex="-1"></a><span class="pp"># else</span></span>
<span id="cb395-9"><a href="#cb395-9" aria-hidden="true" tabindex="-1"></a><span class="pp"># ifdef OS_Mac</span></span>
<span id="cb395-10"><a href="#cb395-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Mac specific logic</span></span>
<span id="cb395-11"><a href="#cb395-11" aria-hidden="true" tabindex="-1"></a><span class="pp"># else</span></span>
<span id="cb395-12"><a href="#cb395-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Other operating systems</span></span>
<span id="cb395-13"><a href="#cb395-13" aria-hidden="true" tabindex="-1"></a><span class="pp"># endif</span></span>
<span id="cb395-14"><a href="#cb395-14" aria-hidden="true" tabindex="-1"></a><span class="pp"># endif</span></span>
<span id="cb395-15"><a href="#cb395-15" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p>For another example, it can distinguish the version of the base
library used.</p>
<div class="sourceCode" id="cb396"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb396-1"><a href="#cb396-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#if !MIN_VERSION_base(4,6,0)</span></span>
<span id="cb396-2"><a href="#cb396-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Base specific logic</span></span>
<span id="cb396-3"><a href="#cb396-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#endif</span></span></code></pre></div>
<p>One can also use the CPP extension to emit Haskell source at
compile-time. This is used in some libraries which have massive
boilerplate obligations. Of course, this can be abused quite easily and
doing this sort of compile-time string-munging should be a last
resort.</p>
<h2 id="typeapplications">TypeApplications</h2>
<p>The type system extension <code>TypeApplications</code> allows you to
use explicit annotations for subexpressions. For example if you have a
subexpression which has the inferred type <code>a -&gt; b -&gt; a</code>
you can name the types of <code>a</code> and <code>b</code> by
explicitly stating <code>@Int @Bool</code> to assign <code>a</code> to
<code>Int</code> and <code>b</code> to <code>Bool</code>. This is
particularly useful when working with typeclasses where type inference
cannot deduce the types of all subexpressions from the toplevel
signature and results in an overly specific default. This is quite
common when working with roundtrips of <code>read</code> and
<code>show</code>. For example:</p>
<div class="sourceCode" id="cb397"
data-include="src/04-extensions/application.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb397-1"><a href="#cb397-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeApplications #-}</span></span>
<span id="cb397-2"><a href="#cb397-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb397-3"><a href="#cb397-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb397-4"><a href="#cb397-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb397-5"><a href="#cb397-5" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Proxy</span> <span class="dt">Int</span></span>
<span id="cb397-6"><a href="#cb397-6" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dt">Proxy</span> <span class="op">@</span><span class="dt">Int</span></span>
<span id="cb397-7"><a href="#cb397-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb397-8"><a href="#cb397-8" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">String</span></span>
<span id="cb397-9"><a href="#cb397-9" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="fu">show</span> (<span class="fu">read</span> <span class="op">@</span><span class="dt">Int</span> <span class="st">&quot;42&quot;</span>)</span></code></pre></div>
<h2 id="derivingvia">DerivingVia</h2>
<p><code>DerivingVia</code> is an extension of
<code>GeneralizedNewtypeDeriving</code>. Just as newtype deriving allows
us to derive instances in terms of instances for the underlying
representation of the newtype, DerivingVia allows deriving instances by
specifying a custom type which has a runtime representation equal to the
desired behavior we’re deriving the instance for. The derived instance
can then be <code>coerced</code> to behave as if it were operating over
the given type. This is a powerful new mechanism that allows us to
derive many typeclasses in terms of other typeclasses.</p>
<div class="sourceCode" id="cb398"
data-include="src/04-extensions/derive_via.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb398-1"><a href="#cb398-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb398-2"><a href="#cb398-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DerivingVia #-}</span></span>
<span id="cb398-3"><a href="#cb398-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb398-4"><a href="#cb398-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb398-5"><a href="#cb398-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-6"><a href="#cb398-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb398-7"><a href="#cb398-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Functor.Const</span> (<span class="dt">Const</span> (..))</span>
<span id="cb398-8"><a href="#cb398-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">Any</span>)</span>
<span id="cb398-9"><a href="#cb398-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-10"><a href="#cb398-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- Deriving Eq in terms of Const functor</span></span>
<span id="cb398-11"><a href="#cb398-11" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Age</span> <span class="ot">=</span> <span class="dt">MkAge</span> <span class="dt">Int</span></span>
<span id="cb398-12"><a href="#cb398-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span></span>
<span id="cb398-13"><a href="#cb398-13" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">Eq</span>)</span>
<span id="cb398-14"><a href="#cb398-14" aria-hidden="true" tabindex="-1"></a>    via <span class="dt">Const</span> <span class="dt">Int</span> <span class="dt">Any</span></span>
<span id="cb398-15"><a href="#cb398-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-16"><a href="#cb398-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- Deriving Num across a nested functor</span></span>
<span id="cb398-17"><a href="#cb398-17" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">FNum</span> f a <span class="ot">=</span> <span class="dt">FNum</span> (f a)</span>
<span id="cb398-18"><a href="#cb398-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Functor</span>)</span>
<span id="cb398-19"><a href="#cb398-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="kw">newtype</span> (<span class="dt">Applicative</span>)</span>
<span id="cb398-20"><a href="#cb398-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-21"><a href="#cb398-21" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Applicative</span> f, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> <span class="dt">Num</span> (<span class="dt">FNum</span> f a) <span class="kw">where</span></span>
<span id="cb398-22"><a href="#cb398-22" aria-hidden="true" tabindex="-1"></a>  (<span class="op">+</span>) <span class="ot">=</span> liftA2 (<span class="op">+</span>)</span>
<span id="cb398-23"><a href="#cb398-23" aria-hidden="true" tabindex="-1"></a>  (<span class="op">-</span>) <span class="ot">=</span> liftA2 (<span class="op">-</span>)</span>
<span id="cb398-24"><a href="#cb398-24" aria-hidden="true" tabindex="-1"></a>  (<span class="op">*</span>) <span class="ot">=</span> liftA2 (<span class="op">*</span>)</span>
<span id="cb398-25"><a href="#cb398-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">abs</span> <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">abs</span></span>
<span id="cb398-26"><a href="#cb398-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">signum</span> <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">signum</span></span>
<span id="cb398-27"><a href="#cb398-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fromInteger</span> <span class="ot">=</span> <span class="dt">FNum</span> <span class="op">.</span> <span class="fu">pure</span> <span class="op">.</span> <span class="fu">fromInteger</span></span>
<span id="cb398-28"><a href="#cb398-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-29"><a href="#cb398-29" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Example</span> a b <span class="ot">=</span> <span class="dt">Example</span> (<span class="dt">Either</span> a b)</span>
<span id="cb398-30"><a href="#cb398-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb398-31"><a href="#cb398-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="kw">newtype</span> (<span class="dt">Applicative</span>)</span>
<span id="cb398-32"><a href="#cb398-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Num</span>) via <span class="dt">FNum</span> (<span class="dt">Either</span> a) b</span>
<span id="cb398-33"><a href="#cb398-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-34"><a href="#cb398-34" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Example</span> <span class="dt">Integer</span> <span class="dt">Integer</span></span>
<span id="cb398-35"><a href="#cb398-35" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dt">Example</span> (<span class="dt">Left</span> <span class="dv">1</span>)</span>
<span id="cb398-36"><a href="#cb398-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-37"><a href="#cb398-37" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">Example</span> <span class="dt">Integer</span> <span class="dt">Integer</span></span>
<span id="cb398-38"><a href="#cb398-38" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="dt">Example</span> (<span class="dt">Right</span> <span class="dv">1</span>)</span>
<span id="cb398-39"><a href="#cb398-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb398-40"><a href="#cb398-40" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> ()</span>
<span id="cb398-41"><a href="#cb398-41" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb398-42"><a href="#cb398-42" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (a <span class="op">+</span> a)</span>
<span id="cb398-43"><a href="#cb398-43" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (a <span class="op">+</span> b)</span>
<span id="cb398-44"><a href="#cb398-44" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (b <span class="op">+</span> b)</span></code></pre></div>
<h2 id="derivingstrategies">DerivingStrategies</h2>
<p>Deriving has proven a powerful mechanism to add typeclass instances
and as such there have been a variety of bifurcations in its use. Since
GHC 8.2 there are now four different algorithms that can be used to
derive typeclass instances. These are enabled by different extensions
and now have specific syntax for invoking each algorithm specifically.
Turning on <code>DerivingStrategies</code> allows you to disambiguate
which algorithm GHC should use for individual class derivations.</p>
<ul>
<li><code>stock</code> - Standard GHC builtin deriving
(i.e. <code>Eq</code>, <code>Ord</code>, <code>Show</code>)</li>
<li><code>anyclass</code> - Deriving via minimal annotations with <a
href="#deriveanyclass">DeriveAnyClass</a>.</li>
<li><code>newtype</code> - Deriving with
[GeneralizedNewtypeDeriving].</li>
<li><code>via</code> - Deriving with <a
href="#derivingvia">DerivingVia</a>.</li>
</ul>
<p>These can be stacked and combined on top of a data or newtype
declaration.</p>
<div class="sourceCode" id="cb399"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb399-1"><a href="#cb399-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Example</span> <span class="ot">=</span> <span class="dt">Example</span> <span class="dt">Int</span></span>
<span id="cb399-2"><a href="#cb399-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock    (<span class="dt">Read</span>, <span class="dt">Show</span>)</span>
<span id="cb399-3"><a href="#cb399-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="kw">newtype</span>  (<span class="dt">Num</span>, <span class="dt">Floating</span>)</span>
<span id="cb399-4"><a href="#cb399-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> anyclass (<span class="dt">ToJSON</span>, <span class="dt">FromJSON</span>, <span class="dt">ToSQL</span>, <span class="dt">FromSQL</span>)</span>
<span id="cb399-5"><a href="#cb399-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>) via (<span class="dt">Const</span> <span class="dt">Int</span> <span class="dt">Any</span>)</span></code></pre></div>
<h2 id="historical-extensions">Historical Extensions</h2>
<p>Several language extensions have either been absorbed into the core
language or become deprecated in favor of others. Others are just
considered misfeatures.</p>
<ul>
<li><code>Rank2Types</code> - Rank2Types has been subsumed by
<code>RankNTypes</code></li>
<li><code>XPolymorphicComponents</code> - Was an implementation detail
of higher-rank polymorphism that no longer exists.</li>
<li><code>NPlusKPatterns</code> - These were largely considered an ugly
edge-case of pattern matching language that was best removed.</li>
<li><code>TraditionalRecordSyntax</code> - Traditional record syntax was
an extension to the Haskell 98 specification for what we now consider
standard record syntax.</li>
<li><code>OverlappingInstances</code> - Subsumed by explicit
<code>OVERLAPPING</code> pragmas.</li>
<li><code>IncoherentInstances</code> - Subsumed by explicit
<code>INCOHERENT</code> pragmas.</li>
<li><code>NullaryTypeClasses</code> - Subsumed by explicit
Multiparameter Typeclasses with no parameters.</li>
<li><code>TypeInType</code> - Is deprecated in favour of the combination
of <code>PolyKinds</code> and <code>DataKinds</code> and extensions to
the GHC typesystem after GHC 8.0.</li>
</ul>
<hr/>
<h1 id="type-class-extensions">Type Class Extensions</h1>
<p>Typeclasses are the bread and butter of abstractions in Haskell, and
even out of the box in Haskell 98 they are quite powerful. However
classes have grown quite a few extensions, additional syntax and
enhancements over the years to augment their utility.</p>
<div class="sourceCode" id="cb400"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb400-1"><a href="#cb400-1" aria-hidden="true" tabindex="-1"></a><span class="co">--        +-----+------------------ Typeclass Context</span></span>
<span id="cb400-2"><a href="#cb400-2" aria-hidden="true" tabindex="-1"></a><span class="co">--        |     |           +------ Typeclass Head</span></span>
<span id="cb400-3"><a href="#cb400-3" aria-hidden="true" tabindex="-1"></a><span class="co">--        |     |           |</span></span>
<span id="cb400-4"><a href="#cb400-4" aria-hidden="true" tabindex="-1"></a><span class="co">--    ^^^^^^^^^^^^^^^     ^^^^^^^^^^^</span></span>
<span id="cb400-5"><a href="#cb400-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Ctx1</span> a, <span class="dt">Ctx2</span> b) <span class="ot">=&gt;</span> <span class="dt">MyClass</span> a b <span class="kw">where</span></span>
<span id="cb400-6"><a href="#cb400-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  method1 ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb400-7"><a href="#cb400-7" aria-hidden="true" tabindex="-1"></a><span class="co">--        |</span></span>
<span id="cb400-8"><a href="#cb400-8" aria-hidden="true" tabindex="-1"></a><span class="co">--        +------------------------ Typeclass Method</span></span></code></pre></div>
<h2 id="standard-hierarchy">Standard Hierarchy</h2>
<p>In the course of writing Haskell there are seven core instances you
will use and derive most frequently. Each of them are lawful classes
with several equations associated with their methods.</p>
<ul>
<li><code>Semigroup</code></li>
<li><code>Monoid</code></li>
<li><code>Functor</code></li>
<li><code>Applicative</code></li>
<li><code>Monad</code></li>
<li><code>Foldable</code></li>
<li><code>Traversable</code></li>
</ul>
<p><img src="img/class.png" width="500" /></p>
<h2 id="instance-search">Instance Search</h2>
<p>Whenever a typeclass method is invoked at a callsite, GHC will
perform an instance search over all available instances defined for the
given typeclass associated with the method. This instance search is
quite similar to backward chaining in logic programming languages. The
search is performed during compilation after all types in all modules
are known and is performed <em>globally</em> across all modules and all
packages available to be linked. The instance search can either result
in no instances, a single instance or multiple instances which satisfy
the conditions of the call site.</p>
<h2 id="orphan-instances">Orphan Instances</h2>
<p>Normally typeclass definitions are restricted to be defined in one of
two places:</p>
<ol type="1">
<li>In the same module as the declaration of the datatype in the
instance head.</li>
<li>In the same module as the class declaration.</li>
</ol>
<p>These two restrictions restrict the instance search space to a system
where a solution (if it exists) can always be found. If we allowed
instances to be defined in any modules then we could potentially have
multiple class instances defined in multiple modules and the search
would be ambiguous.</p>
<p>This restriction can however be disabled with the
<code>-fno-warn-orphans</code> flag.</p>
<div class="sourceCode" id="cb401"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb401-1"><a href="#cb401-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -fno-warn-orphans #-}</span></span></code></pre></div>
<p>This will allow you to define orphan instances in the current module.
But beware this will make the instance search contingent on your import
list and may result in clashes in your codebase where the linker will
fail because there are multiple modules which define the same instance
head.</p>
<p>When used appropriately this can be the way to route around the fact
that upstream modules may define datatypes that you use, but they have
not defined the instances for other downstream libraries that you also
use. You can then write these instances for your codebase without
modifying either upstream library.</p>
<h2 id="minimal-annotations">Minimal Annotations</h2>
<p>In the presence of default implementations for typeclass methods,
there may be several ways to implement a typeclass. For instance Eq is
entirely defined by either defining when two values are equal or not
equal by implying taking the negation of the other. We can define
equality in terms of non-equality and vice-versa.</p>
<div class="sourceCode" id="cb402"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb402-1"><a href="#cb402-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></span>
<span id="cb402-2"><a href="#cb402-2" aria-hidden="true" tabindex="-1"></a>  (<span class="op">==</span>),<span class="ot"> (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb402-3"><a href="#cb402-3" aria-hidden="true" tabindex="-1"></a>  x <span class="op">==</span> y <span class="ot">=</span> <span class="fu">not</span> (x <span class="op">/=</span> y)</span>
<span id="cb402-4"><a href="#cb402-4" aria-hidden="true" tabindex="-1"></a>  x <span class="op">/=</span> y <span class="ot">=</span> <span class="fu">not</span> (x <span class="op">==</span> y)</span></code></pre></div>
<p>Before 7.6.1 there was no way to specify what was the “minimal”
definition required to implement a typeclass</p>
<div class="sourceCode" id="cb403"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb403-1"><a href="#cb403-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></span>
<span id="cb403-2"><a href="#cb403-2" aria-hidden="true" tabindex="-1"></a>  (<span class="op">==</span>),<span class="ot"> (/=) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb403-3"><a href="#cb403-3" aria-hidden="true" tabindex="-1"></a>  x <span class="op">==</span> y <span class="ot">=</span> <span class="fu">not</span> (x <span class="op">/=</span> y)</span>
<span id="cb403-4"><a href="#cb403-4" aria-hidden="true" tabindex="-1"></a>  x <span class="op">/=</span> y <span class="ot">=</span> <span class="fu">not</span> (x <span class="op">==</span> y)</span>
<span id="cb403-5"><a href="#cb403-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">{-# MINIMAL (==) #-}</span></span>
<span id="cb403-6"><a href="#cb403-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">{-# MINIMAL (/=) #-}</span></span></code></pre></div>
<p>Minimal pragmas are boolean expressions. For instance, with
<code>|</code> as logical <code>OR</code>, <em>either</em> definition of
the above functions must be defined. Comma indicates logical
<code>AND</code> where <em>both</em> definitions must be defined.</p>
<div class="sourceCode" id="cb404"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb404-1"><a href="#cb404-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# MINIMAL (==) | (/=) #-}</span> <span class="co">-- Either (==) or (/=)</span></span>
<span id="cb404-2"><a href="#cb404-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# MINIMAL (==) , (/=) #-}</span> <span class="co">-- Both (==) and (/=)</span></span></code></pre></div>
<p>Compiling the <code>-Wmissing-methods</code> will warn when an
instance is defined that does not meet the minimal criterion.</p>
<h2 id="typesynonyminstances">TypeSynonymInstances</h2>
<p>Normally type class definitions are restricted to being defined only
over fully expanded types with all type synonym indirections removed.
Type synonyms introduce a “naming indirection” that can be included in
the instance search to allow you to write synonym instances for multiple
synonyms which expand to concrete types.</p>
<p>This is used quite often in modern Haskell.</p>
<div class="sourceCode" id="cb405"
data-include="src/04-extensions/synonym.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb405-1"><a href="#cb405-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></span>
<span id="cb405-2"><a href="#cb405-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb405-3"><a href="#cb405-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb405-4"><a href="#cb405-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">IntList</span> <span class="ot">=</span> [<span class="dt">Int</span>]</span>
<span id="cb405-5"><a href="#cb405-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb405-6"><a href="#cb405-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">MyClass</span> a</span>
<span id="cb405-7"><a href="#cb405-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb405-8"><a href="#cb405-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Without type synonym instances, we&#39;re forced to manually expand out type</span></span>
<span id="cb405-9"><a href="#cb405-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- synonyms in the typeclass head.</span></span>
<span id="cb405-10"><a href="#cb405-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MyClass</span> [<span class="dt">Int</span>]</span>
<span id="cb405-11"><a href="#cb405-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb405-12"><a href="#cb405-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- With it GHC will do this for us automatically. Type synonyms still need to</span></span>
<span id="cb405-13"><a href="#cb405-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- be fully applied.</span></span>
<span id="cb405-14"><a href="#cb405-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MyClass</span> <span class="dt">IntList</span></span></code></pre></div>
<h2 id="flexibleinstances">FlexibleInstances</h2>
<p>Normally the head of a typeclass instance must contain only a type
constructor applied to any number of type variables. There can be no
nesting of other constructors or non-type variables in the head. The
<code>FlexibleInstances</code> extension loosens this restriction to
allow arbitrary nesting and non-type variables to be mentioned in the
head definition. This extension also implicitly enables
<code>TypeSynonymInstances</code>.</p>
<div class="sourceCode" id="cb406"
data-include="src/04-extensions/flexinstances.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb406-1"><a href="#cb406-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb406-2"><a href="#cb406-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb406-3"><a href="#cb406-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">MyClass</span> a</span>
<span id="cb406-4"><a href="#cb406-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb406-5"><a href="#cb406-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Without flexible instances, all instance heads must be type variable. The</span></span>
<span id="cb406-6"><a href="#cb406-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- following would be legal.</span></span>
<span id="cb406-7"><a href="#cb406-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MyClass</span> (<span class="dt">Maybe</span> a)</span>
<span id="cb406-8"><a href="#cb406-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb406-9"><a href="#cb406-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- With flexible instances, typeclass heads can be arbitrary nested types. The</span></span>
<span id="cb406-10"><a href="#cb406-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- following would be forbidden without it.</span></span>
<span id="cb406-11"><a href="#cb406-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MyClass</span> (<span class="dt">Maybe</span> <span class="dt">Int</span>)</span></code></pre></div>
<h2 id="flexiblecontexts">FlexibleContexts</h2>
<p>Just as with instances, contexts normally are also constrained to
consist entirely of constraints where a class is applied to just type
variables. The <code>FlexibleContexts</code> extension lifts this
restriction and allows any type of type variable and nesting to occur
the class constraint head. There is however still a global restriction
that all class hierarchies must not contain cycles.</p>
<div class="sourceCode" id="cb407"
data-include="src/04-extensions/flexcontexts.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb407-1"><a href="#cb407-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb407-2"><a href="#cb407-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-3"><a href="#cb407-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">MyClass</span> a</span>
<span id="cb407-4"><a href="#cb407-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-5"><a href="#cb407-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Without flexible contexts, all contexts must be type variable. The</span></span>
<span id="cb407-6"><a href="#cb407-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- following would be legal.</span></span>
<span id="cb407-7"><a href="#cb407-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">MyClass</span> a) <span class="ot">=&gt;</span> <span class="dt">MyClass</span> (<span class="dt">Either</span> a b)</span>
<span id="cb407-8"><a href="#cb407-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb407-9"><a href="#cb407-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- With flexible contexts, typeclass contexts can be arbitrary nested types. The</span></span>
<span id="cb407-10"><a href="#cb407-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- following would be forbidden without it.</span></span>
<span id="cb407-11"><a href="#cb407-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">MyClass</span> (<span class="dt">Maybe</span> a)) <span class="ot">=&gt;</span> <span class="dt">MyClass</span> (<span class="dt">Either</span> a b)</span></code></pre></div>
<h2 id="overlappinginstances">OverlappingInstances</h2>
<p>Typeclasses are normally globally coherent, there is only ever one
instance that can be resolved for a type unambiguously at any call site
in the program. There are however extensions to loosen this restriction
and perform more manual direction of the instance search.</p>
<p>Overlapping instances loosens the coherent condition (there can be
multiple instances) but introduces a criterion that it will resolve to
the most specific one.</p>
<div class="sourceCode" id="cb408"
data-include="src/04-extensions/overlapping.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb408-1"><a href="#cb408-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb408-2"><a href="#cb408-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverlappingInstances #-}</span></span>
<span id="cb408-3"><a href="#cb408-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb408-4"><a href="#cb408-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb408-5"><a href="#cb408-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">MyClass</span> a b <span class="kw">where</span></span>
<span id="cb408-6"><a href="#cb408-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  fn ::</span> (a,b)</span>
<span id="cb408-7"><a href="#cb408-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb408-8"><a href="#cb408-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MyClass</span> <span class="dt">Int</span> b <span class="kw">where</span></span>
<span id="cb408-9"><a href="#cb408-9" aria-hidden="true" tabindex="-1"></a>  fn <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;b&quot;</span></span>
<span id="cb408-10"><a href="#cb408-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb408-11"><a href="#cb408-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MyClass</span> a <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb408-12"><a href="#cb408-12" aria-hidden="true" tabindex="-1"></a>  fn <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;a&quot;</span></span>
<span id="cb408-13"><a href="#cb408-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb408-14"><a href="#cb408-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MyClass</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb408-15"><a href="#cb408-15" aria-hidden="true" tabindex="-1"></a>  fn <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;c&quot;</span></span>
<span id="cb408-16"><a href="#cb408-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb408-17"><a href="#cb408-17" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb408-18"><a href="#cb408-18" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> fn</span></code></pre></div>
<p>Historically enabling on the module-level was not the best idea,
since generally we define multiple classes in a module only a subset of
which may be incoherent. As of GHC 7.10 we now have the capacity to just
annotate instances with the <code>OVERLAPPING</code> and
<code>INCOHERENT</code> inline pragmas.</p>
<div class="sourceCode" id="cb409"
data-include="src/04-extensions/overlapping_anno.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb409-1"><a href="#cb409-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb409-2"><a href="#cb409-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb409-3"><a href="#cb409-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb409-4"><a href="#cb409-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">MyClass</span> a b <span class="kw">where</span></span>
<span id="cb409-5"><a href="#cb409-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  fn ::</span> (a,b)</span>
<span id="cb409-6"><a href="#cb409-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb409-7"><a href="#cb409-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="ot">{-# OVERLAPPING #-}</span> <span class="dt">MyClass</span> <span class="dt">Int</span> b <span class="kw">where</span></span>
<span id="cb409-8"><a href="#cb409-8" aria-hidden="true" tabindex="-1"></a>  fn <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;b&quot;</span></span>
<span id="cb409-9"><a href="#cb409-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb409-10"><a href="#cb409-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="ot">{-# OVERLAPPING #-}</span> <span class="dt">MyClass</span> a <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb409-11"><a href="#cb409-11" aria-hidden="true" tabindex="-1"></a>  fn <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;a&quot;</span></span>
<span id="cb409-12"><a href="#cb409-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb409-13"><a href="#cb409-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="ot">{-# OVERLAPPING #-}</span> <span class="dt">MyClass</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb409-14"><a href="#cb409-14" aria-hidden="true" tabindex="-1"></a>  fn <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;c&quot;</span></span>
<span id="cb409-15"><a href="#cb409-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb409-16"><a href="#cb409-16" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb409-17"><a href="#cb409-17" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> fn</span></code></pre></div>
<h2 id="incoherentinstances">IncoherentInstances</h2>
<p>Incoherent instances loosens the restriction that there be only one
specific instance, it will be chosen based on a more complex search
procedure which tries to identify a <em>prime instance</em> based on
information incorporated form <code>OVERLAPPING</code> pragmas on
instances in the search tree. Unless one is doing very advanced
type-level programming use class constraints, this is usually a poor
design decision and a sign to rethink the class hierarchy.</p>
<div class="sourceCode" id="cb410"
data-include="src/04-extensions/incoherent.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb410-1"><a href="#cb410-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb410-2"><a href="#cb410-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE IncoherentInstances #-}</span></span>
<span id="cb410-3"><a href="#cb410-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb410-4"><a href="#cb410-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb410-5"><a href="#cb410-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">MyClass</span> a b <span class="kw">where</span></span>
<span id="cb410-6"><a href="#cb410-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  fn ::</span> (a,b)</span>
<span id="cb410-7"><a href="#cb410-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb410-8"><a href="#cb410-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MyClass</span> <span class="dt">Int</span> b <span class="kw">where</span></span>
<span id="cb410-9"><a href="#cb410-9" aria-hidden="true" tabindex="-1"></a>  fn <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;a&quot;</span></span>
<span id="cb410-10"><a href="#cb410-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb410-11"><a href="#cb410-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MyClass</span> a <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb410-12"><a href="#cb410-12" aria-hidden="true" tabindex="-1"></a>  fn <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;b&quot;</span></span>
<span id="cb410-13"><a href="#cb410-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb410-14"><a href="#cb410-14" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb410-15"><a href="#cb410-15" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> fn</span></code></pre></div>
<p>An example with <code>INCOHERENT</code> annotations:</p>
<div class="sourceCode" id="cb411"
data-include="src/04-extensions/incoherent_anno.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb411-1"><a href="#cb411-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb411-2"><a href="#cb411-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb411-3"><a href="#cb411-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb411-4"><a href="#cb411-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">MyClass</span> a b <span class="kw">where</span></span>
<span id="cb411-5"><a href="#cb411-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  fn ::</span> (a,b)</span>
<span id="cb411-6"><a href="#cb411-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb411-7"><a href="#cb411-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="ot">{-# INCOHERENT #-}</span> <span class="dt">MyClass</span> a <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb411-8"><a href="#cb411-8" aria-hidden="true" tabindex="-1"></a>  fn <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;general&quot;</span></span>
<span id="cb411-9"><a href="#cb411-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb411-10"><a href="#cb411-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="ot">{-# INCOHERENT #-}</span> <span class="dt">MyClass</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb411-11"><a href="#cb411-11" aria-hidden="true" tabindex="-1"></a>  fn <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;specific&quot;</span></span>
<span id="cb411-12"><a href="#cb411-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb411-13"><a href="#cb411-13" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb411-14"><a href="#cb411-14" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> fn</span></code></pre></div>
<hr/>
<h1 id="laziness">Laziness</h1>
<p>Haskell is a unique language that explores an alternative evaluation
model called <em>lazy evaluation</em>. Lazy evaluation implies that
expressions will be evaluated only when needed. In truth, this
evaluation may even be indefinitely deferred. Consider the example in
Haskell of defining an infinite list:</p>
<div class="sourceCode" id="cb412"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb412-1"><a href="#cb412-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> mkInfinite n <span class="ot">=</span> n <span class="op">:</span> mkInfinite n</span>
<span id="cb412-2"><a href="#cb412-2" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">5</span> <span class="op">$</span> mkInfinite <span class="dv">4</span></span>
<span id="cb412-3"><a href="#cb412-3" aria-hidden="true" tabindex="-1"></a>[<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>,<span class="dv">4</span>]</span></code></pre></div>
<p>The primary advantage of lazy evaluation in the large is that
algorithms that operate over both unbounded and bounded data structures
can inhabit the same type signatures and be composed without any
additional need to restructure their logic or force intermediate
computations.</p>
<p>Still, it’s important to recognize that this is another subject on
which much ink has been spilled. In fact, there is an ongoing discussion
in the land of Haskell about the compromises between lazy and strict
evaluation, and there are nuanced arguments for having either paradigm
be the default.</p>
<p>Haskell takes a hybrid approach where it allows strict evaluation
when needed while it uses laziness by default. Needless to say, we can
always find examples where strict evaluation exhibits worse behavior
than lazy evaluation and vice versa. These days Haskell can be both as
lazy or as strict as you like, giving you options for however you prefer
to program.</p>
<p>Languages that attempt to bolt laziness on to a strict evaluation
model often bifurcate classes of algorithms into ones that are
hand-adjusted to consume unbounded structures and those which operate
over bounded structures. In strict languages, mixing and matching
between lazy vs. strict processing often necessitates manifesting large
intermediate structures in memory when such composition would “just
work” in a lazy language.</p>
<p>By virtue of Haskell being the only language to actually explore this
point in the design space, knowledge about lazy evaluation is not widely
absorbed into the collective programmer consciousness and can often be
non-intuitive to the novice. Some time is often needed to fully grok how
lazy evaluation works</p>
<h2 id="strictness">Strictness</h2>
<p>For a more strict definition of strictnees, consider that there are
several evaluation models for the lambda calculus:</p>
<ul>
<li><strong>Strict</strong> - Evaluation is said to be strict if all
arguments are evaluated before the body of a function.</li>
<li><strong>Non-strict</strong> - Evaluation is non-strict if the
arguments are not necessarily evaluated before entering the body of a
function.</li>
</ul>
<p>These ideas give rise to several models, Haskell itself uses the
<em>call-by-need</em> model.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Model</th>
<th style="text-align: left;">Strictness</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Call-by-value</td>
<td style="text-align: left;">Strict</td>
<td style="text-align: left;">Arguments evaluated before function
entered</td>
</tr>
<tr class="even">
<td style="text-align: left;">Call-by-name</td>
<td style="text-align: left;">Non-strict</td>
<td style="text-align: left;">Arguments passed unevaluated</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Call-by-need</td>
<td style="text-align: left;">Non-strict</td>
<td style="text-align: left;">Arguments passed unevaluated but an
expression is only evaluated once</td>
</tr>
</tbody>
</table>
<h2 id="seq-and-whnf">Seq and WHNF</h2>
<p>On the subject of laziness and evaluation, we have names for how
fully evaluated an expression is. A term is said to be in <em>weak head
normal-form</em> if the outermost constructor or lambda expression
cannot be reduced further. A term is said to be in <em>normal form</em>
if it is fully evaluated and all sub-expressions and thunks contained
within are evaluated.</p>
<div class="sourceCode" id="cb413"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb413-1"><a href="#cb413-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- In Normal Form</span></span>
<span id="cb413-2"><a href="#cb413-2" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span></span>
<span id="cb413-3"><a href="#cb413-3" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span>, <span class="st">&quot;foo&quot;</span>)</span>
<span id="cb413-4"><a href="#cb413-4" aria-hidden="true" tabindex="-1"></a>\x <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb413-5"><a href="#cb413-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-6"><a href="#cb413-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Not in Normal Form</span></span>
<span id="cb413-7"><a href="#cb413-7" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span></span>
<span id="cb413-8"><a href="#cb413-8" aria-hidden="true" tabindex="-1"></a>(\x <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">1</span>) <span class="dv">2</span></span>
<span id="cb413-9"><a href="#cb413-9" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;foo&quot;</span> <span class="op">++</span> <span class="st">&quot;bar&quot;</span></span>
<span id="cb413-10"><a href="#cb413-10" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span>, <span class="st">&quot;foo&quot;</span>)</span>
<span id="cb413-11"><a href="#cb413-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-12"><a href="#cb413-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- In Weak Head Normal Form</span></span>
<span id="cb413-13"><a href="#cb413-13" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span>, <span class="st">&quot;foo&quot;</span>)</span>
<span id="cb413-14"><a href="#cb413-14" aria-hidden="true" tabindex="-1"></a>\x <span class="ot">-&gt;</span> <span class="dv">2</span> <span class="op">+</span> <span class="dv">2</span></span>
<span id="cb413-15"><a href="#cb413-15" aria-hidden="true" tabindex="-1"></a><span class="ch">&#39;f&#39;</span> <span class="op">:</span> (<span class="st">&quot;oo&quot;</span> <span class="op">++</span> <span class="st">&quot;bar&quot;</span>)</span>
<span id="cb413-16"><a href="#cb413-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb413-17"><a href="#cb413-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- Not In Weak Head Normal Form</span></span>
<span id="cb413-18"><a href="#cb413-18" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb413-19"><a href="#cb413-19" aria-hidden="true" tabindex="-1"></a>(\x <span class="ot">-&gt;</span> x <span class="op">+</span> <span class="dv">1</span>) <span class="dv">2</span></span>
<span id="cb413-20"><a href="#cb413-20" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;foo&quot;</span> <span class="op">++</span> <span class="st">&quot;bar&quot;</span></span></code></pre></div>
<p>In Haskell, normal evaluation only occurs at the outer constructor of
case-statements in Core. If we pattern match on a list, we don’t
implicitly force all values in the list. An element in a data structure
is only evaluated up to the outermost constructor. For example, to
evaluate the length of a list we need only scrutinize the outer Cons
constructors without regard for their inner values:</p>
<div class="sourceCode" id="cb414"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb414-1"><a href="#cb414-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="fu">length</span> [<span class="fu">undefined</span>, <span class="dv">1</span>]</span>
<span id="cb414-2"><a href="#cb414-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span></span>
<span id="cb414-3"><a href="#cb414-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb414-4"><a href="#cb414-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="fu">head</span> [<span class="fu">undefined</span>, <span class="dv">1</span>]</span>
<span id="cb414-5"><a href="#cb414-5" aria-hidden="true" tabindex="-1"></a>Prelude.undefined</span>
<span id="cb414-6"><a href="#cb414-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb414-7"><a href="#cb414-7" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="fu">snd</span> (<span class="fu">undefined</span>, <span class="dv">1</span>)</span>
<span id="cb414-8"><a href="#cb414-8" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span></span>
<span id="cb414-9"><a href="#cb414-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb414-10"><a href="#cb414-10" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="fu">fst</span> (<span class="fu">undefined</span>, <span class="dv">1</span>)</span>
<span id="cb414-11"><a href="#cb414-11" aria-hidden="true" tabindex="-1"></a>Prelude.undefined</span></code></pre></div>
<p>For example, in a lazy language the following program terminates even
though it contains diverging terms.</p>
<div class="sourceCode" id="cb415"
data-include="src/05-laziness/nodiverge.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb415-1"><a href="#cb415-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ignore ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb415-2"><a href="#cb415-2" aria-hidden="true" tabindex="-1"></a>ignore x <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb415-3"><a href="#cb415-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb415-4"><a href="#cb415-4" aria-hidden="true" tabindex="-1"></a><span class="ot">loop ::</span> a</span>
<span id="cb415-5"><a href="#cb415-5" aria-hidden="true" tabindex="-1"></a>loop <span class="ot">=</span> loop</span>
<span id="cb415-6"><a href="#cb415-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb415-7"><a href="#cb415-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb415-8"><a href="#cb415-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> ignore loop</span></code></pre></div>
<p>In a strict language like OCaml (ignoring its suspensions for the
moment), the same program diverges.</p>
<div class="sourceCode" id="cb416"
data-include="src/05-laziness/diverge.ml"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb416-1"><a href="#cb416-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> ignore x <span class="ot">=</span> <span class="dv">0</span>;; </span>
<span id="cb416-2"><a href="#cb416-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> rec loop a <span class="ot">=</span> loop a;;</span>
<span id="cb416-3"><a href="#cb416-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb416-4"><a href="#cb416-4" aria-hidden="true" tabindex="-1"></a>print_int (ignore (loop ()));</span></code></pre></div>
<h2 id="thunks">Thunks</h2>
<p>In Haskell a <em>thunk</em> is created to stand for an unevaluated
computation. Evaluation of a thunk is called <em>forcing</em> the thunk.
The result is an <em>update</em>, a referentially transparent effect,
which replaces the memory representation of the thunk with the computed
value. The fundamental idea is that a thunk is only updated once
(although it may be forced simultaneously in a multi-threaded
environment) and its resulting value is shared when referenced
subsequently.</p>
<p>The GHCi command <code>:sprint</code> can be used to introspect the
state of unevaluated thunks inside an expression without forcing
evaluation. For instance:</p>
<div class="sourceCode" id="cb417"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb417-1"><a href="#cb417-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="kw">let</span> a <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span>]<span class="ot"> ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb417-2"><a href="#cb417-2" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="kw">let</span> b <span class="ot">=</span> <span class="fu">map</span> (<span class="op">+</span> <span class="dv">1</span>) a</span>
<span id="cb417-3"><a href="#cb417-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb417-4"><a href="#cb417-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>sprint a</span>
<span id="cb417-5"><a href="#cb417-5" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> _</span>
<span id="cb417-6"><a href="#cb417-6" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>sprint b</span>
<span id="cb417-7"><a href="#cb417-7" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> _</span>
<span id="cb417-8"><a href="#cb417-8" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> a <span class="op">!!</span> <span class="dv">4</span></span>
<span id="cb417-9"><a href="#cb417-9" aria-hidden="true" tabindex="-1"></a><span class="dv">5</span></span>
<span id="cb417-10"><a href="#cb417-10" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>sprint a</span>
<span id="cb417-11"><a href="#cb417-11" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">2</span> <span class="op">:</span> <span class="dv">3</span> <span class="op">:</span> <span class="dv">4</span> <span class="op">:</span> <span class="dv">5</span> <span class="op">:</span> _</span>
<span id="cb417-12"><a href="#cb417-12" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> b <span class="op">!!</span> <span class="dv">10</span></span>
<span id="cb417-13"><a href="#cb417-13" aria-hidden="true" tabindex="-1"></a><span class="dv">12</span></span>
<span id="cb417-14"><a href="#cb417-14" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>sprint a</span>
<span id="cb417-15"><a href="#cb417-15" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">2</span> <span class="op">:</span> <span class="dv">3</span> <span class="op">:</span> <span class="dv">4</span> <span class="op">:</span> <span class="dv">5</span> <span class="op">:</span> <span class="dv">6</span> <span class="op">:</span> <span class="dv">7</span> <span class="op">:</span> <span class="dv">8</span> <span class="op">:</span> <span class="dv">9</span> <span class="op">:</span> <span class="dv">10</span> <span class="op">:</span> <span class="dv">11</span> <span class="op">:</span> _</span>
<span id="cb417-16"><a href="#cb417-16" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>sprint b</span>
<span id="cb417-17"><a href="#cb417-17" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> _ <span class="op">:</span> _ <span class="op">:</span> _ <span class="op">:</span> _ <span class="op">:</span> _ <span class="op">:</span> _ <span class="op">:</span> _ <span class="op">:</span> _ <span class="op">:</span> _ <span class="op">:</span> _ <span class="op">:</span> <span class="dv">12</span> <span class="op">:</span> _</span></code></pre></div>
<p>While a thunk is being computed its memory representation is replaced
with a special form known as <em>blackhole</em> which indicates that
computation is ongoing and allows for a short circuit when a computation
might depend on itself to complete.</p>
<p>The <code>seq</code> function introduces an artificial dependence on
the evaluation of order of two terms by requiring that the first
argument be evaluated to WHNF before the evaluation of the second. The
implementation of the <code>seq</code> function is an implementation
detail of GHC.</p>
<div class="sourceCode" id="cb418"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb418-1"><a href="#cb418-1" aria-hidden="true" tabindex="-1"></a><span class="fu">seq</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</span>
<span id="cb418-2"><a href="#cb418-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb418-3"><a href="#cb418-3" aria-hidden="true" tabindex="-1"></a>⊥ <span class="ot">`seq`</span> a <span class="ot">=</span> ⊥</span>
<span id="cb418-4"><a href="#cb418-4" aria-hidden="true" tabindex="-1"></a>a <span class="ot">`seq`</span> b <span class="ot">=</span> b</span></code></pre></div>
<p>For one example where laziness can bite you, the infamous foldl is
well-known to leak space when used carelessly and without several
compiler optimizations applied. The strict foldl’ variant uses seq to
overcome this.</p>
<div class="sourceCode" id="cb419"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb419-1"><a href="#cb419-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a</span>
<span id="cb419-2"><a href="#cb419-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f z [] <span class="ot">=</span> z</span>
<span id="cb419-3"><a href="#cb419-3" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f z (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="fu">foldl</span> f (f z x) xs</span></code></pre></div>
<div class="sourceCode" id="cb420"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb420-1"><a href="#cb420-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldl&#39; ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a</span>
<span id="cb420-2"><a href="#cb420-2" aria-hidden="true" tabindex="-1"></a>foldl&#39; _ z [] <span class="ot">=</span> z</span>
<span id="cb420-3"><a href="#cb420-3" aria-hidden="true" tabindex="-1"></a>foldl&#39; f z (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">let</span> z&#39; <span class="ot">=</span> f z x <span class="kw">in</span> z&#39; <span class="ot">`seq`</span> foldl&#39; f z&#39; xs</span></code></pre></div>
<p>In practice, a combination between the strictness analyzer and the
inliner on <code>-O2</code> will ensure that the strict variant of
<code>foldl</code> is used whenever the function is inlinable at call
site so manually using <code>foldl'</code> is most often not
required.</p>
<p>Of important note is that GHCi runs without any optimizations applied
so the same program that performs poorly in GHCi may not have the same
performance characteristics when compiled with GHC.</p>
<h2 id="bangpatterns">BangPatterns</h2>
<p>The extension <code>BangPatterns</code> allows an alternative syntax
to force arguments to functions to be wrapped in seq. A bang operator on
an argument forces its evaluation to weak head normal form before
performing the pattern match. This can be used to keep specific
arguments evaluated throughout recursion instead of creating a giant
chain of thunks.</p>
<div class="sourceCode" id="cb421"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb421-1"><a href="#cb421-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb421-2"><a href="#cb421-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb421-3"><a href="#cb421-3" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb421-4"><a href="#cb421-4" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> <span class="ot">=</span> go <span class="dv">0</span></span>
<span id="cb421-5"><a href="#cb421-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb421-6"><a href="#cb421-6" aria-hidden="true" tabindex="-1"></a>    go <span class="op">!</span>acc (x<span class="op">:</span>xs) <span class="ot">=</span> go (acc <span class="op">+</span> x) xs</span>
<span id="cb421-7"><a href="#cb421-7" aria-hidden="true" tabindex="-1"></a>    go  acc []     <span class="ot">=</span> acc</span></code></pre></div>
<p>This is desugared into code effectively equivalent to the
following:</p>
<div class="sourceCode" id="cb422"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb422-1"><a href="#cb422-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb422-2"><a href="#cb422-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sum</span> <span class="ot">=</span> go <span class="dv">0</span></span>
<span id="cb422-3"><a href="#cb422-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb422-4"><a href="#cb422-4" aria-hidden="true" tabindex="-1"></a>    go acc _ <span class="op">|</span> acc <span class="ot">`seq`</span> <span class="dt">False</span> <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb422-5"><a href="#cb422-5" aria-hidden="true" tabindex="-1"></a>    go acc (x<span class="op">:</span>xs)              <span class="ot">=</span> go (acc <span class="op">+</span> x) xs</span>
<span id="cb422-6"><a href="#cb422-6" aria-hidden="true" tabindex="-1"></a>    go acc []                  <span class="ot">=</span> acc</span></code></pre></div>
<p>Function application to seq’d arguments is common enough that it has
a special operator.</p>
<div class="sourceCode" id="cb423"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb423-1"><a href="#cb423-1" aria-hidden="true" tabindex="-1"></a><span class="ot">($!) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb423-2"><a href="#cb423-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">$!</span> x  <span class="ot">=</span> <span class="kw">let</span> <span class="op">!</span>vx <span class="ot">=</span> x <span class="kw">in</span> f vx</span></code></pre></div>
<h2 id="strictdata">StrictData</h2>
<p>As of GHC 8.0 strictness annotations can be applied to all
definitions in a module automatically. In previous versions to make
definitions strict it was necessary to use explicit syntactic
annotations at call sites.</p>
<p>Enabling StrictData makes constructor fields strict by default on any
module where the pragma is enabled:</p>
<div class="sourceCode" id="cb424"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb424-1"><a href="#cb424-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE StrictData #-}</span></span>
<span id="cb424-2"><a href="#cb424-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb424-3"><a href="#cb424-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Employee</span> <span class="ot">=</span> <span class="dt">Employee</span></span>
<span id="cb424-4"><a href="#cb424-4" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> name ::</span> <span class="dt">T.Text</span></span>
<span id="cb424-5"><a href="#cb424-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> age ::</span> <span class="dt">Int</span></span>
<span id="cb424-6"><a href="#cb424-6" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Is equivalent to:</p>
<div class="sourceCode" id="cb425"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb425-1"><a href="#cb425-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Employee</span> <span class="ot">=</span> <span class="dt">Employee</span></span>
<span id="cb425-2"><a href="#cb425-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> name ::</span> <span class="op">!</span><span class="dt">T.Text</span></span>
<span id="cb425-3"><a href="#cb425-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> age ::</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb425-4"><a href="#cb425-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<h2 id="strict">Strict</h2>
<p>Strict implies <code>-XStrictData</code> and extends strictness
annotations to all arguments of functions.</p>
<div class="sourceCode" id="cb426"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb426-1"><a href="#cb426-1" aria-hidden="true" tabindex="-1"></a>f x y <span class="ot">=</span> x <span class="op">+</span> y</span></code></pre></div>
<p>Is equivalent to the following function declaration with explicit
bang patterns:</p>
<div class="sourceCode" id="cb427"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb427-1"><a href="#cb427-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">!</span>x <span class="op">!</span>y <span class="ot">=</span> x <span class="op">+</span> y</span></code></pre></div>
<p>On a module-level this effectively makes Haskell a call-by-value
language with some caveats. All arguments to functions are now
explicitly evaluated and all data in constructors within this module are
in head normal form by construction.</p>
<h2 id="deepseq">Deepseq</h2>
<p>There are often times when for performance reasons we need to deeply
evaluate a data structure to normal form leaving no terms unevaluated.
The <code>deepseq</code> library performs this task.</p>
<p>The typeclass <code>NFData</code> (Normal Form Data) allows us to seq
all elements of a structure across any subtypes which themselves
implement NFData.</p>
<div class="sourceCode" id="cb428"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb428-1"><a href="#cb428-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">NFData</span> a <span class="kw">where</span></span>
<span id="cb428-2"><a href="#cb428-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  rnf ::</span> a <span class="ot">-&gt;</span> ()</span>
<span id="cb428-3"><a href="#cb428-3" aria-hidden="true" tabindex="-1"></a>  rnf a <span class="ot">=</span> a <span class="ot">`seq`</span> ()</span>
<span id="cb428-4"><a href="#cb428-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb428-5"><a href="#cb428-5" aria-hidden="true" tabindex="-1"></a><span class="ot">deepseq ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</span>
<span id="cb428-6"><a href="#cb428-6" aria-hidden="true" tabindex="-1"></a><span class="ot">($!!) ::</span> (<span class="dt">NFData</span> a) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span></code></pre></div>
<div class="sourceCode" id="cb429"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb429-1"><a href="#cb429-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NFData</span> <span class="dt">Int</span></span>
<span id="cb429-2"><a href="#cb429-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NFData</span> (a <span class="ot">-&gt;</span> b)</span>
<span id="cb429-3"><a href="#cb429-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb429-4"><a href="#cb429-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">NFData</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span></span>
<span id="cb429-5"><a href="#cb429-5" aria-hidden="true" tabindex="-1"></a>    rnf <span class="dt">Nothing</span>  <span class="ot">=</span> ()</span>
<span id="cb429-6"><a href="#cb429-6" aria-hidden="true" tabindex="-1"></a>    rnf (<span class="dt">Just</span> x) <span class="ot">=</span> rnf x</span>
<span id="cb429-7"><a href="#cb429-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb429-8"><a href="#cb429-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">NFData</span> [a] <span class="kw">where</span></span>
<span id="cb429-9"><a href="#cb429-9" aria-hidden="true" tabindex="-1"></a>    rnf [] <span class="ot">=</span> ()</span>
<span id="cb429-10"><a href="#cb429-10" aria-hidden="true" tabindex="-1"></a>    rnf (x<span class="op">:</span>xs) <span class="ot">=</span> rnf x <span class="ot">`seq`</span> rnf xs</span></code></pre></div>
<div class="sourceCode" id="cb430"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb430-1"><a href="#cb430-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>, <span class="fu">undefined</span>] <span class="ot">`seq`</span> ()</span>
<span id="cb430-2"><a href="#cb430-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- ()</span></span>
<span id="cb430-3"><a href="#cb430-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb430-4"><a href="#cb430-4" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>, <span class="fu">undefined</span>] <span class="ot">`deepseq`</span> ()</span>
<span id="cb430-5"><a href="#cb430-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Prelude.undefined</span></span></code></pre></div>
<p>To force a data structure itself to be fully evaluated we share the
same argument in both positions of deepseq.</p>
<div class="sourceCode" id="cb431"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb431-1"><a href="#cb431-1" aria-hidden="true" tabindex="-1"></a><span class="ot">force ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb431-2"><a href="#cb431-2" aria-hidden="true" tabindex="-1"></a>force x <span class="ot">=</span> x <span class="ot">`deepseq`</span> x</span></code></pre></div>
<h2 id="irrefutable-patterns">Irrefutable Patterns</h2>
<p>A lazy pattern doesn’t require a match on the outer constructor,
instead it lazily calls the accessors of the values as needed. In the
presence of a bottom, we fail at the usage site instead of the outer
pattern match.</p>
<div class="sourceCode" id="cb432"
data-include="src/05-laziness/lazy_patterns.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb432-1"><a href="#cb432-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> (a, b) <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb432-2"><a href="#cb432-2" aria-hidden="true" tabindex="-1"></a>f (a,b) <span class="ot">=</span> <span class="fu">const</span> <span class="dv">1</span> a</span>
<span id="cb432-3"><a href="#cb432-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb432-4"><a href="#cb432-4" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> (a, b) <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb432-5"><a href="#cb432-5" aria-hidden="true" tabindex="-1"></a>g <span class="op">~</span>(a,b) <span class="ot">=</span> <span class="fu">const</span> <span class="dv">1</span> a</span>
<span id="cb432-6"><a href="#cb432-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb432-7"><a href="#cb432-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- λ: f undefined</span></span>
<span id="cb432-8"><a href="#cb432-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- *** Exception: Prelude.undefined</span></span>
<span id="cb432-9"><a href="#cb432-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- λ: g undefined</span></span>
<span id="cb432-10"><a href="#cb432-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1</span></span>
<span id="cb432-11"><a href="#cb432-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb432-12"><a href="#cb432-12" aria-hidden="true" tabindex="-1"></a><span class="ot">j ::</span> <span class="dt">Maybe</span> t <span class="ot">-&gt;</span> t</span>
<span id="cb432-13"><a href="#cb432-13" aria-hidden="true" tabindex="-1"></a>j <span class="op">~</span>(<span class="dt">Just</span> x) <span class="ot">=</span> x</span>
<span id="cb432-14"><a href="#cb432-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb432-15"><a href="#cb432-15" aria-hidden="true" tabindex="-1"></a><span class="ot">k ::</span> <span class="dt">Maybe</span> t <span class="ot">-&gt;</span> t</span>
<span id="cb432-16"><a href="#cb432-16" aria-hidden="true" tabindex="-1"></a>k (<span class="dt">Just</span> x) <span class="ot">=</span> x</span>
<span id="cb432-17"><a href="#cb432-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb432-18"><a href="#cb432-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- λ: j Nothing</span></span>
<span id="cb432-19"><a href="#cb432-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- *** Exception: src/05-laziness/lazy_patterns.hs:15:1-15: Irrefutable pattern failed for pattern (Just x)</span></span>
<span id="cb432-20"><a href="#cb432-20" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb432-21"><a href="#cb432-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- λ: k Nothing</span></span>
<span id="cb432-22"><a href="#cb432-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- *** Exception: src/05-laziness/lazy_patterns.hs:18:1-14: Non-exhaustive patterns in function k</span></span></code></pre></div>
<h2 id="the-debate">The Debate</h2>
<p>Laziness is a controversial design decision in Haskell. It is
difficult to write production Haskell code that operates in constant
memory without some insight into the evaluation model and the runtime. A
lot of industrial codebases have a policy of marking all constructors as
strict by default or enabling <a href="#strictdata">StrictData</a> to
prevent space leaks. If Haskell were being designed from scratch it
probably would not choose laziness as the default model. Future
implementations of Haskell compilers would not choose this point in the
design space if given the option of breaking with the language
specification.</p>
<p>There is a lot of fear, uncertainty and doubt spread about lazy
evaluation that unfortunately loses the forest for the trees and ignores
30 years of advanced research on the type system. In industrial
programming a lot of software is sold on the meme of being of
<em>fast</em> instead of being <em>correct</em>, and lazy evaluation is
an intellectually easy talking point about these upside-down priorities.
Nevertheless the colloquial perception of laziness being “evil” is a
meme that will continue to persist regardless of any underlying reality
because software is intrinsically a social process.</p>
<hr/>
<h1 id="prelude-1">Prelude</h1>
<h2 id="what-to-avoid">What to Avoid?</h2>
<p>Haskell being a 30 year old language has witnessed several
revolutions in the way we structure and compose functional programs. Yet
as a result several portions of the Prelude still reflect old schools of
thought that simply can’t be removed without breaking significant parts
of the ecosystem.</p>
<p>Currently it really only exists in folklore which parts to use and
which not to use, although this is a topic that almost all introductory
books don’t mention and instead make extensive use of the Prelude for
simplicity’s sake.</p>
<p>The short version of the advice on the Prelude is:</p>
<div class="alert alert-success">
<ul>
<li>Avoid String.</li>
<li>Use <code>fmap</code> instead of <code>map</code>.</li>
<li>Use Foldable and Traversable instead of the Control.Monad, and
Data.List versions of traversals.</li>
<li>Avoid partial functions like <code>head</code> and <code>read</code>
or use their total variants.</li>
<li>Avoid exceptions, use ExceptT or Either instead.</li>
<li>Avoid boolean blind functions.</li>
</ul>
</div>
<p>The instances of Foldable for the list type often conflict with the
monomorphic versions in the Prelude which are left in for historical
reasons. So oftentimes it is desirable to explicitly mask these
functions from implicit import and force the use of Foldable and
Traversable instead.</p>
<p>Of course oftentimes one wishes to only use the Prelude explicitly
and one can explicitly import it qualified and use the pieces as desired
without the implicit import of the whole namespace.</p>
<div class="sourceCode" id="cb433"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb433-1"><a href="#cb433-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span> <span class="kw">as</span> <span class="dt">P</span></span></code></pre></div>
<h2 id="what-should-be-in-prelude">What Should be in Prelude</h2>
<p>To get work done on industrial projects you probably need the
following libraries:</p>
<ul>
<li><code>text</code></li>
<li><code>containers</code></li>
<li><code>unordered-containers</code></li>
<li><code>mtl</code></li>
<li><code>transformers</code></li>
<li><code>vector</code></li>
<li><code>filepath</code></li>
<li><code>directory</code></li>
<li><code>process</code></li>
<li><code>bytestring</code></li>
<li><code>optparse-applicative</code></li>
<li><code>unix</code></li>
<li><code>aeson</code></li>
</ul>
<h2 id="custom-preludes">Custom Preludes</h2>
<p>The default Prelude can be disabled in its entirety by twiddling the
<code>-XNoImplicitPrelude</code> flag which allows us to replace the
default import entirely with a custom prelude. Many industrial projects
will roll their own <code>Prologue.hs</code> module which replaces the
legacy prelude.</p>
<div class="sourceCode" id="cb434"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb434-1"><a href="#cb434-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></span></code></pre></div>
<p>For example if we wanted to build up a custom project prelude we
could construct a Prologue module and dump the relevant namespaces we
want from <code>base</code> into our custom export list. Using the
module reexport feature allows us to create an <code>Exports</code>
namespace which contains our Prelude’s symbols. Every subsequent module
in our project will then have <code>import Prologue</code> as the first
import.</p>
<div class="sourceCode" id="cb435"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb435-1"><a href="#cb435-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Prologue</span> (</span>
<span id="cb435-2"><a href="#cb435-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">module</span> <span class="dt">Exports</span>,</span>
<span id="cb435-3"><a href="#cb435-3" aria-hidden="true" tabindex="-1"></a>) <span class="kw">where</span></span>
<span id="cb435-4"><a href="#cb435-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb435-5"><a href="#cb435-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Int</span> <span class="kw">as</span> <span class="dt">Exports</span></span>
<span id="cb435-6"><a href="#cb435-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Tuple</span> <span class="kw">as</span> <span class="dt">Exports</span></span>
<span id="cb435-7"><a href="#cb435-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span> <span class="kw">as</span> <span class="dt">Exports</span></span>
<span id="cb435-8"><a href="#cb435-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.String</span> <span class="kw">as</span> <span class="dt">Exports</span></span>
<span id="cb435-9"><a href="#cb435-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span> <span class="kw">as</span> <span class="dt">Exports</span></span>
<span id="cb435-10"><a href="#cb435-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Traversable</span> <span class="kw">as</span> <span class="dt">Exports</span></span>
<span id="cb435-11"><a href="#cb435-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb435-12"><a href="#cb435-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans.Except</span></span>
<span id="cb435-13"><a href="#cb435-13" aria-hidden="true" tabindex="-1"></a>  as <span class="dt">Exports</span></span>
<span id="cb435-14"><a href="#cb435-14" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ExceptT</span>(<span class="dt">ExceptT</span>), <span class="dt">Except</span>, except, runExcept, runExceptT,</span>
<span id="cb435-15"><a href="#cb435-15" aria-hidden="true" tabindex="-1"></a>   mapExcept, mapExceptT, withExcept, withExceptT)</span></code></pre></div>
<h2 id="preludes">Preludes</h2>
<p>There are many approaches to custom preludes. The most widely used
ones are all available on Hackage.</p>
<ul>
<li><a
href="http://hackage.haskell.org/package/base-prelude">base-prelude</a></li>
<li><a href="http://hackage.haskell.org/package/rio">rio</a></li>
<li><a
href="http://hackage.haskell.org/package/protolude">protolude</a></li>
<li><a href="http://hackage.haskell.org/package/relude">relude</a></li>
<li><a
href="http://hackage.haskell.org/package/foundation">foundation</a></li>
<li><a href="http://hackage.haskell.org/package/rebase">rebase</a></li>
<li><a
href="http://hackage.haskell.org/package/classy-prelude">classy-prelude</a></li>
<li><a
href="http://hackage.haskell.org/package/basic-prelude">basic-prelude</a></li>
</ul>
<p>Different preludes take different approaches to defining what the
Haskell standard library should be. Some are interoperable with existing
code and others require an “all-in” approach that creates an ecosystem
around it. Some projects are more community efforts and others are
developed by consulting companies or industrial users wishing to
standardise their commercial code.</p>
<p>In Modern Haskell there are many different perspectives on Prelude
design and the degree to which more advanced ideas should be used. Which
one is right for you is a matter of personal preference and constraints
in your company.</p>
<h2 id="protolude">Protolude</h2>
<p>Protolude is a minimalist Prelude which provides many sensible
defaults for writing modern Haskell and is compatible with existing
code.</p>
<div class="sourceCode" id="cb436"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb436-1"><a href="#cb436-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NoImplicitPrelude #-}</span></span>
<span id="cb436-2"><a href="#cb436-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb436-3"><a href="#cb436-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Protolude</span></span></code></pre></div>
<p>Protolude is one of the more conservative preludes and is developed
by the author of this document.</p>
<p>See:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/protolude">Protolude
Hackage</a></li>
<li><a href="https://www.github.com/protolude/protolude">Protolude
Github</a></li>
</ul>
<h2 id="partial-functions">Partial Functions</h2>
<p>A <em>partial function</em> is a function which doesn’t terminate and
yield a value for all given inputs. Conversely a <em>total function</em>
terminates and is always defined for all inputs. As mentioned
previously, certain historical parts of the Prelude are full of partial
functions.</p>
<p>The difference between partial and total functions is the compiler
can’t reason about the runtime safety of partial functions purely from
the information specified in the language and as such the proof of
safety is left to the user to guarantee. They are safe to use in the
case where the user can guarantee that invalid inputs cannot occur, but
like any unchecked property its safety or not-safety is going to depend
on the diligence of the programmer. This very much goes against the
overall philosophy of Haskell and as such they are discouraged when not
necessary.</p>
<div class="sourceCode" id="cb437"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb437-1"><a href="#cb437-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb437-2"><a href="#cb437-2" aria-hidden="true" tabindex="-1"></a><span class="fu">read</span><span class="ot"> ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span>
<span id="cb437-3"><a href="#cb437-3" aria-hidden="true" tabindex="-1"></a><span class="ot">(!!) ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>A list of partial functions in the default prelude:</p>
<p><strong>Partial for all inputs</strong></p>
<ul>
<li><code>error</code></li>
<li><code>undefined</code></li>
<li><code>fail</code> – For <code>Monad IO</code></li>
</ul>
<p><strong>Partial for empty lists</strong></p>
<ul>
<li><code>head</code></li>
<li><code>init</code></li>
<li><code>tail</code></li>
<li><code>last</code></li>
<li><code>foldr1</code></li>
<li><code>foldl1</code></li>
<li><code>cycle</code></li>
<li><code>maximum</code></li>
<li><code>minimum</code></li>
</ul>
<p><strong>Partial for Nothing</strong></p>
<ul>
<li><code>fromJust</code></li>
</ul>
<p><strong>Partial for invalid strings lists</strong></p>
<ul>
<li><code>read</code></li>
</ul>
<p><strong>Partial for infinite lists</strong></p>
<ul>
<li><code>sum</code></li>
<li><code>product</code></li>
<li><code>reverse</code></li>
</ul>
<p><strong>Partial for negative or unbounded numbers</strong></p>
<ul>
<li><code>(!)</code></li>
<li><code>(!!)</code></li>
<li><code>toEnum</code></li>
<li><code>genericIndex</code></li>
</ul>
<h2 id="replacing-partiality">Replacing Partiality</h2>
<p>The Prelude has total variants of the historical partial functions
(e.g. <code>Text.Read.readMaybe</code>) in some cases, but often these
are found in the various replacement preludes</p>
<p>The total versions provided fall into three cases:</p>
<ul>
<li><code>May</code> - return Nothing when the function is not defined
for the inputs</li>
<li><code>Def</code> - provide a default value when the function is not
defined for the inputs</li>
<li><code>Note</code> - call <code>error</code> with a custom error
message when the function is not defined for the inputs. This is not
safe, but slightly easier to debug!</li>
</ul>
<div class="sourceCode" id="cb438"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb438-1"><a href="#cb438-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Total</span></span>
<span id="cb438-2"><a href="#cb438-2" aria-hidden="true" tabindex="-1"></a><span class="ot">headMay ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb438-3"><a href="#cb438-3" aria-hidden="true" tabindex="-1"></a><span class="ot">readMay ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb438-4"><a href="#cb438-4" aria-hidden="true" tabindex="-1"></a><span class="ot">atMay ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb438-5"><a href="#cb438-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-6"><a href="#cb438-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Total</span></span>
<span id="cb438-7"><a href="#cb438-7" aria-hidden="true" tabindex="-1"></a><span class="ot">headDef ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb438-8"><a href="#cb438-8" aria-hidden="true" tabindex="-1"></a><span class="ot">readDef ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span>
<span id="cb438-9"><a href="#cb438-9" aria-hidden="true" tabindex="-1"></a><span class="ot">atDef   ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb438-10"><a href="#cb438-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb438-11"><a href="#cb438-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- Partial</span></span>
<span id="cb438-12"><a href="#cb438-12" aria-hidden="true" tabindex="-1"></a><span class="ot">headNote ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb438-13"><a href="#cb438-13" aria-hidden="true" tabindex="-1"></a><span class="ot">readNote ::</span> <span class="dt">Read</span> a <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span>
<span id="cb438-14"><a href="#cb438-14" aria-hidden="true" tabindex="-1"></a><span class="ot">atNote   ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span></code></pre></div>
<h2 id="boolean-blindness">Boolean Blindness</h2>
<p>Boolean blindness is a common problem found in many programming
languages. Consider the following two definitions which deconstruct a
Maybe value into a boolean. Is there anything wrong with the definitions
and below and why is this not caught in the type system?</p>
<div class="sourceCode" id="cb439"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb439-1"><a href="#cb439-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bool</span> <span class="ot">=</span> <span class="dt">True</span> <span class="op">|</span> <span class="dt">False</span></span>
<span id="cb439-2"><a href="#cb439-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb439-3"><a href="#cb439-3" aria-hidden="true" tabindex="-1"></a><span class="ot">isNotJust ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb439-4"><a href="#cb439-4" aria-hidden="true" tabindex="-1"></a>isNotJust (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">True</span> <span class="co">-- ???</span></span>
<span id="cb439-5"><a href="#cb439-5" aria-hidden="true" tabindex="-1"></a>isNotJust <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb439-6"><a href="#cb439-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb439-7"><a href="#cb439-7" aria-hidden="true" tabindex="-1"></a><span class="ot">isJust ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb439-8"><a href="#cb439-8" aria-hidden="true" tabindex="-1"></a>isJust (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb439-9"><a href="#cb439-9" aria-hidden="true" tabindex="-1"></a>isJust <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>The problem with the <code>Bool</code> type is that there is
effectively no difference between True and False at the type level. A
proposition taking a value to a Bool takes any information given and
destroys it. To reason about the behavior we have to trace the
provenance of the proposition we’re getting the boolean answer from, and
this introduces a whole slew of possibilities for misinterpretation. In
the worst case, the only way to reason about safe and unsafe use of a
function is by trusting that a predicate’s lexical name reflects its
provenance!</p>
<p>For instance, testing some proposition over a Bool value representing
whether the branch can perform the computation safely in the presence of
a null is subject to accidental interchange. Consider that in a language
like C or Python testing whether a value is null is indistinguishable to
the language from testing whether the value is <em>not null</em>. Which
of these programs encodes safe usage and which segfaults?</p>
<div class="sourceCode" id="cb440"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb440-1"><a href="#cb440-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This one?</span></span>
<span id="cb440-2"><a href="#cb440-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> p(x):</span>
<span id="cb440-3"><a href="#cb440-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># use x</span></span>
<span id="cb440-4"><a href="#cb440-4" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="kw">not</span> p(x):</span>
<span id="cb440-5"><a href="#cb440-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># don&#39;t use x</span></span>
<span id="cb440-6"><a href="#cb440-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb440-7"><a href="#cb440-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Or this one?</span></span>
<span id="cb440-8"><a href="#cb440-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> p(x):</span>
<span id="cb440-9"><a href="#cb440-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># don&#39;t use x</span></span>
<span id="cb440-10"><a href="#cb440-10" aria-hidden="true" tabindex="-1"></a><span class="cf">elif</span> <span class="kw">not</span> p(x):</span>
<span id="cb440-11"><a href="#cb440-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># use x</span></span></code></pre></div>
<p>From inspection we can’t tell without knowing how p is defined, the
compiler can’t distinguish the two either and thus the language won’t
save us if we happen to mix them up. Instead of making invalid states
<em>unrepresentable</em> we’ve made the invalid state
<em>indistinguishable</em> from the valid one!</p>
<p>The more desirable practice is to match on terms which explicitly
witness the proposition as a type (often in a sum type) and won’t
typecheck otherwise.</p>
<div class="sourceCode" id="cb441"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb441-1"><a href="#cb441-1" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb441-2"><a href="#cb441-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> use x</span>
<span id="cb441-3"><a href="#cb441-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> don&#39;t use x</span>
<span id="cb441-4"><a href="#cb441-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb441-5"><a href="#cb441-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- not ideal</span></span>
<span id="cb441-6"><a href="#cb441-6" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> p x <span class="kw">of</span></span>
<span id="cb441-7"><a href="#cb441-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span>  <span class="ot">-&gt;</span> use x</span>
<span id="cb441-8"><a href="#cb441-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span> <span class="ot">-&gt;</span> don&#39;t use x</span>
<span id="cb441-9"><a href="#cb441-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb441-10"><a href="#cb441-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- not ideal</span></span>
<span id="cb441-11"><a href="#cb441-11" aria-hidden="true" tabindex="-1"></a><span class="kw">if</span> p x</span>
<span id="cb441-12"><a href="#cb441-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">then</span> use x</span>
<span id="cb441-13"><a href="#cb441-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">else</span> don&#39;t use x</span></code></pre></div>
<p>To be fair though, many popular languages completely lack the notion
of sum types (the source of many woes in my opinion) and only have
product types, so this type of reasoning sometimes has no direct
equivalence for those not familiar with ML family languages.</p>
<p>In Haskell, the Prelude provides functions like <code>isJust</code>
and <code>fromJust</code> both of which can be used to subvert this kind
of reasoning and make it easy to introduce bugs and should often be
avoided.</p>
<h2 id="foldable-traversable">Foldable / Traversable</h2>
<p>If coming from an imperative background retraining oneself to think
about iteration over lists in terms of maps, folds, and scans can be
challenging.</p>
<div class="sourceCode" id="cb442"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb442-1"><a href="#cb442-1" aria-hidden="true" tabindex="-1"></a>Prelude.foldl<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [b] <span class="ot">-&gt;</span> a</span>
<span id="cb442-2"><a href="#cb442-2" aria-hidden="true" tabindex="-1"></a>Prelude.foldr<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span>
<span id="cb442-3"><a href="#cb442-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb442-4"><a href="#cb442-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- pseudocode</span></span>
<span id="cb442-5"><a href="#cb442-5" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f z [a<span class="op">...</span>] <span class="ot">=</span> f a (f b ( <span class="op">...</span> (f y z) <span class="op">...</span> ))</span>
<span id="cb442-6"><a href="#cb442-6" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span> f z [a<span class="op">...</span>] <span class="ot">=</span> f <span class="op">...</span> (f (f z a) b) <span class="op">...</span> y</span></code></pre></div>
<p>For a concrete example consider the simple arithmetic sequence over
the binary operator <code>(+)</code>:</p>
<div class="sourceCode" id="cb443"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb443-1"><a href="#cb443-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- foldr (+) 1 [2..]</span></span>
<span id="cb443-2"><a href="#cb443-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span> <span class="op">+</span> (<span class="dv">3</span> <span class="op">+</span> (<span class="dv">4</span> <span class="op">+</span> (<span class="dv">5</span> <span class="op">+</span> <span class="op">...</span>))))</span></code></pre></div>
<div class="sourceCode" id="cb444"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb444-1"><a href="#cb444-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- foldl (+) 1 [2..]</span></span>
<span id="cb444-2"><a href="#cb444-2" aria-hidden="true" tabindex="-1"></a>((((<span class="dv">1</span> <span class="op">+</span> <span class="dv">2</span>) <span class="op">+</span> <span class="dv">3</span>) <span class="op">+</span> <span class="dv">4</span>) <span class="op">+</span> <span class="op">...</span>)</span></code></pre></div>
<p>Foldable and Traversable are the general interface for all traversals
and folds of any data structure which is parameterized over its element
type ( List, Map, Set, Maybe, …). These two classes are used everywhere
in modern Haskell and are extremely important.</p>
<div class="sourceCode" id="cb445"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb445-1"><a href="#cb445-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Foldable</span> t <span class="kw">where</span></span>
<span id="cb445-2"><a href="#cb445-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  fold    ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> t m <span class="ot">-&gt;</span> m</span>
<span id="cb445-3"><a href="#cb445-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  foldMap ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m</span>
<span id="cb445-4"><a href="#cb445-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  foldr   ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</span>
<span id="cb445-5"><a href="#cb445-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  foldr&#39;  ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</span>
<span id="cb445-6"><a href="#cb445-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  foldl   ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</span>
<span id="cb445-7"><a href="#cb445-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  foldl&#39;  ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</span>
<span id="cb445-8"><a href="#cb445-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  foldr1  ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="cb445-9"><a href="#cb445-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  foldl1  ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="cb445-10"><a href="#cb445-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  toList  ::</span> t a <span class="ot">-&gt;</span> [a]</span>
<span id="cb445-11"><a href="#cb445-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  null    ::</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb445-12"><a href="#cb445-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  length  ::</span> t a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb445-13"><a href="#cb445-13" aria-hidden="true" tabindex="-1"></a><span class="ot">  elem    ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb445-14"><a href="#cb445-14" aria-hidden="true" tabindex="-1"></a><span class="ot">  maximum ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="cb445-15"><a href="#cb445-15" aria-hidden="true" tabindex="-1"></a><span class="ot">  minimum ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="cb445-16"><a href="#cb445-16" aria-hidden="true" tabindex="-1"></a><span class="ot">  sum     ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="cb445-17"><a href="#cb445-17" aria-hidden="true" tabindex="-1"></a><span class="ot">  product ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>A foldable instance allows us to apply functions to data types of
monoidal values that collapse the structure using some logic over
<code>mappend</code>.</p>
<p>A traversable instance allows us to apply functions to data types
that walk the structure left-to-right within an applicative context.</p>
<div class="sourceCode" id="cb446"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb446-1"><a href="#cb446-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Functor</span> f, <span class="dt">Foldable</span> f) <span class="ot">=&gt;</span> <span class="dt">Traversable</span> f <span class="kw">where</span></span>
<span id="cb446-2"><a href="#cb446-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  traverse ::</span> <span class="dt">Applicative</span> g <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> g b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> g (f b)</span>
<span id="cb446-3"><a href="#cb446-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb446-4"><a href="#cb446-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Foldable</span> f <span class="kw">where</span></span>
<span id="cb446-5"><a href="#cb446-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  foldMap ::</span> <span class="dt">Monoid</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> m</span></code></pre></div>
<p>The <code>foldMap</code> function is extremely general and
non-intuitively many of the monomorphic list folds can themselves be
written in terms of this single polymorphic function.</p>
<p><code>foldMap</code> takes a function of values to a monoidal
quantity, a functor over the values and collapses the functor into the
monoid. For instance for the trivial Sum monoid:</p>
<div class="sourceCode" id="cb447"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb447-1"><a href="#cb447-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="fu">foldMap</span> <span class="dt">Sum</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb447-2"><a href="#cb447-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Sum</span> {getSum <span class="ot">=</span> <span class="dv">55</span>}</span></code></pre></div>
<p>For instance if we wanted to map a list of some abstract element
types into a hashtable of elements based on pattern matching we could
use it.</p>
<div class="sourceCode" id="cb448"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb448-1"><a href="#cb448-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span></span>
<span id="cb448-2"><a href="#cb448-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb448-3"><a href="#cb448-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb448-4"><a href="#cb448-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Elt</span></span>
<span id="cb448-5"><a href="#cb448-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Elt</span> <span class="dt">Int</span> <span class="dt">Double</span></span>
<span id="cb448-6"><a href="#cb448-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Nil</span></span>
<span id="cb448-7"><a href="#cb448-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb448-8"><a href="#cb448-8" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> [<span class="dt">Elt</span>] <span class="ot">-&gt;</span> <span class="dt">Map.Map</span> <span class="dt">Int</span> <span class="dt">Double</span></span>
<span id="cb448-9"><a href="#cb448-9" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> <span class="fu">foldMap</span> go</span>
<span id="cb448-10"><a href="#cb448-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb448-11"><a href="#cb448-11" aria-hidden="true" tabindex="-1"></a>    go (<span class="dt">Elt</span> x y) <span class="ot">=</span> Map.singleton x y</span>
<span id="cb448-12"><a href="#cb448-12" aria-hidden="true" tabindex="-1"></a>    go <span class="dt">Nil</span> <span class="ot">=</span> Map.empty</span></code></pre></div>
<p>The full Foldable class (with all default implementations) contains a
variety of derived functions which themselves can be written in terms of
<code>foldMap</code> and <code>Endo</code>.</p>
<div class="sourceCode" id="cb449"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb449-1"><a href="#cb449-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Endo</span> a <span class="ot">=</span> <span class="dt">Endo</span> {<span class="ot">appEndo ::</span> a <span class="ot">-&gt;</span> a}</span>
<span id="cb449-2"><a href="#cb449-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb449-3"><a href="#cb449-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Endo</span> a) <span class="kw">where</span></span>
<span id="cb449-4"><a href="#cb449-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">Endo</span> <span class="fu">id</span></span>
<span id="cb449-5"><a href="#cb449-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Endo</span> f <span class="ot">`mappend`</span> <span class="dt">Endo</span> g <span class="ot">=</span> <span class="dt">Endo</span> (f <span class="op">.</span> g)</span></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb450"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb450-1"><a href="#cb450-1" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> b</span>
<span id="cb450-2"><a href="#cb450-2" aria-hidden="true" tabindex="-1"></a><span class="fu">foldr</span> f z t <span class="ot">=</span> appEndo (<span class="fu">foldMap</span> (<span class="dt">Endo</span> <span class="op">.</span> f) t) z</span></code></pre></div>
<p>Most of the operations over lists can be generalized in terms of
combinations of Foldable and Traversable to derive more general
functions that work over all data structures implementing Foldable.</p>
<div class="sourceCode" id="cb451"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb451-1"><a href="#cb451-1" aria-hidden="true" tabindex="-1"></a>Data.Foldable.elem<span class="ot">    ::</span> (<span class="dt">Eq</span> a, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb451-2"><a href="#cb451-2" aria-hidden="true" tabindex="-1"></a>Data.Foldable.sum<span class="ot">     ::</span> (<span class="dt">Num</span> a, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="cb451-3"><a href="#cb451-3" aria-hidden="true" tabindex="-1"></a>Data.Foldable.minimum<span class="ot"> ::</span> (<span class="dt">Ord</span> a, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> a</span>
<span id="cb451-4"><a href="#cb451-4" aria-hidden="true" tabindex="-1"></a>Data.Traversable.mapM<span class="ot"> ::</span> (<span class="dt">Monad</span> m, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</span></code></pre></div>
<p>Unfortunately for historical reasons the names exported by Foldable
quite often conflict with ones defined in the Prelude, either import
them qualified or just disable the Prelude. The operations in the
Foldable class all specialize to the same and behave the same as the
ones in Prelude for List types.</p>
<div class="sourceCode" id="cb452"
data-include="src/06-prelude/foldable_traversable.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb452-1"><a href="#cb452-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb452-2"><a href="#cb452-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Identity</span> (runIdentity)</span>
<span id="cb452-3"><a href="#cb452-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span></span>
<span id="cb452-4"><a href="#cb452-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span></span>
<span id="cb452-5"><a href="#cb452-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Traversable</span></span>
<span id="cb452-6"><a href="#cb452-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (foldr, mapM_)</span>
<span id="cb452-7"><a href="#cb452-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb452-8"><a href="#cb452-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Rose Tree</span></span>
<span id="cb452-9"><a href="#cb452-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Node</span> a [<span class="dt">Tree</span> a] <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb452-10"><a href="#cb452-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb452-11"><a href="#cb452-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Tree</span> <span class="kw">where</span></span>
<span id="cb452-12"><a href="#cb452-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Node</span> x ts) <span class="ot">=</span> <span class="dt">Node</span> (f x) (<span class="fu">fmap</span> (<span class="fu">fmap</span> f) ts)</span>
<span id="cb452-13"><a href="#cb452-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb452-14"><a href="#cb452-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Traversable</span> <span class="dt">Tree</span> <span class="kw">where</span></span>
<span id="cb452-15"><a href="#cb452-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">traverse</span> f (<span class="dt">Node</span> x ts) <span class="ot">=</span> <span class="dt">Node</span> <span class="op">&lt;$&gt;</span> f x <span class="op">&lt;*&gt;</span> <span class="fu">traverse</span> (<span class="fu">traverse</span> f) ts</span>
<span id="cb452-16"><a href="#cb452-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb452-17"><a href="#cb452-17" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Tree</span> <span class="kw">where</span></span>
<span id="cb452-18"><a href="#cb452-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">foldMap</span> f (<span class="dt">Node</span> x ts) <span class="ot">=</span> f x <span class="ot">`mappend`</span> <span class="fu">foldMap</span> (<span class="fu">foldMap</span> f) ts</span>
<span id="cb452-19"><a href="#cb452-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb452-20"><a href="#cb452-20" aria-hidden="true" tabindex="-1"></a><span class="ot">tree ::</span> <span class="dt">Tree</span> <span class="dt">Integer</span></span>
<span id="cb452-21"><a href="#cb452-21" aria-hidden="true" tabindex="-1"></a>tree <span class="ot">=</span> <span class="dt">Node</span> <span class="dv">1</span> [<span class="dt">Node</span> <span class="dv">1</span> [], <span class="dt">Node</span> <span class="dv">2</span> [], <span class="dt">Node</span> <span class="dv">3</span> []]</span>
<span id="cb452-22"><a href="#cb452-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb452-23"><a href="#cb452-23" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb452-24"><a href="#cb452-24" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> <span class="fu">mapM_</span> <span class="fu">print</span> tree</span>
<span id="cb452-25"><a href="#cb452-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb452-26"><a href="#cb452-26" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Integer</span></span>
<span id="cb452-27"><a href="#cb452-27" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">+</span>) <span class="dv">0</span> tree</span>
<span id="cb452-28"><a href="#cb452-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb452-29"><a href="#cb452-29" aria-hidden="true" tabindex="-1"></a><span class="ot">example3 ::</span> <span class="dt">Maybe</span> (<span class="dt">Tree</span> <span class="dt">Integer</span>)</span>
<span id="cb452-30"><a href="#cb452-30" aria-hidden="true" tabindex="-1"></a>example3 <span class="ot">=</span> <span class="fu">traverse</span> (\x <span class="ot">-&gt;</span> <span class="kw">if</span> x <span class="op">&gt;</span> <span class="dv">2</span> <span class="kw">then</span> <span class="dt">Just</span> x <span class="kw">else</span> <span class="dt">Nothing</span>) tree</span>
<span id="cb452-31"><a href="#cb452-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb452-32"><a href="#cb452-32" aria-hidden="true" tabindex="-1"></a><span class="ot">example4 ::</span> <span class="dt">Tree</span> <span class="dt">Integer</span></span>
<span id="cb452-33"><a href="#cb452-33" aria-hidden="true" tabindex="-1"></a>example4 <span class="ot">=</span> runIdentity <span class="op">$</span> <span class="fu">traverse</span> (\x <span class="ot">-&gt;</span> <span class="fu">pure</span> (x <span class="op">+</span> <span class="dv">1</span>)) tree</span></code></pre></div>
<p>The instances we defined above can also be automatically derived by
GHC using several language extensions. The automatic instances are
identical to the hand-written versions above.</p>
<div class="sourceCode" id="cb453"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb453-1"><a href="#cb453-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb453-2"><a href="#cb453-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFoldable #-}</span></span>
<span id="cb453-3"><a href="#cb453-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveTraversable #-}</span></span>
<span id="cb453-4"><a href="#cb453-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb453-5"><a href="#cb453-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Node</span> a [<span class="dt">Tree</span> a]</span>
<span id="cb453-6"><a href="#cb453-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span></code></pre></div>
<hr/>
<h1 id="strings">Strings</h1>
<p>The string situation in Haskell is a sad affair. The default String
type is defined as linked list of pointers to characters which is an
extremely pathological and inefficient way of representing textual data.
Unfortunately for historical reasons large portions of GHC and Base
depend on String.</p>
<p>The String problem is intrinsically linked to the fact that the
default GHC Prelude provides a set of broken defaults that are difficult
to change because GHC and the entire ecosystem historically depend on
it. There are however high performance string libraries that can swapped
in for the broken <code>String</code> type and we will discuss some ways
of working with high-performance and memory efficient replacements.</p>
<h2 id="string">String</h2>
<p>The default Haskell string type is implemented as a naive linked list
of characters, this is hilariously terrible for most purposes but no one
knows how to fix it without rewriting large portions of all code that
exists, and simply nobody wants to commit the time to fix it. So it
remains broken, likely forever.</p>
<div class="sourceCode" id="cb454"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb454-1"><a href="#cb454-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">String</span> <span class="ot">=</span> [<span class="dt">Char</span>]</span></code></pre></div>
<p>However, fear not as there are are two replacement libraries for
processing textual data: <code>text</code> and
<code>bytestring</code>.</p>
<ul>
<li><code>text</code> - Used for handling unicode data.</li>
<li><code>bytestring</code> - Used for handling ASCII data that needs to
interchange with C code or network protocols.</li>
</ul>
<p>For each of these there are two variants for both text and
bytestring.</p>
<ul>
<li><strong>lazy</strong> - Lazy text objects are encoded as lazy lists
of strict chunks of bytes.</li>
<li><strong>strict</strong> - Byte vectors are encoded as strict Word8
arrays of bytes or code points</li>
</ul>
<p>Giving rise to the Cartesian product of the four common string
types:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Variant</th>
<th style="text-align: left;">Module</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>strict text</strong></td>
<td style="text-align: left;"><code>Data.Text</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>lazy text</strong></td>
<td style="text-align: left;"><code>Data.Text.Lazy</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>strict bytestring</strong></td>
<td style="text-align: left;"><code>Data.ByteString</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>lazy bytestring</strong></td>
<td style="text-align: left;"><code>Data.ByteString.Lazy</code></td>
</tr>
</tbody>
</table>
<h2 id="string-conversions">String Conversions</h2>
<p>Conversions between strings types are done with several functions
across the bytestring and text libraries. The mapping between text and
bytestring is inherently lossy so there is some degree of freedom in
choosing the encoding. We’ll just consider utf-8 for simplicity.</p>
<table>
<caption>From : left column, To : top row</caption>
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;">Data.Text</th>
<th style="text-align: left;">Data.Text.Lazy</th>
<th style="text-align: left;">Data.ByteString</th>
<th style="text-align: left;">Data.ByteString.Lazy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Data.Text</td>
<td style="text-align: left;">id</td>
<td style="text-align: left;">fromStrict</td>
<td style="text-align: left;">encodeUtf8</td>
<td style="text-align: left;">encodeUtf8</td>
</tr>
<tr class="even">
<td>Data.Text.Lazy</td>
<td style="text-align: left;">toStrict</td>
<td style="text-align: left;">id</td>
<td style="text-align: left;">encodeUtf8</td>
<td style="text-align: left;">encodeUtf8</td>
</tr>
<tr class="odd">
<td>Data.ByteString</td>
<td style="text-align: left;">decodeUtf8</td>
<td style="text-align: left;">decodeUtf8</td>
<td style="text-align: left;">id</td>
<td style="text-align: left;">fromStrict</td>
</tr>
<tr class="even">
<td>Data.ByteString.Lazy</td>
<td style="text-align: left;">decodeUtf8</td>
<td style="text-align: left;">decodeUtf8</td>
<td style="text-align: left;">toStrict</td>
<td style="text-align: left;">id</td>
</tr>
</tbody>
</table>
<p>Be careful with the functions (<code>decodeUtf8</code>,
<code>decodeUtf16LE</code>, etc.) as they are partial and will throw
errors if the byte array given does not contain unicode code points.
Instead use one of the following functions which will allow you to
explicitly handle the error case:</p>
<div class="sourceCode" id="cb455"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb455-1"><a href="#cb455-1" aria-hidden="true" tabindex="-1"></a><span class="ot">decodeUtf8&#39; ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">UnicodeException</span> <span class="dt">Text</span></span>
<span id="cb455-2"><a href="#cb455-2" aria-hidden="true" tabindex="-1"></a><span class="ot">decodeUtf8With ::</span> <span class="dt">OnDecodeError</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span></code></pre></div>
<h2 id="overloadedstrings">OverloadedStrings</h2>
<p>With the <code>-XOverloadedStrings</code> extension string literals
can be overloaded without the need for explicit packing and can be
written as string literals in the Haskell source and overloaded via the
typeclass <code>IsString</code>. Sometimes this is desirable.</p>
<div class="sourceCode" id="cb456"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb456-1"><a href="#cb456-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">IsString</span> a <span class="kw">where</span></span>
<span id="cb456-2"><a href="#cb456-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  fromString ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>For instance:</p>
<div class="sourceCode" id="cb457"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb457-1"><a href="#cb457-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span><span class="kw">type</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb457-2"><a href="#cb457-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> [<span class="dt">Char</span>]</span>
<span id="cb457-3"><a href="#cb457-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb457-4"><a href="#cb457-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>set <span class="op">-</span><span class="dt">XOverloadedStrings</span></span>
<span id="cb457-5"><a href="#cb457-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb457-6"><a href="#cb457-6" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span><span class="kw">type</span> <span class="st">&quot;foo&quot;</span></span>
<span id="cb457-7"><a href="#cb457-7" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">IsString</span> a <span class="ot">=&gt;</span> a</span></code></pre></div>
<p>We can also derive IsString for newtypes using
<code>GeneralizedNewtypeDeriving</code>, although much of the safety of
the newtype is then lost if it is used interchangeable with other
strings.</p>
<div class="sourceCode" id="cb458"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb458-1"><a href="#cb458-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Cat</span> <span class="ot">=</span> <span class="dt">Cat</span> <span class="dt">Text</span></span>
<span id="cb458-2"><a href="#cb458-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">IsString</span>)</span>
<span id="cb458-3"><a href="#cb458-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb458-4"><a href="#cb458-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fluffy ::</span> <span class="dt">Cat</span></span>
<span id="cb458-5"><a href="#cb458-5" aria-hidden="true" tabindex="-1"></a>fluffy <span class="ot">=</span> <span class="st">&quot;Fluffy&quot;</span></span></code></pre></div>
<p><strong>Import Conventions</strong></p>
<p>Since there are so many modules that provide string datatypes, and
these modules are used ubiquitously, some conventions are often adopted
to import these modules as specific agreed-upon qualified names. In many
Haskell projects you will see the following social conventions used for
distinguish text types.</p>
<p>For datatypes:</p>
<div class="sourceCode" id="cb459"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb459-1"><a href="#cb459-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb459-2"><a href="#cb459-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">TL</span></span>
<span id="cb459-3"><a href="#cb459-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">BS</span></span>
<span id="cb459-4"><a href="#cb459-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span></span>
<span id="cb459-5"><a href="#cb459-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">C</span></span>
<span id="cb459-6"><a href="#cb459-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">CL</span></span></code></pre></div>
<p>For IO operations:</p>
<div class="sourceCode" id="cb460"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb460-1"><a href="#cb460-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">TIO</span></span>
<span id="cb460-2"><a href="#cb460-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">TLIO</span></span></code></pre></div>
<p>For encoding operations:</p>
<div class="sourceCode" id="cb461"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb461-1"><a href="#cb461-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Encoding</span> <span class="kw">as</span> <span class="dt">TE</span></span>
<span id="cb461-2"><a href="#cb461-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy.Encoding</span> <span class="kw">as</span> <span class="dt">TLE</span></span></code></pre></div>
<p>In addition many libraries and alternative preludes will define the
following type synonyms:</p>
<div class="sourceCode" id="cb462"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb462-1"><a href="#cb462-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LText</span> <span class="ot">=</span> <span class="dt">TL.Text</span></span>
<span id="cb462-2"><a href="#cb462-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LByteString</span> <span class="ot">=</span> <span class="dt">BL.ByteString</span></span></code></pre></div>
<h2 id="text">Text</h2>
<p>The <code>Text</code> type is a packed blob of Unicode
characters.</p>
<div class="sourceCode" id="cb463"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb463-1"><a href="#cb463-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pack</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb463-2"><a href="#cb463-2" aria-hidden="true" tabindex="-1"></a><span class="ot">unpack ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<div class="sourceCode" id="cb464"
data-include="src/07-text-bytestring/text.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb464-1"><a href="#cb464-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb464-2"><a href="#cb464-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb464-3"><a href="#cb464-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb464-4"><a href="#cb464-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb464-5"><a href="#cb464-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- From pack</span></span>
<span id="cb464-6"><a href="#cb464-6" aria-hidden="true" tabindex="-1"></a><span class="ot">myTStr1 ::</span> <span class="dt">T.Text</span></span>
<span id="cb464-7"><a href="#cb464-7" aria-hidden="true" tabindex="-1"></a>myTStr1 <span class="ot">=</span> T.pack (<span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">String</span>)</span>
<span id="cb464-8"><a href="#cb464-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb464-9"><a href="#cb464-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- From overloaded string literal.</span></span>
<span id="cb464-10"><a href="#cb464-10" aria-hidden="true" tabindex="-1"></a><span class="ot">myTStr2 ::</span> <span class="dt">T.Text</span></span>
<span id="cb464-11"><a href="#cb464-11" aria-hidden="true" tabindex="-1"></a>myTStr2 <span class="ot">=</span> <span class="st">&quot;bar&quot;</span></span></code></pre></div>
<p>See: <a
href="http://hackage.haskell.org/package/text-1.1.0.1/docs/Data-Text.html">Text</a></p>
<h2 id="text.builder">Text.Builder</h2>
<div class="sourceCode" id="cb465"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb465-1"><a href="#cb465-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toLazyText ::</span> <span class="dt">Builder</span> <span class="ot">-&gt;</span> <span class="dt">Data.Text.Lazy.Internal.Text</span></span>
<span id="cb465-2"><a href="#cb465-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fromLazyText ::</span> <span class="dt">Data.Text.Lazy.Internal.Text</span> <span class="ot">-&gt;</span> <span class="dt">Builder</span></span></code></pre></div>
<p>The Text.Builder allows the efficient monoidal construction of lazy
Text types without having to go through inefficient forms like String or
List types as intermediates.</p>
<div class="sourceCode" id="cb466"
data-include="src/07-text-bytestring/builder.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb466-1"><a href="#cb466-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb466-2"><a href="#cb466-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb466-3"><a href="#cb466-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span> (mconcat, (&lt;&gt;))</span>
<span id="cb466-4"><a href="#cb466-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb466-5"><a href="#cb466-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text.Lazy.Builder</span> (<span class="dt">Builder</span>, toLazyText)</span>
<span id="cb466-6"><a href="#cb466-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text.Lazy.Builder.Int</span> (decimal)</span>
<span id="cb466-7"><a href="#cb466-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb466-8"><a href="#cb466-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb466-9"><a href="#cb466-9" aria-hidden="true" tabindex="-1"></a><span class="ot">beer ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Builder</span></span>
<span id="cb466-10"><a href="#cb466-10" aria-hidden="true" tabindex="-1"></a>beer n <span class="ot">=</span> decimal n <span class="op">&lt;&gt;</span> <span class="st">&quot; bottles of beer on the wall.\n&quot;</span></span>
<span id="cb466-11"><a href="#cb466-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb466-12"><a href="#cb466-12" aria-hidden="true" tabindex="-1"></a><span class="ot">wall ::</span> <span class="dt">Builder</span></span>
<span id="cb466-13"><a href="#cb466-13" aria-hidden="true" tabindex="-1"></a>wall <span class="ot">=</span> <span class="fu">mconcat</span> <span class="op">$</span> <span class="fu">fmap</span> beer [<span class="dv">1</span><span class="op">..</span><span class="dv">1000</span>]</span>
<span id="cb466-14"><a href="#cb466-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb466-15"><a href="#cb466-15" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb466-16"><a href="#cb466-16" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> L.putStrLn <span class="op">$</span> toLazyText wall</span></code></pre></div>
<h2 id="bytestring">ByteString</h2>
<p>ByteStrings are arrays of unboxed characters with either strict or
lazy evaluation.</p>
<div class="sourceCode" id="cb467"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb467-1"><a href="#cb467-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pack</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">ByteString</span></span>
<span id="cb467-2"><a href="#cb467-2" aria-hidden="true" tabindex="-1"></a><span class="ot">unpack ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<div class="sourceCode" id="cb468"
data-include="src/07-text-bytestring/bytestring.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb468-1"><a href="#cb468-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb468-2"><a href="#cb468-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb468-3"><a href="#cb468-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb468-4"><a href="#cb468-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">S8</span></span>
<span id="cb468-5"><a href="#cb468-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb468-6"><a href="#cb468-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- From pack</span></span>
<span id="cb468-7"><a href="#cb468-7" aria-hidden="true" tabindex="-1"></a><span class="ot">bstr1 ::</span> <span class="dt">S.ByteString</span></span>
<span id="cb468-8"><a href="#cb468-8" aria-hidden="true" tabindex="-1"></a>bstr1 <span class="ot">=</span> S.pack [<span class="dv">102</span>, <span class="dv">111</span>, <span class="dv">111</span>] <span class="co">-- ascii encoding of foo as [Word8]</span></span>
<span id="cb468-9"><a href="#cb468-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb468-10"><a href="#cb468-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- From overloaded string literal.</span></span>
<span id="cb468-11"><a href="#cb468-11" aria-hidden="true" tabindex="-1"></a><span class="ot">bstr2 ::</span> <span class="dt">S.ByteString</span></span>
<span id="cb468-12"><a href="#cb468-12" aria-hidden="true" tabindex="-1"></a>bstr2 <span class="ot">=</span> <span class="st">&quot;bar&quot;</span></span></code></pre></div>
<h2 id="printf">Printf</h2>
<p>Haskell also has a variadic <code>printf</code> function in the style
of C.</p>
<div class="sourceCode" id="cb469"
data-include="src/07-text-bytestring/printf.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb469-1"><a href="#cb469-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span></span>
<span id="cb469-2"><a href="#cb469-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Printf</span></span>
<span id="cb469-3"><a href="#cb469-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb469-4"><a href="#cb469-4" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Int</span></span>
<span id="cb469-5"><a href="#cb469-5" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb469-6"><a href="#cb469-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb469-7"><a href="#cb469-7" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">Double</span></span>
<span id="cb469-8"><a href="#cb469-8" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="fl">3.14159</span></span>
<span id="cb469-9"><a href="#cb469-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb469-10"><a href="#cb469-10" aria-hidden="true" tabindex="-1"></a><span class="ot">c ::</span> <span class="dt">String</span></span>
<span id="cb469-11"><a href="#cb469-11" aria-hidden="true" tabindex="-1"></a>c <span class="ot">=</span> <span class="st">&quot;haskell&quot;</span></span>
<span id="cb469-12"><a href="#cb469-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb469-13"><a href="#cb469-13" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">String</span></span>
<span id="cb469-14"><a href="#cb469-14" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> printf <span class="st">&quot;(%i, %f, %s)&quot;</span> a b c</span>
<span id="cb469-15"><a href="#cb469-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- &quot;(3, 3.14159, haskell)&quot;</span></span></code></pre></div>
<h2 id="overloaded-lists">Overloaded Lists</h2>
<p>It is ubiquitous for data structure libraries to expose
<code>toList</code> and <code>fromList</code> functions to construct
various structures out of lists. As of GHC 7.8 we now have the ability
to overload the list syntax in the surface language with the typeclass
<code>IsList</code>.</p>
<div class="sourceCode" id="cb470"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb470-1"><a href="#cb470-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">IsList</span> l <span class="kw">where</span></span>
<span id="cb470-2"><a href="#cb470-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Item</span> l</span>
<span id="cb470-3"><a href="#cb470-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  fromList  ::</span> [<span class="dt">Item</span> l] <span class="ot">-&gt;</span> l</span>
<span id="cb470-4"><a href="#cb470-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  fromListN ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Item</span> l] <span class="ot">-&gt;</span> l</span>
<span id="cb470-5"><a href="#cb470-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  toList    ::</span> l <span class="ot">-&gt;</span> [<span class="dt">Item</span> l]</span>
<span id="cb470-6"><a href="#cb470-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb470-7"><a href="#cb470-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsList</span> [a] <span class="kw">where</span></span>
<span id="cb470-8"><a href="#cb470-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Item</span> [a] <span class="ot">=</span> a</span>
<span id="cb470-9"><a href="#cb470-9" aria-hidden="true" tabindex="-1"></a>  fromList <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb470-10"><a href="#cb470-10" aria-hidden="true" tabindex="-1"></a>  toList   <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<div class="sourceCode" id="cb471"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb471-1"><a href="#cb471-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>seti <span class="op">-</span><span class="dt">XOverloadedLists</span></span>
<span id="cb471-2"><a href="#cb471-2" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span><span class="kw">type</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb471-3"><a href="#cb471-3" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> (<span class="dt">Num</span> (<span class="dt">GHC.Exts.Item</span> l), <span class="dt">GHC.Exts.IsList</span> l) <span class="ot">=&gt;</span> l</span></code></pre></div>
<p>For example we could write an overloaded list instance for hash
tables that simply converts to the hash table using
<code>fromList</code>. Some math libraries that use vector-like
structures will use overloaded lists in this fashion.</p>
<div class="sourceCode" id="cb472"
data-include="src/07-text-bytestring/overloadedlist.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb472-1"><a href="#cb472-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedLists #-}</span></span>
<span id="cb472-2"><a href="#cb472-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb472-3"><a href="#cb472-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb472-4"><a href="#cb472-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb472-5"><a href="#cb472-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">IsList</span> (..))</span>
<span id="cb472-6"><a href="#cb472-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb472-7"><a href="#cb472-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Ord</span> k) <span class="ot">=&gt;</span> <span class="dt">IsList</span> (<span class="dt">Map.Map</span> k v) <span class="kw">where</span></span>
<span id="cb472-8"><a href="#cb472-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Item</span> (<span class="dt">Map.Map</span> k v) <span class="ot">=</span> (k, v)</span>
<span id="cb472-9"><a href="#cb472-9" aria-hidden="true" tabindex="-1"></a>  fromList <span class="ot">=</span> Map.fromList</span>
<span id="cb472-10"><a href="#cb472-10" aria-hidden="true" tabindex="-1"></a>  toList <span class="ot">=</span> Map.toList</span>
<span id="cb472-11"><a href="#cb472-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb472-12"><a href="#cb472-12" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">Int</span></span>
<span id="cb472-13"><a href="#cb472-13" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> [(<span class="st">&quot;a&quot;</span>, <span class="dv">1</span>), (<span class="st">&quot;b&quot;</span>, <span class="dv">2</span>)]</span></code></pre></div>
<h2 id="regex">Regex</h2>
<p><code>regex-tdfa</code> implements POSIX extended regular
expressions. These can operate over any of the major string types and
with OverloadedStrings enabled allows you to write well-typed regex
expressions as strings.</p>
<div class="sourceCode" id="cb473"
data-include="src/07-text-bytestring/regex.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb473-1"><a href="#cb473-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb473-2"><a href="#cb473-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb473-3"><a href="#cb473-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span></span>
<span id="cb473-4"><a href="#cb473-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Regex.TDFA</span></span>
<span id="cb473-5"><a href="#cb473-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb473-6"><a href="#cb473-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Verify url address</span></span>
<span id="cb473-7"><a href="#cb473-7" aria-hidden="true" tabindex="-1"></a><span class="ot">url ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb473-8"><a href="#cb473-8" aria-hidden="true" tabindex="-1"></a>url input <span class="ot">=</span> input <span class="op">=~</span> urlRegex</span>
<span id="cb473-9"><a href="#cb473-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb473-10"><a href="#cb473-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    urlRegex ::</span> <span class="dt">Text</span></span>
<span id="cb473-11"><a href="#cb473-11" aria-hidden="true" tabindex="-1"></a>    urlRegex <span class="ot">=</span> <span class="st">&quot;https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_\\+.~#?&amp;//=]*)&quot;</span></span>
<span id="cb473-12"><a href="#cb473-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb473-13"><a href="#cb473-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Verify email address</span></span>
<span id="cb473-14"><a href="#cb473-14" aria-hidden="true" tabindex="-1"></a><span class="ot">email ::</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb473-15"><a href="#cb473-15" aria-hidden="true" tabindex="-1"></a>email input <span class="ot">=</span> input <span class="op">=~</span> emailRegex</span>
<span id="cb473-16"><a href="#cb473-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb473-17"><a href="#cb473-17" aria-hidden="true" tabindex="-1"></a><span class="ot">    emailRegex ::</span> <span class="dt">Text</span></span>
<span id="cb473-18"><a href="#cb473-18" aria-hidden="true" tabindex="-1"></a>    emailRegex <span class="ot">=</span> <span class="st">&quot;[a-zA-Z0-9+._-]+@[a-zA-Z-]+\\.[a-z]+&quot;</span></span></code></pre></div>
<h2 id="escaping-text">Escaping Text</h2>
<p>Haskell uses C-style single-character escape codes</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Escape</th>
<th style="text-align: left;">Unicode</th>
<th style="text-align: left;">Character</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">\n</td>
<td style="text-align: left;">U+000A</td>
<td style="text-align: left;">newline</td>
</tr>
<tr class="even">
<td style="text-align: left;">\0</td>
<td style="text-align: left;">U+0000</td>
<td style="text-align: left;">null character</td>
</tr>
<tr class="odd">
<td style="text-align: left;">\&amp;</td>
<td style="text-align: left;">n/a</td>
<td style="text-align: left;">empty string</td>
</tr>
<tr class="even">
<td style="text-align: left;">\’</td>
<td style="text-align: left;">U+0027</td>
<td style="text-align: left;">single quote</td>
</tr>
<tr class="odd">
<td style="text-align: left;">\\</td>
<td style="text-align: left;">U+005C</td>
<td style="text-align: left;">backslash</td>
</tr>
<tr class="even">
<td style="text-align: left;">\a</td>
<td style="text-align: left;">U+0007</td>
<td style="text-align: left;">alert</td>
</tr>
<tr class="odd">
<td style="text-align: left;">\b</td>
<td style="text-align: left;">U+0008</td>
<td style="text-align: left;">backspace</td>
</tr>
<tr class="even">
<td style="text-align: left;">\f</td>
<td style="text-align: left;">U+000C</td>
<td style="text-align: left;">form feed</td>
</tr>
<tr class="odd">
<td style="text-align: left;">\r</td>
<td style="text-align: left;">U+000D</td>
<td style="text-align: left;">carriage return</td>
</tr>
<tr class="even">
<td style="text-align: left;">\t</td>
<td style="text-align: left;">U+0009</td>
<td style="text-align: left;">horizontal tab</td>
</tr>
<tr class="odd">
<td style="text-align: left;">\v</td>
<td style="text-align: left;">U+000B</td>
<td style="text-align: left;">vertical tab</td>
</tr>
<tr class="even">
<td style="text-align: left;">\”</td>
<td style="text-align: left;">U+0022</td>
<td style="text-align: left;">double quote</td>
</tr>
</tbody>
</table>
<h2 id="string-splitting">String Splitting</h2>
<p>The <a
href="http://hackage.haskell.org/package/split-0.1.1/docs/Data-List-Split.html">split</a>
package provides a variety of missing functions for splitting list and
string types.</p>
<div class="sourceCode" id="cb474"
data-include="src/06-prelude/split.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb474-1"><a href="#cb474-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.Split</span></span>
<span id="cb474-2"><a href="#cb474-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb474-3"><a href="#cb474-3" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> [<span class="dt">String</span>]</span>
<span id="cb474-4"><a href="#cb474-4" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> splitOn <span class="st">&quot;.&quot;</span> <span class="st">&quot;foo.bar.baz&quot;</span></span>
<span id="cb474-5"><a href="#cb474-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- [&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;]</span></span>
<span id="cb474-6"><a href="#cb474-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb474-7"><a href="#cb474-7" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> [<span class="dt">String</span>]</span>
<span id="cb474-8"><a href="#cb474-8" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> chunksOf <span class="dv">10</span> <span class="st">&quot;To be or not to be that is the question.&quot;</span></span>
<span id="cb474-9"><a href="#cb474-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- [&quot;To be or n&quot;,&quot;ot to be t&quot;,&quot;hat is the&quot;,&quot; question.&quot;]</span></span></code></pre></div>
<hr/>
<h1 id="applicatives">Applicatives</h1>
<p>Like monads Applicatives are an abstract structure for a wide class
of computations that sit between functors and monads in terms of
generality.</p>
<div class="sourceCode" id="cb475"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb475-1"><a href="#cb475-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span><span class="ot"> ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb475-2"><a href="#cb475-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;$&gt;) ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb475-3"><a href="#cb475-3" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>As of GHC 7.6, Applicative is defined as:</p>
<div class="sourceCode" id="cb476"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb476-1"><a href="#cb476-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span></span>
<span id="cb476-2"><a href="#cb476-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  pure ::</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb476-3"><a href="#cb476-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb476-4"><a href="#cb476-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb476-5"><a href="#cb476-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;$&gt;) ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb476-6"><a href="#cb476-6" aria-hidden="true" tabindex="-1"></a>(<span class="op">&lt;$&gt;</span>) <span class="ot">=</span> <span class="fu">fmap</span></span></code></pre></div>
<p>With the following laws:</p>
<div class="sourceCode" id="cb477"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb477-1"><a href="#cb477-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span> <span class="fu">id</span> <span class="op">&lt;*&gt;</span> v <span class="ot">=</span> v</span>
<span id="cb477-2"><a href="#cb477-2" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span> f <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> x <span class="ot">=</span> <span class="fu">pure</span> (f x)</span>
<span id="cb477-3"><a href="#cb477-3" aria-hidden="true" tabindex="-1"></a>u <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> y <span class="ot">=</span> <span class="fu">pure</span> (<span class="op">$</span> y) <span class="op">&lt;*&gt;</span> u</span>
<span id="cb477-4"><a href="#cb477-4" aria-hidden="true" tabindex="-1"></a>u <span class="op">&lt;*&gt;</span> (v <span class="op">&lt;*&gt;</span> w) <span class="ot">=</span> <span class="fu">pure</span> (<span class="op">.</span>) <span class="op">&lt;*&gt;</span> u <span class="op">&lt;*&gt;</span> v <span class="op">&lt;*&gt;</span> w</span></code></pre></div>
<p>As an example, consider the instance for Maybe:</p>
<div class="sourceCode" id="cb478"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb478-1"><a href="#cb478-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb478-2"><a href="#cb478-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span>              <span class="ot">=</span> <span class="dt">Just</span></span>
<span id="cb478-3"><a href="#cb478-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span> <span class="op">&lt;*&gt;</span> _     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb478-4"><a href="#cb478-4" aria-hidden="true" tabindex="-1"></a>  _ <span class="op">&lt;*&gt;</span> <span class="dt">Nothing</span>     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb478-5"><a href="#cb478-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> f <span class="op">&lt;*&gt;</span> <span class="dt">Just</span> x <span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<p>As a rule of thumb, whenever we would use
<code>m &gt;&gt;= return . f</code> what we probably want is an
applicative functor, and not a monad.</p>
<div class="sourceCode" id="cb479"
data-include="src/08-applicatives/applicative.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb479-1"><a href="#cb479-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span> ((&lt;$&gt;), (&lt;*&gt;))</span>
<span id="cb479-2"><a href="#cb479-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.HTTP</span></span>
<span id="cb479-3"><a href="#cb479-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb479-4"><a href="#cb479-4" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Maybe</span> <span class="dt">Integer</span></span>
<span id="cb479-5"><a href="#cb479-5" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> (<span class="op">+</span>) <span class="op">&lt;$&gt;</span> m1 <span class="op">&lt;*&gt;</span> m2</span>
<span id="cb479-6"><a href="#cb479-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb479-7"><a href="#cb479-7" aria-hidden="true" tabindex="-1"></a>    m1 <span class="ot">=</span> <span class="dt">Just</span> <span class="dv">3</span></span>
<span id="cb479-8"><a href="#cb479-8" aria-hidden="true" tabindex="-1"></a>    m2 <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb479-9"><a href="#cb479-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb479-10"><a href="#cb479-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- Nothing</span></span>
<span id="cb479-11"><a href="#cb479-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb479-12"><a href="#cb479-12" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb479-13"><a href="#cb479-13" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> (,,) <span class="op">&lt;$&gt;</span> m1 <span class="op">&lt;*&gt;</span> m2 <span class="op">&lt;*&gt;</span> m3</span>
<span id="cb479-14"><a href="#cb479-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb479-15"><a href="#cb479-15" aria-hidden="true" tabindex="-1"></a>    m1 <span class="ot">=</span> [<span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb479-16"><a href="#cb479-16" aria-hidden="true" tabindex="-1"></a>    m2 <span class="ot">=</span> [<span class="dv">10</span>, <span class="dv">20</span>]</span>
<span id="cb479-17"><a href="#cb479-17" aria-hidden="true" tabindex="-1"></a>    m3 <span class="ot">=</span> [<span class="dv">100</span>, <span class="dv">200</span>]</span>
<span id="cb479-18"><a href="#cb479-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb479-19"><a href="#cb479-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- [(1,10,100),(1,10,200),(1,20,100),(1,20,200),(2,10,100),(2,10,200),(2,20,100),(2,20,200)]</span></span>
<span id="cb479-20"><a href="#cb479-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb479-21"><a href="#cb479-21" aria-hidden="true" tabindex="-1"></a><span class="ot">example3 ::</span> <span class="dt">IO</span> <span class="dt">String</span></span>
<span id="cb479-22"><a href="#cb479-22" aria-hidden="true" tabindex="-1"></a>example3 <span class="ot">=</span> (<span class="op">++</span>) <span class="op">&lt;$&gt;</span> fetch1 <span class="op">&lt;*&gt;</span> fetch2</span>
<span id="cb479-23"><a href="#cb479-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb479-24"><a href="#cb479-24" aria-hidden="true" tabindex="-1"></a>    fetch1 <span class="ot">=</span> simpleHTTP (getRequest <span class="st">&quot;http://www.python.org/&quot;</span>) <span class="op">&gt;&gt;=</span> getResponseBody</span>
<span id="cb479-25"><a href="#cb479-25" aria-hidden="true" tabindex="-1"></a>    fetch2 <span class="ot">=</span> simpleHTTP (getRequest <span class="st">&quot;http://www.haskell.org/&quot;</span>) <span class="op">&gt;&gt;=</span> getResponseBody</span></code></pre></div>
<p>The pattern <code>f &lt;$&gt; a &lt;*&gt; b ...</code> shows up so
frequently that there is a family of functions to lift applicatives of a
fixed number arguments. This pattern also shows up frequently with
monads (<code>liftM</code>, <code>liftM2</code>,
<code>liftM3</code>).</p>
<div class="sourceCode" id="cb480"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb480-1"><a href="#cb480-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftA ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb480-2"><a href="#cb480-2" aria-hidden="true" tabindex="-1"></a>liftA f a <span class="ot">=</span> <span class="fu">pure</span> f <span class="op">&lt;*&gt;</span> a</span>
<span id="cb480-3"><a href="#cb480-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb480-4"><a href="#cb480-4" aria-hidden="true" tabindex="-1"></a><span class="ot">liftA2 ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c</span>
<span id="cb480-5"><a href="#cb480-5" aria-hidden="true" tabindex="-1"></a>liftA2 f a b <span class="ot">=</span> f <span class="op">&lt;$&gt;</span> a <span class="op">&lt;*&gt;</span> b</span>
<span id="cb480-6"><a href="#cb480-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb480-7"><a href="#cb480-7" aria-hidden="true" tabindex="-1"></a><span class="ot">liftA3 ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f c <span class="ot">-&gt;</span> f d</span>
<span id="cb480-8"><a href="#cb480-8" aria-hidden="true" tabindex="-1"></a>liftA3 f a b c <span class="ot">=</span> f <span class="op">&lt;$&gt;</span> a <span class="op">&lt;*&gt;</span> b <span class="op">&lt;*&gt;</span> c</span></code></pre></div>
<p>Applicative also has functions <code>*&gt;</code> and
<code>&lt;*</code> that sequence applicative actions while discarding
the value of one of the arguments. The operator <code>*&gt;</code>
discards the left while <code>&lt;*</code> discards the right. For
example in a monadic parser combinator library the <code>*&gt;</code>
would parse with first parser argument but return the second.</p>
<p>The Applicative functions <code>&lt;$&gt;</code> and
<code>&lt;*&gt;</code> are generalized by <code>liftM</code> and
<code>ap</code> for monads.</p>
<div class="sourceCode" id="cb481"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb481-1"><a href="#cb481-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb481-2"><a href="#cb481-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb481-3"><a href="#cb481-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb481-4"><a href="#cb481-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">C</span> a b <span class="ot">=</span> <span class="dt">C</span> a b</span>
<span id="cb481-5"><a href="#cb481-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb481-6"><a href="#cb481-6" aria-hidden="true" tabindex="-1"></a><span class="ot">mnd ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m (<span class="dt">C</span> a b)</span>
<span id="cb481-7"><a href="#cb481-7" aria-hidden="true" tabindex="-1"></a>mnd a b <span class="ot">=</span> <span class="dt">C</span> <span class="ot">`liftM`</span> a <span class="ot">`ap`</span> b</span>
<span id="cb481-8"><a href="#cb481-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb481-9"><a href="#cb481-9" aria-hidden="true" tabindex="-1"></a><span class="ot">apl ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f (<span class="dt">C</span> a b)</span>
<span id="cb481-10"><a href="#cb481-10" aria-hidden="true" tabindex="-1"></a>apl a b <span class="ot">=</span> <span class="dt">C</span> <span class="op">&lt;$&gt;</span> a <span class="op">&lt;*&gt;</span> b</span></code></pre></div>
<p>See: <a
href="http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf">Applicative
Programming with Effects</a></p>
<h2 id="alternative">Alternative</h2>
<p>Alternative is an extension of the Applicative class with a zero
element and an associative binary operation respecting the zero.</p>
<div class="sourceCode" id="cb482"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb482-1"><a href="#cb482-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> f <span class="kw">where</span></span>
<span id="cb482-2"><a href="#cb482-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- | The identity of &#39;&lt;|&gt;&#39;</span></span>
<span id="cb482-3"><a href="#cb482-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  empty ::</span> f a</span>
<span id="cb482-4"><a href="#cb482-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- | An associative binary operation</span></span>
<span id="cb482-5"><a href="#cb482-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb482-6"><a href="#cb482-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- | One or more.</span></span>
<span id="cb482-7"><a href="#cb482-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  some ::</span> f a <span class="ot">-&gt;</span> f [a]</span>
<span id="cb482-8"><a href="#cb482-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- | Zero or more.</span></span>
<span id="cb482-9"><a href="#cb482-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  many ::</span> f a <span class="ot">-&gt;</span> f [a]</span>
<span id="cb482-10"><a href="#cb482-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb482-11"><a href="#cb482-11" aria-hidden="true" tabindex="-1"></a><span class="ot">optional ::</span> <span class="dt">Alternative</span> f <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> f (<span class="dt">Maybe</span> a)</span>
<span id="cb482-12"><a href="#cb482-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb482-13"><a href="#cb482-13" aria-hidden="true" tabindex="-1"></a><span class="ot">when ::</span> (<span class="dt">Alternative</span> f) <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> f () <span class="ot">-&gt;</span> f ()</span>
<span id="cb482-14"><a href="#cb482-14" aria-hidden="true" tabindex="-1"></a>when p s <span class="ot">=</span> <span class="kw">if</span> p <span class="kw">then</span> s <span class="kw">else</span> <span class="fu">return</span> ()</span>
<span id="cb482-15"><a href="#cb482-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb482-16"><a href="#cb482-16" aria-hidden="true" tabindex="-1"></a><span class="ot">guard ::</span> (<span class="dt">Alternative</span> f) <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> f ()</span>
<span id="cb482-17"><a href="#cb482-17" aria-hidden="true" tabindex="-1"></a>guard <span class="dt">True</span>  <span class="ot">=</span> <span class="fu">pure</span> ()</span>
<span id="cb482-18"><a href="#cb482-18" aria-hidden="true" tabindex="-1"></a>guard <span class="dt">False</span> <span class="ot">=</span> mzero</span></code></pre></div>
<div class="sourceCode" id="cb483"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb483-1"><a href="#cb483-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alternative</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb483-2"><a href="#cb483-2" aria-hidden="true" tabindex="-1"></a>    empty <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb483-3"><a href="#cb483-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="op">&lt;|&gt;</span> r <span class="ot">=</span> r</span>
<span id="cb483-4"><a href="#cb483-4" aria-hidden="true" tabindex="-1"></a>    l       <span class="op">&lt;|&gt;</span> _ <span class="ot">=</span> l</span>
<span id="cb483-5"><a href="#cb483-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb483-6"><a href="#cb483-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alternative</span> [] <span class="kw">where</span></span>
<span id="cb483-7"><a href="#cb483-7" aria-hidden="true" tabindex="-1"></a>    empty <span class="ot">=</span> []</span>
<span id="cb483-8"><a href="#cb483-8" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;|&gt;</span>) <span class="ot">=</span> (<span class="op">++</span>)</span></code></pre></div>
<div class="sourceCode" id="cb484"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb484-1"><a href="#cb484-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="fu">foldl1</span> (<span class="op">&lt;|&gt;</span>) [<span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="dv">5</span>, <span class="dt">Just</span> <span class="dv">3</span>]</span>
<span id="cb484-2"><a href="#cb484-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="dv">5</span></span></code></pre></div>
<p>These instances show up very frequently in parsers where the
alternative operator can model alternative parse branches.</p>
<h2 id="arrows">Arrows</h2>
<p>A category is an algebraic structure that includes a notion of an
identity and a composition operation that is associative and preserves
identities. In practice arrows are not often used in modern Haskell and
are often considered a code smell.</p>
<div class="sourceCode" id="cb485"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb485-1"><a href="#cb485-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> cat <span class="kw">where</span></span>
<span id="cb485-2"><a href="#cb485-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  id ::</span> cat a a</span>
<span id="cb485-3"><a href="#cb485-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (.) ::</span> cat b c <span class="ot">-&gt;</span> cat a b <span class="ot">-&gt;</span> cat a c</span></code></pre></div>
<div class="sourceCode" id="cb486"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb486-1"><a href="#cb486-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Category</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb486-2"><a href="#cb486-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="ot">=</span> Prelude.id</span>
<span id="cb486-3"><a href="#cb486-3" aria-hidden="true" tabindex="-1"></a>  (<span class="op">.</span>) <span class="ot">=</span> (<span class="op">Prelude..</span>)</span></code></pre></div>
<div class="sourceCode" id="cb487"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb487-1"><a href="#cb487-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;&lt;&lt;) ::</span> <span class="dt">Category</span> cat <span class="ot">=&gt;</span> cat b c <span class="ot">-&gt;</span> cat a b <span class="ot">-&gt;</span> cat a c</span>
<span id="cb487-2"><a href="#cb487-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">&lt;&lt;&lt;</span>) <span class="ot">=</span> (<span class="op">.</span>)</span>
<span id="cb487-3"><a href="#cb487-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb487-4"><a href="#cb487-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;&gt;) ::</span> <span class="dt">Category</span> cat <span class="ot">=&gt;</span> cat a b <span class="ot">-&gt;</span> cat b c <span class="ot">-&gt;</span> cat a c</span>
<span id="cb487-5"><a href="#cb487-5" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;&gt;&gt;</span> g <span class="ot">=</span> g <span class="op">.</span> f</span></code></pre></div>
<p>Arrows are an extension of categories with the notion of
products.</p>
<div class="sourceCode" id="cb488"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb488-1"><a href="#cb488-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> a <span class="ot">=&gt;</span> <span class="dt">Arrow</span> a <span class="kw">where</span></span>
<span id="cb488-2"><a href="#cb488-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  arr ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a b c</span>
<span id="cb488-3"><a href="#cb488-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  first ::</span> a b c <span class="ot">-&gt;</span> a (b,d) (c,d)</span>
<span id="cb488-4"><a href="#cb488-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  second ::</span> a b c <span class="ot">-&gt;</span> a (d,b) (d,c)</span>
<span id="cb488-5"><a href="#cb488-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  (***) ::</span> a b c <span class="ot">-&gt;</span> a b&#39; c&#39; <span class="ot">-&gt;</span> a (b,b&#39;) (c,c&#39;)</span>
<span id="cb488-6"><a href="#cb488-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&amp;&amp;&amp;) ::</span> a b c <span class="ot">-&gt;</span> a b c&#39; <span class="ot">-&gt;</span> a b (c,c&#39;)</span></code></pre></div>
<p>The canonical example is for functions.</p>
<div class="sourceCode" id="cb489"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb489-1"><a href="#cb489-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arrow</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb489-2"><a href="#cb489-2" aria-hidden="true" tabindex="-1"></a>  arr f <span class="ot">=</span> f</span>
<span id="cb489-3"><a href="#cb489-3" aria-hidden="true" tabindex="-1"></a>  first f <span class="ot">=</span> f <span class="op">***</span> <span class="fu">id</span></span>
<span id="cb489-4"><a href="#cb489-4" aria-hidden="true" tabindex="-1"></a>  second f <span class="ot">=</span> <span class="fu">id</span> <span class="op">***</span> f</span>
<span id="cb489-5"><a href="#cb489-5" aria-hidden="true" tabindex="-1"></a>  (<span class="op">***</span>) f g <span class="op">~</span>(x,y) <span class="ot">=</span> (f x, g y)</span></code></pre></div>
<p>In this form, functions of multiple arguments can be threaded around
using the arrow combinators in a much more pointfree form. For instance
a histogram function has a nice one-liner.</p>
<div class="sourceCode" id="cb490"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb490-1"><a href="#cb490-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (group, sort)</span>
<span id="cb490-2"><a href="#cb490-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb490-3"><a href="#cb490-3" aria-hidden="true" tabindex="-1"></a><span class="ot">histogram ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [(a, <span class="dt">Int</span>)]</span>
<span id="cb490-4"><a href="#cb490-4" aria-hidden="true" tabindex="-1"></a>histogram <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">head</span> <span class="op">&amp;&amp;&amp;</span> <span class="fu">length</span>) <span class="op">.</span> <span class="fu">group</span> <span class="op">.</span> <span class="fu">sort</span></span></code></pre></div>
<div class="sourceCode" id="cb491"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb491-1"><a href="#cb491-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> histogram <span class="st">&quot;Hello world&quot;</span></span>
<span id="cb491-2"><a href="#cb491-2" aria-hidden="true" tabindex="-1"></a>[(<span class="ch">&#39; &#39;</span>,<span class="dv">1</span>),(<span class="ch">&#39;H&#39;</span>,<span class="dv">1</span>),(<span class="ch">&#39;d&#39;</span>,<span class="dv">1</span>),(<span class="ch">&#39;e&#39;</span>,<span class="dv">1</span>),(<span class="ch">&#39;l&#39;</span>,<span class="dv">3</span>),(<span class="ch">&#39;o&#39;</span>,<span class="dv">2</span>),(<span class="ch">&#39;r&#39;</span>,<span class="dv">1</span>),(<span class="ch">&#39;w&#39;</span>,<span class="dv">1</span>)]</span></code></pre></div>
<p><strong>Arrow notation</strong></p>
<p>GHC has builtin syntax for composing arrows using <code>proc</code>
notation. The following are equivalent after desugaring:</p>
<div class="sourceCode" id="cb492"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb492-1"><a href="#cb492-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE Arrows #-}</span></span>
<span id="cb492-2"><a href="#cb492-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb492-3"><a href="#cb492-3" aria-hidden="true" tabindex="-1"></a><span class="ot">addA ::</span> <span class="dt">Arrow</span> a <span class="ot">=&gt;</span> a b <span class="dt">Int</span> <span class="ot">-&gt;</span> a b <span class="dt">Int</span> <span class="ot">-&gt;</span> a b <span class="dt">Int</span></span>
<span id="cb492-4"><a href="#cb492-4" aria-hidden="true" tabindex="-1"></a>addA f g <span class="ot">=</span> proc x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb492-5"><a href="#cb492-5" aria-hidden="true" tabindex="-1"></a>                y <span class="ot">&lt;-</span> f <span class="op">-&lt;</span> x</span>
<span id="cb492-6"><a href="#cb492-6" aria-hidden="true" tabindex="-1"></a>                z <span class="ot">&lt;-</span> g <span class="op">-&lt;</span> x</span>
<span id="cb492-7"><a href="#cb492-7" aria-hidden="true" tabindex="-1"></a>                returnA <span class="op">-&lt;</span> y <span class="op">+</span> z</span></code></pre></div>
<div class="sourceCode" id="cb493"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb493-1"><a href="#cb493-1" aria-hidden="true" tabindex="-1"></a>addA f g <span class="ot">=</span> arr (\ x <span class="ot">-&gt;</span> (x, x)) <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb493-2"><a href="#cb493-2" aria-hidden="true" tabindex="-1"></a>           first f <span class="op">&gt;&gt;&gt;</span> arr (\ (y, x) <span class="ot">-&gt;</span> (x, y)) <span class="op">&gt;&gt;&gt;</span></span>
<span id="cb493-3"><a href="#cb493-3" aria-hidden="true" tabindex="-1"></a>           first g <span class="op">&gt;&gt;&gt;</span> arr (\ (z, y) <span class="ot">-&gt;</span> y <span class="op">+</span> z)</span></code></pre></div>
<div class="sourceCode" id="cb494"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb494-1"><a href="#cb494-1" aria-hidden="true" tabindex="-1"></a>addA f g <span class="ot">=</span> f <span class="op">&amp;&amp;&amp;</span> g <span class="op">&gt;&gt;&gt;</span> arr (\ (y, z) <span class="ot">-&gt;</span> y <span class="op">+</span> z)</span></code></pre></div>
<p>In practice this notation is not often used and may become deprecated
in the future.</p>
<p>See: <a
href="https://downloads.haskell.org/~ghc/7.8.3/docs/html/users_guide/arrow-notation.html">Arrow
Notation</a></p>
<h2 id="bifunctors">Bifunctors</h2>
<p>Bifunctors are a generalization of functors to include types
parameterized by two parameters and include two map functions for each
parameter.</p>
<div class="sourceCode" id="cb495"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb495-1"><a href="#cb495-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Bifunctor</span> p <span class="kw">where</span></span>
<span id="cb495-2"><a href="#cb495-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  bimap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b d</span>
<span id="cb495-3"><a href="#cb495-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  first ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b c</span>
<span id="cb495-4"><a href="#cb495-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  second ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c</span></code></pre></div>
<p>The bifunctor laws are a natural generalization of the usual functor
laws. Namely they respect identities and composition in the usual
way:</p>
<div class="sourceCode" id="cb496"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb496-1"><a href="#cb496-1" aria-hidden="true" tabindex="-1"></a>bimap <span class="fu">id</span> <span class="fu">id</span> ≡ <span class="fu">id</span></span>
<span id="cb496-2"><a href="#cb496-2" aria-hidden="true" tabindex="-1"></a>first <span class="fu">id</span> ≡ <span class="fu">id</span></span>
<span id="cb496-3"><a href="#cb496-3" aria-hidden="true" tabindex="-1"></a>second <span class="fu">id</span> ≡ <span class="fu">id</span></span></code></pre></div>
<div class="sourceCode" id="cb497"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb497-1"><a href="#cb497-1" aria-hidden="true" tabindex="-1"></a>bimap f g ≡ first f <span class="op">.</span> second g</span></code></pre></div>
<p>The canonical example is for 2-tuples.</p>
<div class="sourceCode" id="cb498"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb498-1"><a href="#cb498-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> first (<span class="op">+</span><span class="dv">1</span>) (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb498-2"><a href="#cb498-2" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb498-3"><a href="#cb498-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> second (<span class="op">+</span><span class="dv">1</span>) (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb498-4"><a href="#cb498-4" aria-hidden="true" tabindex="-1"></a>(<span class="dv">1</span>,<span class="dv">3</span>)</span>
<span id="cb498-5"><a href="#cb498-5" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> bimap (<span class="op">+</span><span class="dv">1</span>) (<span class="op">+</span><span class="dv">1</span>) (<span class="dv">1</span>,<span class="dv">2</span>)</span>
<span id="cb498-6"><a href="#cb498-6" aria-hidden="true" tabindex="-1"></a>(<span class="dv">2</span>,<span class="dv">3</span>)</span>
<span id="cb498-7"><a href="#cb498-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb498-8"><a href="#cb498-8" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> first (<span class="op">+</span><span class="dv">1</span>) (<span class="dt">Left</span> <span class="dv">3</span>)</span>
<span id="cb498-9"><a href="#cb498-9" aria-hidden="true" tabindex="-1"></a><span class="dt">Left</span> <span class="dv">4</span></span>
<span id="cb498-10"><a href="#cb498-10" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> second (<span class="op">+</span><span class="dv">1</span>) (<span class="dt">Left</span> <span class="dv">3</span>)</span>
<span id="cb498-11"><a href="#cb498-11" aria-hidden="true" tabindex="-1"></a><span class="dt">Left</span> <span class="dv">3</span></span>
<span id="cb498-12"><a href="#cb498-12" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> second (<span class="op">+</span><span class="dv">1</span>) (<span class="dt">Right</span> <span class="dv">3</span>)</span>
<span id="cb498-13"><a href="#cb498-13" aria-hidden="true" tabindex="-1"></a><span class="dt">Right</span> <span class="dv">4</span></span></code></pre></div>
<h2 id="polyvariadic-functions">Polyvariadic Functions</h2>
<p>One surprising application of typeclasses is the ability to construct
functions which take an arbitrary number of arguments by defining
instances over function types. The arguments may be of arbitrary type,
but the resulting collected arguments must either be converted into a
single type or unpacked into a sum type.</p>
<div class="sourceCode" id="cb499"
data-include="src/08-applicatives/variadic.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb499-1"><a href="#cb499-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb499-2"><a href="#cb499-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb499-3"><a href="#cb499-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Arg</span> a <span class="kw">where</span></span>
<span id="cb499-4"><a href="#cb499-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  collect&#39; ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> a</span>
<span id="cb499-5"><a href="#cb499-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb499-6"><a href="#cb499-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- extract to IO</span></span>
<span id="cb499-7"><a href="#cb499-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arg</span> (<span class="dt">IO</span> ()) <span class="kw">where</span></span>
<span id="cb499-8"><a href="#cb499-8" aria-hidden="true" tabindex="-1"></a>  collect&#39; acc <span class="ot">=</span> <span class="fu">mapM_</span> <span class="fu">putStrLn</span> acc</span>
<span id="cb499-9"><a href="#cb499-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb499-10"><a href="#cb499-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- extract to [String]</span></span>
<span id="cb499-11"><a href="#cb499-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arg</span> [<span class="dt">String</span>] <span class="kw">where</span></span>
<span id="cb499-12"><a href="#cb499-12" aria-hidden="true" tabindex="-1"></a>  collect&#39; acc <span class="ot">=</span> acc</span>
<span id="cb499-13"><a href="#cb499-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb499-14"><a href="#cb499-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">Arg</span> r) <span class="ot">=&gt;</span> <span class="dt">Arg</span> (a <span class="ot">-&gt;</span> r) <span class="kw">where</span></span>
<span id="cb499-15"><a href="#cb499-15" aria-hidden="true" tabindex="-1"></a>  collect&#39; acc <span class="ot">=</span> \x <span class="ot">-&gt;</span> collect&#39; (acc <span class="op">++</span> [<span class="fu">show</span> x])</span>
<span id="cb499-16"><a href="#cb499-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb499-17"><a href="#cb499-17" aria-hidden="true" tabindex="-1"></a><span class="ot">collect ::</span> <span class="dt">Arg</span> t <span class="ot">=&gt;</span> t</span>
<span id="cb499-18"><a href="#cb499-18" aria-hidden="true" tabindex="-1"></a>collect <span class="ot">=</span> collect&#39; []</span>
<span id="cb499-19"><a href="#cb499-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb499-20"><a href="#cb499-20" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> [<span class="dt">String</span>]</span>
<span id="cb499-21"><a href="#cb499-21" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> collect <span class="ch">&#39;a&#39;</span> <span class="dv">2</span> <span class="fl">3.0</span></span>
<span id="cb499-22"><a href="#cb499-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb499-23"><a href="#cb499-23" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb499-24"><a href="#cb499-24" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> collect () <span class="st">&quot;foo&quot;</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span></code></pre></div>
<hr/>
<h1 id="error-handling">Error Handling</h1>
<p>There are a plethora of ways of handling errors in Haskell. While
Haskell’s runtime supports throwing and handling exceptions, it is
important to use the right method in the right context.</p>
<h2 id="either-monad">Either Monad</h2>
<p>In keeping with the Haskell tradition it is always preferable to use
pure logic when possible. In many simple cases error handling can be
done quite simply by using the <code>Monad</code> instance of Either.
Monadic bind simply threads a <code>Right</code> value through the monad
and “short-circuits” evaluation when a <code>Left</code> is introduced.
This is simple enough error handling which privileges the
<code>Left</code> constructor to hold the error. Many simple functions
which can fail can simply use the <code>Either Error a</code> in the
result type to encode simple error handling.</p>
<p>The downside to this is that it forces every consumer of the function
to pattern match on the result to handle the error case. It also assumes
that all <code>Error</code> types can be encoded inside of the sum type
holding the possible failures.</p>
<div class="sourceCode" id="cb500"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb500-1"><a href="#cb500-1" aria-hidden="true" tabindex="-1"></a>saveDiv <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">DivError</span> <span class="dt">Float</span></span>
<span id="cb500-2"><a href="#cb500-2" aria-hidden="true" tabindex="-1"></a>safeDiv x <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Left</span> <span class="dt">NoDivZero</span></span>
<span id="cb500-3"><a href="#cb500-3" aria-hidden="true" tabindex="-1"></a>safeDiv x y <span class="ot">=</span> <span class="dt">Right</span> (x <span class="ot">`div`</span> y)</span></code></pre></div>
<h2 id="exceptt">ExceptT</h2>
<p>When using the <code>transformers</code> style effect stacks it is
quite common to need to have a layer of the stack which can fail. When
using the style of composing effects a monad transformer (which is a
wrapper around Either monad) can be added which lifts the error handling
into an <code>ExceptT</code> effect layer.</p>
<p>As of mtl 2.2 or higher, the <code>ErrorT</code> class has been
replaced by <code>ExceptT</code> at the transformers level.</p>
<div class="sourceCode" id="cb501"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb501-1"><a href="#cb501-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ExceptT</span> e m a <span class="ot">=</span> <span class="dt">ExceptT</span> (m (<span class="dt">Either</span> e a))</span>
<span id="cb501-2"><a href="#cb501-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb501-3"><a href="#cb501-3" aria-hidden="true" tabindex="-1"></a><span class="ot">runExceptT ::</span> <span class="dt">ExceptT</span> e m a <span class="ot">-&gt;</span> m (<span class="dt">Either</span> e a)</span>
<span id="cb501-4"><a href="#cb501-4" aria-hidden="true" tabindex="-1"></a>runExceptT (<span class="dt">ExceptT</span> m) <span class="ot">=</span> m</span>
<span id="cb501-5"><a href="#cb501-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb501-6"><a href="#cb501-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ExceptT</span> e m) <span class="kw">where</span></span>
<span id="cb501-7"><a href="#cb501-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> a <span class="ot">=</span> <span class="dt">ExceptT</span> <span class="op">$</span> <span class="fu">return</span> (<span class="dt">Right</span> a)</span>
<span id="cb501-8"><a href="#cb501-8" aria-hidden="true" tabindex="-1"></a>    m <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">ExceptT</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb501-9"><a href="#cb501-9" aria-hidden="true" tabindex="-1"></a>        a <span class="ot">&lt;-</span> runExceptT m</span>
<span id="cb501-10"><a href="#cb501-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> a <span class="kw">of</span></span>
<span id="cb501-11"><a href="#cb501-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Left</span> e <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Left</span> e)</span>
<span id="cb501-12"><a href="#cb501-12" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Right</span> x <span class="ot">-&gt;</span> runExceptT (k x)</span>
<span id="cb501-13"><a href="#cb501-13" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fail</span> <span class="ot">=</span> <span class="dt">ExceptT</span> <span class="op">.</span> <span class="fu">fail</span></span>
<span id="cb501-14"><a href="#cb501-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb501-15"><a href="#cb501-15" aria-hidden="true" tabindex="-1"></a><span class="ot">throwE ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> e m a</span>
<span id="cb501-16"><a href="#cb501-16" aria-hidden="true" tabindex="-1"></a>throwE <span class="ot">=</span> <span class="dt">ExceptT</span> <span class="op">.</span> <span class="fu">return</span> <span class="op">.</span> <span class="dt">Left</span></span>
<span id="cb501-17"><a href="#cb501-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb501-18"><a href="#cb501-18" aria-hidden="true" tabindex="-1"></a><span class="ot">catchE ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span></span>
<span id="cb501-19"><a href="#cb501-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">ExceptT</span> e m a               <span class="co">-- ^ the inner computation</span></span>
<span id="cb501-20"><a href="#cb501-20" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> e&#39; m a)    <span class="co">-- ^ a handler for exceptions in the inner</span></span>
<span id="cb501-21"><a href="#cb501-21" aria-hidden="true" tabindex="-1"></a>                                <span class="co">-- computation</span></span>
<span id="cb501-22"><a href="#cb501-22" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">ExceptT</span> e&#39; m a</span>
<span id="cb501-23"><a href="#cb501-23" aria-hidden="true" tabindex="-1"></a>m <span class="ot">`catchE`</span> h <span class="ot">=</span> <span class="dt">ExceptT</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb501-24"><a href="#cb501-24" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> runExceptT m</span>
<span id="cb501-25"><a href="#cb501-25" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> a <span class="kw">of</span></span>
<span id="cb501-26"><a href="#cb501-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Left</span>  l <span class="ot">-&gt;</span> runExceptT (h l)</span>
<span id="cb501-27"><a href="#cb501-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Right</span> r <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Right</span> r)</span></code></pre></div>
<p>And also this can be extended to the mtl <code>MonadError</code>
instance for which we can write instances for IO and Either
themselves:</p>
<div class="sourceCode" id="cb502"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb502-1"><a href="#cb502-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">ExceptT</span> e) <span class="kw">where</span></span>
<span id="cb502-2"><a href="#cb502-2" aria-hidden="true" tabindex="-1"></a>    lift <span class="ot">=</span> <span class="dt">ExceptT</span> <span class="op">.</span> liftM <span class="dt">Right</span></span>
<span id="cb502-3"><a href="#cb502-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb502-4"><a href="#cb502-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadError</span> e m <span class="op">|</span> m <span class="ot">-&gt;</span> e <span class="kw">where</span></span>
<span id="cb502-5"><a href="#cb502-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    throwError ::</span> e <span class="ot">-&gt;</span> m a</span>
<span id="cb502-6"><a href="#cb502-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    catchError ::</span> m a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb502-7"><a href="#cb502-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb502-8"><a href="#cb502-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadError</span> <span class="dt">IOException</span> <span class="dt">IO</span> <span class="kw">where</span></span>
<span id="cb502-9"><a href="#cb502-9" aria-hidden="true" tabindex="-1"></a>    throwError <span class="ot">=</span> <span class="fu">ioError</span></span>
<span id="cb502-10"><a href="#cb502-10" aria-hidden="true" tabindex="-1"></a>    catchError <span class="ot">=</span> <span class="fu">catch</span></span>
<span id="cb502-11"><a href="#cb502-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb502-12"><a href="#cb502-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadError</span> e (<span class="dt">Either</span> e) <span class="kw">where</span></span>
<span id="cb502-13"><a href="#cb502-13" aria-hidden="true" tabindex="-1"></a>    throwError             <span class="ot">=</span> <span class="dt">Left</span></span>
<span id="cb502-14"><a href="#cb502-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span>  l <span class="ot">`catchError`</span> h <span class="ot">=</span> h l</span>
<span id="cb502-15"><a href="#cb502-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> r <span class="ot">`catchError`</span> _ <span class="ot">=</span> <span class="dt">Right</span> r</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html">Control.Monad.Except</a></li>
</ul>
<h2 id="control.exception">Control.Exception</h2>
<p>GHC has a builtin system for propagating errors up at the runtime
level, below the business logic level. These are used internally for all
sorts of concurrency and system interfaces. The runtime provides builtin
operations <code>throw</code> and <code>catch</code> functions which
allow us to throw exceptions in pure code and catch the resulting
exception within IO. Note that the return value of <code>throw</code>
inhabits all types.</p>
<div class="sourceCode" id="cb503"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb503-1"><a href="#cb503-1" aria-hidden="true" tabindex="-1"></a><span class="ot">throw ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> e <span class="ot">-&gt;</span> a</span>
<span id="cb503-2"><a href="#cb503-2" aria-hidden="true" tabindex="-1"></a><span class="fu">catch</span><span class="ot"> ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb503-3"><a href="#cb503-3" aria-hidden="true" tabindex="-1"></a><span class="ot">try ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> e a)</span>
<span id="cb503-4"><a href="#cb503-4" aria-hidden="true" tabindex="-1"></a><span class="ot">evaluate ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span></code></pre></div>
<div class="sourceCode" id="cb504"
data-include="src/09-errors/ioexception.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb504-1"><a href="#cb504-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb504-2"><a href="#cb504-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb504-3"><a href="#cb504-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Typeable</span></span>
<span id="cb504-4"><a href="#cb504-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Exception</span></span>
<span id="cb504-5"><a href="#cb504-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb504-6"><a href="#cb504-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MyException</span> <span class="ot">=</span> <span class="dt">MyException</span></span>
<span id="cb504-7"><a href="#cb504-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Typeable</span>)</span>
<span id="cb504-8"><a href="#cb504-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb504-9"><a href="#cb504-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">MyException</span></span>
<span id="cb504-10"><a href="#cb504-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb504-11"><a href="#cb504-11" aria-hidden="true" tabindex="-1"></a><span class="ot">evil ::</span> [<span class="dt">Int</span>]</span>
<span id="cb504-12"><a href="#cb504-12" aria-hidden="true" tabindex="-1"></a>evil <span class="ot">=</span> [throw <span class="dt">MyException</span>]</span>
<span id="cb504-13"><a href="#cb504-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb504-14"><a href="#cb504-14" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Int</span></span>
<span id="cb504-15"><a href="#cb504-15" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> <span class="fu">head</span> evil</span>
<span id="cb504-16"><a href="#cb504-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb504-17"><a href="#cb504-17" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Int</span></span>
<span id="cb504-18"><a href="#cb504-18" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> <span class="fu">length</span> evil</span>
<span id="cb504-19"><a href="#cb504-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb504-20"><a href="#cb504-20" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb504-21"><a href="#cb504-21" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb504-22"><a href="#cb504-22" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> try (evaluate example1)<span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">MyException</span> <span class="dt">Int</span>)</span>
<span id="cb504-23"><a href="#cb504-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> a</span>
<span id="cb504-24"><a href="#cb504-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb504-25"><a href="#cb504-25" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> try (<span class="fu">return</span> example2)<span class="ot"> ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">MyException</span> <span class="dt">Int</span>)</span>
<span id="cb504-26"><a href="#cb504-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> b</span></code></pre></div>
<p>Because a value will not be evaluated unless needed, if one desires
to know for sure that an exception is either caught or not it can be
deeply forced into head normal form before invoking catch. The
<code>strictCatch</code> is not provided by the standard library but has
a simple implementation in terms of <code>deepseq</code>.</p>
<div class="sourceCode" id="cb505"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb505-1"><a href="#cb505-1" aria-hidden="true" tabindex="-1"></a><span class="ot">strictCatch ::</span> (<span class="dt">NFData</span> a, <span class="dt">Exception</span> e) <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb505-2"><a href="#cb505-2" aria-hidden="true" tabindex="-1"></a>strictCatch <span class="ot">=</span> <span class="fu">catch</span> <span class="op">.</span> (toNF <span class="op">=&lt;&lt;</span>)</span></code></pre></div>
<h2 id="exceptions">Exceptions</h2>
<p>The problem with the previous approach is having to rely on GHC’s
asynchronous exception handling inside of IO to handle basic operations
and the bifurcation of APIs which need to expose different APIs for any
monad that has failure (<code>IO</code>, <code>STM</code>,
<code>ExceptT</code>, etc.).</p>
<p>The <code>exceptions</code> package provides the same API as
<code>Control.Exception</code> but loosens the dependency on IO. It
instead provides a granular set of typeclasses which can operate over
different monads which require a precise subset of error handling
methods.</p>
<ul>
<li><code>MonadThrow</code> - Monads which expose an interface for
throwing exceptions.</li>
<li><code>MonadCatch</code> - Monads which expose an interface for
handling exceptions.</li>
<li><code>MonadMask</code> - Monads which expose an interface for
masking asynchronous exceptions.</li>
</ul>
<p>There are three core primitives that are used in handling runtime
exceptions:</p>
<ul>
<li><code>finally</code> - For handling guaranteed finalisation of code
in the presence of exceptions.</li>
<li><code>onException</code> - For handing exception case only if an
exception is thrown.</li>
<li><code>bracket</code> - For implementing resource handling with
custom acquisition and finalizer logic, in the presence of
exceptions.</li>
</ul>
<p><code>finally</code> takes an <code>IO</code> action to run as a
computation and a secondary function to run after the evaluation of the
first.</p>
<div class="sourceCode" id="cb506"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb506-1"><a href="#cb506-1" aria-hidden="true" tabindex="-1"></a><span class="ot">finally ::</span> <span class="dt">IO</span> a  <span class="co">-- ^ computation to run first</span></span>
<span id="cb506-2"><a href="#cb506-2" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">IO</span> b  <span class="co">-- ^ computation to run afterward (even if an exception was raised)</span></span>
<span id="cb506-3"><a href="#cb506-3" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">IO</span> a  <span class="co">-- returns the value from the first computation</span></span></code></pre></div>
<p><code>onException</code> has a similar signature but the second
function is run <strong>only if</strong> an exception is raised.</p>
<div class="sourceCode" id="cb507"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb507-1"><a href="#cb507-1" aria-hidden="true" tabindex="-1"></a><span class="ot">onException ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span></code></pre></div>
<p>The <code>bracket</code> function takes two functions, an acquisition
function and a finalizer function which “bracket” the evaluation of the
third. The finaliser will be run if the computation throwns an exception
and unwinds.</p>
<div class="sourceCode" id="cb508"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb508-1"><a href="#cb508-1" aria-hidden="true" tabindex="-1"></a>bracket</span>
<span id="cb508-2"><a href="#cb508-2" aria-hidden="true" tabindex="-1"></a><span class="ot">        ::</span> <span class="dt">IO</span> a         <span class="co">-- ^ computation to run first</span></span>
<span id="cb508-3"><a href="#cb508-3" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b)  <span class="co">-- ^ computation to run last</span></span>
<span id="cb508-4"><a href="#cb508-4" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> c)  <span class="co">-- ^ computation to run in-between</span></span>
<span id="cb508-5"><a href="#cb508-5" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">IO</span> c         <span class="co">-- returns the value from the in-between computation</span></span></code></pre></div>
<p>A simple example of usage is bracket logic that handles file
descriptors which need to be explicitly closed after evaluation is done.
The initialiser in this case will return a file descriptor to the body
and then run <code>hClose</code> on the file descriptor after the body
is done with evaluation.</p>
<div class="sourceCode" id="cb509"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb509-1"><a href="#cb509-1" aria-hidden="true" tabindex="-1"></a>bracket</span>
<span id="cb509-2"><a href="#cb509-2" aria-hidden="true" tabindex="-1"></a>  (openFile <span class="st">&quot;myfile&quot;</span> <span class="dt">ReadMode</span>)    <span class="co">-- acquisition</span></span>
<span id="cb509-3"><a href="#cb509-3" aria-hidden="true" tabindex="-1"></a>  (hClose)                        <span class="co">-- finaliser</span></span>
<span id="cb509-4"><a href="#cb509-4" aria-hidden="true" tabindex="-1"></a>  (\fileHandle <span class="ot">-&gt;</span> <span class="op">...</span> )           <span class="co">-- body</span></span></code></pre></div>
<p>In addition the <code>exceptions</code> library exposes several
functions for explicitly handling a variety of exceptions of various
forms. Toplevel handlers that need to “catch em’ all” should use
<code>catchAny</code> for wildcard error handling.</p>
<div class="sourceCode" id="cb510"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb510-1"><a href="#cb510-1" aria-hidden="true" tabindex="-1"></a><span class="fu">catch</span><span class="ot"> ::</span> (<span class="dt">MonadCatch</span> m, <span class="dt">Exception</span> e) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb510-2"><a href="#cb510-2" aria-hidden="true" tabindex="-1"></a><span class="ot">catchIO ::</span> <span class="dt">MonadCatch</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (<span class="dt">IOException</span> <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb510-3"><a href="#cb510-3" aria-hidden="true" tabindex="-1"></a><span class="ot">catchAny ::</span> <span class="dt">MonadCatch</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (<span class="dt">SomeException</span> <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb510-4"><a href="#cb510-4" aria-hidden="true" tabindex="-1"></a><span class="ot">catchAsync ::</span> (<span class="dt">MonadCatch</span> m, <span class="dt">Exception</span> e) <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>A simple example of usage:</p>
<div class="sourceCode" id="cb511"
data-include="src/09-errors/exceptions.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb511-1"><a href="#cb511-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb511-2"><a href="#cb511-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb511-3"><a href="#cb511-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Typeable</span></span>
<span id="cb511-4"><a href="#cb511-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Catch</span></span>
<span id="cb511-5"><a href="#cb511-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Identity</span></span>
<span id="cb511-6"><a href="#cb511-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb511-7"><a href="#cb511-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MyException</span> <span class="ot">=</span> <span class="dt">MyException</span></span>
<span id="cb511-8"><a href="#cb511-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Typeable</span>)</span>
<span id="cb511-9"><a href="#cb511-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb511-10"><a href="#cb511-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Exception</span> <span class="dt">MyException</span></span>
<span id="cb511-11"><a href="#cb511-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb511-12"><a href="#cb511-12" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">MonadCatch</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="dt">Int</span></span>
<span id="cb511-13"><a href="#cb511-13" aria-hidden="true" tabindex="-1"></a>example x y <span class="op">|</span> y <span class="op">==</span> <span class="dv">0</span> <span class="ot">=</span> throwM <span class="dt">MyException</span></span>
<span id="cb511-14"><a href="#cb511-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> x <span class="ot">`div`</span> y</span>
<span id="cb511-15"><a href="#cb511-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb511-16"><a href="#cb511-16" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span><span class="ot"> ::</span> <span class="dt">MonadCatch</span> m <span class="ot">=&gt;</span> m (<span class="dt">Either</span> <span class="dt">MyException</span> <span class="dt">Int</span>)</span>
<span id="cb511-17"><a href="#cb511-17" aria-hidden="true" tabindex="-1"></a><span class="fu">pure</span> <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb511-18"><a href="#cb511-18" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> try (example <span class="dv">1</span> <span class="dv">2</span>)</span>
<span id="cb511-19"><a href="#cb511-19" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> try (example <span class="dv">1</span> <span class="dv">0</span>)</span>
<span id="cb511-20"><a href="#cb511-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (a <span class="op">&gt;&gt;</span> b)</span></code></pre></div>
<p>See: <a
href="http://hackage.haskell.org/package/exceptions">exceptions</a></p>
<h2 id="spoon">Spoon</h2>
<p>Sometimes you’ll be forced to deal with seemingly pure functions that
can throw up at any point. There are many functions in the standard
library like this, and many more on Hackage. You’d like to handle this
logic purely as if it were returning a proper <code>Maybe a</code> but
to catch the logic you’d need to install an IO handler inside IO to
catch it. Spoon allows us to safely (and “purely”, although it uses a
referentially transparent invocation of unsafePerformIO) to catch these
exceptions and put them in Maybe where they belong.</p>
<p>The <code>spoon</code> function evaluates its argument to head normal
form, while <code>teaspoon</code> evaluates to <a
href="#seq-and-whnf">weak head normal form</a>.</p>
<div class="sourceCode" id="cb512"
data-include="src/09-errors/spoon.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb512-1"><a href="#cb512-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Spoon</span></span>
<span id="cb512-2"><a href="#cb512-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb512-3"><a href="#cb512-3" aria-hidden="true" tabindex="-1"></a><span class="ot">goBoom ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb512-4"><a href="#cb512-4" aria-hidden="true" tabindex="-1"></a>goBoom x y <span class="ot">=</span> x <span class="ot">`div`</span> y</span>
<span id="cb512-5"><a href="#cb512-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb512-6"><a href="#cb512-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- evaluate to normal form</span></span>
<span id="cb512-7"><a href="#cb512-7" aria-hidden="true" tabindex="-1"></a><span class="ot">test1 ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]</span>
<span id="cb512-8"><a href="#cb512-8" aria-hidden="true" tabindex="-1"></a>test1 <span class="ot">=</span> spoon [<span class="dv">1</span>, <span class="dv">2</span>, <span class="fu">undefined</span>]</span>
<span id="cb512-9"><a href="#cb512-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb512-10"><a href="#cb512-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- evaluate to weak head normal form</span></span>
<span id="cb512-11"><a href="#cb512-11" aria-hidden="true" tabindex="-1"></a><span class="ot">test2 ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]</span>
<span id="cb512-12"><a href="#cb512-12" aria-hidden="true" tabindex="-1"></a>test2 <span class="ot">=</span> teaspoon [<span class="dv">1</span>, <span class="dv">2</span>, <span class="fu">undefined</span>]</span>
<span id="cb512-13"><a href="#cb512-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb512-14"><a href="#cb512-14" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb512-15"><a href="#cb512-15" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb512-16"><a href="#cb512-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">maybe</span> (<span class="fu">putStrLn</span> <span class="st">&quot;Nothing&quot;</span>) (<span class="fu">print</span> <span class="op">.</span> <span class="fu">length</span>) test1</span>
<span id="cb512-17"><a href="#cb512-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">maybe</span> (<span class="fu">putStrLn</span> <span class="st">&quot;Nothing&quot;</span>) (<span class="fu">print</span> <span class="op">.</span> <span class="fu">length</span>) test2</span></code></pre></div>
<hr/>
<h1 id="advanced-monads">Advanced Monads</h1>
<p>When working with the wider library you will find there a variety of
“advanced monads” which are higher-level constructions on top of of the
monadic interface which enrich the structure with additional rules or
build APIs for combining different types of monads. Some of the
most-used cases are mentioned in this section.</p>
<h2 id="function-monad">Function Monad</h2>
<p>If one writes Haskell long enough one might eventually encounter the
curious beast that is the <code>((-&gt;) r)</code> monad instance. It
generally tends to be non-intuitive to work with, but is quite simple
when one considers it as an unwrapped Reader monad.</p>
<div class="sourceCode" id="cb513"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb513-1"><a href="#cb513-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> ((<span class="ot">-&gt;</span>) r) <span class="kw">where</span></span>
<span id="cb513-2"><a href="#cb513-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> <span class="ot">=</span> (<span class="op">.</span>)</span>
<span id="cb513-3"><a href="#cb513-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb513-4"><a href="#cb513-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> ((<span class="ot">-&gt;</span>) r) <span class="kw">where</span></span>
<span id="cb513-5"><a href="#cb513-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="ot">=</span> <span class="fu">const</span></span>
<span id="cb513-6"><a href="#cb513-6" aria-hidden="true" tabindex="-1"></a>  f <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> \r <span class="ot">-&gt;</span> k (f r) r</span></code></pre></div>
<p>This just uses a prefix form of the arrow type operator.</p>
<div class="sourceCode" id="cb514"
data-include="src/10-advanced-monads/function.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb514-1"><a href="#cb514-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb514-2"><a href="#cb514-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb514-3"><a href="#cb514-3" aria-hidden="true" tabindex="-1"></a><span class="ot">id&#39; ::</span> (<span class="ot">-&gt;</span>) a a</span>
<span id="cb514-4"><a href="#cb514-4" aria-hidden="true" tabindex="-1"></a>id&#39; <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb514-5"><a href="#cb514-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb514-6"><a href="#cb514-6" aria-hidden="true" tabindex="-1"></a><span class="ot">const&#39; ::</span> (<span class="ot">-&gt;</span>) a ((<span class="ot">-&gt;</span>) b a)</span>
<span id="cb514-7"><a href="#cb514-7" aria-hidden="true" tabindex="-1"></a>const&#39; <span class="ot">=</span> <span class="fu">const</span></span>
<span id="cb514-8"><a href="#cb514-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb514-9"><a href="#cb514-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Monad m =&gt; a -&gt; m a</span></span>
<span id="cb514-10"><a href="#cb514-10" aria-hidden="true" tabindex="-1"></a><span class="ot">fret ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb514-11"><a href="#cb514-11" aria-hidden="true" tabindex="-1"></a>fret <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb514-12"><a href="#cb514-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb514-13"><a href="#cb514-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</span></span>
<span id="cb514-14"><a href="#cb514-14" aria-hidden="true" tabindex="-1"></a><span class="ot">fbind ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> b)) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> b)</span>
<span id="cb514-15"><a href="#cb514-15" aria-hidden="true" tabindex="-1"></a>fbind f k <span class="ot">=</span> f <span class="op">&gt;&gt;=</span> k</span>
<span id="cb514-16"><a href="#cb514-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb514-17"><a href="#cb514-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- Monad m =&gt; m (m a) -&gt; m a</span></span>
<span id="cb514-18"><a href="#cb514-18" aria-hidden="true" tabindex="-1"></a><span class="ot">fjoin ::</span> (r <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a)) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a)</span>
<span id="cb514-19"><a href="#cb514-19" aria-hidden="true" tabindex="-1"></a>fjoin <span class="ot">=</span> join</span>
<span id="cb514-20"><a href="#cb514-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb514-21"><a href="#cb514-21" aria-hidden="true" tabindex="-1"></a><span class="ot">fid ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb514-22"><a href="#cb514-22" aria-hidden="true" tabindex="-1"></a>fid <span class="ot">=</span> <span class="fu">const</span> <span class="op">&gt;&gt;=</span> <span class="fu">id</span></span>
<span id="cb514-23"><a href="#cb514-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb514-24"><a href="#cb514-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></span>
<span id="cb514-25"><a href="#cb514-25" aria-hidden="true" tabindex="-1"></a><span class="ot">fcompose ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> b)</span>
<span id="cb514-26"><a href="#cb514-26" aria-hidden="true" tabindex="-1"></a>fcompose <span class="ot">=</span> (<span class="op">.</span>)</span></code></pre></div>
<div class="sourceCode" id="cb515"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb515-1"><a href="#cb515-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Reader</span> r <span class="ot">=</span> (<span class="ot">-&gt;</span>) r <span class="co">-- pseudocode</span></span>
<span id="cb515-2"><a href="#cb515-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb515-3"><a href="#cb515-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> r) <span class="kw">where</span></span>
<span id="cb515-4"><a href="#cb515-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a <span class="ot">=</span> \_ <span class="ot">-&gt;</span> a</span>
<span id="cb515-5"><a href="#cb515-5" aria-hidden="true" tabindex="-1"></a>  f <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> \r <span class="ot">-&gt;</span> k (f r) r</span>
<span id="cb515-6"><a href="#cb515-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb515-7"><a href="#cb515-7" aria-hidden="true" tabindex="-1"></a><span class="ot">ask&#39; ::</span> r <span class="ot">-&gt;</span> r</span>
<span id="cb515-8"><a href="#cb515-8" aria-hidden="true" tabindex="-1"></a>ask&#39; <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb515-9"><a href="#cb515-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb515-10"><a href="#cb515-10" aria-hidden="true" tabindex="-1"></a><span class="ot">asks&#39; ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (r <span class="ot">-&gt;</span> a)</span>
<span id="cb515-11"><a href="#cb515-11" aria-hidden="true" tabindex="-1"></a>asks&#39; f <span class="ot">=</span> <span class="fu">id</span> <span class="op">.</span> f</span>
<span id="cb515-12"><a href="#cb515-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb515-13"><a href="#cb515-13" aria-hidden="true" tabindex="-1"></a><span class="ot">runReader&#39; ::</span> (r <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a</span>
<span id="cb515-14"><a href="#cb515-14" aria-hidden="true" tabindex="-1"></a>runReader&#39; <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<h2 id="rws-monad">RWS Monad</h2>
<p>The RWS monad combines the functionality of the three monads
discussed above, the <strong>R</strong>eader, <strong>W</strong>riter,
and <strong>S</strong>tate. There is also a <code>RWST</code>
transformer.</p>
<div class="sourceCode" id="cb516"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb516-1"><a href="#cb516-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runReader ::</span> <span class="dt">Reader</span> r a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> a</span>
<span id="cb516-2"><a href="#cb516-2" aria-hidden="true" tabindex="-1"></a><span class="ot">runWriter ::</span> <span class="dt">Writer</span> w a <span class="ot">-&gt;</span> (a, w)</span>
<span id="cb516-3"><a href="#cb516-3" aria-hidden="true" tabindex="-1"></a><span class="ot">runState  ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</span></code></pre></div>
<p>These three eval functions are now combined into the following
functions:</p>
<div class="sourceCode" id="cb517"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb517-1"><a href="#cb517-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runRWS  ::</span> <span class="dt">RWS</span> r w s a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s, w)</span>
<span id="cb517-2"><a href="#cb517-2" aria-hidden="true" tabindex="-1"></a><span class="ot">execRWS ::</span> <span class="dt">RWS</span> r w s a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (s, w)</span>
<span id="cb517-3"><a href="#cb517-3" aria-hidden="true" tabindex="-1"></a><span class="ot">evalRWS ::</span> <span class="dt">RWS</span> r w s a <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, w)</span></code></pre></div>
<div class="sourceCode" id="cb518"
data-include="src/10-advanced-monads/rws.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb518-1"><a href="#cb518-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.RWS</span></span>
<span id="cb518-2"><a href="#cb518-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb518-3"><a href="#cb518-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">R</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb518-4"><a href="#cb518-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">W</span> <span class="ot">=</span> [<span class="dt">Int</span>]</span>
<span id="cb518-5"><a href="#cb518-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">S</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb518-6"><a href="#cb518-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb518-7"><a href="#cb518-7" aria-hidden="true" tabindex="-1"></a><span class="ot">computation ::</span> <span class="dt">RWS</span> <span class="dt">R</span> <span class="dt">W</span> <span class="dt">S</span> ()</span>
<span id="cb518-8"><a href="#cb518-8" aria-hidden="true" tabindex="-1"></a>computation <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb518-9"><a href="#cb518-9" aria-hidden="true" tabindex="-1"></a>  e <span class="ot">&lt;-</span> ask</span>
<span id="cb518-10"><a href="#cb518-10" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> get</span>
<span id="cb518-11"><a href="#cb518-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> b <span class="ot">=</span> a <span class="op">+</span> e</span>
<span id="cb518-12"><a href="#cb518-12" aria-hidden="true" tabindex="-1"></a>  put b</span>
<span id="cb518-13"><a href="#cb518-13" aria-hidden="true" tabindex="-1"></a>  tell [b]</span>
<span id="cb518-14"><a href="#cb518-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb518-15"><a href="#cb518-15" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> runRWS computation <span class="dv">2</span> <span class="dv">3</span></span></code></pre></div>
<p>The usual caveat about Writer laziness also applies to RWS.</p>
<h2 id="cont">Cont</h2>
<div class="sourceCode" id="cb519"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb519-1"><a href="#cb519-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runCont ::</span> <span class="dt">Cont</span> r a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb519-2"><a href="#cb519-2" aria-hidden="true" tabindex="-1"></a><span class="ot">callCC ::</span> <span class="dt">MonadCont</span> m <span class="ot">=&gt;</span> ((a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb519-3"><a href="#cb519-3" aria-hidden="true" tabindex="-1"></a><span class="ot">cont ::</span> ((a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> <span class="dt">Cont</span> r a</span></code></pre></div>
<p>In continuation passing style, composite computations are built up
from sequences of nested computations which are terminated by a final
continuation which yields the result of the full computation by passing
a function into the continuation chain.</p>
<div class="sourceCode" id="cb520"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb520-1"><a href="#cb520-1" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb520-2"><a href="#cb520-2" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> x <span class="op">+</span> y</span>
<span id="cb520-3"><a href="#cb520-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb520-4"><a href="#cb520-4" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r</span>
<span id="cb520-5"><a href="#cb520-5" aria-hidden="true" tabindex="-1"></a>add x y k <span class="ot">=</span> k (x <span class="op">+</span> y)</span></code></pre></div>
<div class="sourceCode" id="cb521"
data-include="src/10-advanced-monads/cont.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb521-1"><a href="#cb521-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb521-2"><a href="#cb521-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Cont</span></span>
<span id="cb521-3"><a href="#cb521-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb521-4"><a href="#cb521-4" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> k <span class="dt">Int</span></span>
<span id="cb521-5"><a href="#cb521-5" aria-hidden="true" tabindex="-1"></a>add x y <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> x <span class="op">+</span> y</span>
<span id="cb521-6"><a href="#cb521-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb521-7"><a href="#cb521-7" aria-hidden="true" tabindex="-1"></a><span class="ot">mult ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Cont</span> k <span class="dt">Int</span></span>
<span id="cb521-8"><a href="#cb521-8" aria-hidden="true" tabindex="-1"></a>mult x y <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> x <span class="op">*</span> y</span>
<span id="cb521-9"><a href="#cb521-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb521-10"><a href="#cb521-10" aria-hidden="true" tabindex="-1"></a><span class="ot">contt ::</span> <span class="dt">ContT</span> () <span class="dt">IO</span> ()</span>
<span id="cb521-11"><a href="#cb521-11" aria-hidden="true" tabindex="-1"></a>contt <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb521-12"><a href="#cb521-12" aria-hidden="true" tabindex="-1"></a>    k <span class="ot">&lt;-</span> <span class="kw">do</span></span>
<span id="cb521-13"><a href="#cb521-13" aria-hidden="true" tabindex="-1"></a>      callCC <span class="op">$</span> \exit <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb521-14"><a href="#cb521-14" aria-hidden="true" tabindex="-1"></a>        lift <span class="op">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Entry&quot;</span></span>
<span id="cb521-15"><a href="#cb521-15" aria-hidden="true" tabindex="-1"></a>        exit <span class="op">$</span> \_ <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb521-16"><a href="#cb521-16" aria-hidden="true" tabindex="-1"></a>          <span class="fu">putStrLn</span> <span class="st">&quot;Exit&quot;</span></span>
<span id="cb521-17"><a href="#cb521-17" aria-hidden="true" tabindex="-1"></a>    lift <span class="op">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Inside&quot;</span></span>
<span id="cb521-18"><a href="#cb521-18" aria-hidden="true" tabindex="-1"></a>    lift <span class="op">$</span> k ()</span>
<span id="cb521-19"><a href="#cb521-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb521-20"><a href="#cb521-20" aria-hidden="true" tabindex="-1"></a><span class="ot">callcc ::</span> <span class="dt">Cont</span> <span class="dt">String</span> <span class="dt">Integer</span></span>
<span id="cb521-21"><a href="#cb521-21" aria-hidden="true" tabindex="-1"></a>callcc <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb521-22"><a href="#cb521-22" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span></span>
<span id="cb521-23"><a href="#cb521-23" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> callCC (\k <span class="ot">-&gt;</span> k <span class="dv">2</span>)</span>
<span id="cb521-24"><a href="#cb521-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> a<span class="op">+</span>b</span>
<span id="cb521-25"><a href="#cb521-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb521-26"><a href="#cb521-26" aria-hidden="true" tabindex="-1"></a><span class="ot">ex1 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb521-27"><a href="#cb521-27" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> runCont (f <span class="op">&gt;&gt;=</span> g) <span class="fu">id</span></span>
<span id="cb521-28"><a href="#cb521-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb521-29"><a href="#cb521-29" aria-hidden="true" tabindex="-1"></a>    f <span class="ot">=</span> add <span class="dv">1</span> <span class="dv">2</span></span>
<span id="cb521-30"><a href="#cb521-30" aria-hidden="true" tabindex="-1"></a>    g <span class="ot">=</span> mult <span class="dv">3</span></span>
<span id="cb521-31"><a href="#cb521-31" aria-hidden="true" tabindex="-1"></a><span class="co">-- 9</span></span>
<span id="cb521-32"><a href="#cb521-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb521-33"><a href="#cb521-33" aria-hidden="true" tabindex="-1"></a><span class="ot">ex2 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb521-34"><a href="#cb521-34" aria-hidden="true" tabindex="-1"></a>ex2 <span class="ot">=</span> <span class="fu">print</span> <span class="op">$</span> runCont callcc <span class="fu">show</span></span>
<span id="cb521-35"><a href="#cb521-35" aria-hidden="true" tabindex="-1"></a><span class="co">-- &quot;3&quot;</span></span>
<span id="cb521-36"><a href="#cb521-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb521-37"><a href="#cb521-37" aria-hidden="true" tabindex="-1"></a><span class="ot">ex3 ::</span> <span class="dt">IO</span> ()</span>
<span id="cb521-38"><a href="#cb521-38" aria-hidden="true" tabindex="-1"></a>ex3 <span class="ot">=</span> runContT contt <span class="fu">print</span></span>
<span id="cb521-39"><a href="#cb521-39" aria-hidden="true" tabindex="-1"></a><span class="co">-- Entry</span></span>
<span id="cb521-40"><a href="#cb521-40" aria-hidden="true" tabindex="-1"></a><span class="co">-- Inside</span></span>
<span id="cb521-41"><a href="#cb521-41" aria-hidden="true" tabindex="-1"></a><span class="co">-- Exit</span></span>
<span id="cb521-42"><a href="#cb521-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb521-43"><a href="#cb521-43" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb521-44"><a href="#cb521-44" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb521-45"><a href="#cb521-45" aria-hidden="true" tabindex="-1"></a>  ex1</span>
<span id="cb521-46"><a href="#cb521-46" aria-hidden="true" tabindex="-1"></a>  ex2</span>
<span id="cb521-47"><a href="#cb521-47" aria-hidden="true" tabindex="-1"></a>  ex3</span></code></pre></div>
<div class="sourceCode" id="cb522"
data-include="src/10-advanced-monads/cont_impl.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb522-1"><a href="#cb522-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Cont</span> r a <span class="ot">=</span> <span class="dt">Cont</span> {<span class="ot"> runCont ::</span> ((a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r) }</span>
<span id="cb522-2"><a href="#cb522-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb522-3"><a href="#cb522-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb522-4"><a href="#cb522-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> a       <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> k a</span>
<span id="cb522-5"><a href="#cb522-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Cont</span> c) <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> c (\a <span class="ot">-&gt;</span> runCont (f a) k)</span>
<span id="cb522-6"><a href="#cb522-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb522-7"><a href="#cb522-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadCont</span> m <span class="kw">where</span></span>
<span id="cb522-8"><a href="#cb522-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  callCC ::</span> ((a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb522-9"><a href="#cb522-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb522-10"><a href="#cb522-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadCont</span> (<span class="dt">Cont</span> r) <span class="kw">where</span></span>
<span id="cb522-11"><a href="#cb522-11" aria-hidden="true" tabindex="-1"></a>  callCC f <span class="ot">=</span> <span class="dt">Cont</span> <span class="op">$</span> \k <span class="ot">-&gt;</span> runCont (f (\a <span class="ot">-&gt;</span> <span class="dt">Cont</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> k a)) k</span></code></pre></div>
<ul>
<li><a
href="https://wiki.haskell.org/MonadCont_under_the_hood">MonadCont Under
the Hood</a></li>
</ul>
<h2 id="monadplus">MonadPlus</h2>
<p>Choice and failure.</p>
<div class="sourceCode" id="cb523"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb523-1"><a href="#cb523-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Alternative</span> m, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadPlus</span> m <span class="kw">where</span></span>
<span id="cb523-2"><a href="#cb523-2" aria-hidden="true" tabindex="-1"></a><span class="ot">   mzero ::</span> m a</span>
<span id="cb523-3"><a href="#cb523-3" aria-hidden="true" tabindex="-1"></a><span class="ot">   mplus ::</span> m a <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a</span>
<span id="cb523-4"><a href="#cb523-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb523-5"><a href="#cb523-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadPlus</span> [] <span class="kw">where</span></span>
<span id="cb523-6"><a href="#cb523-6" aria-hidden="true" tabindex="-1"></a>   mzero <span class="ot">=</span> []</span>
<span id="cb523-7"><a href="#cb523-7" aria-hidden="true" tabindex="-1"></a>   mplus <span class="ot">=</span> (<span class="op">++</span>)</span>
<span id="cb523-8"><a href="#cb523-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb523-9"><a href="#cb523-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadPlus</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb523-10"><a href="#cb523-10" aria-hidden="true" tabindex="-1"></a>   mzero <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb523-11"><a href="#cb523-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb523-12"><a href="#cb523-12" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Nothing</span> <span class="ot">`mplus`</span> ys  <span class="ot">=</span> ys</span>
<span id="cb523-13"><a href="#cb523-13" aria-hidden="true" tabindex="-1"></a>   xs      <span class="ot">`mplus`</span> _ys <span class="ot">=</span> xs</span></code></pre></div>
<p>MonadPlus forms a monoid with</p>
<div class="sourceCode" id="cb524"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb524-1"><a href="#cb524-1" aria-hidden="true" tabindex="-1"></a>mzero <span class="ot">`mplus`</span> a <span class="ot">=</span> a</span>
<span id="cb524-2"><a href="#cb524-2" aria-hidden="true" tabindex="-1"></a>a <span class="ot">`mplus`</span> mzero <span class="ot">=</span> a</span>
<span id="cb524-3"><a href="#cb524-3" aria-hidden="true" tabindex="-1"></a>(a <span class="ot">`mplus`</span> b) <span class="ot">`mplus`</span> c <span class="ot">=</span> a <span class="ot">`mplus`</span> (b <span class="ot">`mplus`</span> c)</span></code></pre></div>
<div class="sourceCode" id="cb525"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb525-1"><a href="#cb525-1" aria-hidden="true" tabindex="-1"></a><span class="ot">asum ::</span> (<span class="dt">Foldable</span> t, <span class="dt">Alternative</span> f) <span class="ot">=&gt;</span> t (f a) <span class="ot">-&gt;</span> f a</span>
<span id="cb525-2"><a href="#cb525-2" aria-hidden="true" tabindex="-1"></a>asum <span class="ot">=</span> <span class="fu">foldr</span> (<span class="op">&lt;|&gt;</span>) empty</span>
<span id="cb525-3"><a href="#cb525-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb525-4"><a href="#cb525-4" aria-hidden="true" tabindex="-1"></a><span class="ot">msum ::</span> (<span class="dt">Foldable</span> t, <span class="dt">MonadPlus</span> m) <span class="ot">=&gt;</span> t (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb525-5"><a href="#cb525-5" aria-hidden="true" tabindex="-1"></a>msum <span class="ot">=</span> asum</span></code></pre></div>
<div class="sourceCode" id="cb526"
data-include="src/10-advanced-monads/monadplus.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb526-1"><a href="#cb526-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Safe</span></span>
<span id="cb526-2"><a href="#cb526-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb526-3"><a href="#cb526-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb526-4"><a href="#cb526-4" aria-hidden="true" tabindex="-1"></a><span class="ot">list1 ::</span> [(<span class="dt">Int</span>,<span class="dt">Int</span>)]</span>
<span id="cb526-5"><a href="#cb526-5" aria-hidden="true" tabindex="-1"></a>list1 <span class="ot">=</span> [(a,b) <span class="op">|</span> a <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">25</span>], b <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">25</span>], a <span class="op">&lt;</span> b]</span>
<span id="cb526-6"><a href="#cb526-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb526-7"><a href="#cb526-7" aria-hidden="true" tabindex="-1"></a><span class="ot">list2 ::</span> [(<span class="dt">Int</span>,<span class="dt">Int</span>)]</span>
<span id="cb526-8"><a href="#cb526-8" aria-hidden="true" tabindex="-1"></a>list2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb526-9"><a href="#cb526-9" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">25</span>]</span>
<span id="cb526-10"><a href="#cb526-10" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">25</span>]</span>
<span id="cb526-11"><a href="#cb526-11" aria-hidden="true" tabindex="-1"></a>  guard (a <span class="op">&lt;</span> b)</span>
<span id="cb526-12"><a href="#cb526-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> (a,b)</span>
<span id="cb526-13"><a href="#cb526-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb526-14"><a href="#cb526-14" aria-hidden="true" tabindex="-1"></a><span class="ot">maybe1 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Double</span></span>
<span id="cb526-15"><a href="#cb526-15" aria-hidden="true" tabindex="-1"></a>maybe1 a b <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb526-16"><a href="#cb526-16" aria-hidden="true" tabindex="-1"></a>  a&#39; <span class="ot">&lt;-</span> readMay a</span>
<span id="cb526-17"><a href="#cb526-17" aria-hidden="true" tabindex="-1"></a>  b&#39; <span class="ot">&lt;-</span> readMay b</span>
<span id="cb526-18"><a href="#cb526-18" aria-hidden="true" tabindex="-1"></a>  guard (b&#39; <span class="op">/=</span> <span class="fl">0.0</span>)</span>
<span id="cb526-19"><a href="#cb526-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> a&#39;<span class="op">/</span>b&#39;</span>
<span id="cb526-20"><a href="#cb526-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb526-21"><a href="#cb526-21" aria-hidden="true" tabindex="-1"></a><span class="ot">maybe2 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb526-22"><a href="#cb526-22" aria-hidden="true" tabindex="-1"></a>maybe2 <span class="ot">=</span> msum [<span class="dt">Nothing</span>, <span class="dt">Nothing</span>, <span class="dt">Just</span> <span class="dv">3</span>, <span class="dt">Just</span> <span class="dv">4</span>]</span></code></pre></div>
<h2 id="monadfail">MonadFail</h2>
<p>Before the great awakening, Monads used to be defined as the
following class.</p>
<div class="sourceCode" id="cb527"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb527-1"><a href="#cb527-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span>  <span class="dt">Monad</span> m  <span class="kw">where</span></span>
<span id="cb527-2"><a href="#cb527-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;&gt;=)   ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb527-3"><a href="#cb527-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;&gt;)    ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</span>
<span id="cb527-4"><a href="#cb527-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    return  ::</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb527-5"><a href="#cb527-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    fail    ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a</span>
<span id="cb527-6"><a href="#cb527-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb527-7"><a href="#cb527-7" aria-hidden="true" tabindex="-1"></a>    m <span class="op">&gt;&gt;</span> k  <span class="ot">=</span>  m <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> k</span>
<span id="cb527-8"><a href="#cb527-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fail</span> s  <span class="ot">=</span> <span class="fu">error</span> s</span></code></pre></div>
<p>This was eventually deemed not to be an great design and in
particular the <code>fail</code> function was a misplaced lawless entity
that would generate bottoms. It was also necessary to define
<code>fail</code> for all monads, even those without a notion of
failure. This was considered quite ugly and eventually a breaking change
to base (landed in 4.9) was added which split out <code>MonadFail</code>
into a separate class where it belonged.</p>
<div class="sourceCode" id="cb528"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb528-1"><a href="#cb528-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadFail</span> m <span class="kw">where</span></span>
<span id="cb528-2"><a href="#cb528-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    fail ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>Some of the common instances of MonadFail are shown below:</p>
<div class="sourceCode" id="cb529"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb529-1"><a href="#cb529-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadFail</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb529-2"><a href="#cb529-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fail</span> _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb529-3"><a href="#cb529-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb529-4"><a href="#cb529-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadFail</span> [] <span class="kw">where</span></span>
<span id="cb529-5"><a href="#cb529-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">{-# INLINE fail #-}</span></span>
<span id="cb529-6"><a href="#cb529-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fail</span> _ <span class="ot">=</span> []</span>
<span id="cb529-7"><a href="#cb529-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb529-8"><a href="#cb529-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadFail</span> <span class="dt">IO</span> <span class="kw">where</span></span>
<span id="cb529-9"><a href="#cb529-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fail</span> <span class="ot">=</span> failIO</span></code></pre></div>
<h2 id="monadfix">MonadFix</h2>
<p>The fixed point of a monadic computation. <code>mfix f</code>
executes the action <code>f</code> only once, with the eventual output
fed back as the input.</p>
<div class="sourceCode" id="cb530"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb530-1"><a href="#cb530-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fix ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</span>
<span id="cb530-2"><a href="#cb530-2" aria-hidden="true" tabindex="-1"></a>fix f <span class="ot">=</span> <span class="kw">let</span> x <span class="ot">=</span> f x <span class="kw">in</span> x</span>
<span id="cb530-3"><a href="#cb530-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb530-4"><a href="#cb530-4" aria-hidden="true" tabindex="-1"></a><span class="ot">mfix ::</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</span></code></pre></div>
<div class="sourceCode" id="cb531"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb531-1"><a href="#cb531-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadFix</span> m <span class="kw">where</span></span>
<span id="cb531-2"><a href="#cb531-2" aria-hidden="true" tabindex="-1"></a><span class="ot">   mfix ::</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb531-3"><a href="#cb531-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb531-4"><a href="#cb531-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadFix</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb531-5"><a href="#cb531-5" aria-hidden="true" tabindex="-1"></a>   mfix f <span class="ot">=</span> <span class="kw">let</span> a <span class="ot">=</span> f (unJust a) <span class="kw">in</span> a</span>
<span id="cb531-6"><a href="#cb531-6" aria-hidden="true" tabindex="-1"></a>            <span class="kw">where</span> unJust (<span class="dt">Just</span> x) <span class="ot">=</span> x</span>
<span id="cb531-7"><a href="#cb531-7" aria-hidden="true" tabindex="-1"></a>                  unJust <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;mfix Maybe: Nothing&quot;</span></span></code></pre></div>
<p>The regular do-notation can also be extended with
<code>-XRecursiveDo</code> to accommodate recursive monadic
bindings.</p>
<div class="sourceCode" id="cb532"
data-include="src/10-advanced-monads/monadfix.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb532-1"><a href="#cb532-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecursiveDo #-}</span></span>
<span id="cb532-2"><a href="#cb532-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb532-3"><a href="#cb532-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb532-4"><a href="#cb532-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Fix</span></span>
<span id="cb532-5"><a href="#cb532-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb532-6"><a href="#cb532-6" aria-hidden="true" tabindex="-1"></a><span class="ot">stream1 ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]</span>
<span id="cb532-7"><a href="#cb532-7" aria-hidden="true" tabindex="-1"></a>stream1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb532-8"><a href="#cb532-8" aria-hidden="true" tabindex="-1"></a>  rec xs <span class="ot">&lt;-</span> <span class="dt">Just</span> (<span class="dv">1</span><span class="op">:</span>xs)</span>
<span id="cb532-9"><a href="#cb532-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="fu">map</span> <span class="fu">negate</span> xs)</span>
<span id="cb532-10"><a href="#cb532-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb532-11"><a href="#cb532-11" aria-hidden="true" tabindex="-1"></a><span class="ot">stream2 ::</span> <span class="dt">Maybe</span> [<span class="dt">Int</span>]</span>
<span id="cb532-12"><a href="#cb532-12" aria-hidden="true" tabindex="-1"></a>stream2 <span class="ot">=</span> mfix <span class="op">$</span> \xs <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb532-13"><a href="#cb532-13" aria-hidden="true" tabindex="-1"></a>  xs&#39; <span class="ot">&lt;-</span> <span class="dt">Just</span> (<span class="dv">1</span><span class="op">:</span>xs)</span>
<span id="cb532-14"><a href="#cb532-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="fu">map</span> <span class="fu">negate</span> xs&#39;)</span></code></pre></div>
<h2 id="st-monad">ST Monad</h2>
<p>The ST monad models “threads” of stateful computations which can
manipulate mutable references but are restricted to only return pure
values when evaluated and are statically confined to the ST monad of a
<code>s</code> thread.</p>
<div class="sourceCode" id="cb533"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb533-1"><a href="#cb533-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runST ::</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">ST</span> s a) <span class="ot">-&gt;</span> a</span>
<span id="cb533-2"><a href="#cb533-2" aria-hidden="true" tabindex="-1"></a><span class="ot">newSTRef ::</span> a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s a)</span>
<span id="cb533-3"><a href="#cb533-3" aria-hidden="true" tabindex="-1"></a><span class="ot">readSTRef ::</span> <span class="dt">STRef</span> s a <span class="ot">-&gt;</span> <span class="dt">ST</span> s a</span>
<span id="cb533-4"><a href="#cb533-4" aria-hidden="true" tabindex="-1"></a><span class="ot">writeSTRef ::</span> <span class="dt">STRef</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span></code></pre></div>
<div class="sourceCode" id="cb534"
data-include="src/10-advanced-monads/st.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb534-1"><a href="#cb534-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb534-2"><a href="#cb534-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb534-3"><a href="#cb534-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State.Strict</span></span>
<span id="cb534-4"><a href="#cb534-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.STRef</span></span>
<span id="cb534-5"><a href="#cb534-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb534-6"><a href="#cb534-6" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Int</span></span>
<span id="cb534-7"><a href="#cb534-7" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb534-8"><a href="#cb534-8" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></span>
<span id="cb534-9"><a href="#cb534-9" aria-hidden="true" tabindex="-1"></a>  forM_ [<span class="dv">1</span> <span class="op">..</span> <span class="dv">1000</span>] <span class="op">$</span> \j <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb534-10"><a href="#cb534-10" aria-hidden="true" tabindex="-1"></a>    writeSTRef x j</span>
<span id="cb534-11"><a href="#cb534-11" aria-hidden="true" tabindex="-1"></a>  readSTRef x</span>
<span id="cb534-12"><a href="#cb534-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb534-13"><a href="#cb534-13" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Int</span></span>
<span id="cb534-14"><a href="#cb534-14" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> runST <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb534-15"><a href="#cb534-15" aria-hidden="true" tabindex="-1"></a>  count <span class="ot">&lt;-</span> newSTRef <span class="dv">0</span></span>
<span id="cb534-16"><a href="#cb534-16" aria-hidden="true" tabindex="-1"></a>  replicateM_ (<span class="dv">10</span> <span class="op">^</span> <span class="dv">6</span>) <span class="op">$</span> modifySTRef&#39; count (<span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb534-17"><a href="#cb534-17" aria-hidden="true" tabindex="-1"></a>  readSTRef count</span>
<span id="cb534-18"><a href="#cb534-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb534-19"><a href="#cb534-19" aria-hidden="true" tabindex="-1"></a><span class="ot">example3 ::</span> <span class="dt">Int</span></span>
<span id="cb534-20"><a href="#cb534-20" aria-hidden="true" tabindex="-1"></a>example3 <span class="ot">=</span> <span class="fu">flip</span> evalState <span class="dv">0</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb534-21"><a href="#cb534-21" aria-hidden="true" tabindex="-1"></a>  replicateM_ (<span class="dv">10</span> <span class="op">^</span> <span class="dv">6</span>) <span class="op">$</span> modify&#39; (<span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb534-22"><a href="#cb534-22" aria-hidden="true" tabindex="-1"></a>  get</span></code></pre></div>
<p>Using the ST monad we can create a class of efficient purely
functional data structures that use mutable references in a
referentially transparent way.</p>
<h2 id="free-monads">Free Monads</h2>
<div class="sourceCode" id="cb535"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb535-1"><a href="#cb535-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</span>
<span id="cb535-2"><a href="#cb535-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Free</span><span class="ot"> ::</span> f (<span class="dt">Free</span> f a) <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</span>
<span id="cb535-3"><a href="#cb535-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb535-4"><a href="#cb535-4" aria-hidden="true" tabindex="-1"></a><span class="ot">liftF ::</span> (<span class="dt">Functor</span> f, <span class="dt">MonadFree</span> f m) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> m a</span>
<span id="cb535-5"><a href="#cb535-5" aria-hidden="true" tabindex="-1"></a><span class="ot">retract ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> f a</span></code></pre></div>
<p>Free monads are monads which instead of having a <code>join</code>
operation that combines computations, instead forms composite
computations from application of a functor.</p>
<div class="sourceCode" id="cb536"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb536-1"><a href="#cb536-1" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb536-2"><a href="#cb536-2" aria-hidden="true" tabindex="-1"></a><span class="ot">wrap ::</span> <span class="dt">MonadFree</span> f m <span class="ot">=&gt;</span> f (m a) <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>One of the best examples is the Partiality monad which models
computations which can diverge. Haskell allows unbounded recursion, but
for example we can create a free monad from the <code>Maybe</code>
functor which can be used to fix the call-depth of, for example the <a
href="https://en.wikipedia.org/wiki/Ackermann_function">Ackermann
function</a>.</p>
<div class="sourceCode" id="cb537"
data-include="src/10-advanced-monads/partiality.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb537-1"><a href="#cb537-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Fix</span></span>
<span id="cb537-2"><a href="#cb537-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Free</span></span>
<span id="cb537-3"><a href="#cb537-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb537-4"><a href="#cb537-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Partiality</span> a <span class="ot">=</span> <span class="dt">Free</span> <span class="dt">Maybe</span> a</span>
<span id="cb537-5"><a href="#cb537-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb537-6"><a href="#cb537-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Non-termination.</span></span>
<span id="cb537-7"><a href="#cb537-7" aria-hidden="true" tabindex="-1"></a><span class="ot">never ::</span> <span class="dt">Partiality</span> a</span>
<span id="cb537-8"><a href="#cb537-8" aria-hidden="true" tabindex="-1"></a>never <span class="ot">=</span> fix (<span class="dt">Free</span> <span class="op">.</span> <span class="dt">Just</span>)</span>
<span id="cb537-9"><a href="#cb537-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb537-10"><a href="#cb537-10" aria-hidden="true" tabindex="-1"></a><span class="ot">fromMaybe ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Partiality</span> a</span>
<span id="cb537-11"><a href="#cb537-11" aria-hidden="true" tabindex="-1"></a>fromMaybe (<span class="dt">Just</span> x) <span class="ot">=</span> <span class="dt">Pure</span> x</span>
<span id="cb537-12"><a href="#cb537-12" aria-hidden="true" tabindex="-1"></a>fromMaybe <span class="dt">Nothing</span> <span class="ot">=</span> <span class="dt">Free</span> <span class="dt">Nothing</span></span>
<span id="cb537-13"><a href="#cb537-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb537-14"><a href="#cb537-14" aria-hidden="true" tabindex="-1"></a><span class="ot">runPartiality ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Partiality</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb537-15"><a href="#cb537-15" aria-hidden="true" tabindex="-1"></a>runPartiality <span class="dv">0</span> _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb537-16"><a href="#cb537-16" aria-hidden="true" tabindex="-1"></a>runPartiality _ (<span class="dt">Pure</span> a) <span class="ot">=</span> <span class="dt">Just</span> a</span>
<span id="cb537-17"><a href="#cb537-17" aria-hidden="true" tabindex="-1"></a>runPartiality _ (<span class="dt">Free</span> <span class="dt">Nothing</span>) <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb537-18"><a href="#cb537-18" aria-hidden="true" tabindex="-1"></a>runPartiality n (<span class="dt">Free</span> (<span class="dt">Just</span> a)) <span class="ot">=</span> runPartiality (n<span class="op">-</span><span class="dv">1</span>) a</span>
<span id="cb537-19"><a href="#cb537-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb537-20"><a href="#cb537-20" aria-hidden="true" tabindex="-1"></a><span class="ot">ack ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Partiality</span> <span class="dt">Int</span></span>
<span id="cb537-21"><a href="#cb537-21" aria-hidden="true" tabindex="-1"></a>ack <span class="dv">0</span> n <span class="ot">=</span> <span class="dt">Pure</span> <span class="op">$</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb537-22"><a href="#cb537-22" aria-hidden="true" tabindex="-1"></a>ack m <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Free</span> <span class="op">$</span> <span class="dt">Just</span> <span class="op">$</span> ack (m<span class="op">-</span><span class="dv">1</span>) <span class="dv">1</span></span>
<span id="cb537-23"><a href="#cb537-23" aria-hidden="true" tabindex="-1"></a>ack m n <span class="ot">=</span> <span class="dt">Free</span> <span class="op">$</span> <span class="dt">Just</span> <span class="op">$</span> ack m (n<span class="op">-</span><span class="dv">1</span>) <span class="op">&gt;&gt;=</span> ack (m<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb537-24"><a href="#cb537-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb537-25"><a href="#cb537-25" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb537-26"><a href="#cb537-26" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb537-27"><a href="#cb537-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> diverge <span class="ot">= never ::</span> <span class="dt">Partiality</span> ()</span>
<span id="cb537-28"><a href="#cb537-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> runPartiality <span class="dv">1000</span> diverge</span>
<span id="cb537-29"><a href="#cb537-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> runPartiality <span class="dv">1000</span> (ack <span class="dv">3</span> <span class="dv">4</span>)</span>
<span id="cb537-30"><a href="#cb537-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> runPartiality <span class="dv">5500</span> (ack <span class="dv">3</span> <span class="dv">4</span>)</span></code></pre></div>
<p>The other common use for free monads is to build embedded
domain-specific languages to describe computations. We can model a
subset of the IO monad by building up a pure description of the
computation inside of the IOFree monad and then using the free monad to
encode the translation to an effectful IO computation.</p>
<div class="sourceCode" id="cb538"
data-include="src/10-advanced-monads/free_dsl.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb538-1"><a href="#cb538-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb538-2"><a href="#cb538-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb538-3"><a href="#cb538-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Free</span></span>
<span id="cb538-4"><a href="#cb538-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Exit</span></span>
<span id="cb538-5"><a href="#cb538-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb538-6"><a href="#cb538-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Interaction</span> x</span>
<span id="cb538-7"><a href="#cb538-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Puts</span> <span class="dt">String</span> x</span>
<span id="cb538-8"><a href="#cb538-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Gets</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> x)</span>
<span id="cb538-9"><a href="#cb538-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Exit</span></span>
<span id="cb538-10"><a href="#cb538-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Functor</span>)</span>
<span id="cb538-11"><a href="#cb538-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb538-12"><a href="#cb538-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">IOFree</span> a <span class="ot">=</span> <span class="dt">Free</span> <span class="dt">Interaction</span> a</span>
<span id="cb538-13"><a href="#cb538-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb538-14"><a href="#cb538-14" aria-hidden="true" tabindex="-1"></a><span class="ot">puts ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IOFree</span> ()</span>
<span id="cb538-15"><a href="#cb538-15" aria-hidden="true" tabindex="-1"></a>puts s <span class="ot">=</span> liftF <span class="op">$</span> <span class="dt">Puts</span> s ()</span>
<span id="cb538-16"><a href="#cb538-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb538-17"><a href="#cb538-17" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">IOFree</span> <span class="dt">Char</span></span>
<span id="cb538-18"><a href="#cb538-18" aria-hidden="true" tabindex="-1"></a>get <span class="ot">=</span> liftF <span class="op">$</span> <span class="dt">Gets</span> <span class="fu">id</span></span>
<span id="cb538-19"><a href="#cb538-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb538-20"><a href="#cb538-20" aria-hidden="true" tabindex="-1"></a><span class="ot">exit ::</span> <span class="dt">IOFree</span> r</span>
<span id="cb538-21"><a href="#cb538-21" aria-hidden="true" tabindex="-1"></a>exit <span class="ot">=</span> liftF <span class="dt">Exit</span></span>
<span id="cb538-22"><a href="#cb538-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb538-23"><a href="#cb538-23" aria-hidden="true" tabindex="-1"></a><span class="ot">gets ::</span> <span class="dt">IOFree</span> <span class="dt">String</span></span>
<span id="cb538-24"><a href="#cb538-24" aria-hidden="true" tabindex="-1"></a>gets <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb538-25"><a href="#cb538-25" aria-hidden="true" tabindex="-1"></a>  c <span class="ot">&lt;-</span> get</span>
<span id="cb538-26"><a href="#cb538-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> c <span class="op">==</span> <span class="ch">&#39;\n&#39;</span></span>
<span id="cb538-27"><a href="#cb538-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> <span class="fu">return</span> <span class="st">&quot;&quot;</span></span>
<span id="cb538-28"><a href="#cb538-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> gets <span class="op">&gt;&gt;=</span> \line <span class="ot">-&gt;</span> <span class="fu">return</span> (c <span class="op">:</span> line)</span>
<span id="cb538-29"><a href="#cb538-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb538-30"><a href="#cb538-30" aria-hidden="true" tabindex="-1"></a><span class="co">-- Collapse our IOFree DSL into IO monad actions.</span></span>
<span id="cb538-31"><a href="#cb538-31" aria-hidden="true" tabindex="-1"></a><span class="ot">interp ::</span> <span class="dt">IOFree</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb538-32"><a href="#cb538-32" aria-hidden="true" tabindex="-1"></a>interp (<span class="dt">Pure</span> r) <span class="ot">=</span> <span class="fu">return</span> r</span>
<span id="cb538-33"><a href="#cb538-33" aria-hidden="true" tabindex="-1"></a>interp (<span class="dt">Free</span> x) <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb538-34"><a href="#cb538-34" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Puts</span> s t <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> s <span class="op">&gt;&gt;</span> interp t</span>
<span id="cb538-35"><a href="#cb538-35" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Gets</span> f <span class="ot">-&gt;</span> <span class="fu">getChar</span> <span class="op">&gt;&gt;=</span> interp <span class="op">.</span> f</span>
<span id="cb538-36"><a href="#cb538-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Exit</span> <span class="ot">-&gt;</span> exitSuccess</span>
<span id="cb538-37"><a href="#cb538-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb538-38"><a href="#cb538-38" aria-hidden="true" tabindex="-1"></a><span class="ot">echo ::</span> <span class="dt">IOFree</span> ()</span>
<span id="cb538-39"><a href="#cb538-39" aria-hidden="true" tabindex="-1"></a>echo <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb538-40"><a href="#cb538-40" aria-hidden="true" tabindex="-1"></a>  puts <span class="st">&quot;Enter your name:&quot;</span></span>
<span id="cb538-41"><a href="#cb538-41" aria-hidden="true" tabindex="-1"></a>  str <span class="ot">&lt;-</span> gets</span>
<span id="cb538-42"><a href="#cb538-42" aria-hidden="true" tabindex="-1"></a>  puts str</span>
<span id="cb538-43"><a href="#cb538-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> <span class="fu">length</span> str <span class="op">&gt;</span> <span class="dv">10</span></span>
<span id="cb538-44"><a href="#cb538-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> puts <span class="st">&quot;You have a long name.&quot;</span></span>
<span id="cb538-45"><a href="#cb538-45" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> puts <span class="st">&quot;You have a short name.&quot;</span></span>
<span id="cb538-46"><a href="#cb538-46" aria-hidden="true" tabindex="-1"></a>  exit</span>
<span id="cb538-47"><a href="#cb538-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb538-48"><a href="#cb538-48" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb538-49"><a href="#cb538-49" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> interp echo</span></code></pre></div>
<p>An implementation such as the one found in <a
href="http://hackage.haskell.org/package/free">free</a> might look like
the following:</p>
<div class="sourceCode" id="cb539"
data-include="src/10-advanced-monads/free_impl.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb539-1"><a href="#cb539-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb539-2"><a href="#cb539-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb539-3"><a href="#cb539-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb539-4"><a href="#cb539-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Free</span> f a</span>
<span id="cb539-5"><a href="#cb539-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Pure</span> a</span>
<span id="cb539-6"><a href="#cb539-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Free</span> (f (<span class="dt">Free</span> f a))</span>
<span id="cb539-7"><a href="#cb539-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb539-8"><a href="#cb539-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Free</span> f) <span class="kw">where</span></span>
<span id="cb539-9"><a href="#cb539-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Pure</span> a) <span class="ot">=</span> <span class="dt">Pure</span> (f a)</span>
<span id="cb539-10"><a href="#cb539-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f x <span class="ot">=</span> go x</span>
<span id="cb539-11"><a href="#cb539-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb539-12"><a href="#cb539-12" aria-hidden="true" tabindex="-1"></a>      go (<span class="dt">Free</span> fa) <span class="ot">=</span> <span class="dt">Free</span> (go <span class="op">&lt;$&gt;</span> fa)</span>
<span id="cb539-13"><a href="#cb539-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb539-14"><a href="#cb539-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">Free</span> f) <span class="kw">where</span></span>
<span id="cb539-15"><a href="#cb539-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">Pure</span></span>
<span id="cb539-16"><a href="#cb539-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Pure</span> a <span class="op">&lt;*&gt;</span> <span class="dt">Pure</span> b <span class="ot">=</span> <span class="dt">Pure</span> <span class="op">$</span> a b</span>
<span id="cb539-17"><a href="#cb539-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Pure</span> a <span class="op">&lt;*&gt;</span> <span class="dt">Free</span> mb <span class="ot">=</span> <span class="dt">Free</span> <span class="op">$</span> <span class="fu">fmap</span> a <span class="op">&lt;$&gt;</span> mb</span>
<span id="cb539-18"><a href="#cb539-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Free</span> ma <span class="op">&lt;*&gt;</span> <span class="dt">Pure</span> b <span class="ot">=</span> <span class="dt">Free</span> <span class="op">$</span> <span class="fu">fmap</span> (<span class="op">$</span> b) <span class="op">&lt;$&gt;</span> ma</span>
<span id="cb539-19"><a href="#cb539-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Free</span> ma <span class="op">&lt;*&gt;</span> <span class="dt">Free</span> mb <span class="ot">=</span> <span class="dt">Free</span> <span class="op">$</span> <span class="fu">fmap</span> (<span class="op">&lt;*&gt;</span>) ma <span class="op">&lt;*&gt;</span> mb</span>
<span id="cb539-20"><a href="#cb539-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb539-21"><a href="#cb539-21" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">Free</span> f) <span class="kw">where</span></span>
<span id="cb539-22"><a href="#cb539-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="ot">=</span> <span class="dt">Pure</span></span>
<span id="cb539-23"><a href="#cb539-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Pure</span> a <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> f a</span>
<span id="cb539-24"><a href="#cb539-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Free</span> f <span class="op">&gt;&gt;=</span> g <span class="ot">=</span> <span class="dt">Free</span> (<span class="fu">fmap</span> (<span class="op">&gt;&gt;=</span> g) f)</span>
<span id="cb539-25"><a href="#cb539-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb539-26"><a href="#cb539-26" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadFree</span> f m <span class="kw">where</span></span>
<span id="cb539-27"><a href="#cb539-27" aria-hidden="true" tabindex="-1"></a><span class="ot">  wrap ::</span> f (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb539-28"><a href="#cb539-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb539-29"><a href="#cb539-29" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">MonadFree</span> f (<span class="dt">Free</span> f) <span class="kw">where</span></span>
<span id="cb539-30"><a href="#cb539-30" aria-hidden="true" tabindex="-1"></a>  wrap <span class="ot">=</span> <span class="dt">Free</span></span>
<span id="cb539-31"><a href="#cb539-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb539-32"><a href="#cb539-32" aria-hidden="true" tabindex="-1"></a><span class="ot">liftF ::</span> (<span class="dt">Functor</span> f, <span class="dt">MonadFree</span> f m) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> m a</span>
<span id="cb539-33"><a href="#cb539-33" aria-hidden="true" tabindex="-1"></a>liftF <span class="ot">=</span> wrap <span class="op">.</span> <span class="fu">fmap</span> <span class="fu">return</span></span>
<span id="cb539-34"><a href="#cb539-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb539-35"><a href="#cb539-35" aria-hidden="true" tabindex="-1"></a><span class="ot">iter ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> a</span>
<span id="cb539-36"><a href="#cb539-36" aria-hidden="true" tabindex="-1"></a>iter _ (<span class="dt">Pure</span> a) <span class="ot">=</span> a</span>
<span id="cb539-37"><a href="#cb539-37" aria-hidden="true" tabindex="-1"></a>iter phi (<span class="dt">Free</span> m) <span class="ot">=</span> phi (iter phi <span class="op">&lt;$&gt;</span> m)</span>
<span id="cb539-38"><a href="#cb539-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb539-39"><a href="#cb539-39" aria-hidden="true" tabindex="-1"></a><span class="ot">retract ::</span> <span class="dt">Monad</span> f <span class="ot">=&gt;</span> <span class="dt">Free</span> f a <span class="ot">-&gt;</span> f a</span>
<span id="cb539-40"><a href="#cb539-40" aria-hidden="true" tabindex="-1"></a>retract (<span class="dt">Pure</span> a) <span class="ot">=</span> <span class="fu">return</span> a</span>
<span id="cb539-41"><a href="#cb539-41" aria-hidden="true" tabindex="-1"></a>retract (<span class="dt">Free</span> as) <span class="ot">=</span> as <span class="op">&gt;&gt;=</span> retract</span></code></pre></div>
<h2 id="indexed-monads">Indexed Monads</h2>
<p>Indexed monads are a generalisation of monads that adds an additional
type parameter to the class that carries information about the
computation or structure of the monadic implementation.</p>
<div class="sourceCode" id="cb540"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb540-1"><a href="#cb540-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">IxMonad</span> md <span class="kw">where</span></span>
<span id="cb540-2"><a href="#cb540-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  return ::</span> a <span class="ot">-&gt;</span> md i i a</span>
<span id="cb540-3"><a href="#cb540-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&gt;&gt;=) ::</span> md i m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> md m o b) <span class="ot">-&gt;</span> md i o b</span></code></pre></div>
<p>The canonical use-case is a variant of the vanilla State which allows
type-changing on the state for intermediate steps inside of the monad.
This indeed turns out to be very useful for handling a class of problems
involving resource management since the extra index parameter gives us
space to statically enforce the sequence of monadic actions by allowing
and restricting certain state transitions on the index parameter at
compile-time.</p>
<p>To make this more usable we’ll use the somewhat esoteric
<code>-XRebindableSyntax</code> allowing us to overload the do-notation
and if-then-else syntax by providing alternative definitions local to
the module.</p>
<div class="sourceCode" id="cb541"
data-include="src/10-advanced-monads/indexed.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb541-1"><a href="#cb541-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RebindableSyntax #-}</span></span>
<span id="cb541-2"><a href="#cb541-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb541-3"><a href="#cb541-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span></span>
<span id="cb541-4"><a href="#cb541-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-5"><a href="#cb541-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.IORef</span></span>
<span id="cb541-6"><a href="#cb541-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span></span>
<span id="cb541-7"><a href="#cb541-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (fmap, (&gt;&gt;=), (&gt;&gt;), return)</span>
<span id="cb541-8"><a href="#cb541-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb541-9"><a href="#cb541-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-10"><a href="#cb541-10" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">IState</span> i o a <span class="ot">=</span> <span class="dt">IState</span> {<span class="ot"> runIState ::</span> i <span class="ot">-&gt;</span> (a, o) }</span>
<span id="cb541-11"><a href="#cb541-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-12"><a href="#cb541-12" aria-hidden="true" tabindex="-1"></a><span class="ot">evalIState ::</span> <span class="dt">IState</span> i o a <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> a</span>
<span id="cb541-13"><a href="#cb541-13" aria-hidden="true" tabindex="-1"></a>evalIState st i <span class="ot">=</span> <span class="fu">fst</span> <span class="op">$</span> runIState st i</span>
<span id="cb541-14"><a href="#cb541-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-15"><a href="#cb541-15" aria-hidden="true" tabindex="-1"></a><span class="ot">execIState ::</span> <span class="dt">IState</span> i o a <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> o</span>
<span id="cb541-16"><a href="#cb541-16" aria-hidden="true" tabindex="-1"></a>execIState st i <span class="ot">=</span> <span class="fu">snd</span> <span class="op">$</span> runIState st i</span>
<span id="cb541-17"><a href="#cb541-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-18"><a href="#cb541-18" aria-hidden="true" tabindex="-1"></a><span class="ot">ifThenElse ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb541-19"><a href="#cb541-19" aria-hidden="true" tabindex="-1"></a>ifThenElse b i j <span class="ot">=</span> <span class="kw">case</span> b <span class="kw">of</span></span>
<span id="cb541-20"><a href="#cb541-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span> <span class="ot">-&gt;</span> i</span>
<span id="cb541-21"><a href="#cb541-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span> <span class="ot">-&gt;</span> j</span>
<span id="cb541-22"><a href="#cb541-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-23"><a href="#cb541-23" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">IState</span> s s a</span>
<span id="cb541-24"><a href="#cb541-24" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> a <span class="ot">=</span> <span class="dt">IState</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb541-25"><a href="#cb541-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-26"><a href="#cb541-26" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">IState</span> i o a <span class="ot">-&gt;</span> <span class="dt">IState</span> i o b</span>
<span id="cb541-27"><a href="#cb541-27" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f v <span class="ot">=</span> <span class="dt">IState</span> <span class="op">$</span> \i <span class="ot">-&gt;</span> <span class="kw">let</span> (a, o) <span class="ot">=</span> runIState v i</span>
<span id="cb541-28"><a href="#cb541-28" aria-hidden="true" tabindex="-1"></a>                          <span class="kw">in</span> (f a, o)</span>
<span id="cb541-29"><a href="#cb541-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-30"><a href="#cb541-30" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> <span class="dt">IState</span> i m (<span class="dt">IState</span> m o a) <span class="ot">-&gt;</span> <span class="dt">IState</span> i o a</span>
<span id="cb541-31"><a href="#cb541-31" aria-hidden="true" tabindex="-1"></a>join v <span class="ot">=</span> <span class="dt">IState</span> <span class="op">$</span> \i <span class="ot">-&gt;</span> <span class="kw">let</span> (w, m) <span class="ot">=</span> runIState v i</span>
<span id="cb541-32"><a href="#cb541-32" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">in</span> runIState w m</span>
<span id="cb541-33"><a href="#cb541-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-34"><a href="#cb541-34" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">IState</span> i m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IState</span> m o b) <span class="ot">-&gt;</span> <span class="dt">IState</span> i o b</span>
<span id="cb541-35"><a href="#cb541-35" aria-hidden="true" tabindex="-1"></a>v <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="dt">IState</span> <span class="op">$</span> \i <span class="ot">-&gt;</span> <span class="kw">let</span> (a, m) <span class="ot">=</span> runIState v i</span>
<span id="cb541-36"><a href="#cb541-36" aria-hidden="true" tabindex="-1"></a>                         <span class="kw">in</span> runIState (f a) m</span>
<span id="cb541-37"><a href="#cb541-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-38"><a href="#cb541-38" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;) ::</span> <span class="dt">IState</span> i m a <span class="ot">-&gt;</span> <span class="dt">IState</span> m o b <span class="ot">-&gt;</span> <span class="dt">IState</span> i o b</span>
<span id="cb541-39"><a href="#cb541-39" aria-hidden="true" tabindex="-1"></a>v <span class="op">&gt;&gt;</span> w <span class="ot">=</span> v <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> w</span>
<span id="cb541-40"><a href="#cb541-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-41"><a href="#cb541-41" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">IState</span> s s s</span>
<span id="cb541-42"><a href="#cb541-42" aria-hidden="true" tabindex="-1"></a>get <span class="ot">=</span> <span class="dt">IState</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (s, s)</span>
<span id="cb541-43"><a href="#cb541-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-44"><a href="#cb541-44" aria-hidden="true" tabindex="-1"></a><span class="ot">gets ::</span> (a <span class="ot">-&gt;</span> o) <span class="ot">-&gt;</span> <span class="dt">IState</span> a o a</span>
<span id="cb541-45"><a href="#cb541-45" aria-hidden="true" tabindex="-1"></a>gets f <span class="ot">=</span> <span class="dt">IState</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (s, f s)</span>
<span id="cb541-46"><a href="#cb541-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-47"><a href="#cb541-47" aria-hidden="true" tabindex="-1"></a><span class="ot">put ::</span> o <span class="ot">-&gt;</span> <span class="dt">IState</span> i o ()</span>
<span id="cb541-48"><a href="#cb541-48" aria-hidden="true" tabindex="-1"></a>put o <span class="ot">=</span> <span class="dt">IState</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> ((), o)</span>
<span id="cb541-49"><a href="#cb541-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-50"><a href="#cb541-50" aria-hidden="true" tabindex="-1"></a><span class="ot">modify ::</span> (i <span class="ot">-&gt;</span> o) <span class="ot">-&gt;</span> <span class="dt">IState</span> i o ()</span>
<span id="cb541-51"><a href="#cb541-51" aria-hidden="true" tabindex="-1"></a>modify f <span class="ot">=</span> <span class="dt">IState</span> <span class="op">$</span> \i <span class="ot">-&gt;</span> ((), f i)</span>
<span id="cb541-52"><a href="#cb541-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-53"><a href="#cb541-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-54"><a href="#cb541-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-55"><a href="#cb541-55" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Locked</span> <span class="ot">=</span> <span class="dt">Locked</span></span>
<span id="cb541-56"><a href="#cb541-56" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Unlocked</span> <span class="ot">=</span> <span class="dt">Unlocked</span></span>
<span id="cb541-57"><a href="#cb541-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-58"><a href="#cb541-58" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Stateful</span> a <span class="ot">=</span> <span class="dt">IState</span> a <span class="dt">Unlocked</span> a</span>
<span id="cb541-59"><a href="#cb541-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-60"><a href="#cb541-60" aria-hidden="true" tabindex="-1"></a><span class="ot">acquire ::</span> <span class="dt">IState</span> i <span class="dt">Locked</span> ()</span>
<span id="cb541-61"><a href="#cb541-61" aria-hidden="true" tabindex="-1"></a>acquire <span class="ot">=</span> put <span class="dt">Locked</span></span>
<span id="cb541-62"><a href="#cb541-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-63"><a href="#cb541-63" aria-hidden="true" tabindex="-1"></a><span class="co">-- Can only release the lock if it&#39;s held, try release the lock</span></span>
<span id="cb541-64"><a href="#cb541-64" aria-hidden="true" tabindex="-1"></a><span class="co">-- that&#39;s not held is a now a type error.</span></span>
<span id="cb541-65"><a href="#cb541-65" aria-hidden="true" tabindex="-1"></a><span class="ot">release ::</span> <span class="dt">IState</span> <span class="dt">Locked</span> <span class="dt">Unlocked</span> ()</span>
<span id="cb541-66"><a href="#cb541-66" aria-hidden="true" tabindex="-1"></a>release <span class="ot">=</span> put <span class="dt">Unlocked</span></span>
<span id="cb541-67"><a href="#cb541-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-68"><a href="#cb541-68" aria-hidden="true" tabindex="-1"></a><span class="co">-- Statically forbids improper handling of resources.</span></span>
<span id="cb541-69"><a href="#cb541-69" aria-hidden="true" tabindex="-1"></a><span class="ot">lockExample ::</span> <span class="dt">Stateful</span> a</span>
<span id="cb541-70"><a href="#cb541-70" aria-hidden="true" tabindex="-1"></a>lockExample <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb541-71"><a href="#cb541-71" aria-hidden="true" tabindex="-1"></a>  ptr <span class="ot">&lt;- get  ::</span> <span class="dt">IState</span> a a a</span>
<span id="cb541-72"><a href="#cb541-72" aria-hidden="true" tabindex="-1"></a><span class="ot">  acquire     ::</span> <span class="dt">IState</span> a <span class="dt">Locked</span> ()</span>
<span id="cb541-73"><a href="#cb541-73" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- ...</span></span>
<span id="cb541-74"><a href="#cb541-74" aria-hidden="true" tabindex="-1"></a><span class="ot">  release     ::</span> <span class="dt">IState</span> <span class="dt">Locked</span> <span class="dt">Unlocked</span> ()</span>
<span id="cb541-75"><a href="#cb541-75" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ptr</span>
<span id="cb541-76"><a href="#cb541-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-77"><a href="#cb541-77" aria-hidden="true" tabindex="-1"></a><span class="co">-- Couldn&#39;t match type `Locked&#39; with `Unlocked&#39;</span></span>
<span id="cb541-78"><a href="#cb541-78" aria-hidden="true" tabindex="-1"></a><span class="co">-- In a stmt of a &#39;do&#39; block: return ptr</span></span>
<span id="cb541-79"><a href="#cb541-79" aria-hidden="true" tabindex="-1"></a><span class="ot">failure1 ::</span> <span class="dt">Stateful</span> a</span>
<span id="cb541-80"><a href="#cb541-80" aria-hidden="true" tabindex="-1"></a>failure1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb541-81"><a href="#cb541-81" aria-hidden="true" tabindex="-1"></a>  ptr <span class="ot">&lt;-</span> get</span>
<span id="cb541-82"><a href="#cb541-82" aria-hidden="true" tabindex="-1"></a>  acquire</span>
<span id="cb541-83"><a href="#cb541-83" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ptr <span class="co">-- didn&#39;t release</span></span>
<span id="cb541-84"><a href="#cb541-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-85"><a href="#cb541-85" aria-hidden="true" tabindex="-1"></a><span class="co">-- Couldn&#39;t match type `a&#39; with `Locked&#39;</span></span>
<span id="cb541-86"><a href="#cb541-86" aria-hidden="true" tabindex="-1"></a><span class="co">-- In a stmt of a &#39;do&#39; block: release</span></span>
<span id="cb541-87"><a href="#cb541-87" aria-hidden="true" tabindex="-1"></a><span class="ot">failure2 ::</span> <span class="dt">Stateful</span> a</span>
<span id="cb541-88"><a href="#cb541-88" aria-hidden="true" tabindex="-1"></a>failure2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb541-89"><a href="#cb541-89" aria-hidden="true" tabindex="-1"></a>  ptr <span class="ot">&lt;-</span> get</span>
<span id="cb541-90"><a href="#cb541-90" aria-hidden="true" tabindex="-1"></a>  release <span class="co">-- didn&#39;t acquire</span></span>
<span id="cb541-91"><a href="#cb541-91" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ptr</span>
<span id="cb541-92"><a href="#cb541-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-93"><a href="#cb541-93" aria-hidden="true" tabindex="-1"></a><span class="co">-- Evaluate the resulting state, statically ensuring that the</span></span>
<span id="cb541-94"><a href="#cb541-94" aria-hidden="true" tabindex="-1"></a><span class="co">-- lock is released when finished.</span></span>
<span id="cb541-95"><a href="#cb541-95" aria-hidden="true" tabindex="-1"></a><span class="ot">evalReleased ::</span> <span class="dt">IState</span> i <span class="dt">Unlocked</span> a <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> a</span>
<span id="cb541-96"><a href="#cb541-96" aria-hidden="true" tabindex="-1"></a>evalReleased f st <span class="ot">=</span> evalIState f st</span>
<span id="cb541-97"><a href="#cb541-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb541-98"><a href="#cb541-98" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> (<span class="dt">IORef</span> <span class="dt">Integer</span>)</span>
<span id="cb541-99"><a href="#cb541-99" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> evalReleased <span class="op">&lt;$&gt;</span> <span class="fu">pure</span> lockExample <span class="op">&lt;*&gt;</span> newIORef <span class="dv">0</span></span></code></pre></div>
<h2 id="lifted-base">Lifted Base</h2>
<p>The default prelude predates a lot of the work on monad transformers
and as such many of the common functions for handling errors and
interacting with IO are bound strictly to the IO monad and not to
functions implementing stacks on top of IO or ST. The lifted-base
provides generic control operations such as <code>catch</code> can be
lifted from IO or any other base monad.</p>
<h4 id="monad-base">monad-base</h4>
<p>Monad base provides an abstraction over <code>liftIO</code> and other
functions to explicitly lift into a “privileged” layer of the
transformer stack. It’s implemented as a multiparameter typeclass with
the “base” monad as the parameter b.</p>
<div class="sourceCode" id="cb542"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb542-1"><a href="#cb542-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Lift a computation from the base monad</span></span>
<span id="cb542-2"><a href="#cb542-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Applicative</span> b, <span class="dt">Applicative</span> m, <span class="dt">Monad</span> b, <span class="dt">Monad</span> m)</span>
<span id="cb542-3"><a href="#cb542-3" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=&gt;</span> <span class="dt">MonadBase</span> b m <span class="op">|</span> m <span class="ot">-&gt;</span> b <span class="kw">where</span></span>
<span id="cb542-4"><a href="#cb542-4" aria-hidden="true" tabindex="-1"></a>  liftBase ∷ b a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<h4 id="monad-control">monad-control</h4>
<p>Monad control builds on top of monad-base to extended lifting
operation to control operations like <code>catch</code> and
<code>bracket</code> can be written generically in terms of any
transformer with a base layer supporting these operations. Generic
operations can then be expressed in terms of a
<code>MonadBaseControl</code> and written in terms of the combinator
<code>control</code> which handles the bracket and automatic handler
lifting.</p>
<div class="sourceCode" id="cb543"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb543-1"><a href="#cb543-1" aria-hidden="true" tabindex="-1"></a><span class="ot">control ::</span> <span class="dt">MonadBaseControl</span> b m <span class="ot">=&gt;</span> (<span class="dt">RunInBase</span> m b <span class="ot">-&gt;</span> b (<span class="dt">StM</span> m a)) <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>For example the function catch provided by
<code>Control.Exception</code> is normally locked into IO.</p>
<pre><code>catch :: Exception e =&gt; IO a -&gt; (e -&gt; IO a) -&gt; IO a</code></pre>
<p>By composing it in terms of control we can construct a generic
version which automatically lifts inside of any combination of the usual
transformer stacks that has <code>MonadBaseControl</code> instance.</p>
<div class="sourceCode" id="cb545"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb545-1"><a href="#cb545-1" aria-hidden="true" tabindex="-1"></a><span class="fu">catch</span></span>
<span id="cb545-2"><a href="#cb545-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> (<span class="dt">MonadBaseControl</span> <span class="dt">IO</span> m, <span class="dt">Exception</span> e)</span>
<span id="cb545-3"><a href="#cb545-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> m a        <span class="co">-- ^ Computation</span></span>
<span id="cb545-4"><a href="#cb545-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> m a) <span class="co">-- ^ Handler</span></span>
<span id="cb545-5"><a href="#cb545-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> m a</span>
<span id="cb545-6"><a href="#cb545-6" aria-hidden="true" tabindex="-1"></a><span class="fu">catch</span> a handler <span class="ot">=</span> control <span class="op">$</span> \runInIO <span class="ot">-&gt;</span></span>
<span id="cb545-7"><a href="#cb545-7" aria-hidden="true" tabindex="-1"></a>                    E.catch (runInIO a)</span>
<span id="cb545-8"><a href="#cb545-8" aria-hidden="true" tabindex="-1"></a>                            (\e <span class="ot">-&gt;</span> runInIO <span class="op">$</span> handler e)</span></code></pre></div>
<hr/>
<h1 id="quantification">Quantification</h1>
<p>In logic a predicate is a statement about a subject. For instance the
statement: Socrates is a man, can be written as:</p>
<pre class="text"><code>Man(Socrates)</code></pre>
<p>A predicate assigned to a variable Man(x) has a truth value if the
predicate holds for the subject. The domain of a variable is the set of
all variables that may be assigned to the variable. A quantifier turns
predicates into propositions by assigning values to all variables. For
example the statement: All men are mortal. This is an example of a
universal quantifier which describe a predicate that holds forall
inhabitants of the domain of variables.</p>
<pre class="text"><code>Forall x. If Man(x) then Mortal(x)</code></pre>
<p>The truth value that that Socrates is mortal can be derived from
above relation. Programming with quantifiers in Haskell follows this
same kind of logical convention except we will be working with types and
constraints on types.</p>
<h2 id="universal-quantification">Universal Quantification</h2>
<p>Universal quantification the primary mechanism of encoding
polymorphism in Haskell. The essence of universal quantification is that
we can express functions which operate the same way for a set of types
and whose function behavior is entirely determined <em>only</em> by the
behavior of all types in this span. These are represented at the
type-level by in the introduction of a universal quantifier
(<code>forall</code> or <code>∀</code>) over a set of the type variables
in the signature.</p>
<div class="sourceCode" id="cb548"
data-include="src/11-quantification/universal.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb548-1"><a href="#cb548-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span></span>
<span id="cb548-2"><a href="#cb548-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb548-3"><a href="#cb548-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- ∀a. [a]</span></span>
<span id="cb548-4"><a href="#cb548-4" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="kw">forall</span> a<span class="op">.</span> [a]</span>
<span id="cb548-5"><a href="#cb548-5" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> []</span>
<span id="cb548-6"><a href="#cb548-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb548-7"><a href="#cb548-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- ∀a. [a]</span></span>
<span id="cb548-8"><a href="#cb548-8" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="kw">forall</span> a<span class="op">.</span> [a]</span>
<span id="cb548-9"><a href="#cb548-9" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> [<span class="fu">undefined</span>]</span>
<span id="cb548-10"><a href="#cb548-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb548-11"><a href="#cb548-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- ∀a. ∀b. (a → b) → [a] → [b]</span></span>
<span id="cb548-12"><a href="#cb548-12" aria-hidden="true" tabindex="-1"></a><span class="ot">map&#39; ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="kw">forall</span> b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb548-13"><a href="#cb548-13" aria-hidden="true" tabindex="-1"></a>map&#39; f <span class="ot">=</span> <span class="fu">foldr</span> ((<span class="op">:</span>) <span class="op">.</span> f) []</span>
<span id="cb548-14"><a href="#cb548-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb548-15"><a href="#cb548-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- ∀a. [a] → [a]</span></span>
<span id="cb548-16"><a href="#cb548-16" aria-hidden="true" tabindex="-1"></a><span class="ot">reverse&#39; ::</span> <span class="kw">forall</span> a<span class="op">.</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb548-17"><a href="#cb548-17" aria-hidden="true" tabindex="-1"></a>reverse&#39; <span class="ot">=</span> <span class="fu">foldl</span> (<span class="fu">flip</span> (<span class="op">:</span>)) []</span></code></pre></div>
<p>Normally quantifiers are omitted in type signatures since in
Haskell’s vanilla surface language it is unambiguous to assume to that
free type variables are universally quantified. So the following two are
equivalent:</p>
<div class="sourceCode" id="cb549"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb549-1"><a href="#cb549-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb549-2"><a href="#cb549-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<h2 id="free-theorems">Free Theorems</h2>
<p>A universally quantified type-variable actually implies quite a few
rather deep properties about the implementation of a function that can
be deduced from its type signature. For instance the identity function
in Haskell is guaranteed to only have one implementation since the only
information that the information that can present in the body:</p>
<div class="sourceCode" id="cb550"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb550-1"><a href="#cb550-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb550-2"><a href="#cb550-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<p>These so called <em>free theorems</em> are properties that hold for
any well-typed inhabitant of a universally quantified signature.</p>
<div class="sourceCode" id="cb551"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb551-1"><a href="#cb551-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div>
<p>For example a free theorem of <code>fmap</code> is that every
implementation of functor <em>can only ever have the property</em> that
composition of maps of functions is the same as maps of the functions
composed together.</p>
<div class="sourceCode" id="cb552"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb552-1"><a href="#cb552-1" aria-hidden="true" tabindex="-1"></a><span class="kw">forall</span> f g<span class="op">.</span> <span class="fu">fmap</span> f <span class="op">.</span> <span class="fu">fmap</span> g <span class="ot">=</span> <span class="fu">fmap</span> (f <span class="op">.</span> g)</span></code></pre></div>
<h2 id="type-systems">Type Systems</h2>
<p><strong>Hindley-Milner type system</strong></p>
<p>The Hindley-Milner type system is historically important as one of
the first typed lambda calculi that admitted both polymorphism and a
variety of inference techniques that could always decide principal
types.</p>
<div class="sourceCode" id="cb553"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb553-1"><a href="#cb553-1" aria-hidden="true" tabindex="-1"></a>e <span class="op">:</span> x</span>
<span id="cb553-2"><a href="#cb553-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> λx<span class="op">:</span>t<span class="op">.</span>e            <span class="co">-- value abstraction</span></span>
<span id="cb553-3"><a href="#cb553-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> e1 e2             <span class="co">-- application</span></span>
<span id="cb553-4"><a href="#cb553-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="kw">let</span> x <span class="ot">=</span> e1 <span class="kw">in</span> e2  <span class="co">-- let</span></span>
<span id="cb553-5"><a href="#cb553-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb553-6"><a href="#cb553-6" aria-hidden="true" tabindex="-1"></a>t <span class="op">:</span> t <span class="ot">-&gt;</span> t     <span class="co">-- function types</span></span>
<span id="cb553-7"><a href="#cb553-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> a          <span class="co">-- type variables</span></span>
<span id="cb553-8"><a href="#cb553-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb553-9"><a href="#cb553-9" aria-hidden="true" tabindex="-1"></a>σ <span class="op">:</span> ∀ a <span class="op">.</span> t    <span class="co">-- type scheme</span></span></code></pre></div>
<p>In an type checker implementation, a <em>generalize</em> function
converts all type variables within the type into polymorphic type
variables yielding a type scheme. While a <em>instantiate</em> function
maps a scheme to a type, but with any polymorphic variables converted
into unbound type variables.</p>
<h2 id="rank-n-types">Rank-N Types</h2>
<p>System-F is the type system that underlies Haskell. System-F subsumes
the HM type system in the sense that every type expressible in HM can be
expressed within System-F. System-F is sometimes referred to in texts as
the <em>Girald-Reynolds polymorphic lambda calculus</em> or
<em>second-order lambda calculus</em>.</p>
<div class="sourceCode" id="cb554"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb554-1"><a href="#cb554-1" aria-hidden="true" tabindex="-1"></a>t <span class="op">:</span> t <span class="ot">-&gt;</span> t     <span class="co">-- function types</span></span>
<span id="cb554-2"><a href="#cb554-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> a          <span class="co">-- type variables</span></span>
<span id="cb554-3"><a href="#cb554-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> ∀ a <span class="op">.</span> t    <span class="co">-- forall</span></span>
<span id="cb554-4"><a href="#cb554-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb554-5"><a href="#cb554-5" aria-hidden="true" tabindex="-1"></a>e <span class="op">:</span> x          <span class="co">-- variables</span></span>
<span id="cb554-6"><a href="#cb554-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> λ(x<span class="op">:</span>t)<span class="op">.</span>e   <span class="co">-- value abstraction</span></span>
<span id="cb554-7"><a href="#cb554-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> e1 e2      <span class="co">-- value application</span></span>
<span id="cb554-8"><a href="#cb554-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> Λa<span class="op">.</span>e       <span class="co">-- type abstraction</span></span>
<span id="cb554-9"><a href="#cb554-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> e_t        <span class="co">-- type application</span></span></code></pre></div>
<p>An example with equivalents of GHC Core in comments:</p>
<div class="sourceCode" id="cb555"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb555-1"><a href="#cb555-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> <span class="op">:</span> ∀ t<span class="op">.</span> t <span class="ot">-&gt;</span> t</span>
<span id="cb555-2"><a href="#cb555-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> <span class="ot">=</span> Λt<span class="op">.</span> λx<span class="op">:</span>t<span class="op">.</span> x</span>
<span id="cb555-3"><a href="#cb555-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- id :: forall t. t -&gt; t</span></span>
<span id="cb555-4"><a href="#cb555-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- id = \ (@ t) (x :: t) -&gt; x</span></span>
<span id="cb555-5"><a href="#cb555-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb555-6"><a href="#cb555-6" aria-hidden="true" tabindex="-1"></a>tr <span class="op">:</span> ∀ a<span class="op">.</span> ∀ b<span class="op">.</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb555-7"><a href="#cb555-7" aria-hidden="true" tabindex="-1"></a>tr <span class="ot">=</span> Λa<span class="op">.</span> Λb<span class="op">.</span> λx<span class="op">:</span>a<span class="op">.</span> λy<span class="op">:</span>b<span class="op">.</span> x</span>
<span id="cb555-8"><a href="#cb555-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- tr :: forall a b. a -&gt; b -&gt; a</span></span>
<span id="cb555-9"><a href="#cb555-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- tr = \ (@ a) (@ b) (x :: a) (y :: b) -&gt; x</span></span>
<span id="cb555-10"><a href="#cb555-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb555-11"><a href="#cb555-11" aria-hidden="true" tabindex="-1"></a>fl <span class="op">:</span> ∀ a<span class="op">.</span> ∀ b<span class="op">.</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</span>
<span id="cb555-12"><a href="#cb555-12" aria-hidden="true" tabindex="-1"></a>fl <span class="ot">=</span> Λa<span class="op">.</span> Λb<span class="op">.</span> λx<span class="op">:</span>a<span class="op">.</span> λy<span class="op">:</span>b<span class="op">.</span> y</span>
<span id="cb555-13"><a href="#cb555-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- fl :: forall a b. a -&gt; b -&gt; b</span></span>
<span id="cb555-14"><a href="#cb555-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- fl = \ (@ a) (@ b) (x :: a) (y :: b) -&gt; y</span></span>
<span id="cb555-15"><a href="#cb555-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb555-16"><a href="#cb555-16" aria-hidden="true" tabindex="-1"></a>nil <span class="op">:</span> ∀ a<span class="op">.</span> [a]</span>
<span id="cb555-17"><a href="#cb555-17" aria-hidden="true" tabindex="-1"></a>nil <span class="ot">=</span> Λa<span class="op">.</span> Λb<span class="op">.</span> λz<span class="op">:</span>b<span class="op">.</span> λf<span class="op">:</span>(a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b)<span class="op">.</span> z</span>
<span id="cb555-18"><a href="#cb555-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- nil :: forall a. [a]</span></span>
<span id="cb555-19"><a href="#cb555-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- nil = \ (@ a) (@ b) (z :: b) (f :: a -&gt; b -&gt; b) -&gt; z</span></span>
<span id="cb555-20"><a href="#cb555-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb555-21"><a href="#cb555-21" aria-hidden="true" tabindex="-1"></a>cons <span class="op">:</span> ∀ a<span class="op">.</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb555-22"><a href="#cb555-22" aria-hidden="true" tabindex="-1"></a>cons <span class="ot">=</span> Λa<span class="op">.</span> λx<span class="op">:</span>a<span class="op">.</span> λxs<span class="op">:</span>(∀ b<span class="op">.</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b)<span class="op">.</span></span>
<span id="cb555-23"><a href="#cb555-23" aria-hidden="true" tabindex="-1"></a>    Λb<span class="op">.</span> λz<span class="op">:</span>b<span class="op">.</span> λf <span class="op">:</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b)<span class="op">.</span> f x (xs_b z f)</span>
<span id="cb555-24"><a href="#cb555-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- cons :: forall a. a -&gt; [a] -&gt; [a]</span></span>
<span id="cb555-25"><a href="#cb555-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- cons = \ (@ a) (x :: a) (xs :: forall b. b -&gt; (a -&gt; b -&gt; b) -&gt; b)</span></span>
<span id="cb555-26"><a href="#cb555-26" aria-hidden="true" tabindex="-1"></a><span class="co">--     (@ b) (z :: b) (f :: a -&gt; b -&gt; b) -&gt; f x (xs @ b z f)</span></span></code></pre></div>
<p>Normally when Haskell’s typechecker infers a type signature it places
all quantifiers of type variables at the outermost position such that no
quantifiers appear within the body of the type expression, called the
prenex restriction. This restricts an entire class of type signatures
that would otherwise be expressible within System-F, but has the benefit
of making inference much easier.</p>
<p><code>-XRankNTypes</code> loosens the prenex restriction such that we
may explicitly place quantifiers within the body of the type. The bad
news is that the general problem of inference in this relaxed system is
undecidable in general, so we’re required to explicitly annotate
functions which use RankNTypes or they are otherwise inferred as rank 1
and may not typecheck at all.</p>
<div class="sourceCode" id="cb556"
data-include="src/11-quantification/rankn.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb556-1"><a href="#cb556-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb556-2"><a href="#cb556-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb556-3"><a href="#cb556-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Can&#39;t unify ( Bool ~ Char )</span></span>
<span id="cb556-4"><a href="#cb556-4" aria-hidden="true" tabindex="-1"></a><span class="ot">rank1 ::</span> <span class="kw">forall</span> a<span class="op">.</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, <span class="dt">Char</span>)</span>
<span id="cb556-5"><a href="#cb556-5" aria-hidden="true" tabindex="-1"></a>rank1 f <span class="ot">=</span> (f <span class="dt">True</span>, f <span class="ch">&#39;a&#39;</span>)</span>
<span id="cb556-6"><a href="#cb556-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb556-7"><a href="#cb556-7" aria-hidden="true" tabindex="-1"></a><span class="ot">rank2 ::</span> (<span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Bool</span>, <span class="dt">Char</span>)</span>
<span id="cb556-8"><a href="#cb556-8" aria-hidden="true" tabindex="-1"></a>rank2 f <span class="ot">=</span> (f <span class="dt">True</span>, f <span class="ch">&#39;a&#39;</span>)</span>
<span id="cb556-9"><a href="#cb556-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb556-10"><a href="#cb556-10" aria-hidden="true" tabindex="-1"></a><span class="ot">auto ::</span> (<span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="kw">forall</span> b<span class="op">.</span> b <span class="ot">-&gt;</span> b)</span>
<span id="cb556-11"><a href="#cb556-11" aria-hidden="true" tabindex="-1"></a>auto x <span class="ot">=</span> x</span>
<span id="cb556-12"><a href="#cb556-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb556-13"><a href="#cb556-13" aria-hidden="true" tabindex="-1"></a><span class="ot">xauto ::</span> <span class="kw">forall</span> a<span class="op">.</span> (<span class="kw">forall</span> b<span class="op">.</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb556-14"><a href="#cb556-14" aria-hidden="true" tabindex="-1"></a>xauto f <span class="ot">=</span> f</span></code></pre></div>
<div class="sourceCode" id="cb557"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb557-1"><a href="#cb557-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Monomorphic</span> <span class="dt">Rank</span> <span class="dv">0</span><span class="op">:</span> t</span>
<span id="cb557-2"><a href="#cb557-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Polymorphic</span> <span class="dt">Rank</span> <span class="dv">1</span><span class="op">:</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> t</span>
<span id="cb557-3"><a href="#cb557-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Polymorphic</span> <span class="dt">Rank</span> <span class="dv">2</span><span class="op">:</span> (<span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> t</span>
<span id="cb557-4"><a href="#cb557-4" aria-hidden="true" tabindex="-1"></a><span class="dt">Polymorphic</span> <span class="dt">Rank</span> <span class="dv">3</span><span class="op">:</span> ((<span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> t</span></code></pre></div>
<p>Of important note is that the type variables bound by an explicit
quantifier in a higher ranked type may not escape their enclosing scope.
The typechecker will explicitly enforce this by enforcing that variables
bound inside of rank-n types (called skolem constants) will not unify
with free meta type variables inferred by the inference engine.</p>
<div class="sourceCode" id="cb558"
data-include="src/11-quantification/skolem_capture.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb558-1"><a href="#cb558-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb558-2"><a href="#cb558-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb558-3"><a href="#cb558-3" aria-hidden="true" tabindex="-1"></a><span class="ot">escape ::</span> (<span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb558-4"><a href="#cb558-4" aria-hidden="true" tabindex="-1"></a>escape f <span class="ot">=</span> f <span class="dv">0</span></span>
<span id="cb558-5"><a href="#cb558-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb558-6"><a href="#cb558-6" aria-hidden="true" tabindex="-1"></a>g x <span class="ot">=</span> escape (\a <span class="ot">-&gt;</span> x)</span></code></pre></div>
<p>In this example in order for the expression to be well typed,
<code>f</code> would necessarily have (<code>Int -&gt; Int</code>) which
implies that <code>a ~ Int</code> over the whole type, but since
<code>a</code> is bound under the quantifier it must not be unified with
<code>Int</code> and so the typechecker must fail with a skolem capture
error.</p>
<div class="sourceCode" id="cb559"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb559-1"><a href="#cb559-1" aria-hidden="true" tabindex="-1"></a>Couldn<span class="ot">&#39;</span><span class="ss">t match expected type `a</span><span class="ot">&#39;</span> with actual type <span class="ot">`</span><span class="st">t&#39;</span></span>
<span id="cb559-2"><a href="#cb559-2" aria-hidden="true" tabindex="-1"></a><span class="ot">`</span>a<span class="ot">&#39;</span><span class="ss"> is a rigid type variable bound by a type expected by the context: a -&gt; a</span></span>
<span id="cb559-3"><a href="#cb559-3" aria-hidden="true" tabindex="-1"></a><span class="ss">`t</span><span class="ot">&#39;</span> is a rigid type variable bound by the inferred type of g :: t -&gt; Int</span>
<span id="cb559-4"><a href="#cb559-4" aria-hidden="true" tabindex="-1"></a>In the expression: x In the first argument of <span class="ot">`</span><span class="st">escape&#39;, namely </span><span class="ot">`</span>(\ a -&gt; x)<span class="ot">&#39;</span></span>
<span id="cb559-5"><a href="#cb559-5" aria-hidden="true" tabindex="-1"></a><span class="ss">In the expression: escape (\ a -&gt; x)</span></span></code></pre></div>
<p>This can actually be used for our advantage to enforce several types
of invariants about scope and use of specific type variables. For
example the ST monad uses a second rank type to prevent the capture of
references between ST monads with separate state threads where the
<code>s</code> type variable is bound within a rank-2 type and cannot
escape, statically guaranteeing that the implementation details of the
ST internals can’t leak out and thus ensuring its referential
transparency.</p>
<h2 id="existential-quantification">Existential Quantification</h2>
<p>An existential type is a pair of a type and a term with a special set
of packing and unpacking semantics. The type of the value encoded in the
existential is known by the producer but not by the consumer of the
existential value.</p>
<div class="sourceCode" id="cb560"
data-include="src/11-quantification/existential.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb560-1"><a href="#cb560-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span></span>
<span id="cb560-2"><a href="#cb560-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb560-3"><a href="#cb560-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb560-4"><a href="#cb560-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- ∃ t. (t, t → t, t → String)</span></span>
<span id="cb560-5"><a href="#cb560-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Box</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Box</span></span>
<span id="cb560-6"><a href="#cb560-6" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> value  ::</span> a</span>
<span id="cb560-7"><a href="#cb560-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> update ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb560-8"><a href="#cb560-8" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> print  ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb560-9"><a href="#cb560-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb560-10"><a href="#cb560-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb560-11"><a href="#cb560-11" aria-hidden="true" tabindex="-1"></a><span class="ot">boxa ::</span> <span class="dt">Box</span></span>
<span id="cb560-12"><a href="#cb560-12" aria-hidden="true" tabindex="-1"></a>boxa <span class="ot">=</span> <span class="dt">Box</span> <span class="dv">1</span> <span class="fu">negate</span> <span class="fu">show</span></span>
<span id="cb560-13"><a href="#cb560-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb560-14"><a href="#cb560-14" aria-hidden="true" tabindex="-1"></a><span class="ot">boxb ::</span> <span class="dt">Box</span></span>
<span id="cb560-15"><a href="#cb560-15" aria-hidden="true" tabindex="-1"></a>boxb <span class="ot">=</span> <span class="dt">Box</span> <span class="st">&quot;foo&quot;</span> <span class="fu">reverse</span> <span class="fu">show</span></span>
<span id="cb560-16"><a href="#cb560-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb560-17"><a href="#cb560-17" aria-hidden="true" tabindex="-1"></a><span class="ot">apply ::</span> <span class="dt">Box</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb560-18"><a href="#cb560-18" aria-hidden="true" tabindex="-1"></a>apply (<span class="dt">Box</span> x f p) <span class="ot">=</span> p (f x)</span>
<span id="cb560-19"><a href="#cb560-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb560-20"><a href="#cb560-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- ∃ t. Show t =&gt; t</span></span>
<span id="cb560-21"><a href="#cb560-21" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SBox</span> <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">SBox</span> a</span>
<span id="cb560-22"><a href="#cb560-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb560-23"><a href="#cb560-23" aria-hidden="true" tabindex="-1"></a><span class="ot">boxes ::</span> [<span class="dt">SBox</span>]</span>
<span id="cb560-24"><a href="#cb560-24" aria-hidden="true" tabindex="-1"></a>boxes <span class="ot">=</span> [<span class="dt">SBox</span> (), <span class="dt">SBox</span> <span class="dv">2</span>, <span class="dt">SBox</span> <span class="st">&quot;foo&quot;</span>]</span>
<span id="cb560-25"><a href="#cb560-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb560-26"><a href="#cb560-26" aria-hidden="true" tabindex="-1"></a><span class="ot">showBox ::</span> <span class="dt">SBox</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb560-27"><a href="#cb560-27" aria-hidden="true" tabindex="-1"></a>showBox (<span class="dt">SBox</span> a) <span class="ot">=</span> <span class="fu">show</span> a</span>
<span id="cb560-28"><a href="#cb560-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb560-29"><a href="#cb560-29" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb560-30"><a href="#cb560-30" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">mapM_</span> (<span class="fu">putStrLn</span> <span class="op">.</span> showBox) boxes</span>
<span id="cb560-31"><a href="#cb560-31" aria-hidden="true" tabindex="-1"></a><span class="co">-- ()</span></span>
<span id="cb560-32"><a href="#cb560-32" aria-hidden="true" tabindex="-1"></a><span class="co">-- 2</span></span>
<span id="cb560-33"><a href="#cb560-33" aria-hidden="true" tabindex="-1"></a><span class="co">-- &quot;foo&quot;</span></span></code></pre></div>
<p>The existential over <code>SBox</code> gathers a collection of values
defined purely in terms of their Show interface and an opaque pointer,
no other information is available about the values and they can’t be
accessed or unpacked in any other way.</p>
<p>Passing around existential types allows us to hide information from
consumers of data types and restrict the behavior that functions can
use. Passing records around with existential variables allows a type to
be “bundled” with a fixed set of functions that operate over its hidden
internals.</p>
<h2 id="impredicative-types">Impredicative Types</h2>
<p>Although extremely brittle, GHC also has limited support for
impredicative polymorphism which allows instantiating type variable with
a polymorphic type. Implied is that this loosens the restriction that
quantifiers must precede arrow types and now they may be placed inside
of type-constructors.</p>
<div class="sourceCode" id="cb561"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb561-1"><a href="#cb561-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Can&#39;t unify ( Int ~ Char )</span></span>
<span id="cb561-2"><a href="#cb561-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb561-3"><a href="#cb561-3" aria-hidden="true" tabindex="-1"></a><span class="ot">revUni ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Maybe</span> ([a] <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> ([<span class="dt">Int</span>], [<span class="dt">Char</span>])</span>
<span id="cb561-4"><a href="#cb561-4" aria-hidden="true" tabindex="-1"></a>revUni (<span class="dt">Just</span> g) <span class="ot">=</span> <span class="dt">Just</span> (g [<span class="dv">3</span>], g <span class="st">&quot;hello&quot;</span>)</span>
<span id="cb561-5"><a href="#cb561-5" aria-hidden="true" tabindex="-1"></a>revUni <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<div class="sourceCode" id="cb562"
data-include="src/11-quantification/impredicative.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb562-1"><a href="#cb562-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ImpredicativeTypes #-}</span></span>
<span id="cb562-2"><a href="#cb562-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb562-3"><a href="#cb562-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Uses higher-ranked polymorphism.</span></span>
<span id="cb562-4"><a href="#cb562-4" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> (<span class="kw">forall</span> a<span class="op">.</span> [a] <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Char</span>)</span>
<span id="cb562-5"><a href="#cb562-5" aria-hidden="true" tabindex="-1"></a>f get <span class="ot">=</span> (get [<span class="dv">1</span>,<span class="dv">2</span>], get [<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>, <span class="ch">&#39;c&#39;</span>])</span>
<span id="cb562-6"><a href="#cb562-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb562-7"><a href="#cb562-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Uses impredicative polymorphism.</span></span>
<span id="cb562-8"><a href="#cb562-8" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> <span class="dt">Maybe</span> (<span class="kw">forall</span> a<span class="op">.</span> [a] <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Char</span>)</span>
<span id="cb562-9"><a href="#cb562-9" aria-hidden="true" tabindex="-1"></a>g <span class="dt">Nothing</span> <span class="ot">=</span> (<span class="dv">0</span>, <span class="ch">&#39;0&#39;</span>)</span>
<span id="cb562-10"><a href="#cb562-10" aria-hidden="true" tabindex="-1"></a>g (<span class="dt">Just</span> get) <span class="ot">=</span> (get [<span class="dv">1</span>,<span class="dv">2</span>], get [<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;c&#39;</span>])</span></code></pre></div>
<p>Use of this extension is very rare, and there is some consideration
that <code>-XImpredicativeTypes</code> is fundamentally broken. Although
GHC is very liberal about telling us to enable it when one accidentally
makes a typo in a type signature!</p>
<p>Some notable trivia, the <code>($)</code> operator is wired into GHC
in a very special way as to allow impredicative instantiation of
<code>runST</code> to be applied via <code>($)</code> by special-casing
the <code>($)</code> operator only when used for the ST monad.</p>
<p>For example if we define a function <code>apply</code> which should
behave identically to <code>($)</code> we’ll get an error about
polymorphic instantiation even though they are defined identically!</p>
<div class="sourceCode" id="cb563"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb563-1"><a href="#cb563-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb563-2"><a href="#cb563-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb563-3"><a href="#cb563-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb563-4"><a href="#cb563-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb563-5"><a href="#cb563-5" aria-hidden="true" tabindex="-1"></a>f <span class="ot">`apply`</span> x <span class="ot">=</span>  f x</span>
<span id="cb563-6"><a href="#cb563-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb563-7"><a href="#cb563-7" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">ST</span> s a) <span class="ot">-&gt;</span> a</span>
<span id="cb563-8"><a href="#cb563-8" aria-hidden="true" tabindex="-1"></a>foo st <span class="ot">=</span> runST <span class="op">$</span> st</span>
<span id="cb563-9"><a href="#cb563-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb563-10"><a href="#cb563-10" aria-hidden="true" tabindex="-1"></a><span class="ot">bar ::</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">ST</span> s a) <span class="ot">-&gt;</span> a</span>
<span id="cb563-11"><a href="#cb563-11" aria-hidden="true" tabindex="-1"></a>bar st <span class="ot">=</span> runST <span class="ot">`apply`</span> st</span></code></pre></div>
<div class="sourceCode" id="cb564"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb564-1"><a href="#cb564-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Couldn&#39;t</span> match expected <span class="kw">type</span> <span class="ot">`forall s. ST s a&#39;</span></span>
<span id="cb564-2"><a href="#cb564-2" aria-hidden="true" tabindex="-1"></a><span class="ot">                with actual type `</span><span class="dt">ST</span> s0 a&#39;</span>
<span id="cb564-3"><a href="#cb564-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">In</span> the second argument <span class="kw">of</span> <span class="ot">`apply&#39;, namely `</span>st&#39;</span>
<span id="cb564-4"><a href="#cb564-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">In</span> the expression<span class="op">:</span> runST <span class="ot">`apply`</span> st</span>
<span id="cb564-5"><a href="#cb564-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">In</span> an equation for <span class="ot">`bar&#39;: bar st = runST `</span>apply<span class="ot">` st</span></span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="https://www.haskell.org/pipermail/glasgow-haskell-users/2010-November/019431.html">SPJ
Notes on $</a></li>
</ul>
<h2 id="scoped-type-variables">Scoped Type Variables</h2>
<p>Normally the type variables used within the toplevel signature for a
function are only scoped to the type-signature and not the body of the
function and its rigid signatures over terms and let/where clauses.
Enabling <code>-XScopedTypeVariables</code> loosens this restriction
allowing the type variables mentioned in the toplevel to be scoped
within the value-level body of a function and all signatures contained
therein.</p>
<div class="sourceCode" id="cb565"
data-include="src/11-quantification/scopedtvars.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb565-1"><a href="#cb565-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span></span>
<span id="cb565-2"><a href="#cb565-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb565-3"><a href="#cb565-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb565-4"><a href="#cb565-4" aria-hidden="true" tabindex="-1"></a><span class="ot">poly ::</span> <span class="kw">forall</span> a b c<span class="op">.</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> (a, a)</span>
<span id="cb565-5"><a href="#cb565-5" aria-hidden="true" tabindex="-1"></a>poly x y z <span class="ot">=</span> (f x y, f x z)</span>
<span id="cb565-6"><a href="#cb565-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb565-7"><a href="#cb565-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- second argument is universally quantified from inference</span></span>
<span id="cb565-8"><a href="#cb565-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- f :: forall t0 t1. t0 -&gt; t1 -&gt; t0</span></span>
<span id="cb565-9"><a href="#cb565-9" aria-hidden="true" tabindex="-1"></a>    f x&#39; _ <span class="ot">=</span> x&#39;</span>
<span id="cb565-10"><a href="#cb565-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb565-11"><a href="#cb565-11" aria-hidden="true" tabindex="-1"></a><span class="ot">mono ::</span> <span class="kw">forall</span> a b c<span class="op">.</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> (a, a)</span>
<span id="cb565-12"><a href="#cb565-12" aria-hidden="true" tabindex="-1"></a>mono x y z <span class="ot">=</span> (f x y, f x z)</span>
<span id="cb565-13"><a href="#cb565-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb565-14"><a href="#cb565-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- b is not implicitly universally quantified because it is in scope</span></span>
<span id="cb565-15"><a href="#cb565-15" aria-hidden="true" tabindex="-1"></a><span class="ot">    f ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb565-16"><a href="#cb565-16" aria-hidden="true" tabindex="-1"></a>    f x&#39; _ <span class="ot">=</span> x&#39;</span>
<span id="cb565-17"><a href="#cb565-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb565-18"><a href="#cb565-18" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> ()</span>
<span id="cb565-19"><a href="#cb565-19" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb565-20"><a href="#cb565-20" aria-hidden="true" tabindex="-1"></a><span class="ot">  x ::</span> [<span class="dt">Int</span>] <span class="ot">&lt;-</span> <span class="fu">readLn</span></span>
<span id="cb565-21"><a href="#cb565-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> x</span></code></pre></div>
<hr/>
<h1 id="gadts">GADTs</h1>
<p><em>Generalized Algebraic Data types</em> (GADTs) are an extension to
algebraic datatypes that allow us to qualify the constructors to
datatypes with type equality constraints, allowing a class of types that
are not expressible using vanilla ADTs.</p>
<p><code>-XGADTs</code> implicitly enables an alternative syntax for
datatype declarations ( <code>-XGADTSyntax</code> ) such that the
following declarations are equivalent:</p>
<div class="sourceCode" id="cb566"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb566-1"><a href="#cb566-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Vanilla</span></span>
<span id="cb566-2"><a href="#cb566-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a</span>
<span id="cb566-3"><a href="#cb566-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb566-4"><a href="#cb566-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span>
<span id="cb566-5"><a href="#cb566-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb566-6"><a href="#cb566-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- GADTSyntax</span></span>
<span id="cb566-7"><a href="#cb566-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="kw">where</span></span>
<span id="cb566-8"><a href="#cb566-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Empty</span><span class="ot"> ::</span> <span class="dt">List</span> a</span>
<span id="cb566-9"><a href="#cb566-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> a</span></code></pre></div>
<p>For an example use consider the data type <code>Term</code>, we have
a term in which we <code>Succ</code> which takes a <code>Term</code>
parameterized by <code>a</code> which spans all types. Problems arise
between the clash whether (<code>a ~ Bool</code>) or
(<code>a ~ Int</code>) when trying to write the evaluator.</p>
<div class="sourceCode" id="cb567"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb567-1"><a href="#cb567-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> a</span>
<span id="cb567-2"><a href="#cb567-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Lit</span> a</span>
<span id="cb567-3"><a href="#cb567-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Succ</span> (<span class="dt">Term</span> a)</span>
<span id="cb567-4"><a href="#cb567-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">IsZero</span> (<span class="dt">Term</span> a)</span>
<span id="cb567-5"><a href="#cb567-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb567-6"><a href="#cb567-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- can&#39;t be well-typed :(</span></span>
<span id="cb567-7"><a href="#cb567-7" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Lit</span> i)      <span class="ot">=</span> i</span>
<span id="cb567-8"><a href="#cb567-8" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Succ</span> t)     <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> eval t</span>
<span id="cb567-9"><a href="#cb567-9" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">IsZero</span> i)   <span class="ot">=</span> eval i <span class="op">==</span> <span class="dv">0</span></span></code></pre></div>
<p>And we admit the construction of meaningless terms which forces more
error handling cases.</p>
<div class="sourceCode" id="cb568"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb568-1"><a href="#cb568-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- This is a valid type.</span></span>
<span id="cb568-2"><a href="#cb568-2" aria-hidden="true" tabindex="-1"></a>failure <span class="ot">=</span> <span class="dt">Succ</span> ( <span class="dt">Lit</span> <span class="dt">True</span> )</span></code></pre></div>
<p>Using a GADT we can express the type invariants for our language
(i.e. only type-safe expressions are representable). Pattern matching on
this GADT then carries type equality constraints without the need for
explicit tags.</p>
<div class="sourceCode" id="cb569"
data-include="src/12-gadts/gadt.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb569-1"><a href="#cb569-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# Language GADTs #-}</span></span>
<span id="cb569-2"><a href="#cb569-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb569-3"><a href="#cb569-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span> a <span class="kw">where</span></span>
<span id="cb569-4"><a href="#cb569-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lit</span><span class="ot">    ::</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb569-5"><a href="#cb569-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Succ</span><span class="ot">   ::</span> <span class="dt">Term</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Int</span></span>
<span id="cb569-6"><a href="#cb569-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IsZero</span><span class="ot"> ::</span> <span class="dt">Term</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Bool</span></span>
<span id="cb569-7"><a href="#cb569-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">If</span><span class="ot">     ::</span> <span class="dt">Term</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb569-8"><a href="#cb569-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb569-9"><a href="#cb569-9" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb569-10"><a href="#cb569-10" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Lit</span> i)      <span class="ot">=</span> i                                   <span class="co">-- Term a</span></span>
<span id="cb569-11"><a href="#cb569-11" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Succ</span> t)     <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> eval t                          <span class="co">-- Term (a ~ Int)</span></span>
<span id="cb569-12"><a href="#cb569-12" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">IsZero</span> i)   <span class="ot">=</span> eval i <span class="op">==</span> <span class="dv">0</span>                         <span class="co">-- Term (a ~ Int)</span></span>
<span id="cb569-13"><a href="#cb569-13" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">If</span> b e1 e2) <span class="ot">=</span> <span class="kw">if</span> eval b <span class="kw">then</span> eval e1 <span class="kw">else</span> eval e2 <span class="co">-- Term (a ~ Bool)</span></span>
<span id="cb569-14"><a href="#cb569-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb569-15"><a href="#cb569-15" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">Int</span></span>
<span id="cb569-16"><a href="#cb569-16" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> eval (<span class="dt">Succ</span> (<span class="dt">Succ</span> (<span class="dt">Lit</span> <span class="dv">3</span>)))</span></code></pre></div>
<p>This time around:</p>
<div class="sourceCode" id="cb570"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb570-1"><a href="#cb570-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- This is rejected at compile-time.</span></span>
<span id="cb570-2"><a href="#cb570-2" aria-hidden="true" tabindex="-1"></a>failure <span class="ot">=</span> <span class="dt">Succ</span> ( <span class="dt">Lit</span> <span class="dt">True</span> )</span></code></pre></div>
<p>Explicit equality constraints (<code>a ~ b</code>) can be added to a
function’s context. For example the following expand out to the same
types.</p>
<div class="sourceCode" id="cb571"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb571-1"><a href="#cb571-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (a, a)</span>
<span id="cb571-2"><a href="#cb571-2" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> (a <span class="op">~</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> (a,b)</span></code></pre></div>
<div class="sourceCode" id="cb572"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb572-1"><a href="#cb572-1" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Int</span> <span class="op">~</span> <span class="dt">Int</span>)  <span class="ot">=&gt;</span> <span class="op">...</span></span>
<span id="cb572-2"><a href="#cb572-2" aria-hidden="true" tabindex="-1"></a>(a <span class="op">~</span> <span class="dt">Int</span>)    <span class="ot">=&gt;</span> <span class="op">...</span></span>
<span id="cb572-3"><a href="#cb572-3" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Int</span> <span class="op">~</span> a)    <span class="ot">=&gt;</span> <span class="op">...</span></span>
<span id="cb572-4"><a href="#cb572-4" aria-hidden="true" tabindex="-1"></a>(a <span class="op">~</span> b)      <span class="ot">=&gt;</span> <span class="op">...</span></span>
<span id="cb572-5"><a href="#cb572-5" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Int</span> <span class="op">~</span> <span class="dt">Bool</span>) <span class="ot">=&gt;</span> <span class="op">...</span> <span class="co">-- Will not typecheck.</span></span></code></pre></div>
<p>This is effectively the implementation detail of what GHC is doing
behind the scenes to implement GADTs ( implicitly passing and threading
equality terms around ). If we wanted we could do the same setup that
GHC does just using equality constraints and existential quantification.
Indeed, the internal representation of GADTs is as regular algebraic
datatypes that carry coercion evidence as arguments.</p>
<div class="sourceCode" id="cb573"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb573-1"><a href="#cb573-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb573-2"><a href="#cb573-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExistentialQuantification #-}</span></span>
<span id="cb573-3"><a href="#cb573-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb573-4"><a href="#cb573-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Using Constraints</span></span>
<span id="cb573-5"><a href="#cb573-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Exp</span> a</span>
<span id="cb573-6"><a href="#cb573-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> (a <span class="op">~</span> <span class="dt">Int</span>) <span class="ot">=&gt;</span> <span class="dt">LitInt</span> a</span>
<span id="cb573-7"><a href="#cb573-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> (a <span class="op">~</span> <span class="dt">Bool</span>) <span class="ot">=&gt;</span> <span class="dt">LitBool</span> a</span>
<span id="cb573-8"><a href="#cb573-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="kw">forall</span> b<span class="op">.</span> (b <span class="op">~</span> <span class="dt">Bool</span>) <span class="ot">=&gt;</span> <span class="dt">If</span> (<span class="dt">Exp</span> b) (<span class="dt">Exp</span> a) (<span class="dt">Exp</span> a)</span>
<span id="cb573-9"><a href="#cb573-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb573-10"><a href="#cb573-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- Using GADTs</span></span>
<span id="cb573-11"><a href="#cb573-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- data Exp a where</span></span>
<span id="cb573-12"><a href="#cb573-12" aria-hidden="true" tabindex="-1"></a><span class="co">--   LitInt  :: Int  -&gt; Exp Int</span></span>
<span id="cb573-13"><a href="#cb573-13" aria-hidden="true" tabindex="-1"></a><span class="co">--   LitBool :: Bool -&gt; Exp Bool</span></span>
<span id="cb573-14"><a href="#cb573-14" aria-hidden="true" tabindex="-1"></a><span class="co">--   If      :: Exp Bool -&gt; Exp a -&gt; Exp a -&gt; Exp a</span></span>
<span id="cb573-15"><a href="#cb573-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb573-16"><a href="#cb573-16" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Exp</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb573-17"><a href="#cb573-17" aria-hidden="true" tabindex="-1"></a>eval e <span class="ot">=</span> <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb573-18"><a href="#cb573-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LitInt</span> i   <span class="ot">-&gt;</span> i</span>
<span id="cb573-19"><a href="#cb573-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">LitBool</span> b  <span class="ot">-&gt;</span> b</span>
<span id="cb573-20"><a href="#cb573-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">If</span> b tr fl <span class="ot">-&gt;</span> <span class="kw">if</span> eval b <span class="kw">then</span> eval tr <span class="kw">else</span> eval fl</span></code></pre></div>
<p>In the presence of GADTs inference becomes intractable in many cases,
often requiring an explicit annotation. For example <code>f</code> can
either have <code>T a -&gt; [a]</code> or <code>T a -&gt; [Int]</code>
and neither is principal.</p>
<div class="sourceCode" id="cb574"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb574-1"><a href="#cb574-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb574-2"><a href="#cb574-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">T1</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">T</span> <span class="dt">Int</span></span>
<span id="cb574-3"><a href="#cb574-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">T2</span><span class="ot"> ::</span> <span class="dt">T</span> a</span>
<span id="cb574-4"><a href="#cb574-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb574-5"><a href="#cb574-5" aria-hidden="true" tabindex="-1"></a>f (<span class="dt">T1</span> n) <span class="ot">=</span> [n]</span>
<span id="cb574-6"><a href="#cb574-6" aria-hidden="true" tabindex="-1"></a>f <span class="dt">T2</span>     <span class="ot">=</span> []</span></code></pre></div>
<h2 id="kind-signatures">Kind Signatures</h2>
<p>Haskell’s kind system (i.e. the “type of the types”) is a system
consisting the single kind <code>*</code> and an arrow kind
<code>-&gt;</code>.</p>
<div class="sourceCode" id="cb575"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb575-1"><a href="#cb575-1" aria-hidden="true" tabindex="-1"></a>κ <span class="op">:</span> <span class="op">*</span></span>
<span id="cb575-2"><a href="#cb575-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> κ <span class="ot">-&gt;</span> κ</span></code></pre></div>
<div class="sourceCode" id="cb576"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb576-1"><a href="#cb576-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Int</span><span class="ot"> ::</span> <span class="op">*</span></span>
<span id="cb576-2"><a href="#cb576-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Maybe</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb576-3"><a href="#cb576-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Either</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span></code></pre></div>
<p>There are in fact some extensions to this system that will be covered
later ( see: PolyKinds and Unboxed types in later sections ) but most
kinds in everyday code are simply either stars or arrows.</p>
<p>With the KindSignatures extension enabled we can now annotate top
level type signatures with their explicit kinds, bypassing the normal
kind inference procedures.</p>
<div class="sourceCode" id="cb577"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb577-1"><a href="#cb577-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb577-2"><a href="#cb577-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb577-3"><a href="#cb577-3" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> <span class="kw">forall</span> (<span class="ot">a ::</span> <span class="op">*</span>)<span class="op">.</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb577-4"><a href="#cb577-4" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<p>On top of default GADT declaration we can also constrain the
parameters of the GADT to specific kinds. For basic usage Haskell’s kind
inference can deduce this reasonably well, but combined with some other
type system extensions that extend the kind system this becomes
essential.</p>
<div class="sourceCode" id="cb578"
data-include="src/12-gadts/kindsignatures.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb578-1"><a href="#cb578-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# Language GADTs #-}</span></span>
<span id="cb578-2"><a href="#cb578-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb578-3"><a href="#cb578-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb578-4"><a href="#cb578-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Term</span><span class="ot"> a ::</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb578-5"><a href="#cb578-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lit</span><span class="ot">    ::</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb578-6"><a href="#cb578-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Succ</span><span class="ot">   ::</span> <span class="dt">Term</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Int</span></span>
<span id="cb578-7"><a href="#cb578-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">IsZero</span><span class="ot"> ::</span> <span class="dt">Term</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> <span class="dt">Bool</span></span>
<span id="cb578-8"><a href="#cb578-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">If</span><span class="ot">     ::</span> <span class="dt">Term</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a <span class="ot">-&gt;</span> <span class="dt">Term</span> a</span>
<span id="cb578-9"><a href="#cb578-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb578-10"><a href="#cb578-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb578-11"><a href="#cb578-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Vec</span> n a</span>
<span id="cb578-12"><a href="#cb578-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</span>
<span id="cb578-13"><a href="#cb578-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb578-14"><a href="#cb578-14" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fix</span><span class="ot"> ::</span> (<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb578-15"><a href="#cb578-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">In</span><span class="ot"> ::</span> f (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span></code></pre></div>
<h2 id="void">Void</h2>
<p>The Void type is the type with no inhabitants. It unifies only with
itself.</p>
<p>Using a newtype wrapper we can create a type where recursion makes it
impossible to construct an inhabitant.</p>
<div class="sourceCode" id="cb579"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb579-1"><a href="#cb579-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Void :: Void -&gt; Void</span></span>
<span id="cb579-2"><a href="#cb579-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Void</span> <span class="ot">=</span> <span class="dt">Void</span> <span class="dt">Void</span></span></code></pre></div>
<p>Or using <code>-XEmptyDataDecls</code> we can also construct the
uninhabited type equivalently as a data declaration with no
constructors.</p>
<div class="sourceCode" id="cb580"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb580-1"><a href="#cb580-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Void</span></span></code></pre></div>
<p>The only inhabitant of both of these types is a diverging term like
(<code>undefined</code>).</p>
<h2 id="phantom-types">Phantom Types</h2>
<p>Phantom types are parameters that appear on the left hand side of a
type declaration but which are not constrained by the values of the
types inhabitants. They are effectively slots for us to encode
additional information at the type-level.</p>
<div class="sourceCode" id="cb581"
data-include="src/12-gadts/phantom.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb581-1"><a href="#cb581-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Void</span></span>
<span id="cb581-2"><a href="#cb581-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb581-3"><a href="#cb581-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Foo</span> tag a <span class="ot">=</span> <span class="dt">Foo</span> a</span>
<span id="cb581-4"><a href="#cb581-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb581-5"><a href="#cb581-5" aria-hidden="true" tabindex="-1"></a><span class="ot">combine ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Foo</span> tag a <span class="ot">-&gt;</span> <span class="dt">Foo</span> tag a <span class="ot">-&gt;</span> <span class="dt">Foo</span> tag a</span>
<span id="cb581-6"><a href="#cb581-6" aria-hidden="true" tabindex="-1"></a>combine (<span class="dt">Foo</span> a) (<span class="dt">Foo</span> b) <span class="ot">=</span> <span class="dt">Foo</span> (a<span class="op">+</span>b)</span>
<span id="cb581-7"><a href="#cb581-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb581-8"><a href="#cb581-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- All identical at the value level, but differ at the type level.</span></span>
<span id="cb581-9"><a href="#cb581-9" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Foo</span> () <span class="dt">Int</span></span>
<span id="cb581-10"><a href="#cb581-10" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dt">Foo</span> <span class="dv">1</span></span>
<span id="cb581-11"><a href="#cb581-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb581-12"><a href="#cb581-12" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">Foo</span> t <span class="dt">Int</span></span>
<span id="cb581-13"><a href="#cb581-13" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="dt">Foo</span> <span class="dv">1</span></span>
<span id="cb581-14"><a href="#cb581-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb581-15"><a href="#cb581-15" aria-hidden="true" tabindex="-1"></a><span class="ot">c ::</span> <span class="dt">Foo</span> <span class="dt">Void</span> <span class="dt">Int</span></span>
<span id="cb581-16"><a href="#cb581-16" aria-hidden="true" tabindex="-1"></a>c <span class="ot">=</span> <span class="dt">Foo</span> <span class="dv">1</span></span>
<span id="cb581-17"><a href="#cb581-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb581-18"><a href="#cb581-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- () ~ ()</span></span>
<span id="cb581-19"><a href="#cb581-19" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Foo</span> () <span class="dt">Int</span></span>
<span id="cb581-20"><a href="#cb581-20" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> combine a a</span>
<span id="cb581-21"><a href="#cb581-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb581-22"><a href="#cb581-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- t ~ ()</span></span>
<span id="cb581-23"><a href="#cb581-23" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Foo</span> () <span class="dt">Int</span></span>
<span id="cb581-24"><a href="#cb581-24" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> combine a b</span>
<span id="cb581-25"><a href="#cb581-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb581-26"><a href="#cb581-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- t0 ~ t1</span></span>
<span id="cb581-27"><a href="#cb581-27" aria-hidden="true" tabindex="-1"></a><span class="ot">example3 ::</span> <span class="dt">Foo</span> t <span class="dt">Int</span></span>
<span id="cb581-28"><a href="#cb581-28" aria-hidden="true" tabindex="-1"></a>example3 <span class="ot">=</span> combine b b</span>
<span id="cb581-29"><a href="#cb581-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb581-30"><a href="#cb581-30" aria-hidden="true" tabindex="-1"></a><span class="co">-- Couldn&#39;t match type `t&#39; with `Void&#39;</span></span>
<span id="cb581-31"><a href="#cb581-31" aria-hidden="true" tabindex="-1"></a><span class="ot">example4 ::</span> <span class="dt">Foo</span> t <span class="dt">Int</span></span>
<span id="cb581-32"><a href="#cb581-32" aria-hidden="true" tabindex="-1"></a>example4 <span class="ot">=</span> combine b c</span></code></pre></div>
<p>Notice the type variable <code>tag</code> does not appear in the
right hand side of the declaration. Using this allows us to express
invariants at the type-level that need not manifest at the value-level.
We’re effectively programming by adding extra information at the
type-level.</p>
<p>Consider the case of using newtypes to statically distinguish between
plaintext and cryptotext.</p>
<div class="sourceCode" id="cb582"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb582-1"><a href="#cb582-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Plaintext</span> <span class="ot">=</span> <span class="dt">Plaintext</span> <span class="dt">Text</span></span>
<span id="cb582-2"><a href="#cb582-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Cryptotext</span> <span class="ot">=</span> <span class="dt">Cryptotext</span> <span class="dt">Text</span></span>
<span id="cb582-3"><a href="#cb582-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb582-4"><a href="#cb582-4" aria-hidden="true" tabindex="-1"></a><span class="ot">encrypt ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Plaintext</span> <span class="ot">-&gt;</span> <span class="dt">Cryptotext</span></span>
<span id="cb582-5"><a href="#cb582-5" aria-hidden="true" tabindex="-1"></a><span class="ot">decrypt ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Cryptotext</span> <span class="ot">-&gt;</span> <span class="dt">Plaintext</span></span></code></pre></div>
<p>Using phantom types we use an extra parameter.</p>
<div class="sourceCode" id="cb583"
data-include="src/12-gadts/phantom_example.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb583-1"><a href="#cb583-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span></span>
<span id="cb583-2"><a href="#cb583-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb583-3"><a href="#cb583-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Cryptotext</span></span>
<span id="cb583-4"><a href="#cb583-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Plaintext</span></span>
<span id="cb583-5"><a href="#cb583-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb583-6"><a href="#cb583-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Msg</span> a <span class="ot">=</span> <span class="dt">Msg</span> <span class="dt">Text</span></span>
<span id="cb583-7"><a href="#cb583-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb583-8"><a href="#cb583-8" aria-hidden="true" tabindex="-1"></a><span class="ot">encrypt ::</span> <span class="dt">Msg</span> <span class="dt">Plaintext</span> <span class="ot">-&gt;</span> <span class="dt">Msg</span> <span class="dt">Cryptotext</span></span>
<span id="cb583-9"><a href="#cb583-9" aria-hidden="true" tabindex="-1"></a>encrypt <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb583-10"><a href="#cb583-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb583-11"><a href="#cb583-11" aria-hidden="true" tabindex="-1"></a><span class="ot">decrypt ::</span> <span class="dt">Msg</span> <span class="dt">Cryptotext</span> <span class="ot">-&gt;</span> <span class="dt">Msg</span> <span class="dt">Plaintext</span></span>
<span id="cb583-12"><a href="#cb583-12" aria-hidden="true" tabindex="-1"></a>decrypt <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<p>Using <code>-XEmptyDataDecls</code> can be a powerful combination
with phantom types that contain no value inhabitants and are “anonymous
types”.</p>
<div class="sourceCode" id="cb584"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb584-1"><a href="#cb584-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE EmptyDataDecls #-}</span></span>
<span id="cb584-2"><a href="#cb584-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb584-3"><a href="#cb584-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Token</span> a</span></code></pre></div>
<p>The <a href="http://hackage.haskell.org/package/tagged">tagged</a>
library defines a similar <code>Tagged</code> newtype wrapper.</p>
<h2 id="typelevel-operations">Typelevel Operations</h2>
<p>With a richer language for datatypes we can express terms that
witness the relationship between terms in the constructors, for example
we can now express a term which expresses propositional equality between
two types.</p>
<p>The type <code>Eql a b</code> is a proof that types <code>a</code>
and <code>b</code> are equal, by pattern matching on the single
<code>Refl</code> constructor we introduce the equality constraint into
the body of the pattern match.</p>
<div class="sourceCode" id="cb585"
data-include="src/12-gadts/equal.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb585-1"><a href="#cb585-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb585-2"><a href="#cb585-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span></span>
<span id="cb585-3"><a href="#cb585-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb585-4"><a href="#cb585-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- a ≡ b</span></span>
<span id="cb585-5"><a href="#cb585-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Eql</span> a b <span class="kw">where</span></span>
<span id="cb585-6"><a href="#cb585-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Refl</span><span class="ot"> ::</span> <span class="dt">Eql</span> a a</span>
<span id="cb585-7"><a href="#cb585-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb585-8"><a href="#cb585-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Congruence</span></span>
<span id="cb585-9"><a href="#cb585-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- (f : A → B) {x y} → x ≡ y → f x ≡ f y</span></span>
<span id="cb585-10"><a href="#cb585-10" aria-hidden="true" tabindex="-1"></a><span class="ot">cong ::</span> <span class="dt">Eql</span> a b <span class="ot">-&gt;</span> <span class="dt">Eql</span> (f a) (f b)</span>
<span id="cb585-11"><a href="#cb585-11" aria-hidden="true" tabindex="-1"></a>cong <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb585-12"><a href="#cb585-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb585-13"><a href="#cb585-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Symmetry</span></span>
<span id="cb585-14"><a href="#cb585-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- {a b : A} → a ≡ b → a ≡ b</span></span>
<span id="cb585-15"><a href="#cb585-15" aria-hidden="true" tabindex="-1"></a><span class="ot">sym ::</span> <span class="dt">Eql</span> a b <span class="ot">-&gt;</span> <span class="dt">Eql</span> b a</span>
<span id="cb585-16"><a href="#cb585-16" aria-hidden="true" tabindex="-1"></a>sym <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb585-17"><a href="#cb585-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb585-18"><a href="#cb585-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- Transitivity</span></span>
<span id="cb585-19"><a href="#cb585-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- {a b c : A} → a ≡ b → b ≡ c → a ≡ c</span></span>
<span id="cb585-20"><a href="#cb585-20" aria-hidden="true" tabindex="-1"></a><span class="ot">trans ::</span> <span class="dt">Eql</span> a b <span class="ot">-&gt;</span> <span class="dt">Eql</span> b c <span class="ot">-&gt;</span> <span class="dt">Eql</span> a c</span>
<span id="cb585-21"><a href="#cb585-21" aria-hidden="true" tabindex="-1"></a>trans <span class="dt">Refl</span> <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb585-22"><a href="#cb585-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb585-23"><a href="#cb585-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- Coerce one type to another given a proof of their equality.</span></span>
<span id="cb585-24"><a href="#cb585-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- {a b : A} → a ≡ b → a → b</span></span>
<span id="cb585-25"><a href="#cb585-25" aria-hidden="true" tabindex="-1"></a><span class="ot">castWith ::</span> <span class="dt">Eql</span> a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb585-26"><a href="#cb585-26" aria-hidden="true" tabindex="-1"></a>castWith <span class="dt">Refl</span> <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb585-27"><a href="#cb585-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb585-28"><a href="#cb585-28" aria-hidden="true" tabindex="-1"></a><span class="co">-- Trivial cases</span></span>
<span id="cb585-29"><a href="#cb585-29" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="kw">forall</span> n<span class="op">.</span> <span class="dt">Eql</span> n n</span>
<span id="cb585-30"><a href="#cb585-30" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb585-31"><a href="#cb585-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb585-32"><a href="#cb585-32" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="kw">forall</span><span class="op">.</span> <span class="dt">Eql</span> () ()</span>
<span id="cb585-33"><a href="#cb585-33" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="dt">Refl</span></span></code></pre></div>
<p>As of GHC 7.8 these constructors and functions are included in the
Prelude in the <a
href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Type-Equality.html">Data.Type.Equality</a>
module.</p>
</hr>
<h1 id="interpreters">Interpreters</h1>
<p>The lambda calculus forms the theoretical and practical foundation
for many languages. At the heart of every calculus is three
components:</p>
<ul>
<li><strong>Var</strong> - A variable</li>
<li><strong>Lam</strong> - A lambda abstraction</li>
<li><strong>App</strong> - An application</li>
</ul>
<div class="center">
<p><img src="img/lambda.png" /></p>
</div>
<p>There are many different ways of modeling these constructions and
data structure representations, but they all more or less contain these
three elements. For example, a lambda calculus that uses String names on
lambda binders and variables might be written like the following:</p>
<div class="sourceCode" id="cb586"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb586-1"><a href="#cb586-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb586-2"><a href="#cb586-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb586-3"><a href="#cb586-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Exp</span></span>
<span id="cb586-4"><a href="#cb586-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Name</span></span>
<span id="cb586-5"><a href="#cb586-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Name</span> <span class="dt">Exp</span></span>
<span id="cb586-6"><a href="#cb586-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Exp</span> <span class="dt">Exp</span></span></code></pre></div>
<p>A lambda expression in which all variables that appear in the body of
the expression are referenced in an outer lambda binder is said to be
<em>closed</em> while an expression with unbound free variables is
<em>open</em>.</p>
<h2 id="hoas">HOAS</h2>
<p>Higher Order Abstract Syntax (<em>HOAS</em>) is a technique for
implementing the lambda calculus in a language where the binders of the
lambda expression map directly onto lambda binders of the host language
( i.e. Haskell ) to give us substitution machinery in our custom
language by exploiting Haskell’s implementation.</p>
<div class="sourceCode" id="cb587"
data-include="src/13-lambda-calculus/hoas.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb587-1"><a href="#cb587-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb587-2"><a href="#cb587-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb587-3"><a href="#cb587-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> a <span class="kw">where</span></span>
<span id="cb587-4"><a href="#cb587-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Con</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</span>
<span id="cb587-5"><a href="#cb587-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lam</span><span class="ot"> ::</span> (<span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> b) <span class="ot">-&gt;</span> <span class="dt">Expr</span> (a <span class="ot">-&gt;</span> b)</span>
<span id="cb587-6"><a href="#cb587-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">App</span><span class="ot"> ::</span> <span class="dt">Expr</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> b</span>
<span id="cb587-7"><a href="#cb587-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb587-8"><a href="#cb587-8" aria-hidden="true" tabindex="-1"></a><span class="ot">i ::</span> <span class="dt">Expr</span> (a <span class="ot">-&gt;</span> a)</span>
<span id="cb587-9"><a href="#cb587-9" aria-hidden="true" tabindex="-1"></a>i <span class="ot">=</span> <span class="dt">Lam</span> (\x <span class="ot">-&gt;</span> x)</span>
<span id="cb587-10"><a href="#cb587-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb587-11"><a href="#cb587-11" aria-hidden="true" tabindex="-1"></a><span class="ot">k ::</span> <span class="dt">Expr</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a)</span>
<span id="cb587-12"><a href="#cb587-12" aria-hidden="true" tabindex="-1"></a>k <span class="ot">=</span> <span class="dt">Lam</span> (\x <span class="ot">-&gt;</span> <span class="dt">Lam</span> (\y <span class="ot">-&gt;</span> x))</span>
<span id="cb587-13"><a href="#cb587-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb587-14"><a href="#cb587-14" aria-hidden="true" tabindex="-1"></a><span class="ot">s ::</span> <span class="dt">Expr</span> ((a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c))</span>
<span id="cb587-15"><a href="#cb587-15" aria-hidden="true" tabindex="-1"></a>s <span class="ot">=</span> <span class="dt">Lam</span> (\x <span class="ot">-&gt;</span> <span class="dt">Lam</span> (\y <span class="ot">-&gt;</span> <span class="dt">Lam</span> (\z <span class="ot">-&gt;</span> <span class="dt">App</span> (<span class="dt">App</span> x z) (<span class="dt">App</span> y z))))</span>
<span id="cb587-16"><a href="#cb587-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb587-17"><a href="#cb587-17" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb587-18"><a href="#cb587-18" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Con</span> v) <span class="ot">=</span> v</span>
<span id="cb587-19"><a href="#cb587-19" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">Lam</span> f) <span class="ot">=</span> \x <span class="ot">-&gt;</span> eval (f (<span class="dt">Con</span> x))</span>
<span id="cb587-20"><a href="#cb587-20" aria-hidden="true" tabindex="-1"></a>eval (<span class="dt">App</span> e1 e2) <span class="ot">=</span> (eval e1) (eval e2)</span>
<span id="cb587-21"><a href="#cb587-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb587-22"><a href="#cb587-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb587-23"><a href="#cb587-23" aria-hidden="true" tabindex="-1"></a><span class="ot">skk ::</span> <span class="dt">Expr</span> (a <span class="ot">-&gt;</span> a)</span>
<span id="cb587-24"><a href="#cb587-24" aria-hidden="true" tabindex="-1"></a>skk <span class="ot">=</span> <span class="dt">App</span> (<span class="dt">App</span> s k) k</span>
<span id="cb587-25"><a href="#cb587-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb587-26"><a href="#cb587-26" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">Integer</span></span>
<span id="cb587-27"><a href="#cb587-27" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> eval skk <span class="dv">1</span></span>
<span id="cb587-28"><a href="#cb587-28" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1</span></span></code></pre></div>
<p>Pretty printing HOAS terms can also be quite complicated since the
body of the function is under a Haskell lambda binder.</p>
<h2 id="phoas">PHOAS</h2>
<p>A slightly different form of HOAS called PHOAS uses lambda datatype
parameterized over the binder type. In this form evaluation requires
unpacking into a separate Value type to wrap the lambda expression.</p>
<div class="sourceCode" id="cb588"
data-include="src/13-lambda-calculus/phoas.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb588-1"><a href="#cb588-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb588-2"><a href="#cb588-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb588-3"><a href="#cb588-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ExprP</span> a</span>
<span id="cb588-4"><a href="#cb588-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">VarP</span> a</span>
<span id="cb588-5"><a href="#cb588-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">AppP</span> (<span class="dt">ExprP</span> a) (<span class="dt">ExprP</span> a)</span>
<span id="cb588-6"><a href="#cb588-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">LamP</span> (a <span class="ot">-&gt;</span> <span class="dt">ExprP</span> a)</span>
<span id="cb588-7"><a href="#cb588-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">LitP</span> <span class="dt">Integer</span></span>
<span id="cb588-8"><a href="#cb588-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb588-9"><a href="#cb588-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Value</span></span>
<span id="cb588-10"><a href="#cb588-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">VLit</span> <span class="dt">Integer</span></span>
<span id="cb588-11"><a href="#cb588-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">VFun</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>)</span>
<span id="cb588-12"><a href="#cb588-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb588-13"><a href="#cb588-13" aria-hidden="true" tabindex="-1"></a><span class="ot">fromVFun ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> (<span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Value</span>)</span>
<span id="cb588-14"><a href="#cb588-14" aria-hidden="true" tabindex="-1"></a>fromVFun val <span class="ot">=</span> <span class="kw">case</span> val <span class="kw">of</span></span>
<span id="cb588-15"><a href="#cb588-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">VFun</span> f <span class="ot">-&gt;</span> f</span>
<span id="cb588-16"><a href="#cb588-16" aria-hidden="true" tabindex="-1"></a>  _      <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;not a function&quot;</span></span>
<span id="cb588-17"><a href="#cb588-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb588-18"><a href="#cb588-18" aria-hidden="true" tabindex="-1"></a><span class="ot">fromVLit ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb588-19"><a href="#cb588-19" aria-hidden="true" tabindex="-1"></a>fromVLit val <span class="ot">=</span> <span class="kw">case</span> val <span class="kw">of</span></span>
<span id="cb588-20"><a href="#cb588-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">VLit</span> n <span class="ot">-&gt;</span> n</span>
<span id="cb588-21"><a href="#cb588-21" aria-hidden="true" tabindex="-1"></a>  _      <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;not an integer&quot;</span></span>
<span id="cb588-22"><a href="#cb588-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb588-23"><a href="#cb588-23" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Expr</span> {<span class="ot"> unExpr ::</span> <span class="kw">forall</span> a <span class="op">.</span> <span class="dt">ExprP</span> a }</span>
<span id="cb588-24"><a href="#cb588-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb588-25"><a href="#cb588-25" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Value</span></span>
<span id="cb588-26"><a href="#cb588-26" aria-hidden="true" tabindex="-1"></a>eval e <span class="ot">=</span> ev (unExpr e) <span class="kw">where</span></span>
<span id="cb588-27"><a href="#cb588-27" aria-hidden="true" tabindex="-1"></a>  ev (<span class="dt">LamP</span> f)      <span class="ot">=</span> <span class="dt">VFun</span>(ev <span class="op">.</span> f)</span>
<span id="cb588-28"><a href="#cb588-28" aria-hidden="true" tabindex="-1"></a>  ev (<span class="dt">VarP</span> v)      <span class="ot">=</span> v</span>
<span id="cb588-29"><a href="#cb588-29" aria-hidden="true" tabindex="-1"></a>  ev (<span class="dt">AppP</span> e1 e2)  <span class="ot">=</span> fromVFun (ev e1) (ev e2)</span>
<span id="cb588-30"><a href="#cb588-30" aria-hidden="true" tabindex="-1"></a>  ev (<span class="dt">LitP</span> n)      <span class="ot">=</span> <span class="dt">VLit</span> n</span>
<span id="cb588-31"><a href="#cb588-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb588-32"><a href="#cb588-32" aria-hidden="true" tabindex="-1"></a><span class="ot">i ::</span> <span class="dt">ExprP</span> a</span>
<span id="cb588-33"><a href="#cb588-33" aria-hidden="true" tabindex="-1"></a>i <span class="ot">=</span> <span class="dt">LamP</span> (\a <span class="ot">-&gt;</span> <span class="dt">VarP</span> a)</span>
<span id="cb588-34"><a href="#cb588-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb588-35"><a href="#cb588-35" aria-hidden="true" tabindex="-1"></a><span class="ot">k ::</span> <span class="dt">ExprP</span> a</span>
<span id="cb588-36"><a href="#cb588-36" aria-hidden="true" tabindex="-1"></a>k <span class="ot">=</span> <span class="dt">LamP</span> (\x <span class="ot">-&gt;</span> <span class="dt">LamP</span> (\y <span class="ot">-&gt;</span> <span class="dt">VarP</span> x))</span>
<span id="cb588-37"><a href="#cb588-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb588-38"><a href="#cb588-38" aria-hidden="true" tabindex="-1"></a><span class="ot">s ::</span> <span class="dt">ExprP</span> a</span>
<span id="cb588-39"><a href="#cb588-39" aria-hidden="true" tabindex="-1"></a>s <span class="ot">=</span> <span class="dt">LamP</span> (\x <span class="ot">-&gt;</span> <span class="dt">LamP</span> (\y <span class="ot">-&gt;</span> <span class="dt">LamP</span> (\z <span class="ot">-&gt;</span> <span class="dt">AppP</span> (<span class="dt">AppP</span> (<span class="dt">VarP</span> x) (<span class="dt">VarP</span> z)) (<span class="dt">AppP</span> (<span class="dt">VarP</span> y) (<span class="dt">VarP</span> z)))))</span>
<span id="cb588-40"><a href="#cb588-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb588-41"><a href="#cb588-41" aria-hidden="true" tabindex="-1"></a><span class="ot">skk ::</span> <span class="dt">ExprP</span> a</span>
<span id="cb588-42"><a href="#cb588-42" aria-hidden="true" tabindex="-1"></a>skk <span class="ot">=</span> <span class="dt">AppP</span> (<span class="dt">AppP</span> s k) k</span>
<span id="cb588-43"><a href="#cb588-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb588-44"><a href="#cb588-44" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">Integer</span></span>
<span id="cb588-45"><a href="#cb588-45" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> fromVLit <span class="op">$</span> eval <span class="op">$</span> <span class="dt">Expr</span> (<span class="dt">AppP</span> skk (<span class="dt">LitP</span> <span class="dv">3</span>))</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="http://adam.chlipala.net/papers/PhoasICFP08/PhoasICFP08Talk.pdf">PHOAS</a></li>
<li><a
href="http://www.seas.upenn.edu/~sweirich/papers/itabox/icfp-published-version.pdf">Encoding
Higher-Order Abstract Syntax with Parametric Polymorphism</a></li>
</ul>
<h2 id="final-interpreters">Final Interpreters</h2>
<p>Using typeclasses we can implement a <em>final interpreter</em> which
models a set of extensible terms using functions bound to typeclasses
rather than data constructors. Instances of the typeclass form
interpreters over these terms.</p>
<p>For example we can write a small language that includes basic
arithmetic, and then retroactively extend our expression language with a
multiplication operator without changing the base. At the same time our
interpreter logic remains invariant under extension with new
expressions.</p>
<div class="sourceCode" id="cb589"
data-include="src/14-interpreters/fext.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb589-1"><a href="#cb589-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb589-2"><a href="#cb589-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb589-3"><a href="#cb589-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></span>
<span id="cb589-4"><a href="#cb589-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NoMonomorphismRestriction #-}</span></span>
<span id="cb589-5"><a href="#cb589-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb589-6"><a href="#cb589-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Expr</span> repr <span class="kw">where</span></span>
<span id="cb589-7"><a href="#cb589-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  lit ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> repr</span>
<span id="cb589-8"><a href="#cb589-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  neg ::</span> repr <span class="ot">-&gt;</span> repr</span>
<span id="cb589-9"><a href="#cb589-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  add ::</span> repr <span class="ot">-&gt;</span> repr <span class="ot">-&gt;</span> repr</span>
<span id="cb589-10"><a href="#cb589-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  mul ::</span> repr <span class="ot">-&gt;</span> repr <span class="ot">-&gt;</span> repr</span>
<span id="cb589-11"><a href="#cb589-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb589-12"><a href="#cb589-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Expr</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb589-13"><a href="#cb589-13" aria-hidden="true" tabindex="-1"></a>  lit n <span class="ot">=</span> n</span>
<span id="cb589-14"><a href="#cb589-14" aria-hidden="true" tabindex="-1"></a>  neg a <span class="ot">=</span> <span class="op">-</span>a</span>
<span id="cb589-15"><a href="#cb589-15" aria-hidden="true" tabindex="-1"></a>  add a b <span class="ot">=</span> a <span class="op">+</span> b</span>
<span id="cb589-16"><a href="#cb589-16" aria-hidden="true" tabindex="-1"></a>  mul a b <span class="ot">=</span> a <span class="op">*</span> b</span>
<span id="cb589-17"><a href="#cb589-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb589-18"><a href="#cb589-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Expr</span> <span class="dt">String</span> <span class="kw">where</span></span>
<span id="cb589-19"><a href="#cb589-19" aria-hidden="true" tabindex="-1"></a>  lit n <span class="ot">=</span> <span class="fu">show</span> n</span>
<span id="cb589-20"><a href="#cb589-20" aria-hidden="true" tabindex="-1"></a>  neg a <span class="ot">=</span> <span class="st">&quot;(-&quot;</span> <span class="op">++</span> a <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb589-21"><a href="#cb589-21" aria-hidden="true" tabindex="-1"></a>  add a b <span class="ot">=</span> <span class="st">&quot;(&quot;</span> <span class="op">++</span> a <span class="op">++</span> <span class="st">&quot; + &quot;</span> <span class="op">++</span> b <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb589-22"><a href="#cb589-22" aria-hidden="true" tabindex="-1"></a>  mul a b <span class="ot">=</span> <span class="st">&quot;(&quot;</span> <span class="op">++</span> a <span class="op">++</span> <span class="st">&quot; * &quot;</span> <span class="op">++</span> b <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb589-23"><a href="#cb589-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb589-24"><a href="#cb589-24" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">BoolExpr</span> repr <span class="kw">where</span></span>
<span id="cb589-25"><a href="#cb589-25" aria-hidden="true" tabindex="-1"></a><span class="ot">  eq ::</span> repr <span class="ot">-&gt;</span> repr <span class="ot">-&gt;</span> repr</span>
<span id="cb589-26"><a href="#cb589-26" aria-hidden="true" tabindex="-1"></a><span class="ot">  tr ::</span> repr</span>
<span id="cb589-27"><a href="#cb589-27" aria-hidden="true" tabindex="-1"></a><span class="ot">  fl ::</span> repr</span>
<span id="cb589-28"><a href="#cb589-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb589-29"><a href="#cb589-29" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BoolExpr</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb589-30"><a href="#cb589-30" aria-hidden="true" tabindex="-1"></a>  eq a b <span class="ot">=</span> <span class="kw">if</span> a <span class="op">==</span> b <span class="kw">then</span> tr <span class="kw">else</span> fl</span>
<span id="cb589-31"><a href="#cb589-31" aria-hidden="true" tabindex="-1"></a>  tr <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb589-32"><a href="#cb589-32" aria-hidden="true" tabindex="-1"></a>  fl <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb589-33"><a href="#cb589-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb589-34"><a href="#cb589-34" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">BoolExpr</span> <span class="dt">String</span> <span class="kw">where</span></span>
<span id="cb589-35"><a href="#cb589-35" aria-hidden="true" tabindex="-1"></a>  eq a b <span class="ot">=</span> <span class="st">&quot;(&quot;</span> <span class="op">++</span> a <span class="op">++</span> <span class="st">&quot; == &quot;</span> <span class="op">++</span> b <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb589-36"><a href="#cb589-36" aria-hidden="true" tabindex="-1"></a>  tr <span class="ot">=</span> <span class="st">&quot;true&quot;</span></span>
<span id="cb589-37"><a href="#cb589-37" aria-hidden="true" tabindex="-1"></a>  fl <span class="ot">=</span> <span class="st">&quot;false&quot;</span></span>
<span id="cb589-38"><a href="#cb589-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb589-39"><a href="#cb589-39" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb589-40"><a href="#cb589-40" aria-hidden="true" tabindex="-1"></a>eval <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb589-41"><a href="#cb589-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb589-42"><a href="#cb589-42" aria-hidden="true" tabindex="-1"></a><span class="ot">render ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb589-43"><a href="#cb589-43" aria-hidden="true" tabindex="-1"></a>render <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb589-44"><a href="#cb589-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb589-45"><a href="#cb589-45" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> (<span class="dt">BoolExpr</span> repr, <span class="dt">Expr</span> repr) <span class="ot">=&gt;</span> repr</span>
<span id="cb589-46"><a href="#cb589-46" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> eq (add (lit <span class="dv">1</span>) (lit <span class="dv">2</span>)) (lit <span class="dv">3</span>)</span>
<span id="cb589-47"><a href="#cb589-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb589-48"><a href="#cb589-48" aria-hidden="true" tabindex="-1"></a><span class="ot">result ::</span> <span class="dt">Int</span></span>
<span id="cb589-49"><a href="#cb589-49" aria-hidden="true" tabindex="-1"></a>result <span class="ot">=</span> eval expr</span>
<span id="cb589-50"><a href="#cb589-50" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1</span></span>
<span id="cb589-51"><a href="#cb589-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb589-52"><a href="#cb589-52" aria-hidden="true" tabindex="-1"></a><span class="ot">string ::</span> <span class="dt">String</span></span>
<span id="cb589-53"><a href="#cb589-53" aria-hidden="true" tabindex="-1"></a>string <span class="ot">=</span> render expr</span>
<span id="cb589-54"><a href="#cb589-54" aria-hidden="true" tabindex="-1"></a><span class="co">-- &quot;((1 + 2) == 3)&quot;</span></span></code></pre></div>
<h2 id="finally-tagless">Finally Tagless</h2>
<p>Writing an evaluator for the lambda calculus can likewise also be
modeled with a final interpreter and a Identity functor.</p>
<div class="sourceCode" id="cb590"
data-include="src/14-interpreters/final.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb590-1"><a href="#cb590-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (id)</span>
<span id="cb590-2"><a href="#cb590-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb590-3"><a href="#cb590-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Expr</span> rep <span class="kw">where</span></span>
<span id="cb590-4"><a href="#cb590-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  lam ::</span> (rep a <span class="ot">-&gt;</span> rep b) <span class="ot">-&gt;</span> rep (a <span class="ot">-&gt;</span> b)</span>
<span id="cb590-5"><a href="#cb590-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  app ::</span> rep (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (rep a <span class="ot">-&gt;</span> rep b)</span>
<span id="cb590-6"><a href="#cb590-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  lit ::</span> a <span class="ot">-&gt;</span> rep a</span>
<span id="cb590-7"><a href="#cb590-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb590-8"><a href="#cb590-8" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Interpret</span> a <span class="ot">=</span> <span class="dt">R</span> {<span class="ot"> reify ::</span> a }</span>
<span id="cb590-9"><a href="#cb590-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb590-10"><a href="#cb590-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Expr</span> <span class="dt">Interpret</span> <span class="kw">where</span></span>
<span id="cb590-11"><a href="#cb590-11" aria-hidden="true" tabindex="-1"></a>  lam f   <span class="ot">=</span> <span class="dt">R</span> <span class="op">$</span> reify <span class="op">.</span> f <span class="op">.</span> <span class="dt">R</span></span>
<span id="cb590-12"><a href="#cb590-12" aria-hidden="true" tabindex="-1"></a>  app f a <span class="ot">=</span> <span class="dt">R</span> <span class="op">$</span> reify f <span class="op">$</span> reify a</span>
<span id="cb590-13"><a href="#cb590-13" aria-hidden="true" tabindex="-1"></a>  lit     <span class="ot">=</span> <span class="dt">R</span></span>
<span id="cb590-14"><a href="#cb590-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb590-15"><a href="#cb590-15" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">Interpret</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb590-16"><a href="#cb590-16" aria-hidden="true" tabindex="-1"></a>eval e <span class="ot">=</span> reify e</span>
<span id="cb590-17"><a href="#cb590-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb590-18"><a href="#cb590-18" aria-hidden="true" tabindex="-1"></a><span class="ot">e1 ::</span> <span class="dt">Expr</span> rep <span class="ot">=&gt;</span> rep <span class="dt">Int</span></span>
<span id="cb590-19"><a href="#cb590-19" aria-hidden="true" tabindex="-1"></a>e1 <span class="ot">=</span> app (lam (\x <span class="ot">-&gt;</span> x)) (lit <span class="dv">3</span>)</span>
<span id="cb590-20"><a href="#cb590-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb590-21"><a href="#cb590-21" aria-hidden="true" tabindex="-1"></a><span class="ot">e2 ::</span> <span class="dt">Expr</span> rep <span class="ot">=&gt;</span> rep <span class="dt">Int</span></span>
<span id="cb590-22"><a href="#cb590-22" aria-hidden="true" tabindex="-1"></a>e2 <span class="ot">=</span> app (lam (\x <span class="ot">-&gt;</span> lit <span class="dv">4</span>)) (lam <span class="op">$</span> \x <span class="ot">-&gt;</span> lam <span class="op">$</span> \y <span class="ot">-&gt;</span> y)</span>
<span id="cb590-23"><a href="#cb590-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb590-24"><a href="#cb590-24" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Int</span></span>
<span id="cb590-25"><a href="#cb590-25" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> eval e1</span>
<span id="cb590-26"><a href="#cb590-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- 3</span></span>
<span id="cb590-27"><a href="#cb590-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb590-28"><a href="#cb590-28" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Int</span></span>
<span id="cb590-29"><a href="#cb590-29" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> eval e2</span>
<span id="cb590-30"><a href="#cb590-30" aria-hidden="true" tabindex="-1"></a><span class="co">-- 4</span></span></code></pre></div>
<p>See: <a href="http://okmij.org/ftp/tagless-final/">Typed Tagless
Interpretations and Typed Compilation</a></p>
<h2 id="datatypes">Datatypes</h2>
<p>The usual hand-wavy way of describing algebraic datatypes is to
indicate the how natural correspondence between sum types, product
types, and polynomial expressions arises.</p>
<div class="sourceCode" id="cb591"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb591-1"><a href="#cb591-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Void</span>                       <span class="co">-- 0</span></span>
<span id="cb591-2"><a href="#cb591-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Unit</span>     <span class="ot">=</span> <span class="dt">Unit</span>            <span class="co">-- 1</span></span>
<span id="cb591-3"><a href="#cb591-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Sum</span> a b  <span class="ot">=</span> <span class="dt">Inl</span> a <span class="op">|</span> <span class="dt">Inr</span> b   <span class="co">-- a + b</span></span>
<span id="cb591-4"><a href="#cb591-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Prod</span> a b <span class="ot">=</span> <span class="dt">Prod</span> a b        <span class="co">-- a * b</span></span>
<span id="cb591-5"><a href="#cb591-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (<span class="ot">-&gt;</span>) a b <span class="ot">=</span> a <span class="ot">-&gt;</span> b          <span class="co">-- b ^ a</span></span></code></pre></div>
<p>Intuitively it follows the notion that the cardinality of set of
inhabitants of a type can always be given as a function of the number of
its holes. A product type admits a number of inhabitants as a function
of the product (i.e. cardinality of the Cartesian product), a sum type
as the sum of its holes and a function type as the exponential of the
span of the domain and codomain.</p>
<div class="sourceCode" id="cb592"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb592-1"><a href="#cb592-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1 + A</span></span>
<span id="cb592-2"><a href="#cb592-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre></div>
<p>Recursive types correspond to infinite series of these terms.</p>
<div class="sourceCode" id="cb593"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb593-1"><a href="#cb593-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- pseudocode</span></span>
<span id="cb593-2"><a href="#cb593-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb593-3"><a href="#cb593-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- μX. 1 + X</span></span>
<span id="cb593-4"><a href="#cb593-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> a <span class="ot">=</span> <span class="dt">Z</span> <span class="op">|</span> <span class="dt">S</span> <span class="dt">Nat</span></span>
<span id="cb593-5"><a href="#cb593-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Nat</span> a <span class="ot">=</span> μ a<span class="op">.</span> <span class="dv">1</span> <span class="op">+</span> a</span>
<span id="cb593-6"><a href="#cb593-6" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> (<span class="dv">1</span> <span class="op">+</span> (<span class="dv">1</span> <span class="op">+</span> <span class="op">...</span>))</span>
<span id="cb593-7"><a href="#cb593-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb593-8"><a href="#cb593-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- μX. 1 + A * X</span></span>
<span id="cb593-9"><a href="#cb593-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span>
<span id="cb593-10"><a href="#cb593-10" aria-hidden="true" tabindex="-1"></a><span class="dt">List</span> a <span class="ot">=</span> μ a<span class="op">.</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">*</span> (<span class="dt">List</span> a)</span>
<span id="cb593-11"><a href="#cb593-11" aria-hidden="true" tabindex="-1"></a>       <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">+</span> a<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> a<span class="op">^</span><span class="dv">3</span> <span class="op">+</span> a<span class="op">^</span><span class="dv">4</span> <span class="op">...</span></span>
<span id="cb593-12"><a href="#cb593-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb593-13"><a href="#cb593-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- μX. A + A*X*X</span></span>
<span id="cb593-14"><a href="#cb593-14" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a f <span class="ot">=</span> <span class="dt">Leaf</span> a <span class="op">|</span> <span class="dt">Tree</span> a f f</span>
<span id="cb593-15"><a href="#cb593-15" aria-hidden="true" tabindex="-1"></a><span class="dt">Tree</span> a <span class="ot">=</span> μ a<span class="op">.</span> <span class="dv">1</span> <span class="op">+</span> a <span class="op">*</span> (<span class="dt">List</span> a)</span>
<span id="cb593-16"><a href="#cb593-16" aria-hidden="true" tabindex="-1"></a>       <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> a<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> a<span class="op">^</span><span class="dv">4</span> <span class="op">+</span> a<span class="op">^</span><span class="dv">6</span> <span class="op">+</span> a<span class="op">^</span><span class="dv">8</span> <span class="op">...</span></span></code></pre></div>
<h2 id="f-algebras">F-Algebras</h2>
<p>The <em>initial algebra</em> approach differs from the final
interpreter approach in that we now represent our terms as algebraic
datatypes and the interpreter implements recursion and evaluation occurs
through pattern matching.</p>
<div class="sourceCode" id="cb594"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb594-1"><a href="#cb594-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Algebra</span> f a <span class="ot">=</span> f a <span class="ot">-&gt;</span> a</span>
<span id="cb594-2"><a href="#cb594-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Coalgebra</span> f a <span class="ot">=</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb594-3"><a href="#cb594-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }</span>
<span id="cb594-4"><a href="#cb594-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb594-5"><a href="#cb594-5" aria-hidden="true" tabindex="-1"></a><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb594-6"><a href="#cb594-6" aria-hidden="true" tabindex="-1"></a><span class="ot">ana  ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb594-7"><a href="#cb594-7" aria-hidden="true" tabindex="-1"></a><span class="ot">hylo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f b <span class="ot">-&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>In Haskell a F-algebra is a functor <code>f a</code> together with a
function <code>f a -&gt; a</code>. A coalgebra reverses the function.
For a functor <code>f</code> we can form its recursive unrolling using
the recursive <code>Fix</code> newtype wrapper.</p>
<div class="sourceCode" id="cb595"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb595-1"><a href="#cb595-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }</span>
<span id="cb595-2"><a href="#cb595-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb595-3"><a href="#cb595-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Fix</span><span class="ot"> ::</span> f (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb595-4"><a href="#cb595-4" aria-hidden="true" tabindex="-1"></a><span class="ot">unFix ::</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> f (<span class="dt">Fix</span> f)</span></code></pre></div>
<div class="sourceCode" id="cb596"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb596-1"><a href="#cb596-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Fix</span> f <span class="ot">=</span> f (f (f (f (f (f ( <span class="op">...</span> ))))))</span>
<span id="cb596-2"><a href="#cb596-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb596-3"><a href="#cb596-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">T</span> b a <span class="ot">=</span> <span class="dt">T</span> (a <span class="ot">-&gt;</span> b)</span>
<span id="cb596-4"><a href="#cb596-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb596-5"><a href="#cb596-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Fix</span> (<span class="dt">T</span> a)</span>
<span id="cb596-6"><a href="#cb596-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Fix</span> <span class="dt">T</span> <span class="ot">-&gt;</span> a</span>
<span id="cb596-7"><a href="#cb596-7" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Fix</span> <span class="dt">T</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</span>
<span id="cb596-8"><a href="#cb596-8" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Fix</span> <span class="dt">T</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb596-9"><a href="#cb596-9" aria-hidden="true" tabindex="-1"></a><span class="op">...</span></span></code></pre></div>
<p>In this form we can write down a generalized fold/unfold function
that are datatype generic and written purely in terms of the recursing
under the functor.</p>
<div class="sourceCode" id="cb597"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb597-1"><a href="#cb597-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb597-2"><a href="#cb597-2" aria-hidden="true" tabindex="-1"></a>cata alg <span class="ot">=</span> alg <span class="op">.</span> <span class="fu">fmap</span> (cata alg) <span class="op">.</span> unFix</span>
<span id="cb597-3"><a href="#cb597-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb597-4"><a href="#cb597-4" aria-hidden="true" tabindex="-1"></a><span class="ot">ana ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb597-5"><a href="#cb597-5" aria-hidden="true" tabindex="-1"></a>ana coalg <span class="ot">=</span> <span class="dt">Fix</span> <span class="op">.</span> <span class="fu">fmap</span> (ana coalg) <span class="op">.</span> coalg</span></code></pre></div>
<p>We call these functions <em>catamorphisms</em> and
<em>anamorphisms</em>. Notice especially that the types of these two
functions simply reverse the direction of arrows. Interpreted in another
way they transform an algebra/coalgebra which defines a flat
structure-preserving mapping between <code>Fix f</code> <code>f</code>
into a function which either rolls or unrolls the fixpoint. What is
particularly nice about this approach is that the recursion is
abstracted away inside the functor definition and we are free to just
implement the flat transformation logic!</p>
<p>For example a construction of the natural numbers in this form:</p>
<div class="sourceCode" id="cb598"
data-include="src/14-interpreters/initial.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb598-1"><a href="#cb598-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb598-2"><a href="#cb598-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb598-3"><a href="#cb598-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span></span>
<span id="cb598-4"><a href="#cb598-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb598-5"><a href="#cb598-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb598-6"><a href="#cb598-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-7"><a href="#cb598-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Algebra</span> f a <span class="ot">=</span> f a <span class="ot">-&gt;</span> a</span>
<span id="cb598-8"><a href="#cb598-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-9"><a href="#cb598-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Coalgebra</span> f a <span class="ot">=</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb598-10"><a href="#cb598-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-11"><a href="#cb598-11" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> {<span class="ot">unFix ::</span> f (<span class="dt">Fix</span> f)}</span>
<span id="cb598-12"><a href="#cb598-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-13"><a href="#cb598-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- catamorphism</span></span>
<span id="cb598-14"><a href="#cb598-14" aria-hidden="true" tabindex="-1"></a><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb598-15"><a href="#cb598-15" aria-hidden="true" tabindex="-1"></a>cata alg <span class="ot">=</span> alg <span class="op">.</span> <span class="fu">fmap</span> (cata alg) <span class="op">.</span> unFix</span>
<span id="cb598-16"><a href="#cb598-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-17"><a href="#cb598-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- anamorphism</span></span>
<span id="cb598-18"><a href="#cb598-18" aria-hidden="true" tabindex="-1"></a><span class="ot">ana ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb598-19"><a href="#cb598-19" aria-hidden="true" tabindex="-1"></a>ana coalg <span class="ot">=</span> <span class="dt">Fix</span> <span class="op">.</span> <span class="fu">fmap</span> (ana coalg) <span class="op">.</span> coalg</span>
<span id="cb598-20"><a href="#cb598-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-21"><a href="#cb598-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- hylomorphism</span></span>
<span id="cb598-22"><a href="#cb598-22" aria-hidden="true" tabindex="-1"></a><span class="ot">hylo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f b <span class="ot">-&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb598-23"><a href="#cb598-23" aria-hidden="true" tabindex="-1"></a>hylo f g <span class="ot">=</span> cata f <span class="op">.</span> ana g</span>
<span id="cb598-24"><a href="#cb598-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-25"><a href="#cb598-25" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Fix</span> <span class="dt">NatF</span></span>
<span id="cb598-26"><a href="#cb598-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-27"><a href="#cb598-27" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NatF</span> a <span class="ot">=</span> <span class="dt">S</span> a <span class="op">|</span> <span class="dt">Z</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb598-28"><a href="#cb598-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-29"><a href="#cb598-29" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">NatF</span> <span class="kw">where</span></span>
<span id="cb598-30"><a href="#cb598-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f <span class="dt">Z</span> <span class="ot">=</span> <span class="dt">Z</span></span>
<span id="cb598-31"><a href="#cb598-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">S</span> x) <span class="ot">=</span> <span class="dt">S</span> (f x)</span>
<span id="cb598-32"><a href="#cb598-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-33"><a href="#cb598-33" aria-hidden="true" tabindex="-1"></a><span class="ot">plus ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb598-34"><a href="#cb598-34" aria-hidden="true" tabindex="-1"></a>plus n <span class="ot">=</span> cata phi</span>
<span id="cb598-35"><a href="#cb598-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb598-36"><a href="#cb598-36" aria-hidden="true" tabindex="-1"></a>    phi <span class="dt">Z</span> <span class="ot">=</span> n</span>
<span id="cb598-37"><a href="#cb598-37" aria-hidden="true" tabindex="-1"></a>    phi (<span class="dt">S</span> m) <span class="ot">=</span> s m</span>
<span id="cb598-38"><a href="#cb598-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-39"><a href="#cb598-39" aria-hidden="true" tabindex="-1"></a><span class="ot">times ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb598-40"><a href="#cb598-40" aria-hidden="true" tabindex="-1"></a>times n <span class="ot">=</span> cata phi</span>
<span id="cb598-41"><a href="#cb598-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb598-42"><a href="#cb598-42" aria-hidden="true" tabindex="-1"></a>    phi <span class="dt">Z</span> <span class="ot">=</span> z</span>
<span id="cb598-43"><a href="#cb598-43" aria-hidden="true" tabindex="-1"></a>    phi (<span class="dt">S</span> m) <span class="ot">=</span> plus n m</span>
<span id="cb598-44"><a href="#cb598-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-45"><a href="#cb598-45" aria-hidden="true" tabindex="-1"></a><span class="ot">int ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb598-46"><a href="#cb598-46" aria-hidden="true" tabindex="-1"></a>int <span class="ot">=</span> cata phi</span>
<span id="cb598-47"><a href="#cb598-47" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb598-48"><a href="#cb598-48" aria-hidden="true" tabindex="-1"></a>    phi <span class="dt">Z</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb598-49"><a href="#cb598-49" aria-hidden="true" tabindex="-1"></a>    phi (<span class="dt">S</span> f) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> f</span>
<span id="cb598-50"><a href="#cb598-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-51"><a href="#cb598-51" aria-hidden="true" tabindex="-1"></a><span class="ot">nat ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb598-52"><a href="#cb598-52" aria-hidden="true" tabindex="-1"></a>nat <span class="ot">=</span> ana (psi <span class="dt">Z</span> <span class="dt">S</span>)</span>
<span id="cb598-53"><a href="#cb598-53" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb598-54"><a href="#cb598-54" aria-hidden="true" tabindex="-1"></a>    psi f _ <span class="dv">0</span> <span class="ot">=</span> f</span>
<span id="cb598-55"><a href="#cb598-55" aria-hidden="true" tabindex="-1"></a>    psi _ f n <span class="ot">=</span> f (n <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb598-56"><a href="#cb598-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-57"><a href="#cb598-57" aria-hidden="true" tabindex="-1"></a><span class="ot">z ::</span> <span class="dt">Nat</span></span>
<span id="cb598-58"><a href="#cb598-58" aria-hidden="true" tabindex="-1"></a>z <span class="ot">=</span> <span class="dt">Fix</span> <span class="dt">Z</span></span>
<span id="cb598-59"><a href="#cb598-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-60"><a href="#cb598-60" aria-hidden="true" tabindex="-1"></a><span class="ot">s ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb598-61"><a href="#cb598-61" aria-hidden="true" tabindex="-1"></a>s <span class="ot">=</span> <span class="dt">Fix</span> <span class="op">.</span> <span class="dt">S</span></span>
<span id="cb598-62"><a href="#cb598-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-63"><a href="#cb598-63" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Str</span> <span class="ot">=</span> <span class="dt">Fix</span> <span class="dt">StrF</span></span>
<span id="cb598-64"><a href="#cb598-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-65"><a href="#cb598-65" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StrF</span> x <span class="ot">=</span> <span class="dt">Cons</span> <span class="dt">Char</span> x <span class="op">|</span> <span class="dt">Nil</span></span>
<span id="cb598-66"><a href="#cb598-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-67"><a href="#cb598-67" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">StrF</span> <span class="kw">where</span></span>
<span id="cb598-68"><a href="#cb598-68" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Cons</span> a as) <span class="ot">=</span> <span class="dt">Cons</span> a (f as)</span>
<span id="cb598-69"><a href="#cb598-69" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb598-70"><a href="#cb598-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-71"><a href="#cb598-71" aria-hidden="true" tabindex="-1"></a><span class="ot">nil ::</span> <span class="dt">Str</span></span>
<span id="cb598-72"><a href="#cb598-72" aria-hidden="true" tabindex="-1"></a>nil <span class="ot">=</span> <span class="dt">Fix</span> <span class="dt">Nil</span></span>
<span id="cb598-73"><a href="#cb598-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-74"><a href="#cb598-74" aria-hidden="true" tabindex="-1"></a><span class="ot">cons ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Str</span> <span class="ot">-&gt;</span> <span class="dt">Str</span></span>
<span id="cb598-75"><a href="#cb598-75" aria-hidden="true" tabindex="-1"></a>cons x xs <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">Cons</span> x xs)</span>
<span id="cb598-76"><a href="#cb598-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-77"><a href="#cb598-77" aria-hidden="true" tabindex="-1"></a><span class="ot">str ::</span> <span class="dt">Str</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb598-78"><a href="#cb598-78" aria-hidden="true" tabindex="-1"></a>str <span class="ot">=</span> cata phi</span>
<span id="cb598-79"><a href="#cb598-79" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb598-80"><a href="#cb598-80" aria-hidden="true" tabindex="-1"></a>    phi <span class="dt">Nil</span> <span class="ot">=</span> []</span>
<span id="cb598-81"><a href="#cb598-81" aria-hidden="true" tabindex="-1"></a>    phi (<span class="dt">Cons</span> x xs) <span class="ot">=</span> x <span class="op">:</span> xs</span>
<span id="cb598-82"><a href="#cb598-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-83"><a href="#cb598-83" aria-hidden="true" tabindex="-1"></a><span class="ot">str&#39; ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Str</span></span>
<span id="cb598-84"><a href="#cb598-84" aria-hidden="true" tabindex="-1"></a>str&#39; <span class="ot">=</span> ana (psi <span class="dt">Nil</span> <span class="dt">Cons</span>)</span>
<span id="cb598-85"><a href="#cb598-85" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb598-86"><a href="#cb598-86" aria-hidden="true" tabindex="-1"></a>    psi f _ [] <span class="ot">=</span> f</span>
<span id="cb598-87"><a href="#cb598-87" aria-hidden="true" tabindex="-1"></a>    psi _ f (a <span class="op">:</span> as) <span class="ot">=</span> f a as</span>
<span id="cb598-88"><a href="#cb598-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-89"><a href="#cb598-89" aria-hidden="true" tabindex="-1"></a><span class="ot">map&#39; ::</span> (<span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>) <span class="ot">-&gt;</span> <span class="dt">Str</span> <span class="ot">-&gt;</span> <span class="dt">Str</span></span>
<span id="cb598-90"><a href="#cb598-90" aria-hidden="true" tabindex="-1"></a>map&#39; f <span class="ot">=</span> hylo g unFix</span>
<span id="cb598-91"><a href="#cb598-91" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb598-92"><a href="#cb598-92" aria-hidden="true" tabindex="-1"></a>    g <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">Fix</span> <span class="dt">Nil</span></span>
<span id="cb598-93"><a href="#cb598-93" aria-hidden="true" tabindex="-1"></a>    g (<span class="dt">Cons</span> a x) <span class="ot">=</span> <span class="dt">Fix</span> <span class="op">$</span> <span class="dt">Cons</span> (f a) x</span>
<span id="cb598-94"><a href="#cb598-94" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-95"><a href="#cb598-95" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">TreeF</span> a)</span>
<span id="cb598-96"><a href="#cb598-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-97"><a href="#cb598-97" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TreeF</span> a f <span class="ot">=</span> <span class="dt">Leaf</span> a <span class="op">|</span> <span class="dt">Tree</span> a f f <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb598-98"><a href="#cb598-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-99"><a href="#cb598-99" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">TreeF</span> a) <span class="kw">where</span></span>
<span id="cb598-100"><a href="#cb598-100" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Leaf</span> a) <span class="ot">=</span> <span class="dt">Leaf</span> a</span>
<span id="cb598-101"><a href="#cb598-101" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (<span class="dt">Tree</span> a b c) <span class="ot">=</span> <span class="dt">Tree</span> a (f b) (f c)</span>
<span id="cb598-102"><a href="#cb598-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-103"><a href="#cb598-103" aria-hidden="true" tabindex="-1"></a><span class="ot">depth ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb598-104"><a href="#cb598-104" aria-hidden="true" tabindex="-1"></a>depth <span class="ot">=</span> cata phi</span>
<span id="cb598-105"><a href="#cb598-105" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb598-106"><a href="#cb598-106" aria-hidden="true" tabindex="-1"></a>    phi (<span class="dt">Leaf</span> _) <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb598-107"><a href="#cb598-107" aria-hidden="true" tabindex="-1"></a>    phi (<span class="dt">Tree</span> _ l r) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">max</span> l r</span>
<span id="cb598-108"><a href="#cb598-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb598-109"><a href="#cb598-109" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Int</span></span>
<span id="cb598-110"><a href="#cb598-110" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> int (plus (nat <span class="dv">125</span>) (nat <span class="dv">25</span>))</span>
<span id="cb598-111"><a href="#cb598-111" aria-hidden="true" tabindex="-1"></a><span class="co">-- 150</span></span></code></pre></div>
<p>Or for example an interpreter for a small expression language that
depends on a scoping dictionary.</p>
<div class="sourceCode" id="cb599"
data-include="src/14-interpreters/initial_interpreter.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb599-1"><a href="#cb599-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb599-2"><a href="#cb599-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb599-3"><a href="#cb599-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span></span>
<span id="cb599-4"><a href="#cb599-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb599-5"><a href="#cb599-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb599-6"><a href="#cb599-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-7"><a href="#cb599-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb599-8"><a href="#cb599-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb599-9"><a href="#cb599-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-10"><a href="#cb599-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Algebra</span> f a <span class="ot">=</span> f a <span class="ot">-&gt;</span> a</span>
<span id="cb599-11"><a href="#cb599-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Coalgebra</span> f a <span class="ot">=</span> a <span class="ot">-&gt;</span> f a</span>
<span id="cb599-12"><a href="#cb599-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-13"><a href="#cb599-13" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }</span>
<span id="cb599-14"><a href="#cb599-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-15"><a href="#cb599-15" aria-hidden="true" tabindex="-1"></a><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb599-16"><a href="#cb599-16" aria-hidden="true" tabindex="-1"></a>cata alg <span class="ot">=</span> alg <span class="op">.</span> <span class="fu">fmap</span> (cata alg) <span class="op">.</span> unFix</span>
<span id="cb599-17"><a href="#cb599-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-18"><a href="#cb599-18" aria-hidden="true" tabindex="-1"></a><span class="ot">ana ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f</span>
<span id="cb599-19"><a href="#cb599-19" aria-hidden="true" tabindex="-1"></a>ana coalg <span class="ot">=</span> <span class="dt">Fix</span> <span class="op">.</span> <span class="fu">fmap</span> (ana coalg) <span class="op">.</span> coalg</span>
<span id="cb599-20"><a href="#cb599-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-21"><a href="#cb599-21" aria-hidden="true" tabindex="-1"></a><span class="ot">hylo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Algebra</span> f b <span class="ot">-&gt;</span> <span class="dt">Coalgebra</span> f a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb599-22"><a href="#cb599-22" aria-hidden="true" tabindex="-1"></a>hylo f g <span class="ot">=</span> cata f <span class="op">.</span> ana g</span>
<span id="cb599-23"><a href="#cb599-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-24"><a href="#cb599-24" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb599-25"><a href="#cb599-25" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> <span class="dt">M.Map</span> <span class="dt">Id</span> <span class="dt">Int</span></span>
<span id="cb599-26"><a href="#cb599-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-27"><a href="#cb599-27" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Fix</span> <span class="dt">ExprF</span></span>
<span id="cb599-28"><a href="#cb599-28" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ExprF</span> a</span>
<span id="cb599-29"><a href="#cb599-29" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Lit</span> <span class="dt">Int</span></span>
<span id="cb599-30"><a href="#cb599-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Var</span> <span class="dt">Id</span></span>
<span id="cb599-31"><a href="#cb599-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Add</span> a a</span>
<span id="cb599-32"><a href="#cb599-32" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Mul</span> a a</span>
<span id="cb599-33"><a href="#cb599-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Functor</span>)</span>
<span id="cb599-34"><a href="#cb599-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-35"><a href="#cb599-35" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Eq</span> (f (<span class="dt">Fix</span> f)) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Fix</span> f)</span>
<span id="cb599-36"><a href="#cb599-36" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Ord</span> (f (<span class="dt">Fix</span> f)) <span class="ot">=&gt;</span> <span class="dt">Ord</span> (<span class="dt">Fix</span> f)</span>
<span id="cb599-37"><a href="#cb599-37" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (f (<span class="dt">Fix</span> f)) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Fix</span> f)</span>
<span id="cb599-38"><a href="#cb599-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-39"><a href="#cb599-39" aria-hidden="true" tabindex="-1"></a><span class="ot">eval ::</span> <span class="dt">M.Map</span> <span class="dt">Id</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> <span class="dt">ExprF</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb599-40"><a href="#cb599-40" aria-hidden="true" tabindex="-1"></a>eval env <span class="ot">=</span> cata phi <span class="kw">where</span></span>
<span id="cb599-41"><a href="#cb599-41" aria-hidden="true" tabindex="-1"></a>  phi ex <span class="ot">=</span> <span class="kw">case</span> ex <span class="kw">of</span></span>
<span id="cb599-42"><a href="#cb599-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Lit</span> c   <span class="ot">-&gt;</span> <span class="fu">pure</span> c</span>
<span id="cb599-43"><a href="#cb599-43" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Var</span> i   <span class="ot">-&gt;</span> M.lookup i env</span>
<span id="cb599-44"><a href="#cb599-44" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Add</span> x y <span class="ot">-&gt;</span> liftA2 (<span class="op">+</span>) x y</span>
<span id="cb599-45"><a href="#cb599-45" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Mul</span> x y <span class="ot">-&gt;</span> liftA2 (<span class="op">*</span>) x y</span>
<span id="cb599-46"><a href="#cb599-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-47"><a href="#cb599-47" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">Expr</span></span>
<span id="cb599-48"><a href="#cb599-48" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">Mul</span> n (<span class="dt">Fix</span> (<span class="dt">Add</span> x y)))</span>
<span id="cb599-49"><a href="#cb599-49" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb599-50"><a href="#cb599-50" aria-hidden="true" tabindex="-1"></a>    n <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">Lit</span> <span class="dv">10</span>)</span>
<span id="cb599-51"><a href="#cb599-51" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)</span>
<span id="cb599-52"><a href="#cb599-52" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>)</span>
<span id="cb599-53"><a href="#cb599-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-54"><a href="#cb599-54" aria-hidden="true" tabindex="-1"></a><span class="ot">env ::</span> <span class="dt">M.Map</span> <span class="dt">Id</span> <span class="dt">Int</span></span>
<span id="cb599-55"><a href="#cb599-55" aria-hidden="true" tabindex="-1"></a>env <span class="ot">=</span> M.fromList [(<span class="st">&quot;x&quot;</span>, <span class="dv">1</span>), (<span class="st">&quot;y&quot;</span>, <span class="dv">2</span>)]</span>
<span id="cb599-56"><a href="#cb599-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-57"><a href="#cb599-57" aria-hidden="true" tabindex="-1"></a><span class="ot">compose ::</span> (f (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb599-58"><a href="#cb599-58" aria-hidden="true" tabindex="-1"></a>compose x y <span class="ot">=</span> x <span class="op">.</span> unFix <span class="op">.</span> y</span>
<span id="cb599-59"><a href="#cb599-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb599-60"><a href="#cb599-60" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb599-61"><a href="#cb599-61" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> eval env expr</span>
<span id="cb599-62"><a href="#cb599-62" aria-hidden="true" tabindex="-1"></a><span class="co">-- Just 30</span></span></code></pre></div>
<p>What is especially elegant about this approach is how naturally
catamorphisms compose into efficient composite transformations.</p>
<div class="sourceCode" id="cb600"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb600-1"><a href="#cb600-1" aria-hidden="true" tabindex="-1"></a><span class="ot">compose ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f (<span class="dt">Fix</span> f) <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb600-2"><a href="#cb600-2" aria-hidden="true" tabindex="-1"></a>compose f g <span class="ot">=</span> f <span class="op">.</span> unFix <span class="op">.</span> g</span></code></pre></div>
<h2 id="recursion-schemes-the-morphism-zoo">Recursion Schemes &amp; The
Morphism Zoo</h2>
<p>Recursion schemes are a generally way of classifying a families of
traversal algorithms that modify data structures recursively. Recursion
schemes give rise to a rich set of algebraic structures which can be
composed to devise all sorts of elaborate term rewrite systems. Most
applications of recursion schemes occur in the context of graph
rewriting or abstract syntax tree manipulation.</p>
<p>Several basic recursion schemes form the foundation of these rules.
Grossly, a <em>anamorphism</em> is an unfolding of a data structure into
a list of terms, while a <em>catamorphism</em> is a is the refolding of
a data structure from a list of terms.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Name</th>
<th style="text-align: left;">Type Signature</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Catamorphism</td>
<td
style="text-align: left;"><code>cata :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Anamorphism</td>
<td
style="text-align: left;"><code>ana :: (b -&gt; Maybe (a, b)) -&gt; b -&gt; [a]</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Paramorphism</td>
<td
style="text-align: left;"><code>para :: (a -&gt; ([a], b) -&gt; b) -&gt; b -&gt; [a] -&gt; b</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">Apomorphism</td>
<td
style="text-align: left;"><code>apo :: (b -&gt; (a, Either [a] b))  -&gt;  b  -&gt; [a]</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Hylomorphism</td>
<td
style="text-align: left;"><code>hylo :: Functor f =&gt; (f b -&gt; b) -&gt; (a -&gt; f a) -&gt; a -&gt; b</code></td>
</tr>
</tbody>
</table>
<p>For a <code>Fix</code> point type over a type with a Functor instance
for the parameter <code>f</code> we can write down the recursion schemes
as the following definitions:</p>
<div class="sourceCode" id="cb601"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb601-1"><a href="#cb601-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A fix-point type.</span></span>
<span id="cb601-2"><a href="#cb601-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }</span>
<span id="cb601-3"><a href="#cb601-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb601-4"><a href="#cb601-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Catamorphism or generic function fold.</span></span>
<span id="cb601-5"><a href="#cb601-5" aria-hidden="true" tabindex="-1"></a><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (<span class="dt">Fix</span> f <span class="ot">-&gt;</span> a)</span>
<span id="cb601-6"><a href="#cb601-6" aria-hidden="true" tabindex="-1"></a>cata f <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> (cata f) <span class="op">.</span> unFix</span>
<span id="cb601-7"><a href="#cb601-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb601-8"><a href="#cb601-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Anamorphism or generic function unfold.</span></span>
<span id="cb601-9"><a href="#cb601-9" aria-hidden="true" tabindex="-1"></a><span class="ot">ana ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Fix</span> f)</span>
<span id="cb601-10"><a href="#cb601-10" aria-hidden="true" tabindex="-1"></a>ana f <span class="ot">=</span> <span class="dt">Fix</span> <span class="op">.</span> <span class="fu">fmap</span> (ana f) <span class="op">.</span> f</span>
<span id="cb601-11"><a href="#cb601-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb601-12"><a href="#cb601-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Hylomorphism</span></span>
<span id="cb601-13"><a href="#cb601-13" aria-hidden="true" tabindex="-1"></a><span class="ot">hylo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb601-14"><a href="#cb601-14" aria-hidden="true" tabindex="-1"></a>hylo f g <span class="ot">=</span> h <span class="kw">where</span> h <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> h <span class="op">.</span> g</span>
<span id="cb601-15"><a href="#cb601-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb601-16"><a href="#cb601-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- Paramorphism</span></span>
<span id="cb601-17"><a href="#cb601-17" aria-hidden="true" tabindex="-1"></a><span class="ot">para ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f (<span class="dt">Fix</span> f, t) <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> t</span>
<span id="cb601-18"><a href="#cb601-18" aria-hidden="true" tabindex="-1"></a>para f (<span class="dt">Fix</span> x) <span class="ot">=</span> psi (<span class="fu">fmap</span> l x) <span class="kw">where</span></span>
<span id="cb601-19"><a href="#cb601-19" aria-hidden="true" tabindex="-1"></a>  l x <span class="ot">=</span> (x, para f x)</span></code></pre></div>
<p>One can also construct monadic versions of these functions which have
a result type inside of a monad. Instead of using function composition
we use <a href="#kleisli-category">Kleisi composition</a>.</p>
<div class="sourceCode" id="cb602"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb602-1"><a href="#cb602-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Monadic catamorphism</span></span>
<span id="cb602-2"><a href="#cb602-2" aria-hidden="true" tabindex="-1"></a><span class="ot">cataM ::</span> (<span class="dt">Traversable</span> f, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> m a</span>
<span id="cb602-3"><a href="#cb602-3" aria-hidden="true" tabindex="-1"></a>cataM f <span class="ot">=</span> f <span class="op">&lt;=&lt;</span> <span class="fu">traverse</span> (cataM f) <span class="op">.</span> unfix</span></code></pre></div>
<p>The library <code>recursion-schemes</code> implements these basic
recursion schemes as well as whole family of higher-order combinators
off the shelf. These are implemented in terms of two typeclases
<code>Recursive</code> and <code>Corecursive</code> which extend an
instance of Functor with default methods for catamorphisms and
anamorphisms. For the <code>Fix</code> type above these functions expand
into the following definitions:</p>
<div class="sourceCode" id="cb603"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb603-1"><a href="#cb603-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> t <span class="ot">=&gt;</span> <span class="dt">Recursive</span> t <span class="kw">where</span></span>
<span id="cb603-2"><a href="#cb603-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  project ::</span> t <span class="ot">-&gt;</span> t t</span>
<span id="cb603-3"><a href="#cb603-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  cata ::</span> (t a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> a</span>
<span id="cb603-4"><a href="#cb603-4" aria-hidden="true" tabindex="-1"></a>  cata f <span class="ot">=</span> c <span class="kw">where</span> c <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> c <span class="op">.</span> project</span>
<span id="cb603-5"><a href="#cb603-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb603-6"><a href="#cb603-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Functor</span> t <span class="ot">=&gt;</span> <span class="dt">Corecursive</span> t <span class="kw">where</span></span>
<span id="cb603-7"><a href="#cb603-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  embed ::</span> t <span class="ot">-&gt;</span> t t</span>
<span id="cb603-8"><a href="#cb603-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  ana ::</span> (a <span class="ot">-&gt;</span> t a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> t</span>
<span id="cb603-9"><a href="#cb603-9" aria-hidden="true" tabindex="-1"></a>  ana g <span class="ot">=</span> a <span class="kw">where</span> a <span class="ot">=</span> embed <span class="op">.</span> <span class="fu">fmap</span> a <span class="op">.</span> g</span>
<span id="cb603-10"><a href="#cb603-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb603-11"><a href="#cb603-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- Additional ListF helper</span></span>
<span id="cb603-12"><a href="#cb603-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ListF</span> a b <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a b</span></code></pre></div>
<p>The canonical example of a catamorphism is the factorial function
which is a composition of a coalgebra which creates a list from
<code>n</code> to <code>1</code> and an algebra which multiplies the
resulting list to a single result:</p>
<div class="sourceCode" id="cb604"
data-include="src/14-interpreters/factorial.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb604-1"><a href="#cb604-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Functor.Foldable</span></span>
<span id="cb604-2"><a href="#cb604-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb604-3"><a href="#cb604-3" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb604-4"><a href="#cb604-4" aria-hidden="true" tabindex="-1"></a>factorial <span class="ot">=</span> hylo alg coalg</span>
<span id="cb604-5"><a href="#cb604-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb604-6"><a href="#cb604-6" aria-hidden="true" tabindex="-1"></a><span class="ot">    coalg ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ListF</span> <span class="dt">Int</span> <span class="dt">Int</span></span>
<span id="cb604-7"><a href="#cb604-7" aria-hidden="true" tabindex="-1"></a>    coalg m</span>
<span id="cb604-8"><a href="#cb604-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> m <span class="op">&lt;=</span> <span class="dv">1</span> <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb604-9"><a href="#cb604-9" aria-hidden="true" tabindex="-1"></a>      <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Cons</span> m (m <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb604-10"><a href="#cb604-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    alg ::</span> <span class="dt">ListF</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb604-11"><a href="#cb604-11" aria-hidden="true" tabindex="-1"></a>    alg <span class="dt">Nil</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb604-12"><a href="#cb604-12" aria-hidden="true" tabindex="-1"></a>    alg (<span class="dt">Cons</span> a x) <span class="ot">=</span> a <span class="op">*</span> x</span></code></pre></div>
<p>Another example is unfolding of lambda calculus to perform a
substitution over a variable. We can define a catamoprhism for
traversing over the AST.</p>
<div class="sourceCode" id="cb605"
data-include="src/14-interpreters/catamorphism.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb605-1"><a href="#cb605-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb605-2"><a href="#cb605-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb605-3"><a href="#cb605-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb605-4"><a href="#cb605-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></span>
<span id="cb605-5"><a href="#cb605-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-6"><a href="#cb605-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> <span class="kw">hiding</span> (forM_, mapM, sequence)</span>
<span id="cb605-7"><a href="#cb605-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb605-8"><a href="#cb605-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Traversable</span></span>
<span id="cb605-9"><a href="#cb605-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (mapM)</span>
<span id="cb605-10"><a href="#cb605-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-11"><a href="#cb605-11" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Fix</span> (<span class="ot">f ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">=</span> <span class="dt">Fix</span> {<span class="ot">outF ::</span> f (<span class="dt">Fix</span> f)}</span>
<span id="cb605-12"><a href="#cb605-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-13"><a href="#cb605-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Catamorphism</span></span>
<span id="cb605-14"><a href="#cb605-14" aria-hidden="true" tabindex="-1"></a><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb605-15"><a href="#cb605-15" aria-hidden="true" tabindex="-1"></a>cata f <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> (cata f) <span class="op">.</span> outF</span>
<span id="cb605-16"><a href="#cb605-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-17"><a href="#cb605-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- Monadic catamorphism</span></span>
<span id="cb605-18"><a href="#cb605-18" aria-hidden="true" tabindex="-1"></a><span class="ot">cataM ::</span> (<span class="dt">Traversable</span> f, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> m a</span>
<span id="cb605-19"><a href="#cb605-19" aria-hidden="true" tabindex="-1"></a>cataM f <span class="ot">=</span> f <span class="op">&lt;=&lt;</span> <span class="fu">mapM</span> (cataM f) <span class="op">.</span> outF</span>
<span id="cb605-20"><a href="#cb605-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-21"><a href="#cb605-21" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ExprF</span> r</span>
<span id="cb605-22"><a href="#cb605-22" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">EVar</span> <span class="dt">String</span></span>
<span id="cb605-23"><a href="#cb605-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">EApp</span> r r</span>
<span id="cb605-24"><a href="#cb605-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">ELam</span> r r</span>
<span id="cb605-25"><a href="#cb605-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Functor</span>)</span>
<span id="cb605-26"><a href="#cb605-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-27"><a href="#cb605-27" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Fix</span> <span class="dt">ExprF</span></span>
<span id="cb605-28"><a href="#cb605-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-29"><a href="#cb605-29" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Fix</span> <span class="dt">ExprF</span>) <span class="kw">where</span></span>
<span id="cb605-30"><a href="#cb605-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Fix</span> f) <span class="ot">=</span> <span class="fu">show</span> f</span>
<span id="cb605-31"><a href="#cb605-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-32"><a href="#cb605-32" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> (<span class="dt">Fix</span> <span class="dt">ExprF</span>) <span class="kw">where</span></span>
<span id="cb605-33"><a href="#cb605-33" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Fix</span> x <span class="op">==</span> <span class="dt">Fix</span> y <span class="ot">=</span> x <span class="op">==</span> y</span>
<span id="cb605-34"><a href="#cb605-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-35"><a href="#cb605-35" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Ord</span> (<span class="dt">Fix</span> <span class="dt">ExprF</span>) <span class="kw">where</span></span>
<span id="cb605-36"><a href="#cb605-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">compare</span> (<span class="dt">Fix</span> x) (<span class="dt">Fix</span> y) <span class="ot">=</span> <span class="fu">compare</span> x y</span>
<span id="cb605-37"><a href="#cb605-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-38"><a href="#cb605-38" aria-hidden="true" tabindex="-1"></a><span class="ot">mkApp ::</span> <span class="dt">Fix</span> <span class="dt">ExprF</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> <span class="dt">ExprF</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> <span class="dt">ExprF</span></span>
<span id="cb605-39"><a href="#cb605-39" aria-hidden="true" tabindex="-1"></a>mkApp x y <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">EApp</span> x y)</span>
<span id="cb605-40"><a href="#cb605-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-41"><a href="#cb605-41" aria-hidden="true" tabindex="-1"></a><span class="ot">mkVar ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> <span class="dt">ExprF</span></span>
<span id="cb605-42"><a href="#cb605-42" aria-hidden="true" tabindex="-1"></a>mkVar x <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">EVar</span> x)</span>
<span id="cb605-43"><a href="#cb605-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-44"><a href="#cb605-44" aria-hidden="true" tabindex="-1"></a><span class="ot">mkLam ::</span> <span class="dt">Fix</span> <span class="dt">ExprF</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> <span class="dt">ExprF</span> <span class="ot">-&gt;</span> <span class="dt">Fix</span> <span class="dt">ExprF</span></span>
<span id="cb605-45"><a href="#cb605-45" aria-hidden="true" tabindex="-1"></a>mkLam x y <span class="ot">=</span> <span class="dt">Fix</span> (<span class="dt">ELam</span> x y)</span>
<span id="cb605-46"><a href="#cb605-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-47"><a href="#cb605-47" aria-hidden="true" tabindex="-1"></a><span class="ot">i ::</span> <span class="dt">Fix</span> <span class="dt">ExprF</span></span>
<span id="cb605-48"><a href="#cb605-48" aria-hidden="true" tabindex="-1"></a>i <span class="ot">=</span> mkLam (mkVar <span class="st">&quot;x&quot;</span>) (mkVar <span class="st">&quot;x&quot;</span>)</span>
<span id="cb605-49"><a href="#cb605-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-50"><a href="#cb605-50" aria-hidden="true" tabindex="-1"></a><span class="ot">k ::</span> <span class="dt">Fix</span> <span class="dt">ExprF</span></span>
<span id="cb605-51"><a href="#cb605-51" aria-hidden="true" tabindex="-1"></a>k <span class="ot">=</span> mkLam (mkVar <span class="st">&quot;x&quot;</span>) <span class="op">$</span> mkLam (mkVar <span class="st">&quot;y&quot;</span>) <span class="op">$</span> (mkVar <span class="st">&quot;x&quot;</span>)</span>
<span id="cb605-52"><a href="#cb605-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb605-53"><a href="#cb605-53" aria-hidden="true" tabindex="-1"></a><span class="ot">subst ::</span> <span class="dt">M.Map</span> <span class="dt">String</span> (<span class="dt">ExprF</span> <span class="dt">Expr</span>) <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb605-54"><a href="#cb605-54" aria-hidden="true" tabindex="-1"></a>subst env <span class="ot">=</span> cata alg</span>
<span id="cb605-55"><a href="#cb605-55" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb605-56"><a href="#cb605-56" aria-hidden="true" tabindex="-1"></a>    alg (<span class="dt">EVar</span> x) <span class="op">|</span> <span class="dt">Just</span> e <span class="ot">&lt;-</span> M.lookup x env <span class="ot">=</span> <span class="dt">Fix</span> e</span>
<span id="cb605-57"><a href="#cb605-57" aria-hidden="true" tabindex="-1"></a>    alg e <span class="ot">=</span> <span class="dt">Fix</span> e</span></code></pre></div>
<p>Another use case would be to collect the free variables inside of the
AST. This example use the <code>recursion-schemes</code> library.</p>
<div class="sourceCode" id="cb606"
data-include="src/14-interpreters/recursion_schemes.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb606-1"><a href="#cb606-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveFunctor #-}</span></span>
<span id="cb606-2"><a href="#cb606-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb606-3"><a href="#cb606-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb606-4"><a href="#cb606-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Functor.Foldable</span></span>
<span id="cb606-5"><a href="#cb606-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb606-6"><a href="#cb606-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Var</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb606-7"><a href="#cb606-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb606-8"><a href="#cb606-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Exp</span></span>
<span id="cb606-9"><a href="#cb606-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Var</span></span>
<span id="cb606-10"><a href="#cb606-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Exp</span> <span class="dt">Exp</span></span>
<span id="cb606-11"><a href="#cb606-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> [<span class="dt">Var</span>] <span class="dt">Exp</span></span>
<span id="cb606-12"><a href="#cb606-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb606-13"><a href="#cb606-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb606-14"><a href="#cb606-14" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ExpF</span> a</span>
<span id="cb606-15"><a href="#cb606-15" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">VarF</span> <span class="dt">Var</span></span>
<span id="cb606-16"><a href="#cb606-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">AppF</span> a a</span>
<span id="cb606-17"><a href="#cb606-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">LamF</span> [<span class="dt">Var</span>] a</span>
<span id="cb606-18"><a href="#cb606-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Functor</span>)</span>
<span id="cb606-19"><a href="#cb606-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb606-20"><a href="#cb606-20" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Base</span> <span class="dt">Exp</span> <span class="ot">=</span> <span class="dt">ExpF</span></span>
<span id="cb606-21"><a href="#cb606-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb606-22"><a href="#cb606-22" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Recursive</span> <span class="dt">Exp</span> <span class="kw">where</span></span>
<span id="cb606-23"><a href="#cb606-23" aria-hidden="true" tabindex="-1"></a>  project (<span class="dt">Var</span> a) <span class="ot">=</span> <span class="dt">VarF</span> a</span>
<span id="cb606-24"><a href="#cb606-24" aria-hidden="true" tabindex="-1"></a>  project (<span class="dt">App</span> a b) <span class="ot">=</span> <span class="dt">AppF</span> a b</span>
<span id="cb606-25"><a href="#cb606-25" aria-hidden="true" tabindex="-1"></a>  project (<span class="dt">Lam</span> a b) <span class="ot">=</span> <span class="dt">LamF</span> a b</span>
<span id="cb606-26"><a href="#cb606-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb606-27"><a href="#cb606-27" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Corecursive</span> <span class="dt">Exp</span> <span class="kw">where</span></span>
<span id="cb606-28"><a href="#cb606-28" aria-hidden="true" tabindex="-1"></a>  embed (<span class="dt">VarF</span> a) <span class="ot">=</span> <span class="dt">Var</span> a</span>
<span id="cb606-29"><a href="#cb606-29" aria-hidden="true" tabindex="-1"></a>  embed (<span class="dt">AppF</span> a b) <span class="ot">=</span> <span class="dt">App</span> a b</span>
<span id="cb606-30"><a href="#cb606-30" aria-hidden="true" tabindex="-1"></a>  embed (<span class="dt">LamF</span> a b) <span class="ot">=</span> <span class="dt">Lam</span> a b</span>
<span id="cb606-31"><a href="#cb606-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb606-32"><a href="#cb606-32" aria-hidden="true" tabindex="-1"></a><span class="ot">fvs ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> [<span class="dt">Var</span>]</span>
<span id="cb606-33"><a href="#cb606-33" aria-hidden="true" tabindex="-1"></a>fvs <span class="ot">=</span> cata phi</span>
<span id="cb606-34"><a href="#cb606-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb606-35"><a href="#cb606-35" aria-hidden="true" tabindex="-1"></a>    phi (<span class="dt">VarF</span> a) <span class="ot">=</span> [a]</span>
<span id="cb606-36"><a href="#cb606-36" aria-hidden="true" tabindex="-1"></a>    phi (<span class="dt">AppF</span> a b) <span class="ot">=</span> a <span class="op">++</span> b</span>
<span id="cb606-37"><a href="#cb606-37" aria-hidden="true" tabindex="-1"></a>    phi (<span class="dt">LamF</span> a b) <span class="ot">=</span> <span class="fu">foldr</span> (<span class="fu">filter</span> <span class="op">.</span> (<span class="op">/=</span>)) a b</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="http://hackage.haskell.org/package/recursion-schemes">recursion-schemes</a></li>
</ul>
<h2 id="hint-and-mueval">Hint and Mueval</h2>
<p>GHC itself can actually interpret arbitrary Haskell source on the fly
by hooking into the GHC’s bytecode interpreter ( the same used for GHCi
). The hint package allows us to parse, typecheck, and evaluate
arbitrary strings into arbitrary Haskell programs and evaluate them.</p>
<div class="sourceCode" id="cb607"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb607-1"><a href="#cb607-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.Interpreter</span></span>
<span id="cb607-2"><a href="#cb607-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb607-3"><a href="#cb607-3" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> <span class="dt">Interpreter</span> <span class="dt">String</span></span>
<span id="cb607-4"><a href="#cb607-4" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> eval <span class="st">&quot;(\\x -&gt; x) 1&quot;</span></span>
<span id="cb607-5"><a href="#cb607-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb607-6"><a href="#cb607-6" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">InterpreterError</span> <span class="dt">String</span>)</span>
<span id="cb607-7"><a href="#cb607-7" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> runInterpreter foo</span></code></pre></div>
<p>This is generally not a wise thing to build a library around, unless
of course the purpose of the program is itself to evaluate arbitrary
Haskell code ( something like an online Haskell shell or the likes
).</p>
<p>Both hint and mueval do effectively the same task, designed around
slightly different internals of the GHC Api.</p>
<p>See:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/mueval">hint</a></li>
<li><a href="http://hackage.haskell.org/package/mueval">mueval</a></li>
</ul>
<hr/>
<h1 id="testing">Testing</h1>
<p>Unit testing frameworks are an important component in the Haskell
ecosystem. Program correctness is a central philosophical concept and
unit testing forms the third part of the ecosystem that includes strong
type system and property testing. Generally speaking unit tests tend to
be of less importance in Haskell since the type system makes an enormous
amount of invalid programs completely inexpressible by construction.
Unit tests tend to be written later in the development lifecycle and
generally tend to be about the core logic of the program and not the
intermediate plumbing.</p>
<p>A prominent school of thought on Haskell library design tends to
favor constructing programs built around strong equational laws which
guarantee strong invariants about program behavior under composition.
Many of the testing tools are built around this style of design.</p>
<h2 id="quickcheck">QuickCheck</h2>
<p>Probably the most famous Haskell library, QuickCheck is a testing
framework. This is a framework for generating large random tests for
arbitrary functions automatically based on the types of their
arguments.</p>
<div class="sourceCode" id="cb608"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb608-1"><a href="#cb608-1" aria-hidden="true" tabindex="-1"></a><span class="ot">quickCheck ::</span> <span class="dt">Testable</span> prop <span class="ot">=&gt;</span> prop <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb608-2"><a href="#cb608-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(==&gt;) ::</span> <span class="dt">Testable</span> prop <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> prop <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb608-3"><a href="#cb608-3" aria-hidden="true" tabindex="-1"></a><span class="ot">forAll ::</span> (<span class="dt">Show</span> a, <span class="dt">Testable</span> prop) <span class="ot">=&gt;</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> prop) <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb608-4"><a href="#cb608-4" aria-hidden="true" tabindex="-1"></a><span class="ot">choose ::</span> <span class="dt">Random</span> a <span class="ot">=&gt;</span> (a, a) <span class="ot">-&gt;</span> <span class="dt">Gen</span> a</span></code></pre></div>
<div class="sourceCode" id="cb609"
data-include="src/15-testing/qcheck.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb609-1"><a href="#cb609-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></span>
<span id="cb609-2"><a href="#cb609-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb609-3"><a href="#cb609-3" aria-hidden="true" tabindex="-1"></a><span class="ot">qsort ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb609-4"><a href="#cb609-4" aria-hidden="true" tabindex="-1"></a>qsort []     <span class="ot">=</span> []</span>
<span id="cb609-5"><a href="#cb609-5" aria-hidden="true" tabindex="-1"></a>qsort (x<span class="op">:</span>xs) <span class="ot">=</span> qsort lhs <span class="op">++</span> [x] <span class="op">++</span> qsort rhs</span>
<span id="cb609-6"><a href="#cb609-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> lhs <span class="ot">=</span> <span class="fu">filter</span>  (<span class="op">&lt;</span> x) xs</span>
<span id="cb609-7"><a href="#cb609-7" aria-hidden="true" tabindex="-1"></a>          rhs <span class="ot">=</span> <span class="fu">filter</span> (<span class="op">&gt;=</span> x) xs</span>
<span id="cb609-8"><a href="#cb609-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb609-9"><a href="#cb609-9" aria-hidden="true" tabindex="-1"></a><span class="ot">prop_maximum ::</span>  [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb609-10"><a href="#cb609-10" aria-hidden="true" tabindex="-1"></a>prop_maximum xs <span class="ot">=</span> <span class="fu">not</span> (<span class="fu">null</span> xs) <span class="op">==&gt;</span></span>
<span id="cb609-11"><a href="#cb609-11" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">last</span> (qsort xs) <span class="op">==</span> <span class="fu">maximum</span> xs</span>
<span id="cb609-12"><a href="#cb609-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb609-13"><a href="#cb609-13" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb609-14"><a href="#cb609-14" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> quickCheck prop_maximum</span></code></pre></div>
<div class="sourceCode" id="cb610"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb610-1"><a href="#cb610-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> runhaskell qcheck.hs</span>
<span id="cb610-2"><a href="#cb610-2" aria-hidden="true" tabindex="-1"></a><span class="ex">***</span> Failed! Falsifiable <span class="er">(</span><span class="ex">after</span> 3 tests and 4 shrinks<span class="kw">)</span><span class="bu">:</span></span>
<span id="cb610-3"><a href="#cb610-3" aria-hidden="true" tabindex="-1"></a><span class="ex">[0]</span></span>
<span id="cb610-4"><a href="#cb610-4" aria-hidden="true" tabindex="-1"></a><span class="ex">[1]</span></span>
<span id="cb610-5"><a href="#cb610-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb610-6"><a href="#cb610-6" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> runhaskell qcheck.hs</span>
<span id="cb610-7"><a href="#cb610-7" aria-hidden="true" tabindex="-1"></a><span class="ex">+++</span> OK, passed 1000 tests.</span></code></pre></div>
<p>The test data generator can be extended with custom types and refined
with predicates that restrict the domain of cases to test.</p>
<div class="sourceCode" id="cb611"
data-include="src/15-testing/arbitrary.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb611-1"><a href="#cb611-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck</span></span>
<span id="cb611-2"><a href="#cb611-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb611-3"><a href="#cb611-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Blue</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb611-4"><a href="#cb611-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb611-5"><a href="#cb611-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Color</span> <span class="kw">where</span></span>
<span id="cb611-6"><a href="#cb611-6" aria-hidden="true" tabindex="-1"></a>  arbitrary <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb611-7"><a href="#cb611-7" aria-hidden="true" tabindex="-1"></a>    n <span class="ot">&lt;-</span> choose (<span class="dv">0</span>,<span class="dv">2</span>)<span class="ot"> ::</span> <span class="dt">Gen</span> <span class="dt">Int</span></span>
<span id="cb611-8"><a href="#cb611-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> <span class="kw">case</span> n <span class="kw">of</span></span>
<span id="cb611-9"><a href="#cb611-9" aria-hidden="true" tabindex="-1"></a>      <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">Red</span></span>
<span id="cb611-10"><a href="#cb611-10" aria-hidden="true" tabindex="-1"></a>      <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">Green</span></span>
<span id="cb611-11"><a href="#cb611-11" aria-hidden="true" tabindex="-1"></a>      <span class="dv">2</span> <span class="ot">-&gt;</span> <span class="dt">Blue</span></span>
<span id="cb611-12"><a href="#cb611-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb611-13"><a href="#cb611-13" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">IO</span> [<span class="dt">Color</span>]</span>
<span id="cb611-14"><a href="#cb611-14" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> sample&#39; arbitrary</span>
<span id="cb611-15"><a href="#cb611-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- [Red,Green,Red,Blue,Red,Red,Red,Blue,Green,Red,Red]</span></span></code></pre></div>
<p>See: <a
href="http://www.cse.chalmers.se/~rjmh/QuickCheck/manual.html">QuickCheck:
An Automatic Testing Tool for Haskell</a></p>
<h2 id="smallcheck">SmallCheck</h2>
<p>Like QuickCheck, SmallCheck is a property testing system but instead
of producing random arbitrary test data it instead enumerates a
deterministic series of test data to a fixed depth.</p>
<div class="sourceCode" id="cb612"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb612-1"><a href="#cb612-1" aria-hidden="true" tabindex="-1"></a><span class="ot">smallCheck ::</span> <span class="dt">Testable</span> <span class="dt">IO</span> a <span class="ot">=&gt;</span> <span class="dt">Depth</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb612-2"><a href="#cb612-2" aria-hidden="true" tabindex="-1"></a><span class="ot">list ::</span> <span class="dt">Depth</span> <span class="ot">-&gt;</span> <span class="dt">Series</span> <span class="dt">Identity</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb612-3"><a href="#cb612-3" aria-hidden="true" tabindex="-1"></a><span class="ot">sample&#39; ::</span> <span class="dt">Gen</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> [a]</span></code></pre></div>
<div class="sourceCode" id="cb613"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb613-1"><a href="#cb613-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> list <span class="dv">3</span><span class="ot"> series ::</span> [<span class="dt">Int</span>]</span>
<span id="cb613-2"><a href="#cb613-2" aria-hidden="true" tabindex="-1"></a>[<span class="dv">0</span>,<span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>,<span class="dv">2</span>,<span class="op">-</span><span class="dv">2</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">3</span>]</span>
<span id="cb613-3"><a href="#cb613-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb613-4"><a href="#cb613-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> list <span class="dv">3</span><span class="ot"> series ::</span> [<span class="dt">Double</span>]</span>
<span id="cb613-5"><a href="#cb613-5" aria-hidden="true" tabindex="-1"></a>[<span class="fl">0.0</span>,<span class="fl">1.0</span>,<span class="op">-</span><span class="fl">1.0</span>,<span class="fl">2.0</span>,<span class="fl">0.5</span>,<span class="op">-</span><span class="fl">2.0</span>,<span class="fl">4.0</span>,<span class="fl">0.25</span>,<span class="op">-</span><span class="fl">0.5</span>,<span class="op">-</span><span class="fl">4.0</span>,<span class="op">-</span><span class="fl">0.25</span>]</span>
<span id="cb613-6"><a href="#cb613-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb613-7"><a href="#cb613-7" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> list <span class="dv">3</span><span class="ot"> series ::</span> [(<span class="dt">Int</span>, <span class="dt">String</span>)]</span>
<span id="cb613-8"><a href="#cb613-8" aria-hidden="true" tabindex="-1"></a>[(<span class="dv">0</span>,<span class="st">&quot;&quot;</span>),(<span class="dv">1</span>,<span class="st">&quot;&quot;</span>),(<span class="dv">0</span>,<span class="st">&quot;a&quot;</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="st">&quot;&quot;</span>),(<span class="dv">0</span>,<span class="st">&quot;b&quot;</span>),(<span class="dv">1</span>,<span class="st">&quot;a&quot;</span>),(<span class="dv">2</span>,<span class="st">&quot;&quot;</span>),(<span class="dv">1</span>,<span class="st">&quot;b&quot;</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="st">&quot;a&quot;</span>),(<span class="op">-</span><span class="dv">2</span>,<span class="st">&quot;&quot;</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="st">&quot;b&quot;</span>),(<span class="dv">2</span>,<span class="st">&quot;a&quot;</span>),(<span class="op">-</span><span class="dv">2</span>,<span class="st">&quot;a&quot;</span>),(<span class="dv">2</span>,<span class="st">&quot;b&quot;</span>),(<span class="op">-</span><span class="dv">2</span>,<span class="st">&quot;b&quot;</span>)]</span></code></pre></div>
<p>It is useful to generate test cases over <em>all</em> possible inputs
of a program up to some depth.</p>
<div class="sourceCode" id="cb614"
data-include="src/15-testing/smallcheck.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb614-1"><a href="#cb614-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.SmallCheck</span></span>
<span id="cb614-2"><a href="#cb614-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb614-3"><a href="#cb614-3" aria-hidden="true" tabindex="-1"></a><span class="ot">distrib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb614-4"><a href="#cb614-4" aria-hidden="true" tabindex="-1"></a>distrib a b c <span class="ot">=</span> a <span class="op">*</span> (b <span class="op">+</span> c) <span class="op">==</span> a <span class="op">*</span> b <span class="op">+</span> a <span class="op">*</span> c</span>
<span id="cb614-5"><a href="#cb614-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb614-6"><a href="#cb614-6" aria-hidden="true" tabindex="-1"></a><span class="ot">cauchy ::</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb614-7"><a href="#cb614-7" aria-hidden="true" tabindex="-1"></a>cauchy xs ys <span class="ot">=</span> (<span class="fu">abs</span> (dot xs ys))<span class="op">^</span><span class="dv">2</span> <span class="op">&lt;=</span> (dot xs xs) <span class="op">*</span> (dot ys ys)</span>
<span id="cb614-8"><a href="#cb614-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb614-9"><a href="#cb614-9" aria-hidden="true" tabindex="-1"></a><span class="ot">failure ::</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb614-10"><a href="#cb614-10" aria-hidden="true" tabindex="-1"></a>failure xs ys <span class="ot">=</span> <span class="fu">abs</span> (dot xs ys) <span class="op">&lt;=</span> (dot xs xs) <span class="op">*</span> (dot ys ys)</span>
<span id="cb614-11"><a href="#cb614-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb614-12"><a href="#cb614-12" aria-hidden="true" tabindex="-1"></a><span class="ot">dot ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb614-13"><a href="#cb614-13" aria-hidden="true" tabindex="-1"></a>dot xs ys <span class="ot">=</span> <span class="fu">sum</span> (<span class="fu">zipWith</span> (<span class="op">*</span>) xs ys)</span>
<span id="cb614-14"><a href="#cb614-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb614-15"><a href="#cb614-15" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb614-16"><a href="#cb614-16" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb614-17"><a href="#cb614-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Testing distributivity...&quot;</span></span>
<span id="cb614-18"><a href="#cb614-18" aria-hidden="true" tabindex="-1"></a>  smallCheck <span class="dv">25</span> distrib</span>
<span id="cb614-19"><a href="#cb614-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb614-20"><a href="#cb614-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Testing Cauchy-Schwarz...&quot;</span></span>
<span id="cb614-21"><a href="#cb614-21" aria-hidden="true" tabindex="-1"></a>  smallCheck <span class="dv">4</span> cauchy</span>
<span id="cb614-22"><a href="#cb614-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb614-23"><a href="#cb614-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Testing invalid Cauchy-Schwarz...&quot;</span></span>
<span id="cb614-24"><a href="#cb614-24" aria-hidden="true" tabindex="-1"></a>  smallCheck <span class="dv">4</span> failure</span></code></pre></div>
<div class="sourceCode" id="cb615"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb615-1"><a href="#cb615-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> runhaskell smallcheck<span class="op">.</span>hs</span>
<span id="cb615-2"><a href="#cb615-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Testing</span> distributivity<span class="op">...</span></span>
<span id="cb615-3"><a href="#cb615-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Completed</span> <span class="dv">132651</span> tests without failure<span class="op">.</span></span>
<span id="cb615-4"><a href="#cb615-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb615-5"><a href="#cb615-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Testing</span> <span class="dt">Cauchy</span><span class="op">-Schwarz...</span></span>
<span id="cb615-6"><a href="#cb615-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Completed</span> <span class="dv">27556</span> tests without failure<span class="op">.</span></span>
<span id="cb615-7"><a href="#cb615-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb615-8"><a href="#cb615-8" aria-hidden="true" tabindex="-1"></a><span class="dt">Testing</span> invalid <span class="dt">Cauchy</span><span class="op">-Schwarz...</span></span>
<span id="cb615-9"><a href="#cb615-9" aria-hidden="true" tabindex="-1"></a><span class="dt">Failed</span> test no<span class="op">.</span> <span class="dv">349</span><span class="op">.</span></span>
<span id="cb615-10"><a href="#cb615-10" aria-hidden="true" tabindex="-1"></a>there exist [<span class="fl">1.0</span>] [<span class="fl">0.5</span>] such that</span>
<span id="cb615-11"><a href="#cb615-11" aria-hidden="true" tabindex="-1"></a>  condition is false</span></code></pre></div>
<p>Just like for QuickCheck we can implement series instances for our
custom datatypes. For example there is no default instance for Vector,
so let’s implement one:</p>
<div class="sourceCode" id="cb616"
data-include="src/15-testing/smallcheck_series.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb616-1"><a href="#cb616-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb616-2"><a href="#cb616-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb616-3"><a href="#cb616-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-4"><a href="#cb616-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.SmallCheck</span></span>
<span id="cb616-5"><a href="#cb616-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.SmallCheck.Series</span></span>
<span id="cb616-6"><a href="#cb616-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb616-7"><a href="#cb616-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-8"><a href="#cb616-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb616-9"><a href="#cb616-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-10"><a href="#cb616-10" aria-hidden="true" tabindex="-1"></a><span class="ot">dot ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">V.Vector</span> a <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb616-11"><a href="#cb616-11" aria-hidden="true" tabindex="-1"></a>dot xs ys <span class="ot">=</span> V.sum (V.zipWith (<span class="op">*</span>) xs ys)</span>
<span id="cb616-12"><a href="#cb616-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-13"><a href="#cb616-13" aria-hidden="true" tabindex="-1"></a><span class="ot">cauchy ::</span> <span class="dt">V.Vector</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">V.Vector</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb616-14"><a href="#cb616-14" aria-hidden="true" tabindex="-1"></a>cauchy xs ys <span class="ot">=</span> (<span class="fu">abs</span> (dot xs ys))<span class="op">^</span><span class="dv">2</span> <span class="op">&lt;=</span> (dot xs xs) <span class="op">*</span> (dot ys ys)</span>
<span id="cb616-15"><a href="#cb616-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-16"><a href="#cb616-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Serial</span> m a, <span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">Serial</span> m (<span class="dt">V.Vector</span> a) <span class="kw">where</span></span>
<span id="cb616-17"><a href="#cb616-17" aria-hidden="true" tabindex="-1"></a>  series <span class="ot">=</span> V.fromList <span class="op">&lt;$&gt;</span> series</span>
<span id="cb616-18"><a href="#cb616-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb616-19"><a href="#cb616-19" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb616-20"><a href="#cb616-20" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> smallCheck <span class="dv">4</span> cauchy</span></code></pre></div>
<p>SmallCheck can also use Generics to derive Serial instances, for
example to enumerate all trees of a certain depth we might use:</p>
<div class="sourceCode" id="cb617"
data-include="src/15-testing/smallcheck_tree.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb617-1"><a href="#cb617-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb617-2"><a href="#cb617-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb617-3"><a href="#cb617-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb617-4"><a href="#cb617-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb617-5"><a href="#cb617-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb617-6"><a href="#cb617-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.SmallCheck.Series</span></span>
<span id="cb617-7"><a href="#cb617-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb617-8"><a href="#cb617-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tree</span> a <span class="ot">=</span> <span class="dt">Null</span> <span class="op">|</span> <span class="dt">Fork</span> (<span class="dt">Tree</span> a) a (<span class="dt">Tree</span> a)</span>
<span id="cb617-9"><a href="#cb617-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)</span>
<span id="cb617-10"><a href="#cb617-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb617-11"><a href="#cb617-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Serial</span> m a <span class="ot">=&gt;</span> <span class="dt">Serial</span> m (<span class="dt">Tree</span> a)</span>
<span id="cb617-12"><a href="#cb617-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb617-13"><a href="#cb617-13" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> [<span class="dt">Tree</span> ()]</span>
<span id="cb617-14"><a href="#cb617-14" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> list <span class="dv">3</span> series</span>
<span id="cb617-15"><a href="#cb617-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb617-16"><a href="#cb617-16" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> example</span></code></pre></div>
<h2 id="quickspec">QuickSpec</h2>
<p>Using the QuickCheck arbitrary machinery we can also rather
remarkably enumerate a large number of combinations of functions to try
and deduce algebraic laws from trying out inputs for small cases. Of
course the fundamental limitation of this approach is that a function
may not exhibit any interesting properties for small cases or for simple
function compositions. So in general case this approach won’t work, but
practically it still quite useful.</p>
<div class="sourceCode" id="cb618"
data-include="src/15-testing/quickspec.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb618-1"><a href="#cb618-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb618-2"><a href="#cb618-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb618-3"><a href="#cb618-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb618-4"><a href="#cb618-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb618-5"><a href="#cb618-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb618-6"><a href="#cb618-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Typeable</span></span>
<span id="cb618-7"><a href="#cb618-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">QuickSpec</span> <span class="kw">hiding</span> (arith, bools, lists)</span>
<span id="cb618-8"><a href="#cb618-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.QuickCheck.Arbitrary</span></span>
<span id="cb618-9"><a href="#cb618-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb618-10"><a href="#cb618-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Var</span> k a <span class="ot">=</span> (<span class="dt">Typeable</span> a, <span class="dt">Arbitrary</span> a, <span class="dt">CoArbitrary</span> a, k a)</span>
<span id="cb618-11"><a href="#cb618-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb618-12"><a href="#cb618-12" aria-hidden="true" tabindex="-1"></a><span class="ot">listCons ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Var</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Sig</span></span>
<span id="cb618-13"><a href="#cb618-13" aria-hidden="true" tabindex="-1"></a>listCons a <span class="ot">=</span></span>
<span id="cb618-14"><a href="#cb618-14" aria-hidden="true" tabindex="-1"></a>  background</span>
<span id="cb618-15"><a href="#cb618-15" aria-hidden="true" tabindex="-1"></a>    [ <span class="st">&quot;[]&quot;</span> <span class="ot">`fun0`</span> ([]<span class="ot"> ::</span> [a]),</span>
<span id="cb618-16"><a href="#cb618-16" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;:&quot;</span> <span class="ot">`fun2`</span> (<span class="ot">(:) ::</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a])</span>
<span id="cb618-17"><a href="#cb618-17" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb618-18"><a href="#cb618-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb618-19"><a href="#cb618-19" aria-hidden="true" tabindex="-1"></a><span class="ot">lists ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Var</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [<span class="dt">Sig</span>]</span>
<span id="cb618-20"><a href="#cb618-20" aria-hidden="true" tabindex="-1"></a>lists a <span class="ot">=</span></span>
<span id="cb618-21"><a href="#cb618-21" aria-hidden="true" tabindex="-1"></a>  [ <span class="co">-- Names to print arbitrary variables</span></span>
<span id="cb618-22"><a href="#cb618-22" aria-hidden="true" tabindex="-1"></a>    funs&#39;,</span>
<span id="cb618-23"><a href="#cb618-23" aria-hidden="true" tabindex="-1"></a>    funvars&#39;,</span>
<span id="cb618-24"><a href="#cb618-24" aria-hidden="true" tabindex="-1"></a>    vars&#39;,</span>
<span id="cb618-25"><a href="#cb618-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Ambient definitions</span></span>
<span id="cb618-26"><a href="#cb618-26" aria-hidden="true" tabindex="-1"></a>    listCons a,</span>
<span id="cb618-27"><a href="#cb618-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Expressions to deduce properties of</span></span>
<span id="cb618-28"><a href="#cb618-28" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;sort&quot;</span> <span class="ot">`fun1`</span> (<span class="fu">sort</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]),</span>
<span id="cb618-29"><a href="#cb618-29" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;map&quot;</span> <span class="ot">`fun2`</span> (<span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]),</span>
<span id="cb618-30"><a href="#cb618-30" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;id&quot;</span> <span class="ot">`fun1`</span> (<span class="fu">id</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]),</span>
<span id="cb618-31"><a href="#cb618-31" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;reverse&quot;</span> <span class="ot">`fun1`</span> (<span class="fu">reverse</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> [a]),</span>
<span id="cb618-32"><a href="#cb618-32" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;minimum&quot;</span> <span class="ot">`fun1`</span> (<span class="fu">minimum</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> a),</span>
<span id="cb618-33"><a href="#cb618-33" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;length&quot;</span> <span class="ot">`fun1`</span> (<span class="fu">length</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Int</span>),</span>
<span id="cb618-34"><a href="#cb618-34" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;++&quot;</span> <span class="ot">`fun2`</span> (<span class="ot">(++) ::</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a])</span>
<span id="cb618-35"><a href="#cb618-35" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb618-36"><a href="#cb618-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb618-37"><a href="#cb618-37" aria-hidden="true" tabindex="-1"></a>    funs&#39; <span class="ot">=</span> funs (<span class="fu">undefined</span><span class="ot"> ::</span> a)</span>
<span id="cb618-38"><a href="#cb618-38" aria-hidden="true" tabindex="-1"></a>    funvars&#39; <span class="ot">=</span> vars [<span class="st">&quot;f&quot;</span>, <span class="st">&quot;g&quot;</span>, <span class="st">&quot;h&quot;</span>] (<span class="fu">undefined</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a)</span>
<span id="cb618-39"><a href="#cb618-39" aria-hidden="true" tabindex="-1"></a>    vars&#39; <span class="ot">=</span> [<span class="st">&quot;xs&quot;</span>, <span class="st">&quot;ys&quot;</span>, <span class="st">&quot;zs&quot;</span>] <span class="ot">`vars`</span> (<span class="fu">undefined</span><span class="ot"> ::</span> [a])</span>
<span id="cb618-40"><a href="#cb618-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb618-41"><a href="#cb618-41" aria-hidden="true" tabindex="-1"></a><span class="ot">tvar ::</span> <span class="dt">A</span></span>
<span id="cb618-42"><a href="#cb618-42" aria-hidden="true" tabindex="-1"></a>tvar <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb618-43"><a href="#cb618-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb618-44"><a href="#cb618-44" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb618-45"><a href="#cb618-45" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> quickSpec (lists tvar)</span></code></pre></div>
<p>Running this we rather see it is able to deduce most of the laws for
list functions.</p>
<div class="sourceCode" id="cb619"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb619-1"><a href="#cb619-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> runhaskell src/quickspec.hs</span>
<span id="cb619-2"><a href="#cb619-2" aria-hidden="true" tabindex="-1"></a><span class="ex">--</span> background functions <span class="at">--</span></span>
<span id="cb619-3"><a href="#cb619-3" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> :: A <span class="at">-</span><span class="op">&gt;</span> A</span>
<span id="cb619-4"><a href="#cb619-4" aria-hidden="true" tabindex="-1"></a><span class="kw">(</span><span class="bu">:</span><span class="kw">)</span> <span class="ex">::</span> A <span class="at">-</span><span class="op">&gt;</span> <span class="pp">[</span><span class="ss">A</span><span class="pp">]</span> <span class="at">-</span><span class="op">&gt;</span> <span class="pp">[</span><span class="ss">A</span><span class="pp">]</span></span>
<span id="cb619-5"><a href="#cb619-5" aria-hidden="true" tabindex="-1"></a><span class="kw">(</span><span class="bu">.</span><span class="kw">)</span> <span class="ex">::</span> <span class="er">(</span><span class="ex">A</span> <span class="at">-</span><span class="op">&gt;</span> A<span class="kw">)</span> <span class="ex">-</span><span class="op">&gt;</span> <span class="er">(</span><span class="ex">A</span> <span class="at">-</span><span class="op">&gt;</span> A<span class="kw">)</span> <span class="ex">-</span><span class="op">&gt;</span> A <span class="at">-</span><span class="op">&gt;</span> A</span>
<span id="cb619-6"><a href="#cb619-6" aria-hidden="true" tabindex="-1"></a><span class="ex">[]</span> :: <span class="pp">[</span><span class="ss">A</span><span class="pp">]</span></span>
<span id="cb619-7"><a href="#cb619-7" aria-hidden="true" tabindex="-1"></a><span class="ex">--</span> variables <span class="at">--</span></span>
<span id="cb619-8"><a href="#cb619-8" aria-hidden="true" tabindex="-1"></a><span class="ex">f,</span> g, h :: A <span class="at">-</span><span class="op">&gt;</span> A</span>
<span id="cb619-9"><a href="#cb619-9" aria-hidden="true" tabindex="-1"></a><span class="ex">xs,</span> ys, zs :: <span class="pp">[</span><span class="ss">A</span><span class="pp">]</span></span>
<span id="cb619-10"><a href="#cb619-10" aria-hidden="true" tabindex="-1"></a><span class="ex">==</span> Equations about map ==</span>
<span id="cb619-11"><a href="#cb619-11" aria-hidden="true" tabindex="-1"></a>  <span class="ex">1:</span> map f [] == []</span>
<span id="cb619-12"><a href="#cb619-12" aria-hidden="true" tabindex="-1"></a>  <span class="ex">2:</span> map id xs == xs</span>
<span id="cb619-13"><a href="#cb619-13" aria-hidden="true" tabindex="-1"></a>  <span class="ex">3:</span> map <span class="er">(</span><span class="ex">f.g</span><span class="kw">)</span> <span class="ex">xs</span> == map f <span class="er">(</span><span class="ex">map</span> g xs<span class="kw">)</span></span>
<span id="cb619-14"><a href="#cb619-14" aria-hidden="true" tabindex="-1"></a><span class="ex">==</span> Equations about minimum ==</span>
<span id="cb619-15"><a href="#cb619-15" aria-hidden="true" tabindex="-1"></a>  <span class="ex">4:</span> minimum [] == undefined</span>
<span id="cb619-16"><a href="#cb619-16" aria-hidden="true" tabindex="-1"></a><span class="ex">==</span> Equations about <span class="er">(</span><span class="ex">++</span><span class="kw">)</span> <span class="ex">==</span></span>
<span id="cb619-17"><a href="#cb619-17" aria-hidden="true" tabindex="-1"></a>  <span class="ex">5:</span> xs++[] == xs</span>
<span id="cb619-18"><a href="#cb619-18" aria-hidden="true" tabindex="-1"></a>  <span class="ex">6:</span> []++xs == xs</span>
<span id="cb619-19"><a href="#cb619-19" aria-hidden="true" tabindex="-1"></a>  <span class="ex">7:</span> <span class="er">(</span><span class="ex">xs++ys</span><span class="kw">)</span><span class="ex">++zs</span> == xs+<span class="pp">+(</span>ys++zs<span class="pp">)</span></span>
<span id="cb619-20"><a href="#cb619-20" aria-hidden="true" tabindex="-1"></a><span class="ex">==</span> Equations about sort ==</span>
<span id="cb619-21"><a href="#cb619-21" aria-hidden="true" tabindex="-1"></a>  <span class="ex">8:</span> sort [] == []</span>
<span id="cb619-22"><a href="#cb619-22" aria-hidden="true" tabindex="-1"></a>  <span class="ex">9:</span> sort <span class="er">(</span><span class="fu">sort</span> xs<span class="kw">)</span> <span class="ex">==</span> sort xs</span>
<span id="cb619-23"><a href="#cb619-23" aria-hidden="true" tabindex="-1"></a><span class="ex">==</span> Equations about id ==</span>
<span id="cb619-24"><a href="#cb619-24" aria-hidden="true" tabindex="-1"></a> <span class="ex">10:</span> id xs == xs</span>
<span id="cb619-25"><a href="#cb619-25" aria-hidden="true" tabindex="-1"></a><span class="ex">==</span> Equations about reverse ==</span>
<span id="cb619-26"><a href="#cb619-26" aria-hidden="true" tabindex="-1"></a> <span class="ex">11:</span> reverse [] == []</span>
<span id="cb619-27"><a href="#cb619-27" aria-hidden="true" tabindex="-1"></a> <span class="ex">12:</span> reverse <span class="er">(</span><span class="ex">reverse</span> xs<span class="kw">)</span> <span class="ex">==</span> xs</span>
<span id="cb619-28"><a href="#cb619-28" aria-hidden="true" tabindex="-1"></a><span class="ex">==</span> Equations about several functions ==</span>
<span id="cb619-29"><a href="#cb619-29" aria-hidden="true" tabindex="-1"></a> <span class="ex">13:</span> minimum <span class="er">(</span><span class="ex">xs++ys</span><span class="kw">)</span> <span class="ex">==</span> minimum <span class="er">(</span><span class="ex">ys++xs</span><span class="kw">)</span></span>
<span id="cb619-30"><a href="#cb619-30" aria-hidden="true" tabindex="-1"></a> <span class="ex">14:</span> length <span class="er">(</span><span class="ex">map</span> f xs<span class="kw">)</span> <span class="ex">==</span> length xs</span>
<span id="cb619-31"><a href="#cb619-31" aria-hidden="true" tabindex="-1"></a> <span class="ex">15:</span> length <span class="er">(</span><span class="ex">xs++ys</span><span class="kw">)</span> <span class="ex">==</span> length <span class="er">(</span><span class="ex">ys++xs</span><span class="kw">)</span></span>
<span id="cb619-32"><a href="#cb619-32" aria-hidden="true" tabindex="-1"></a> <span class="ex">16:</span> sort <span class="er">(</span><span class="ex">xs++ys</span><span class="kw">)</span> <span class="ex">==</span> sort <span class="er">(</span><span class="ex">ys++xs</span><span class="kw">)</span></span>
<span id="cb619-33"><a href="#cb619-33" aria-hidden="true" tabindex="-1"></a> <span class="ex">17:</span> map f <span class="er">(</span><span class="ex">reverse</span> xs<span class="kw">)</span> <span class="ex">==</span> reverse <span class="er">(</span><span class="ex">map</span> f xs<span class="kw">)</span></span>
<span id="cb619-34"><a href="#cb619-34" aria-hidden="true" tabindex="-1"></a> <span class="ex">18:</span> minimum <span class="er">(</span><span class="fu">sort</span> xs<span class="kw">)</span> <span class="ex">==</span> minimum xs</span>
<span id="cb619-35"><a href="#cb619-35" aria-hidden="true" tabindex="-1"></a> <span class="ex">19:</span> minimum <span class="er">(</span><span class="ex">reverse</span> xs<span class="kw">)</span> <span class="ex">==</span> minimum xs</span>
<span id="cb619-36"><a href="#cb619-36" aria-hidden="true" tabindex="-1"></a> <span class="ex">20:</span> minimum <span class="er">(</span><span class="ex">xs++xs</span><span class="kw">)</span> <span class="ex">==</span> minimum xs</span>
<span id="cb619-37"><a href="#cb619-37" aria-hidden="true" tabindex="-1"></a> <span class="ex">21:</span> length <span class="er">(</span><span class="fu">sort</span> xs<span class="kw">)</span> <span class="ex">==</span> length xs</span>
<span id="cb619-38"><a href="#cb619-38" aria-hidden="true" tabindex="-1"></a> <span class="ex">22:</span> length <span class="er">(</span><span class="ex">reverse</span> xs<span class="kw">)</span> <span class="ex">==</span> length xs</span>
<span id="cb619-39"><a href="#cb619-39" aria-hidden="true" tabindex="-1"></a> <span class="ex">23:</span> sort <span class="er">(</span><span class="ex">reverse</span> xs<span class="kw">)</span> <span class="ex">==</span> sort xs</span>
<span id="cb619-40"><a href="#cb619-40" aria-hidden="true" tabindex="-1"></a> <span class="ex">24:</span> map f xs++map f ys == map f <span class="er">(</span><span class="ex">xs++ys</span><span class="kw">)</span></span>
<span id="cb619-41"><a href="#cb619-41" aria-hidden="true" tabindex="-1"></a> <span class="ex">25:</span> reverse xs++reverse ys == reverse <span class="er">(</span><span class="ex">ys++xs</span><span class="kw">)</span></span></code></pre></div>
<p>Keep in mind the rather remarkable fact that this is all deduced
automatically from the types alone!</p>
<h2 id="tasty">Tasty</h2>
<p>Tasty is the commonly used unit testing framework. It combines all of
the testing frameworks (Quickcheck, SmallCheck, HUnit) into a common API
for forming runnable batches of tests and collecting the results.</p>
<div class="sourceCode" id="cb620"
data-include="src/15-testing/tasty.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb620-1"><a href="#cb620-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.Tasty</span></span>
<span id="cb620-2"><a href="#cb620-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.Tasty.HUnit</span></span>
<span id="cb620-3"><a href="#cb620-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.Tasty.QuickCheck</span></span>
<span id="cb620-4"><a href="#cb620-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Test.Tasty.SmallCheck</span> <span class="kw">as</span> <span class="dt">SC</span></span>
<span id="cb620-5"><a href="#cb620-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb620-6"><a href="#cb620-6" aria-hidden="true" tabindex="-1"></a><span class="ot">arith ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb620-7"><a href="#cb620-7" aria-hidden="true" tabindex="-1"></a>arith x y <span class="ot">=</span> (x <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">&amp;&amp;</span> (y <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">==&gt;</span> (x<span class="op">+</span>y)<span class="op">^</span><span class="dv">2</span> <span class="op">&gt;</span> x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> y<span class="op">^</span><span class="dv">2</span></span>
<span id="cb620-8"><a href="#cb620-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb620-9"><a href="#cb620-9" aria-hidden="true" tabindex="-1"></a><span class="ot">negation ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb620-10"><a href="#cb620-10" aria-hidden="true" tabindex="-1"></a>negation x <span class="ot">=</span> <span class="fu">abs</span> (x<span class="op">^</span><span class="dv">2</span>) <span class="op">&gt;=</span> x</span>
<span id="cb620-11"><a href="#cb620-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb620-12"><a href="#cb620-12" aria-hidden="true" tabindex="-1"></a><span class="ot">suite ::</span> <span class="dt">TestTree</span></span>
<span id="cb620-13"><a href="#cb620-13" aria-hidden="true" tabindex="-1"></a>suite <span class="ot">=</span> testGroup <span class="st">&quot;Test Suite&quot;</span> [</span>
<span id="cb620-14"><a href="#cb620-14" aria-hidden="true" tabindex="-1"></a>    testGroup <span class="st">&quot;Units&quot;</span></span>
<span id="cb620-15"><a href="#cb620-15" aria-hidden="true" tabindex="-1"></a>      [ testCase <span class="st">&quot;Equality&quot;</span> <span class="op">$</span> <span class="dt">True</span> <span class="op">@=?</span> <span class="dt">True</span></span>
<span id="cb620-16"><a href="#cb620-16" aria-hidden="true" tabindex="-1"></a>      , testCase <span class="st">&quot;Assertion&quot;</span> <span class="op">$</span> assert <span class="op">$</span> (<span class="fu">length</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]) <span class="op">==</span> <span class="dv">3</span></span>
<span id="cb620-17"><a href="#cb620-17" aria-hidden="true" tabindex="-1"></a>      ],</span>
<span id="cb620-18"><a href="#cb620-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb620-19"><a href="#cb620-19" aria-hidden="true" tabindex="-1"></a>    testGroup <span class="st">&quot;QuickCheck tests&quot;</span></span>
<span id="cb620-20"><a href="#cb620-20" aria-hidden="true" tabindex="-1"></a>      [ testProperty <span class="st">&quot;Quickcheck test&quot;</span> arith</span>
<span id="cb620-21"><a href="#cb620-21" aria-hidden="true" tabindex="-1"></a>      ],</span>
<span id="cb620-22"><a href="#cb620-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb620-23"><a href="#cb620-23" aria-hidden="true" tabindex="-1"></a>    testGroup <span class="st">&quot;SmallCheck tests&quot;</span></span>
<span id="cb620-24"><a href="#cb620-24" aria-hidden="true" tabindex="-1"></a>      [ SC.testProperty <span class="st">&quot;Negation&quot;</span> negation</span>
<span id="cb620-25"><a href="#cb620-25" aria-hidden="true" tabindex="-1"></a>      ]</span>
<span id="cb620-26"><a href="#cb620-26" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb620-27"><a href="#cb620-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb620-28"><a href="#cb620-28" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb620-29"><a href="#cb620-29" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> defaultMain suite</span></code></pre></div>
<div class="sourceCode" id="cb621"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb621-1"><a href="#cb621-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> runhaskell TestSuite.hs</span>
<span id="cb621-2"><a href="#cb621-2" aria-hidden="true" tabindex="-1"></a><span class="ex">Unit</span> tests</span>
<span id="cb621-3"><a href="#cb621-3" aria-hidden="true" tabindex="-1"></a>  <span class="ex">Units</span></span>
<span id="cb621-4"><a href="#cb621-4" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Equality:</span>        OK</span>
<span id="cb621-5"><a href="#cb621-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Assertion:</span>       OK</span>
<span id="cb621-6"><a href="#cb621-6" aria-hidden="true" tabindex="-1"></a>  <span class="ex">QuickCheck</span> tests</span>
<span id="cb621-7"><a href="#cb621-7" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Quickcheck</span> test: OK</span>
<span id="cb621-8"><a href="#cb621-8" aria-hidden="true" tabindex="-1"></a>      <span class="ex">+++</span> OK, passed 100 tests.</span>
<span id="cb621-9"><a href="#cb621-9" aria-hidden="true" tabindex="-1"></a>  <span class="ex">SmallCheck</span> tests</span>
<span id="cb621-10"><a href="#cb621-10" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Negation:</span>        OK</span>
<span id="cb621-11"><a href="#cb621-11" aria-hidden="true" tabindex="-1"></a>      <span class="ex">11</span> tests completed</span></code></pre></div>
<h2 id="silently">Silently</h2>
<p>Often in the process of testing IO heavy code we’ll need to redirect
stdout to compare it some known quantity. The <code>silently</code>
package allows us to capture anything done to stdout across any library
inside of IO block and return the result to the test runner.</p>
<div class="sourceCode" id="cb622"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb622-1"><a href="#cb622-1" aria-hidden="true" tabindex="-1"></a><span class="ot">capture ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">String</span>, a)</span></code></pre></div>
<div class="sourceCode" id="cb623"
data-include="src/15-testing/silently.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb623-1"><a href="#cb623-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.Tasty</span></span>
<span id="cb623-2"><a href="#cb623-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Test.Tasty.HUnit</span></span>
<span id="cb623-3"><a href="#cb623-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO.Silently</span></span>
<span id="cb623-4"><a href="#cb623-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb623-5"><a href="#cb623-5" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb623-6"><a href="#cb623-6" aria-hidden="true" tabindex="-1"></a>test n <span class="ot">=</span> <span class="fu">print</span> (n <span class="op">*</span> n)</span>
<span id="cb623-7"><a href="#cb623-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb623-8"><a href="#cb623-8" aria-hidden="true" tabindex="-1"></a>testCapture n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb623-9"><a href="#cb623-9" aria-hidden="true" tabindex="-1"></a>  (stdout, result) <span class="ot">&lt;-</span> capture (test n)</span>
<span id="cb623-10"><a href="#cb623-10" aria-hidden="true" tabindex="-1"></a>  assert (stdout <span class="op">==</span> <span class="fu">show</span> (n<span class="op">*</span>n) <span class="op">++</span> <span class="st">&quot;\n&quot;</span>)</span>
<span id="cb623-11"><a href="#cb623-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb623-12"><a href="#cb623-12" aria-hidden="true" tabindex="-1"></a><span class="ot">suite ::</span> <span class="dt">TestTree</span></span>
<span id="cb623-13"><a href="#cb623-13" aria-hidden="true" tabindex="-1"></a>suite <span class="ot">=</span> testGroup <span class="st">&quot;Test Suite&quot;</span> [</span>
<span id="cb623-14"><a href="#cb623-14" aria-hidden="true" tabindex="-1"></a>    testGroup <span class="st">&quot;Units&quot;</span></span>
<span id="cb623-15"><a href="#cb623-15" aria-hidden="true" tabindex="-1"></a>      [ testCase <span class="st">&quot;Equality&quot;</span> <span class="op">$</span> testCapture <span class="dv">10</span></span>
<span id="cb623-16"><a href="#cb623-16" aria-hidden="true" tabindex="-1"></a>      ]</span>
<span id="cb623-17"><a href="#cb623-17" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb623-18"><a href="#cb623-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb623-19"><a href="#cb623-19" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb623-20"><a href="#cb623-20" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> defaultMain suite</span></code></pre></div>
</hr>
<h1 id="type-families">Type Families</h1>
<p>Type families are a powerful extension the Haskell type system,
developed in 2005, that provide type-indexed data types and named
functions on types. This allows a whole new level of computation to
occur at compile-time and opens an entire arena of type-level
abstractions that were previously impossible to express. Type families
proved to be nearly as fruitful as typeclasses and indeed, many previous
approaches to type-level programming using classes are achieved much
more simply with type families.</p>
<h2 id="multiparam-typeclasses">MultiParam Typeclasses</h2>
<p>Resolution of vanilla Haskell 98 typeclasses proceeds via very simple
context reduction that minimizes interdependency between predicates,
resolves superclasses, and reduces the types to head normal form. For
example:</p>
<div class="sourceCode" id="cb624"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb624-1"><a href="#cb624-1" aria-hidden="true" tabindex="-1"></a>(<span class="dt">Eq</span> [a], <span class="dt">Ord</span> [a]) <span class="ot">=&gt;</span> [a]</span>
<span id="cb624-2"><a href="#cb624-2" aria-hidden="true" tabindex="-1"></a><span class="op">==&gt;</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a]</span></code></pre></div>
<p>If a single parameter typeclass expresses a property of a type (
i.e. whether it’s in a class or not in class ) then a multiparameter
typeclass expresses relationships between types. For example if we
wanted to express the relation that a type can be converted to another
type we might use a class like:</p>
<div class="sourceCode" id="cb625"
data-include="src/16-type-families/mparam.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb625-1"><a href="#cb625-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb625-2"><a href="#cb625-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb625-3"><a href="#cb625-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span></span>
<span id="cb625-4"><a href="#cb625-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb625-5"><a href="#cb625-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Convertible</span> a b <span class="kw">where</span></span>
<span id="cb625-6"><a href="#cb625-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  convert ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb625-7"><a href="#cb625-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb625-8"><a href="#cb625-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="dt">Integer</span> <span class="kw">where</span></span>
<span id="cb625-9"><a href="#cb625-9" aria-hidden="true" tabindex="-1"></a>  convert <span class="ot">=</span> <span class="fu">toInteger</span></span>
<span id="cb625-10"><a href="#cb625-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb625-11"><a href="#cb625-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="dt">Char</span> <span class="kw">where</span></span>
<span id="cb625-12"><a href="#cb625-12" aria-hidden="true" tabindex="-1"></a>  convert <span class="ot">=</span> <span class="fu">chr</span></span>
<span id="cb625-13"><a href="#cb625-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb625-14"><a href="#cb625-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Char</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb625-15"><a href="#cb625-15" aria-hidden="true" tabindex="-1"></a>  convert <span class="ot">=</span> <span class="fu">ord</span></span></code></pre></div>
<p>Of course now our instances for <code>Convertible Int</code> are not
unique anymore, so there no longer exists a nice procedure for
determining the inferred type of <code>b</code> from just
<code>a</code>. To remedy this let’s add a functional dependency
<code>a -&gt; b</code>, which tells GHC that an instance <code>a</code>
uniquely determines the instance that b can be. So we’ll see that our
two instances relating <code>Int</code> to both <code>Integer</code> and
<code>Char</code> conflict.</p>
<div class="sourceCode" id="cb626"
data-include="src/16-type-families/mparam_fun.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb626-1"><a href="#cb626-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb626-2"><a href="#cb626-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span></span>
<span id="cb626-3"><a href="#cb626-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb626-4"><a href="#cb626-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb626-5"><a href="#cb626-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span></span>
<span id="cb626-6"><a href="#cb626-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb626-7"><a href="#cb626-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Convertible</span> a b <span class="op">|</span> a <span class="ot">-&gt;</span> b <span class="kw">where</span></span>
<span id="cb626-8"><a href="#cb626-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  convert ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb626-9"><a href="#cb626-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb626-10"><a href="#cb626-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="dt">Char</span> <span class="kw">where</span></span>
<span id="cb626-11"><a href="#cb626-11" aria-hidden="true" tabindex="-1"></a>  convert <span class="ot">=</span> <span class="fu">chr</span></span>
<span id="cb626-12"><a href="#cb626-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb626-13"><a href="#cb626-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Char</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb626-14"><a href="#cb626-14" aria-hidden="true" tabindex="-1"></a>  convert <span class="ot">=</span> <span class="fu">ord</span></span></code></pre></div>
<div class="sourceCode" id="cb627"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb627-1"><a href="#cb627-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Functional</span> dependencies conflict between <span class="kw">instance</span> declarations<span class="op">:</span></span>
<span id="cb627-2"><a href="#cb627-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="dt">Integer</span></span>
<span id="cb627-3"><a href="#cb627-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="dt">Char</span></span></code></pre></div>
<p>Now there’s a simpler procedure for determining instances uniquely
and multiparameter typeclasses become more usable and inferable again.
Effectively a functional dependency <code>| a -&gt; b</code> says that
we can’t define multiple multiparamater typeclass instances with the
same <code>a</code> but different <code>b</code>.</p>
<div class="sourceCode" id="cb628"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb628-1"><a href="#cb628-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> convert (<span class="dv">42</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb628-2"><a href="#cb628-2" aria-hidden="true" tabindex="-1"></a><span class="ch">&#39;*&#39;</span></span>
<span id="cb628-3"><a href="#cb628-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> convert <span class="ch">&#39;*&#39;</span></span>
<span id="cb628-4"><a href="#cb628-4" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span></span></code></pre></div>
<p>Now let’s make things not so simple. Turning on
<code>UndecidableInstances</code> loosens the constraint on context
reduction that can only allow constraints of the class to become
structural smaller than its head. As a result implicit computation can
now occur <em>within in the type class instance search</em>. Combined
with a type-level representation of Peano numbers we find that we can
encode basic arithmetic at the type-level.</p>
<div class="sourceCode" id="cb629"
data-include="src/16-type-families/fundeps.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb629-1"><a href="#cb629-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb629-2"><a href="#cb629-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb629-3"><a href="#cb629-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb629-4"><a href="#cb629-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span></span>
<span id="cb629-5"><a href="#cb629-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb629-6"><a href="#cb629-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-7"><a href="#cb629-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Z</span></span>
<span id="cb629-8"><a href="#cb629-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">S</span> n</span>
<span id="cb629-9"><a href="#cb629-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-10"><a href="#cb629-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Zero</span>  <span class="ot">=</span> <span class="dt">Z</span></span>
<span id="cb629-11"><a href="#cb629-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">One</span>   <span class="ot">=</span> <span class="dt">S</span> <span class="dt">Zero</span></span>
<span id="cb629-12"><a href="#cb629-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Two</span>   <span class="ot">=</span> <span class="dt">S</span> <span class="dt">One</span></span>
<span id="cb629-13"><a href="#cb629-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Three</span> <span class="ot">=</span> <span class="dt">S</span> <span class="dt">Two</span></span>
<span id="cb629-14"><a href="#cb629-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Four</span>  <span class="ot">=</span> <span class="dt">S</span> <span class="dt">Three</span></span>
<span id="cb629-15"><a href="#cb629-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-16"><a href="#cb629-16" aria-hidden="true" tabindex="-1"></a><span class="ot">zero ::</span> <span class="dt">Zero</span></span>
<span id="cb629-17"><a href="#cb629-17" aria-hidden="true" tabindex="-1"></a>zero <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb629-18"><a href="#cb629-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-19"><a href="#cb629-19" aria-hidden="true" tabindex="-1"></a><span class="ot">one ::</span> <span class="dt">One</span></span>
<span id="cb629-20"><a href="#cb629-20" aria-hidden="true" tabindex="-1"></a>one <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb629-21"><a href="#cb629-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-22"><a href="#cb629-22" aria-hidden="true" tabindex="-1"></a><span class="ot">two ::</span> <span class="dt">Two</span></span>
<span id="cb629-23"><a href="#cb629-23" aria-hidden="true" tabindex="-1"></a>two <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb629-24"><a href="#cb629-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-25"><a href="#cb629-25" aria-hidden="true" tabindex="-1"></a><span class="ot">three ::</span> <span class="dt">Three</span></span>
<span id="cb629-26"><a href="#cb629-26" aria-hidden="true" tabindex="-1"></a>three <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb629-27"><a href="#cb629-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-28"><a href="#cb629-28" aria-hidden="true" tabindex="-1"></a><span class="ot">four ::</span> <span class="dt">Four</span></span>
<span id="cb629-29"><a href="#cb629-29" aria-hidden="true" tabindex="-1"></a>four <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb629-30"><a href="#cb629-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-31"><a href="#cb629-31" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Eval</span> a <span class="kw">where</span></span>
<span id="cb629-32"><a href="#cb629-32" aria-hidden="true" tabindex="-1"></a><span class="ot">  eval ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb629-33"><a href="#cb629-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-34"><a href="#cb629-34" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eval</span> <span class="dt">Zero</span> <span class="kw">where</span></span>
<span id="cb629-35"><a href="#cb629-35" aria-hidden="true" tabindex="-1"></a>  eval _ <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb629-36"><a href="#cb629-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-37"><a href="#cb629-37" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eval</span> n <span class="ot">=&gt;</span> <span class="dt">Eval</span> (<span class="dt">S</span> n) <span class="kw">where</span></span>
<span id="cb629-38"><a href="#cb629-38" aria-hidden="true" tabindex="-1"></a>  eval m <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> eval (prev m)</span>
<span id="cb629-39"><a href="#cb629-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-40"><a href="#cb629-40" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Pred</span> a b <span class="op">|</span> a <span class="ot">-&gt;</span> b <span class="kw">where</span></span>
<span id="cb629-41"><a href="#cb629-41" aria-hidden="true" tabindex="-1"></a><span class="ot">  prev ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb629-42"><a href="#cb629-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-43"><a href="#cb629-43" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Pred</span> <span class="dt">Zero</span> <span class="dt">Zero</span> <span class="kw">where</span></span>
<span id="cb629-44"><a href="#cb629-44" aria-hidden="true" tabindex="-1"></a>  prev <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb629-45"><a href="#cb629-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-46"><a href="#cb629-46" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Pred</span> (<span class="dt">S</span> n) n <span class="kw">where</span></span>
<span id="cb629-47"><a href="#cb629-47" aria-hidden="true" tabindex="-1"></a>  prev <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb629-48"><a href="#cb629-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-49"><a href="#cb629-49" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Add</span> a b c <span class="op">|</span> a b <span class="ot">-&gt;</span> c <span class="kw">where</span></span>
<span id="cb629-50"><a href="#cb629-50" aria-hidden="true" tabindex="-1"></a><span class="ot">  add ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span>
<span id="cb629-51"><a href="#cb629-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-52"><a href="#cb629-52" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Add</span> <span class="dt">Zero</span> a a <span class="kw">where</span></span>
<span id="cb629-53"><a href="#cb629-53" aria-hidden="true" tabindex="-1"></a>  add <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb629-54"><a href="#cb629-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-55"><a href="#cb629-55" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Add</span> a b c <span class="ot">=&gt;</span> <span class="dt">Add</span> (<span class="dt">S</span> a) b (<span class="dt">S</span> c) <span class="kw">where</span></span>
<span id="cb629-56"><a href="#cb629-56" aria-hidden="true" tabindex="-1"></a>  add <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb629-57"><a href="#cb629-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-58"><a href="#cb629-58" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Three</span></span>
<span id="cb629-59"><a href="#cb629-59" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> add one two</span>
<span id="cb629-60"><a href="#cb629-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-61"><a href="#cb629-61" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> <span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))</span>
<span id="cb629-62"><a href="#cb629-62" aria-hidden="true" tabindex="-1"></a>g <span class="ot">=</span> add two two</span>
<span id="cb629-63"><a href="#cb629-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb629-64"><a href="#cb629-64" aria-hidden="true" tabindex="-1"></a><span class="ot">h ::</span> <span class="dt">Int</span></span>
<span id="cb629-65"><a href="#cb629-65" aria-hidden="true" tabindex="-1"></a>h <span class="ot">=</span> eval (add three four)</span></code></pre></div>
<p>If the typeclass contexts look similar to Prolog you’re not wrong, if
one reads the contexts qualifier <code>(=&gt;)</code> backwards as
turnstiles <code>:-</code> then it’s precisely the same equations.</p>
<div class="sourceCode" id="cb630"><pre
class="sourceCode prolog"><code class="sourceCode prolog"><span id="cb630-1"><a href="#cb630-1" aria-hidden="true" tabindex="-1"></a>add(<span class="dv">0</span><span class="kw">,</span> <span class="dt">A</span><span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span></span>
<span id="cb630-2"><a href="#cb630-2" aria-hidden="true" tabindex="-1"></a>add(s(<span class="dt">A</span>)<span class="kw">,</span> <span class="dt">B</span><span class="kw">,</span> s(<span class="dt">C</span>)) <span class="kw">:-</span> add(<span class="dt">A</span><span class="kw">,</span> <span class="dt">B</span><span class="kw">,</span> <span class="dt">C</span>)<span class="kw">.</span></span>
<span id="cb630-3"><a href="#cb630-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb630-4"><a href="#cb630-4" aria-hidden="true" tabindex="-1"></a>pred(<span class="dv">0</span><span class="kw">,</span> <span class="dv">0</span>)<span class="kw">.</span></span>
<span id="cb630-5"><a href="#cb630-5" aria-hidden="true" tabindex="-1"></a>pred(<span class="dt">S</span>(<span class="dt">A</span>)<span class="kw">,</span> <span class="dt">A</span>)<span class="kw">.</span></span></code></pre></div>
<p>This is kind of abusing typeclasses and if used carelessly it can
fail to terminate or overflow at compile-time.
<code>UndecidableInstances</code> shouldn’t be turned on without careful
forethought about what it implies.</p>
<div class="sourceCode" id="cb631"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb631-1"><a href="#cb631-1" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb631-2"><a href="#cb631-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Context</span> reduction stack overflow; size <span class="ot">=</span> <span class="dv">201</span></span></code></pre></div>
<h2 id="type-families-1">Type Families</h2>
<p>Type families allows us to write functions in the type domain which
take types as arguments which can yield either types or values indexed
on their arguments which are evaluated at compile-time in during
typechecking. Type families come in two varieties: <strong>data
families</strong> and <strong>type synonym families</strong>.</p>
<ul>
<li><strong>type families</strong> are named function on types</li>
<li><strong>data families</strong> are type-indexed data types</li>
</ul>
<p>First let’s look at <em>type synonym families</em>, there are two
equivalent syntactic ways of constructing them. Either as
<em>associated</em> type families declared within a typeclass or as
standalone declarations at the toplevel. The following forms are
semantically equivalent, although the unassociated form is strictly more
general:</p>
<div class="sourceCode" id="cb632"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb632-1"><a href="#cb632-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- (1) Unassociated form</span></span>
<span id="cb632-2"><a href="#cb632-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Rep</span> a</span>
<span id="cb632-3"><a href="#cb632-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Rep</span> <span class="dt">Int</span> <span class="ot">=</span> <span class="dt">Char</span></span>
<span id="cb632-4"><a href="#cb632-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Rep</span> <span class="dt">Char</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb632-5"><a href="#cb632-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb632-6"><a href="#cb632-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Convertible</span> a <span class="kw">where</span></span>
<span id="cb632-7"><a href="#cb632-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  convert ::</span> a <span class="ot">-&gt;</span> <span class="dt">Rep</span> a</span>
<span id="cb632-8"><a href="#cb632-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb632-9"><a href="#cb632-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb632-10"><a href="#cb632-10" aria-hidden="true" tabindex="-1"></a>  convert <span class="ot">=</span> <span class="fu">chr</span></span>
<span id="cb632-11"><a href="#cb632-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb632-12"><a href="#cb632-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Char</span> <span class="kw">where</span></span>
<span id="cb632-13"><a href="#cb632-13" aria-hidden="true" tabindex="-1"></a>  convert <span class="ot">=</span> <span class="fu">ord</span></span>
<span id="cb632-14"><a href="#cb632-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb632-15"><a href="#cb632-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb632-16"><a href="#cb632-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb632-17"><a href="#cb632-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- (2) Associated form</span></span>
<span id="cb632-18"><a href="#cb632-18" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Convertible</span> a <span class="kw">where</span></span>
<span id="cb632-19"><a href="#cb632-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Rep</span> a</span>
<span id="cb632-20"><a href="#cb632-20" aria-hidden="true" tabindex="-1"></a><span class="ot">  convert ::</span> a <span class="ot">-&gt;</span> <span class="dt">Rep</span> a</span>
<span id="cb632-21"><a href="#cb632-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb632-22"><a href="#cb632-22" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb632-23"><a href="#cb632-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Rep</span> <span class="dt">Int</span> <span class="ot">=</span> <span class="dt">Char</span></span>
<span id="cb632-24"><a href="#cb632-24" aria-hidden="true" tabindex="-1"></a>  convert <span class="ot">=</span> <span class="fu">chr</span></span>
<span id="cb632-25"><a href="#cb632-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb632-26"><a href="#cb632-26" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Convertible</span> <span class="dt">Char</span> <span class="kw">where</span></span>
<span id="cb632-27"><a href="#cb632-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Rep</span> <span class="dt">Char</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb632-28"><a href="#cb632-28" aria-hidden="true" tabindex="-1"></a>  convert <span class="ot">=</span> <span class="fu">ord</span></span></code></pre></div>
<p>Using the same example we used for multiparameter + functional
dependencies illustration we see that there is a direct translation
between the type family approach and functional dependencies. These two
approaches have the same expressive power.</p>
<p>An associated type family can be queried using the
<code>:kind!</code> command in GHCi.</p>
<div class="sourceCode" id="cb633"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb633-1"><a href="#cb633-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Rep</span> <span class="dt">Int</span></span>
<span id="cb633-2"><a href="#cb633-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Rep</span> <span class="dt">Int</span><span class="ot"> ::</span> <span class="op">*</span></span>
<span id="cb633-3"><a href="#cb633-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Char</span></span>
<span id="cb633-4"><a href="#cb633-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Rep</span> <span class="dt">Char</span></span>
<span id="cb633-5"><a href="#cb633-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Rep</span> <span class="dt">Char</span><span class="ot"> ::</span> <span class="op">*</span></span>
<span id="cb633-6"><a href="#cb633-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Int</span></span></code></pre></div>
<p><em>Data families</em> on the other hand allow us to create new type
parameterized data constructors. Normally we can only define typeclasses
functions whose behavior results in a uniform result which is purely a
result of the typeclasses arguments. With data families we can allow
specialized behavior indexed on the type.</p>
<p>For example if we wanted to create more complicated vector structures
( bit-masked vectors, vectors of tuples, … ) that exposed a uniform API
but internally handled the differences in their data layout we can use
data families to accomplish this:</p>
<div class="sourceCode" id="cb634"
data-include="src/16-type-families/datafamily.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb634-1"><a href="#cb634-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb634-2"><a href="#cb634-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb634-3"><a href="#cb634-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb634-4"><a href="#cb634-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb634-5"><a href="#cb634-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">family</span> <span class="dt">Array</span> a</span>
<span id="cb634-6"><a href="#cb634-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Array</span> <span class="dt">Int</span>       <span class="ot">=</span> <span class="dt">IArray</span> (<span class="dt">V.Vector</span> <span class="dt">Int</span>)</span>
<span id="cb634-7"><a href="#cb634-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Array</span> <span class="dt">Bool</span>      <span class="ot">=</span> <span class="dt">BArray</span> (<span class="dt">V.Vector</span> <span class="dt">Bool</span>)</span>
<span id="cb634-8"><a href="#cb634-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Array</span> (a,b)     <span class="ot">=</span> <span class="dt">PArray</span> (<span class="dt">Array</span> a) (<span class="dt">Array</span> b)</span>
<span id="cb634-9"><a href="#cb634-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Array</span> (<span class="dt">Maybe</span> a) <span class="ot">=</span> <span class="dt">MArray</span> (<span class="dt">V.Vector</span> <span class="dt">Bool</span>) (<span class="dt">Array</span> a)</span>
<span id="cb634-10"><a href="#cb634-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb634-11"><a href="#cb634-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">IArray</span> a <span class="kw">where</span></span>
<span id="cb634-12"><a href="#cb634-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  index ::</span> <span class="dt">Array</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb634-13"><a href="#cb634-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb634-14"><a href="#cb634-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IArray</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb634-15"><a href="#cb634-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">index</span> (<span class="dt">IArray</span> xs) i <span class="ot">=</span> xs <span class="op">V.!</span> i</span>
<span id="cb634-16"><a href="#cb634-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb634-17"><a href="#cb634-17" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IArray</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb634-18"><a href="#cb634-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">index</span> (<span class="dt">BArray</span> xs) i <span class="ot">=</span> xs <span class="op">V.!</span> i</span>
<span id="cb634-19"><a href="#cb634-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb634-20"><a href="#cb634-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- Vector of pairs</span></span>
<span id="cb634-21"><a href="#cb634-21" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">IArray</span> a, <span class="dt">IArray</span> b) <span class="ot">=&gt;</span> <span class="dt">IArray</span> (a, b) <span class="kw">where</span></span>
<span id="cb634-22"><a href="#cb634-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">index</span> (<span class="dt">PArray</span> xs ys) i <span class="ot">=</span> (<span class="fu">index</span> xs i, <span class="fu">index</span> ys i)</span>
<span id="cb634-23"><a href="#cb634-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb634-24"><a href="#cb634-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- Vector of missing values</span></span>
<span id="cb634-25"><a href="#cb634-25" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">IArray</span> a) <span class="ot">=&gt;</span> <span class="dt">IArray</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span></span>
<span id="cb634-26"><a href="#cb634-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">index</span> (<span class="dt">MArray</span> bm xs) i <span class="ot">=</span></span>
<span id="cb634-27"><a href="#cb634-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> bm <span class="op">V.!</span> i <span class="kw">of</span></span>
<span id="cb634-28"><a href="#cb634-28" aria-hidden="true" tabindex="-1"></a>      <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb634-29"><a href="#cb634-29" aria-hidden="true" tabindex="-1"></a>      <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">$</span> <span class="fu">index</span> xs i</span></code></pre></div>
<h2 id="injectivity">Injectivity</h2>
<p>The type level functions defined by type-families are not necessarily
<em>injective</em>, the function may map two distinct input types to the
same output type. This differs from the behavior of type constructors (
which are also type-level functions ) which are injective.</p>
<p>For example for the constructor <code>Maybe</code>,
<code>Maybe t1 = Maybe t2</code> implies that <code>t1 = t2</code>.</p>
<div class="sourceCode" id="cb635"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb635-1"><a href="#cb635-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span> <span class="op">|</span> <span class="dt">Just</span> a</span>
<span id="cb635-2"><a href="#cb635-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Maybe a ~ Maybe b  implies  a ~ b</span></span>
<span id="cb635-3"><a href="#cb635-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb635-4"><a href="#cb635-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Int</span> <span class="ot">=</span> <span class="dt">Bool</span></span>
<span id="cb635-5"><a href="#cb635-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Char</span> <span class="ot">=</span> <span class="dt">Bool</span></span>
<span id="cb635-6"><a href="#cb635-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb635-7"><a href="#cb635-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- F a ~ F b does not imply  a ~ b, in general</span></span></code></pre></div>
<h2 id="roles">Roles</h2>
<p>Roles are a further level of specification for type variables
parameters of datatypes.</p>
<ul>
<li><code>nominal</code></li>
<li><code>representational</code></li>
<li><code>phantom</code></li>
</ul>
<p>They were added to the language to address a rather nasty and
long-standing bug around the correspondence between a newtype and its
runtime representation. The fundamental distinction that roles introduce
is there are two notions of type equality. Two types are <em>nominally
equal</em> when they have the same name. This is the usual equality in
Haskell or Core. Two types are <em>representationally equal</em> when
they have the same representation. (If a type is higher-kinded, all
nominally equal instantiations lead to representationally equal
types.)</p>
<ul>
<li><code>nominal</code> - Two types are the same.</li>
<li><code>representational</code> - Two types have the same runtime
representation.</li>
</ul>
<div class="sourceCode" id="cb636"
data-include="src/16-type-families/roles.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb636-1"><a href="#cb636-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb636-2"><a href="#cb636-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span></span>
<span id="cb636-3"><a href="#cb636-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb636-4"><a href="#cb636-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb636-5"><a href="#cb636-5" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Age</span> <span class="ot">=</span> <span class="dt">MkAge</span> {<span class="ot">unAge ::</span> <span class="dt">Int</span>}</span>
<span id="cb636-6"><a href="#cb636-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb636-7"><a href="#cb636-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Inspect</span> x</span>
<span id="cb636-8"><a href="#cb636-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb636-9"><a href="#cb636-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Inspect</span> <span class="dt">Age</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb636-10"><a href="#cb636-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb636-11"><a href="#cb636-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Inspect</span> <span class="dt">Int</span> <span class="ot">=</span> <span class="dt">Bool</span></span>
<span id="cb636-12"><a href="#cb636-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb636-13"><a href="#cb636-13" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Boom</span> a <span class="kw">where</span></span>
<span id="cb636-14"><a href="#cb636-14" aria-hidden="true" tabindex="-1"></a><span class="ot">  boom ::</span> a <span class="ot">-&gt;</span> <span class="dt">Inspect</span> a</span>
<span id="cb636-15"><a href="#cb636-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb636-16"><a href="#cb636-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Boom</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb636-17"><a href="#cb636-17" aria-hidden="true" tabindex="-1"></a>  boom <span class="ot">=</span> (<span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb636-18"><a href="#cb636-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb636-19"><a href="#cb636-19" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Boom</span> <span class="dt">Age</span></span>
<span id="cb636-20"><a href="#cb636-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb636-21"><a href="#cb636-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- GHC 7.6.3 exhibits undefined behavior</span></span>
<span id="cb636-22"><a href="#cb636-22" aria-hidden="true" tabindex="-1"></a>failure <span class="ot">=</span> boom (<span class="dt">MkAge</span> <span class="dv">3</span>)</span>
<span id="cb636-23"><a href="#cb636-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- -6341068275333450897</span></span></code></pre></div>
<p>Roles are normally inferred automatically, but with the
<code>RoleAnnotations</code> extension they can be manually annotated.
Except in rare cases this should not be necessary although it is helpful
to know what is going on under the hood.</p>
<div class="sourceCode" id="cb637"
data-include="src/16-type-families/role_infer.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb637-1"><a href="#cb637-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb637-2"><a href="#cb637-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb637-3"><a href="#cb637-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb637-4"><a href="#cb637-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb637-5"><a href="#cb637-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RoleAnnotations #-}</span></span>
<span id="cb637-6"><a href="#cb637-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb637-7"><a href="#cb637-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Zero</span> <span class="op">|</span> <span class="dt">Suc</span> <span class="dt">Nat</span></span>
<span id="cb637-8"><a href="#cb637-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb637-9"><a href="#cb637-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> role <span class="dt">Vec</span> nominal representational</span>
<span id="cb637-10"><a href="#cb637-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb637-11"><a href="#cb637-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Vec</span> <span class="dt">Zero</span> a</span>
<span id="cb637-12"><a href="#cb637-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:*) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">Suc</span> n) a</span>
<span id="cb637-13"><a href="#cb637-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb637-14"><a href="#cb637-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> role <span class="dt">App</span> representational nominal</span>
<span id="cb637-15"><a href="#cb637-15" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">App</span> (<span class="ot">f ::</span> k <span class="ot">-&gt;</span> <span class="op">*</span>) (<span class="ot">a ::</span> k) <span class="ot">=</span> <span class="dt">App</span> (f a)</span>
<span id="cb637-16"><a href="#cb637-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb637-17"><a href="#cb637-17" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> role <span class="dt">Mu</span> nominal nominal</span>
<span id="cb637-18"><a href="#cb637-18" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Mu</span> (<span class="ot">f ::</span> (k <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="op">*</span>) (<span class="ot">a ::</span> k) <span class="ot">=</span> <span class="dt">Roll</span> (f (<span class="dt">Mu</span> f) a)</span>
<span id="cb637-19"><a href="#cb637-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb637-20"><a href="#cb637-20" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> role <span class="dt">Proxy</span> phantom</span>
<span id="cb637-21"><a href="#cb637-21" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Proxy</span> (<span class="ot">a ::</span> k) <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>With:</p>
<div class="sourceCode" id="cb638"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb638-1"><a href="#cb638-1" aria-hidden="true" tabindex="-1"></a><span class="ot">coerce ::</span> <span class="dt">Coercible</span> <span class="op">*</span> a b <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb638-2"><a href="#cb638-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="op">~</span><span class="dt">R</span><span class="op">#</span>) k k a b <span class="ot">=&gt;</span> <span class="dt">Coercible</span> k a b</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Coerce.html#t:Coercible">Data.Coerce</a></li>
<li><a href="https://ghc.haskell.org/trac/ghc/wiki/Roles">Roles</a></li>
<li><a
href="http://typesandkinds.wordpress.com/2013/08/15/roles-a-new-feature-of-ghc/">Roles:
A New Feature of GHC</a></li>
</ul>
<h2 id="nonempty">NonEmpty</h2>
<p>Rather than having degenerate (and often partial) cases of many of
the Prelude functions to accommodate the null case of lists, it is
sometimes preferable to statically enforce empty lists from even being
constructed as an inhabitant of a type.</p>
<div class="sourceCode" id="cb639"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb639-1"><a href="#cb639-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:|</span>, <span class="op">&lt;|</span></span>
<span id="cb639-2"><a href="#cb639-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NonEmpty</span> a <span class="ot">=</span> a <span class="op">:|</span> [a]</span>
<span id="cb639-3"><a href="#cb639-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb639-4"><a href="#cb639-4" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span><span class="ot"> ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb639-5"><a href="#cb639-5" aria-hidden="true" tabindex="-1"></a><span class="ot">toList ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb639-6"><a href="#cb639-6" aria-hidden="true" tabindex="-1"></a><span class="ot">fromList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> a</span></code></pre></div>
<div class="sourceCode" id="cb640"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb640-1"><a href="#cb640-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span><span class="ot"> ::</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb640-2"><a href="#cb640-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span> <span class="op">~</span>(a <span class="op">:|</span> _) <span class="ot">=</span> a</span></code></pre></div>
<div class="sourceCode" id="cb641"
data-include="src/16-type-families/noempty.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb641-1"><a href="#cb641-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List.NonEmpty</span></span>
<span id="cb641-2"><a href="#cb641-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (head, tail, foldl1)</span>
<span id="cb641-3"><a href="#cb641-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span> (foldl1)</span>
<span id="cb641-4"><a href="#cb641-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb641-5"><a href="#cb641-5" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">NonEmpty</span> <span class="dt">Integer</span></span>
<span id="cb641-6"><a href="#cb641-6" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> fromList [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb641-7"><a href="#cb641-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1 :| [2,3]</span></span>
<span id="cb641-8"><a href="#cb641-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb641-9"><a href="#cb641-9" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">NonEmpty</span> <span class="dt">Integer</span></span>
<span id="cb641-10"><a href="#cb641-10" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="dv">1</span> <span class="op">:|</span> [<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb641-11"><a href="#cb641-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1 :| [2,3]</span></span>
<span id="cb641-12"><a href="#cb641-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb641-13"><a href="#cb641-13" aria-hidden="true" tabindex="-1"></a><span class="ot">c ::</span> <span class="dt">NonEmpty</span> <span class="dt">Integer</span></span>
<span id="cb641-14"><a href="#cb641-14" aria-hidden="true" tabindex="-1"></a>c <span class="ot">=</span> fromList []</span>
<span id="cb641-15"><a href="#cb641-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- *** Exception: NonEmpty.fromList: empty list</span></span>
<span id="cb641-16"><a href="#cb641-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb641-17"><a href="#cb641-17" aria-hidden="true" tabindex="-1"></a><span class="ot">d ::</span> <span class="dt">Integer</span></span>
<span id="cb641-18"><a href="#cb641-18" aria-hidden="true" tabindex="-1"></a>d <span class="ot">=</span> <span class="fu">foldl1</span> (<span class="op">+</span>) <span class="op">$</span> fromList [<span class="dv">1</span><span class="op">..</span><span class="dv">100</span>]</span>
<span id="cb641-19"><a href="#cb641-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- 5050</span></span></code></pre></div>
<h2 id="manual-proofs">Manual Proofs</h2>
<p>One of most deep results in computer science, the <a
href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry–Howard
correspondence</a>, is the relation that logical propositions can be
modeled by types and instantiating those types constitute proofs of
these propositions. Programs are proofs and proofs are programs.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Types</th>
<th style="text-align: left;">Logic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>A</code></td>
<td style="text-align: left;">proposition</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>a : A</code></td>
<td style="text-align: left;">proof</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>B(x)</code></td>
<td style="text-align: left;">predicate</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Void</code></td>
<td style="text-align: left;">⊥</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Unit</code></td>
<td style="text-align: left;">⊤</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>A + B</code></td>
<td style="text-align: left;">A ∨ B</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>A × B</code></td>
<td style="text-align: left;">A ∧ B</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>A -&gt; B</code></td>
<td style="text-align: left;">A ⇒ B</td>
</tr>
</tbody>
</table>
<p>In dependently typed languages we can exploit this result to its full
extent, in Haskell we don’t have the strength that dependent types
provide but can still prove trivial results. For example, now we can
model a type level function for addition and provide a small proof that
zero is an additive identity.</p>
<div class="sourceCode" id="cb642"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb642-1"><a href="#cb642-1" aria-hidden="true" tabindex="-1"></a><span class="dt">P</span> <span class="dv">0</span>                   [ base step ]</span>
<span id="cb642-2"><a href="#cb642-2" aria-hidden="true" tabindex="-1"></a>∀n<span class="op">.</span> <span class="dt">P</span> n  → <span class="dt">P</span> (<span class="dv">1</span><span class="op">+</span>n)    [ inductive step ]</span>
<span id="cb642-3"><a href="#cb642-3" aria-hidden="true" tabindex="-1"></a><span class="co">-------------------</span></span>
<span id="cb642-4"><a href="#cb642-4" aria-hidden="true" tabindex="-1"></a>∀n<span class="op">.</span> <span class="dt">P</span>(n)</span></code></pre></div>
<div class="sourceCode" id="cb643"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb643-1"><a href="#cb643-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Axiom</span> <span class="dv">1</span><span class="op">:</span> a <span class="op">+</span> <span class="dv">0</span> <span class="ot">=</span> a</span>
<span id="cb643-2"><a href="#cb643-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Axiom</span> <span class="dv">2</span><span class="op">:</span> a <span class="op">+</span> suc b <span class="ot">=</span> suc (a <span class="op">+</span> b)</span>
<span id="cb643-3"><a href="#cb643-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb643-4"><a href="#cb643-4" aria-hidden="true" tabindex="-1"></a>  <span class="dv">0</span> <span class="op">+</span> suc a</span>
<span id="cb643-5"><a href="#cb643-5" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> suc (<span class="dv">0</span> <span class="op">+</span> a)  [by <span class="dt">Axiom</span> <span class="dv">2</span>]</span>
<span id="cb643-6"><a href="#cb643-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> suc a        [<span class="dt">Induction</span> hypothesis]</span>
<span id="cb643-7"><a href="#cb643-7" aria-hidden="true" tabindex="-1"></a>∎</span></code></pre></div>
<p>Translated into Haskell our axioms are simply type definitions and
recursing over the inductive datatype constitutes the inductive step of
our proof.</p>
<div class="sourceCode" id="cb644"
data-include="src/16-type-families/proof.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb644-1"><a href="#cb644-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb644-2"><a href="#cb644-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb644-3"><a href="#cb644-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span></span>
<span id="cb644-4"><a href="#cb644-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb644-5"><a href="#cb644-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb644-6"><a href="#cb644-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Z</span></span>
<span id="cb644-7"><a href="#cb644-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">S</span> n</span>
<span id="cb644-8"><a href="#cb644-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb644-9"><a href="#cb644-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SNat</span> n <span class="kw">where</span></span>
<span id="cb644-10"><a href="#cb644-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Zero</span><span class="ot"> ::</span> <span class="dt">SNat</span> <span class="dt">Z</span></span>
<span id="cb644-11"><a href="#cb644-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Succ</span><span class="ot"> ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> (<span class="dt">S</span> n)</span>
<span id="cb644-12"><a href="#cb644-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb644-13"><a href="#cb644-13" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Eql</span> a b <span class="kw">where</span></span>
<span id="cb644-14"><a href="#cb644-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Refl</span><span class="ot"> ::</span> <span class="dt">Eql</span> a a</span>
<span id="cb644-15"><a href="#cb644-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb644-16"><a href="#cb644-16" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Add</span> m n</span>
<span id="cb644-17"><a href="#cb644-17" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Add</span> <span class="dt">Z</span> n <span class="ot">=</span> n</span>
<span id="cb644-18"><a href="#cb644-18" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Add</span> (<span class="dt">S</span> m) n <span class="ot">=</span> <span class="dt">S</span> (<span class="dt">Add</span> m n)</span>
<span id="cb644-19"><a href="#cb644-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb644-20"><a href="#cb644-20" aria-hidden="true" tabindex="-1"></a><span class="ot">add ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> <span class="dt">SNat</span> (<span class="dt">Add</span> n m)</span>
<span id="cb644-21"><a href="#cb644-21" aria-hidden="true" tabindex="-1"></a>add <span class="dt">Zero</span>     m <span class="ot">=</span> m</span>
<span id="cb644-22"><a href="#cb644-22" aria-hidden="true" tabindex="-1"></a>add (<span class="dt">Succ</span> n) m <span class="ot">=</span> <span class="dt">Succ</span> (add n m)</span>
<span id="cb644-23"><a href="#cb644-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb644-24"><a href="#cb644-24" aria-hidden="true" tabindex="-1"></a><span class="ot">cong ::</span> <span class="dt">Eql</span> a b <span class="ot">-&gt;</span> <span class="dt">Eql</span> (f a) (f b)</span>
<span id="cb644-25"><a href="#cb644-25" aria-hidden="true" tabindex="-1"></a>cong <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb644-26"><a href="#cb644-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb644-27"><a href="#cb644-27" aria-hidden="true" tabindex="-1"></a><span class="co">-- ∀n. 0 + suc n = suc n</span></span>
<span id="cb644-28"><a href="#cb644-28" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_suc ::</span> <span class="kw">forall</span> n<span class="op">.</span>  <span class="dt">SNat</span> n</span>
<span id="cb644-29"><a href="#cb644-29" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">Eql</span> (<span class="dt">Add</span> <span class="dt">Z</span> (<span class="dt">S</span> n)) (<span class="dt">S</span> n)</span>
<span id="cb644-30"><a href="#cb644-30" aria-hidden="true" tabindex="-1"></a>plus_suc <span class="dt">Zero</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb644-31"><a href="#cb644-31" aria-hidden="true" tabindex="-1"></a>plus_suc (<span class="dt">Succ</span> n) <span class="ot">=</span> cong (plus_suc n)</span>
<span id="cb644-32"><a href="#cb644-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb644-33"><a href="#cb644-33" aria-hidden="true" tabindex="-1"></a><span class="co">-- ∀n. 0 + n = n</span></span>
<span id="cb644-34"><a href="#cb644-34" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_zero ::</span> <span class="kw">forall</span> n<span class="op">.</span> <span class="dt">SNat</span> n</span>
<span id="cb644-35"><a href="#cb644-35" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">Eql</span> (<span class="dt">Add</span> <span class="dt">Z</span> n) n</span>
<span id="cb644-36"><a href="#cb644-36" aria-hidden="true" tabindex="-1"></a>plus_zero <span class="dt">Zero</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb644-37"><a href="#cb644-37" aria-hidden="true" tabindex="-1"></a>plus_zero (<span class="dt">Succ</span> n) <span class="ot">=</span> cong (plus_zero n)</span></code></pre></div>
<p>Using the <code>TypeOperators</code> extension we can also use infix
notation at the type-level.</p>
<div class="sourceCode" id="cb645"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb645-1"><a href="#cb645-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> a <span class="op">:=:</span> b <span class="kw">where</span></span>
<span id="cb645-2"><a href="#cb645-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Refl</span><span class="ot"> ::</span> a <span class="op">:=:</span> a</span>
<span id="cb645-3"><a href="#cb645-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb645-4"><a href="#cb645-4" aria-hidden="true" tabindex="-1"></a><span class="ot">cong ::</span> a <span class="op">:=:</span> b <span class="ot">-&gt;</span> (f a) <span class="op">:=:</span> (f b)</span>
<span id="cb645-5"><a href="#cb645-5" aria-hidden="true" tabindex="-1"></a>cong <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb645-6"><a href="#cb645-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb645-7"><a href="#cb645-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="op">:+</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb645-8"><a href="#cb645-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Zero</span>     <span class="op">:+</span> m <span class="ot">=</span> m</span>
<span id="cb645-9"><a href="#cb645-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> (<span class="dt">Succ</span> n) <span class="op">:+</span> m <span class="ot">=</span> <span class="dt">Succ</span> (n <span class="op">:+</span> m)</span>
<span id="cb645-10"><a href="#cb645-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb645-11"><a href="#cb645-11" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_suc ::</span> <span class="kw">forall</span> n m<span class="op">.</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> (n <span class="op">:+</span> (<span class="dt">S</span> m)) <span class="op">:=:</span> (<span class="dt">S</span> (n <span class="op">:+</span> m))</span>
<span id="cb645-12"><a href="#cb645-12" aria-hidden="true" tabindex="-1"></a>plus_suc <span class="dt">Zero</span> m <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb645-13"><a href="#cb645-13" aria-hidden="true" tabindex="-1"></a>plus_suc (<span class="dt">Succ</span> n) m <span class="ot">=</span> cong (plus_suc n m)</span></code></pre></div>
<h2 id="constraint-kinds">Constraint Kinds</h2>
<p>GHC’s implementation also exposes the predicates that bound
quantifiers in Haskell as types themselves, with the
<code>-XConstraintKinds</code> extension enabled. Using this extension
we work with constraints as first class types.</p>
<div class="sourceCode" id="cb646"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb646-1"><a href="#cb646-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Num</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb646-2"><a href="#cb646-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Odd</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span></code></pre></div>
<div class="sourceCode" id="cb647"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb647-1"><a href="#cb647-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">T1</span> a <span class="ot">=</span> (<span class="dt">Num</span> a, <span class="dt">Ord</span> a)</span></code></pre></div>
<p>The empty constraint set is indicated by
<code>() :: Constraint</code>.</p>
<p>For a contrived example if we wanted to create a generic
<code>Sized</code> class that carried with it constraints on the
elements of the container in question we could achieve this quite simply
using type families.</p>
<div class="sourceCode" id="cb648"
data-include="src/16-type-families/constraintkinds.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb648-1"><a href="#cb648-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ConstrainedClassMethods #-}</span></span>
<span id="cb648-2"><a href="#cb648-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb648-3"><a href="#cb648-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb648-4"><a href="#cb648-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb648-5"><a href="#cb648-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashSet</span></span>
<span id="cb648-6"><a href="#cb648-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Hashable</span></span>
<span id="cb648-7"><a href="#cb648-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)</span>
<span id="cb648-8"><a href="#cb648-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb648-9"><a href="#cb648-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Con</span><span class="ot"> a ::</span> <span class="dt">Constraint</span></span>
<span id="cb648-10"><a href="#cb648-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb648-11"><a href="#cb648-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Con</span> [a] <span class="ot">=</span> (<span class="dt">Ord</span> a, <span class="dt">Eq</span> a)</span>
<span id="cb648-12"><a href="#cb648-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb648-13"><a href="#cb648-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Con</span> (<span class="dt">HashSet</span> a) <span class="ot">=</span> (<span class="dt">Hashable</span> a)</span>
<span id="cb648-14"><a href="#cb648-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb648-15"><a href="#cb648-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Sized</span> a <span class="kw">where</span></span>
<span id="cb648-16"><a href="#cb648-16" aria-hidden="true" tabindex="-1"></a><span class="ot">  gsize ::</span> <span class="dt">Con</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb648-17"><a href="#cb648-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb648-18"><a href="#cb648-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Sized</span> [a] <span class="kw">where</span></span>
<span id="cb648-19"><a href="#cb648-19" aria-hidden="true" tabindex="-1"></a>  gsize <span class="ot">=</span> <span class="fu">length</span></span>
<span id="cb648-20"><a href="#cb648-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb648-21"><a href="#cb648-21" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Sized</span> (<span class="dt">HashSet</span> a) <span class="kw">where</span></span>
<span id="cb648-22"><a href="#cb648-22" aria-hidden="true" tabindex="-1"></a>  gsize <span class="ot">=</span> size</span></code></pre></div>
<p>One use-case of this is to capture the typeclass dictionary
constrained by a function and reify it as a value.</p>
<div class="sourceCode" id="cb649"
data-include="src/16-type-families/dict.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb649-1"><a href="#cb649-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb649-2"><a href="#cb649-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb649-3"><a href="#cb649-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb649-4"><a href="#cb649-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb649-5"><a href="#cb649-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)</span>
<span id="cb649-6"><a href="#cb649-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb649-7"><a href="#cb649-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Dict</span><span class="ot"> ::</span> <span class="dt">Constraint</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb649-8"><a href="#cb649-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Dict</span><span class="ot"> ::</span> (c) <span class="ot">=&gt;</span> <span class="dt">Dict</span> c</span>
<span id="cb649-9"><a href="#cb649-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb649-10"><a href="#cb649-10" aria-hidden="true" tabindex="-1"></a><span class="ot">dShow ::</span> <span class="dt">Dict</span> (<span class="dt">Show</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb649-11"><a href="#cb649-11" aria-hidden="true" tabindex="-1"></a>dShow <span class="dt">Dict</span> x <span class="ot">=</span> <span class="fu">show</span> x</span>
<span id="cb649-12"><a href="#cb649-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb649-13"><a href="#cb649-13" aria-hidden="true" tabindex="-1"></a><span class="ot">dEqNum ::</span> <span class="dt">Dict</span> (<span class="dt">Eq</span> a, <span class="dt">Num</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb649-14"><a href="#cb649-14" aria-hidden="true" tabindex="-1"></a>dEqNum <span class="dt">Dict</span> x <span class="ot">=</span> x <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb649-15"><a href="#cb649-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb649-16"><a href="#cb649-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb649-17"><a href="#cb649-17" aria-hidden="true" tabindex="-1"></a><span class="ot">fShow ::</span> <span class="dt">String</span></span>
<span id="cb649-18"><a href="#cb649-18" aria-hidden="true" tabindex="-1"></a>fShow <span class="ot">=</span> dShow <span class="dt">Dict</span> <span class="dv">10</span></span>
<span id="cb649-19"><a href="#cb649-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb649-20"><a href="#cb649-20" aria-hidden="true" tabindex="-1"></a><span class="ot">fEqual ::</span> <span class="dt">Bool</span></span>
<span id="cb649-21"><a href="#cb649-21" aria-hidden="true" tabindex="-1"></a>fEqual <span class="ot">=</span> dEqNum <span class="dt">Dict</span> <span class="dv">0</span></span></code></pre></div>
<h2 id="typefamilydependencies">TypeFamilyDependencies</h2>
<p>Type families historically have not been injective, i.e. they are not
guaranteed to maps distinct elements of its arguments to the same
element of its result. The syntax is similar to the multiparmater
typeclass functional dependencies in that the resulting type is uniquely
determined by a set of the type families parameters.</p>
<div class="sourceCode" id="cb650"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb650-1"><a href="#cb650-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE XTypeFamilyDependencies #-}</span></span>
<span id="cb650-2"><a href="#cb650-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb650-3"><a href="#cb650-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">F</span> a b c <span class="ot">=</span> (<span class="ot">result ::</span> k) <span class="op">|</span> result <span class="ot">-&gt;</span> a b c</span>
<span id="cb650-4"><a href="#cb650-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Int</span>  <span class="dt">Char</span> <span class="dt">Bool</span> <span class="ot">=</span> <span class="dt">Bool</span></span>
<span id="cb650-5"><a href="#cb650-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Char</span> <span class="dt">Bool</span> <span class="dt">Int</span>  <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb650-6"><a href="#cb650-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">F</span> <span class="dt">Bool</span> <span class="dt">Int</span>  <span class="dt">Char</span> <span class="ot">=</span> <span class="dt">Char</span></span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="http://ics.p.lodz.pl/~stolarek/_media/pl:research:stolarek_peyton-jones_eisenberg_injectivity_extended.pdf">Injective
type families for Haskell</a></li>
</ul>
</hr>
<h1 id="promotion">Promotion</h1>
<h2 id="higher-kinded-types">Higher Kinded Types</h2>
<p>What are higher kinded types?</p>
<p>The kind system in Haskell is unique by contrast with most other
languages in that it allows datatypes to be constructed which take types
and type constructor to other types. Such a system is said to support
<em>higher kinded types</em>.</p>
<p>All kind annotations in Haskell necessarily result in a kind
<code>*</code> although any terms to the left may be higher-kinded
(<code>* -&gt; *</code>).</p>
<p>The common example is the Monad which has kind
<code>* -&gt; *</code>. But we have also seen this higher-kindedness in
free monads.</p>
<div class="sourceCode" id="cb651"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb651-1"><a href="#cb651-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Free</span> f a <span class="kw">where</span></span>
<span id="cb651-2"><a href="#cb651-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Pure</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</span>
<span id="cb651-3"><a href="#cb651-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Free</span><span class="ot"> ::</span> f (<span class="dt">Free</span> f a) <span class="ot">-&gt;</span> <span class="dt">Free</span> f a</span>
<span id="cb651-4"><a href="#cb651-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb651-5"><a href="#cb651-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Cofree</span> f a <span class="kw">where</span></span>
<span id="cb651-6"><a href="#cb651-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cofree</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> f (<span class="dt">Cofree</span> f a) <span class="ot">-&gt;</span> <span class="dt">Cofree</span> f a</span></code></pre></div>
<div class="sourceCode" id="cb652"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb652-1"><a href="#cb652-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Free</span><span class="ot"> ::</span> (<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb652-2"><a href="#cb652-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Cofree</span><span class="ot"> ::</span> (<span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span></code></pre></div>
<p>For instance <code>Cofree Maybe a</code> for some monokinded type
<code>a</code> models a non-empty list with
<code>Maybe :: * -&gt; *</code>.</p>
<div class="sourceCode" id="cb653"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb653-1"><a href="#cb653-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Cofree Maybe a is a non-empty list</span></span>
<span id="cb653-2"><a href="#cb653-2" aria-hidden="true" tabindex="-1"></a><span class="ot">testCofree ::</span> <span class="dt">Cofree</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb653-3"><a href="#cb653-3" aria-hidden="true" tabindex="-1"></a>testCofree <span class="ot">=</span> (<span class="dt">Cofree</span> <span class="dv">1</span> (<span class="dt">Just</span> (<span class="dt">Cofree</span> <span class="dv">2</span> <span class="dt">Nothing</span>)))</span></code></pre></div>
<h2 id="kind-polymorphism">Kind Polymorphism</h2>
<p>The regular value level function which takes a function and applies
it to an argument is universally generalized over in the usual
Hindley-Milner way.</p>
<div class="sourceCode" id="cb654"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb654-1"><a href="#cb654-1" aria-hidden="true" tabindex="-1"></a><span class="ot">app ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb654-2"><a href="#cb654-2" aria-hidden="true" tabindex="-1"></a>app f a <span class="ot">=</span> f a</span></code></pre></div>
<p>But when we do the same thing at the type-level we see we lose
information about the polymorphism of the constructor applied.</p>
<div class="sourceCode" id="cb655"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb655-1"><a href="#cb655-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- TApp :: (* -&gt; *) -&gt; * -&gt; *</span></span>
<span id="cb655-2"><a href="#cb655-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TApp</span> f a <span class="ot">=</span> <span class="dt">MkTApp</span> (f a)</span></code></pre></div>
<p>Turning on <code>-XPolyKinds</code> allows polymorphic variables at
the kind level as well.</p>
<div class="sourceCode" id="cb656"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb656-1"><a href="#cb656-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Default:   (* -&gt; *) -&gt; * -&gt; *</span></span>
<span id="cb656-2"><a href="#cb656-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- PolyKinds: (k -&gt; *) -&gt; k -&gt; *</span></span>
<span id="cb656-3"><a href="#cb656-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TApp</span> f a <span class="ot">=</span> <span class="dt">MkTApp</span> (f a)</span>
<span id="cb656-4"><a href="#cb656-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb656-5"><a href="#cb656-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- Default:   ((* -&gt; *) -&gt; (* -&gt; *)) -&gt; (* -&gt; *)</span></span>
<span id="cb656-6"><a href="#cb656-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- PolyKinds: ((k -&gt; *) -&gt; (k -&gt; *)) -&gt; (k -&gt; *)</span></span>
<span id="cb656-7"><a href="#cb656-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Mu</span> f a <span class="ot">=</span> <span class="dt">Roll</span> (f (<span class="dt">Mu</span> f) a)</span>
<span id="cb656-8"><a href="#cb656-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb656-9"><a href="#cb656-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Default:   * -&gt; *</span></span>
<span id="cb656-10"><a href="#cb656-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- PolyKinds: k -&gt; *</span></span>
<span id="cb656-11"><a href="#cb656-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Proxy</span> a <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>Using the polykinded <code>Proxy</code> type allows us to write down
type class functions over constructors of arbitrary kind arity.</p>
<div class="sourceCode" id="cb657"
data-include="src/17-promotion/kindpoly.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb657-1"><a href="#cb657-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb657-2"><a href="#cb657-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb657-3"><a href="#cb657-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb657-4"><a href="#cb657-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb657-5"><a href="#cb657-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Proxy</span> a <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb657-6"><a href="#cb657-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Rep</span> <span class="ot">=</span> <span class="dt">Rep</span></span>
<span id="cb657-7"><a href="#cb657-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb657-8"><a href="#cb657-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">PolyClass</span> a <span class="kw">where</span></span>
<span id="cb657-9"><a href="#cb657-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  foo ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">Rep</span></span>
<span id="cb657-10"><a href="#cb657-10" aria-hidden="true" tabindex="-1"></a>  foo <span class="ot">=</span> <span class="fu">const</span> <span class="dt">Rep</span></span>
<span id="cb657-11"><a href="#cb657-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb657-12"><a href="#cb657-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- () :: *</span></span>
<span id="cb657-13"><a href="#cb657-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- [] :: * -&gt; *</span></span>
<span id="cb657-14"><a href="#cb657-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- Either :: * -&gt; * -&gt; *</span></span>
<span id="cb657-15"><a href="#cb657-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb657-16"><a href="#cb657-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">PolyClass</span> ()</span>
<span id="cb657-17"><a href="#cb657-17" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">PolyClass</span> []</span>
<span id="cb657-18"><a href="#cb657-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">PolyClass</span> <span class="dt">Either</span></span></code></pre></div>
<p>For example we can write down the polymorphic <code>S</code>
<code>K</code> combinators at the type level now.</p>
<div class="sourceCode" id="cb658"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb658-1"><a href="#cb658-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb658-2"><a href="#cb658-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb658-3"><a href="#cb658-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">I</span> (<span class="ot">a ::</span> <span class="op">*</span>) <span class="ot">=</span> <span class="dt">I</span> a</span>
<span id="cb658-4"><a href="#cb658-4" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">K</span> (<span class="ot">a ::</span> <span class="op">*</span>) (<span class="ot">b ::</span> k) <span class="ot">=</span> <span class="dt">K</span> a</span>
<span id="cb658-5"><a href="#cb658-5" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Flip</span> (<span class="ot">f ::</span> k1 <span class="ot">-&gt;</span> k2 <span class="ot">-&gt;</span> <span class="op">*</span>) (<span class="ot">x ::</span> k2) (<span class="ot">y ::</span> k1) <span class="ot">=</span> <span class="dt">Flip</span> (f y x)</span>
<span id="cb658-6"><a href="#cb658-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb658-7"><a href="#cb658-7" aria-hidden="true" tabindex="-1"></a><span class="ot">unI ::</span> <span class="dt">I</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb658-8"><a href="#cb658-8" aria-hidden="true" tabindex="-1"></a>unI (<span class="dt">I</span> x) <span class="ot">=</span> x</span>
<span id="cb658-9"><a href="#cb658-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb658-10"><a href="#cb658-10" aria-hidden="true" tabindex="-1"></a><span class="ot">unK ::</span> <span class="dt">K</span> a b <span class="ot">-&gt;</span> a</span>
<span id="cb658-11"><a href="#cb658-11" aria-hidden="true" tabindex="-1"></a>unK (<span class="dt">K</span> x) <span class="ot">=</span> x</span>
<span id="cb658-12"><a href="#cb658-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb658-13"><a href="#cb658-13" aria-hidden="true" tabindex="-1"></a><span class="ot">unFlip ::</span> <span class="dt">Flip</span> f x y <span class="ot">-&gt;</span> f y x</span>
<span id="cb658-14"><a href="#cb658-14" aria-hidden="true" tabindex="-1"></a>unFlip (<span class="dt">Flip</span> x) <span class="ot">=</span> x</span></code></pre></div>
<h2 id="data-kinds">Data Kinds</h2>
<p>The <code>-XDataKinds</code> extension allows us to refer to
constructors at the value level and the type level. Consider a simple
sum type:</p>
<div class="sourceCode" id="cb659"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb659-1"><a href="#cb659-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">S</span> a b <span class="ot">=</span> <span class="dt">L</span> a <span class="op">|</span> <span class="dt">R</span> b</span>
<span id="cb659-2"><a href="#cb659-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb659-3"><a href="#cb659-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- S :: * -&gt; * -&gt; *</span></span>
<span id="cb659-4"><a href="#cb659-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- L :: a -&gt; S a b</span></span>
<span id="cb659-5"><a href="#cb659-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- R :: b -&gt; S a b</span></span></code></pre></div>
<p>With the extension enabled we see that our type constructors are now
automatically promoted so that <code>L</code> or <code>R</code> can be
viewed as both a data constructor of the type <code>S</code> or as the
type <code>L</code> with kind <code>S</code>.</p>
<div class="sourceCode" id="cb660"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb660-1"><a href="#cb660-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb660-2"><a href="#cb660-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb660-3"><a href="#cb660-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">S</span> a b <span class="ot">=</span> <span class="dt">L</span> a <span class="op">|</span> <span class="dt">R</span> b</span>
<span id="cb660-4"><a href="#cb660-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb660-5"><a href="#cb660-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- S :: * -&gt; * -&gt; *</span></span>
<span id="cb660-6"><a href="#cb660-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- L :: * -&gt; S * *</span></span>
<span id="cb660-7"><a href="#cb660-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- R :: * -&gt; S * *</span></span></code></pre></div>
<p>Promoted data constructors can referred to in type signatures by
prefixing them with a single quote. Also of importance is that these
promoted constructors are not exported with a module by default, but
type synonym instances can be created for the ticked promoted types and
exported directly.</p>
<div class="sourceCode" id="cb661"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb661-1"><a href="#cb661-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Foo</span> <span class="ot">=</span> <span class="dt">Bar</span> <span class="op">|</span> <span class="dt">Baz</span></span>
<span id="cb661-2"><a href="#cb661-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Bar</span> <span class="ot">=</span> <span class="dt">&#39;Bar</span></span>
<span id="cb661-3"><a href="#cb661-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Baz</span> <span class="ot">=</span> <span class="dt">&#39;Baz</span></span></code></pre></div>
<p>Combining this with type families we see we can write meaningful,
type-level functions by lifting types to the kind level.</p>
<div class="sourceCode" id="cb662"
data-include="src/17-promotion/typefamily.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb662-1"><a href="#cb662-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb662-2"><a href="#cb662-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb662-3"><a href="#cb662-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb662-4"><a href="#cb662-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">Bool</span>(..))</span>
<span id="cb662-5"><a href="#cb662-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb662-6"><a href="#cb662-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bool</span> <span class="ot">=</span> <span class="dt">False</span> <span class="op">|</span> <span class="dt">True</span></span>
<span id="cb662-7"><a href="#cb662-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb662-8"><a href="#cb662-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Not</span> (<span class="ot">a ::</span> <span class="dt">Bool</span>)<span class="ot"> ::</span> <span class="dt">Bool</span></span>
<span id="cb662-9"><a href="#cb662-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb662-10"><a href="#cb662-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Not</span> <span class="dt">True</span> <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb662-11"><a href="#cb662-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Not</span> <span class="dt">False</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb662-12"><a href="#cb662-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb662-13"><a href="#cb662-13" aria-hidden="true" tabindex="-1"></a><span class="ot">false ::</span> <span class="dt">Not</span> <span class="dt">True</span> <span class="op">~</span> <span class="dt">False</span> <span class="ot">=&gt;</span> a</span>
<span id="cb662-14"><a href="#cb662-14" aria-hidden="true" tabindex="-1"></a>false <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb662-15"><a href="#cb662-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb662-16"><a href="#cb662-16" aria-hidden="true" tabindex="-1"></a><span class="ot">true ::</span> <span class="dt">Not</span> <span class="dt">False</span> <span class="op">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> a</span>
<span id="cb662-17"><a href="#cb662-17" aria-hidden="true" tabindex="-1"></a>true <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb662-18"><a href="#cb662-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb662-19"><a href="#cb662-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- Fails at compile time.</span></span>
<span id="cb662-20"><a href="#cb662-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- Couldn&#39;t match type &#39;False with &#39;True</span></span>
<span id="cb662-21"><a href="#cb662-21" aria-hidden="true" tabindex="-1"></a><span class="ot">invalid ::</span> <span class="dt">Not</span> <span class="dt">True</span> <span class="op">~</span> <span class="dt">True</span> <span class="ot">=&gt;</span> a</span>
<span id="cb662-22"><a href="#cb662-22" aria-hidden="true" tabindex="-1"></a>invalid <span class="ot">=</span> <span class="fu">undefined</span></span></code></pre></div>
<h2 id="size-indexed-vectors">Size-Indexed Vectors</h2>
<p>Using this new structure we can create a <code>Vec</code> type which
is parameterized by its length as well as its element type now that we
have a kind language rich enough to encode the successor type in the
kind signature of the generalized algebraic datatype.</p>
<div class="sourceCode" id="cb663"
data-include="src/17-promotion/datakinds.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb663-1"><a href="#cb663-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb663-2"><a href="#cb663-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb663-3"><a href="#cb663-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb663-4"><a href="#cb663-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb663-5"><a href="#cb663-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb663-6"><a href="#cb663-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-7"><a href="#cb663-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Z</span> <span class="op">|</span> <span class="dt">S</span> <span class="dt">Nat</span> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb663-8"><a href="#cb663-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-9"><a href="#cb663-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Zero</span>  <span class="ot">=</span> <span class="dt">Z</span></span>
<span id="cb663-10"><a href="#cb663-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">One</span>   <span class="ot">=</span> <span class="dt">S</span> <span class="dt">Zero</span></span>
<span id="cb663-11"><a href="#cb663-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Two</span>   <span class="ot">=</span> <span class="dt">S</span> <span class="dt">One</span></span>
<span id="cb663-12"><a href="#cb663-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Three</span> <span class="ot">=</span> <span class="dt">S</span> <span class="dt">Two</span></span>
<span id="cb663-13"><a href="#cb663-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Four</span>  <span class="ot">=</span> <span class="dt">S</span> <span class="dt">Three</span></span>
<span id="cb663-14"><a href="#cb663-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Five</span>  <span class="ot">=</span> <span class="dt">S</span> <span class="dt">Four</span></span>
<span id="cb663-15"><a href="#cb663-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-16"><a href="#cb663-16" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb663-17"><a href="#cb663-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Vec</span> <span class="dt">Z</span> a</span>
<span id="cb663-18"><a href="#cb663-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dt">S</span> n) a</span>
<span id="cb663-19"><a href="#cb663-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-20"><a href="#cb663-20" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Vec</span> n a) <span class="kw">where</span></span>
<span id="cb663-21"><a href="#cb663-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> <span class="dt">Nil</span>         <span class="ot">=</span> <span class="st">&quot;Nil&quot;</span></span>
<span id="cb663-22"><a href="#cb663-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Cons</span> x xs) <span class="ot">=</span> <span class="st">&quot;Cons &quot;</span> <span class="op">++</span> <span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot; (&quot;</span> <span class="op">++</span> <span class="fu">show</span> xs <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb663-23"><a href="#cb663-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-24"><a href="#cb663-24" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">FromList</span> n <span class="kw">where</span></span>
<span id="cb663-25"><a href="#cb663-25" aria-hidden="true" tabindex="-1"></a><span class="ot">  fromList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a</span>
<span id="cb663-26"><a href="#cb663-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-27"><a href="#cb663-27" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromList</span> <span class="dt">Z</span> <span class="kw">where</span></span>
<span id="cb663-28"><a href="#cb663-28" aria-hidden="true" tabindex="-1"></a>  fromList [] <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb663-29"><a href="#cb663-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-30"><a href="#cb663-30" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromList</span> n <span class="ot">=&gt;</span> <span class="dt">FromList</span> (<span class="dt">S</span> n) <span class="kw">where</span></span>
<span id="cb663-31"><a href="#cb663-31" aria-hidden="true" tabindex="-1"></a>  fromList (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Cons</span> x <span class="op">$</span> fromList xs</span>
<span id="cb663-32"><a href="#cb663-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-33"><a href="#cb663-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-34"><a href="#cb663-34" aria-hidden="true" tabindex="-1"></a><span class="ot">lengthVec ::</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb663-35"><a href="#cb663-35" aria-hidden="true" tabindex="-1"></a>lengthVec <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">Z</span></span>
<span id="cb663-36"><a href="#cb663-36" aria-hidden="true" tabindex="-1"></a>lengthVec (<span class="dt">Cons</span> x xs) <span class="ot">=</span> <span class="dt">S</span> (lengthVec xs)</span>
<span id="cb663-37"><a href="#cb663-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-38"><a href="#cb663-38" aria-hidden="true" tabindex="-1"></a><span class="ot">zipVec ::</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n b <span class="ot">-&gt;</span> <span class="dt">Vec</span> n (a,b)</span>
<span id="cb663-39"><a href="#cb663-39" aria-hidden="true" tabindex="-1"></a>zipVec <span class="dt">Nil</span> <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb663-40"><a href="#cb663-40" aria-hidden="true" tabindex="-1"></a>zipVec (<span class="dt">Cons</span> x xs) (<span class="dt">Cons</span> y ys) <span class="ot">=</span> <span class="dt">Cons</span> (x,y) (zipVec xs ys)</span>
<span id="cb663-41"><a href="#cb663-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-42"><a href="#cb663-42" aria-hidden="true" tabindex="-1"></a><span class="ot">vec4 ::</span> <span class="dt">Vec</span> <span class="dt">Four</span> <span class="dt">Int</span></span>
<span id="cb663-43"><a href="#cb663-43" aria-hidden="true" tabindex="-1"></a>vec4 <span class="ot">=</span> fromList [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb663-44"><a href="#cb663-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-45"><a href="#cb663-45" aria-hidden="true" tabindex="-1"></a><span class="ot">vec5 ::</span> <span class="dt">Vec</span> <span class="dt">Five</span> <span class="dt">Int</span></span>
<span id="cb663-46"><a href="#cb663-46" aria-hidden="true" tabindex="-1"></a>vec5 <span class="ot">=</span> fromList [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb663-47"><a href="#cb663-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-48"><a href="#cb663-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-49"><a href="#cb663-49" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Nat</span></span>
<span id="cb663-50"><a href="#cb663-50" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> lengthVec vec4</span>
<span id="cb663-51"><a href="#cb663-51" aria-hidden="true" tabindex="-1"></a><span class="co">-- S (S (S (S Z)))</span></span>
<span id="cb663-52"><a href="#cb663-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb663-53"><a href="#cb663-53" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Vec</span> <span class="dt">Four</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb663-54"><a href="#cb663-54" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> zipVec vec4 vec4</span>
<span id="cb663-55"><a href="#cb663-55" aria-hidden="true" tabindex="-1"></a><span class="co">-- Cons (0,0) (Cons (1,1) (Cons (2,2) (Cons (3,3) (Nil))))</span></span></code></pre></div>
<p>So now if we try to zip two <code>Vec</code> types with the wrong
shape then we get an error at compile-time about the off-by-one
error.</p>
<div class="sourceCode" id="cb664"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb664-1"><a href="#cb664-1" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> zipVec vec4 vec5</span>
<span id="cb664-2"><a href="#cb664-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- Couldn&#39;t match type &#39;S &#39;Z with &#39;Z</span></span>
<span id="cb664-3"><a href="#cb664-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Expected type: Vec Four Int</span></span>
<span id="cb664-4"><a href="#cb664-4" aria-hidden="true" tabindex="-1"></a><span class="co">--   Actual type: Vec Five Int</span></span></code></pre></div>
<p>The same technique we can use to create a container which is
statically indexed by an empty or non-empty flag, such that if we try to
take the head of an empty list we’ll get a compile-time error, or stated
equivalently we have an obligation to prove to the compiler that the
argument we hand to the head function is non-empty.</p>
<div class="sourceCode" id="cb665"
data-include="src/17-promotion/nonempty.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb665-1"><a href="#cb665-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb665-2"><a href="#cb665-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb665-3"><a href="#cb665-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb665-4"><a href="#cb665-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb665-5"><a href="#cb665-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb665-6"><a href="#cb665-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb665-7"><a href="#cb665-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Size</span> <span class="ot">=</span> <span class="dt">Empty</span> <span class="op">|</span> <span class="dt">NonEmpty</span></span>
<span id="cb665-8"><a href="#cb665-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb665-9"><a href="#cb665-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">List</span> a b <span class="kw">where</span></span>
<span id="cb665-10"><a href="#cb665-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">List</span> <span class="dt">Empty</span> a</span>
<span id="cb665-11"><a href="#cb665-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">List</span> b a <span class="ot">-&gt;</span> <span class="dt">List</span> <span class="dt">NonEmpty</span> a</span>
<span id="cb665-12"><a href="#cb665-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb665-13"><a href="#cb665-13" aria-hidden="true" tabindex="-1"></a><span class="ot">head&#39; ::</span> <span class="dt">List</span> <span class="dt">NonEmpty</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb665-14"><a href="#cb665-14" aria-hidden="true" tabindex="-1"></a>head&#39; (<span class="dt">Cons</span> x _) <span class="ot">=</span> x</span>
<span id="cb665-15"><a href="#cb665-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb665-16"><a href="#cb665-16" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Int</span></span>
<span id="cb665-17"><a href="#cb665-17" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> head&#39; (<span class="dv">1</span> <span class="ot">`Cons`</span> (<span class="dv">2</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>))</span>
<span id="cb665-18"><a href="#cb665-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb665-19"><a href="#cb665-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- Cannot match type Empty with NonEmpty</span></span>
<span id="cb665-20"><a href="#cb665-20" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Int</span></span>
<span id="cb665-21"><a href="#cb665-21" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> head&#39; <span class="dt">Nil</span></span></code></pre></div>
<div class="sourceCode" id="cb666"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb666-1"><a href="#cb666-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> <span class="dt">None</span> with <span class="dt">Many</span></span>
<span id="cb666-2"><a href="#cb666-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Expected</span> <span class="kw">type</span><span class="op">:</span> <span class="dt">List</span> <span class="dt">NonEmpty</span> <span class="dt">Int</span></span>
<span id="cb666-3"><a href="#cb666-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Actual</span> <span class="kw">type</span><span class="op">:</span> <span class="dt">List</span> <span class="dt">Empty</span> <span class="dt">Int</span></span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="https://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf">Giving
Haskell a Promotion</a></li>
</ul>
<h2 id="typelevel-numbers">Typelevel Numbers</h2>
<p>GHC’s type literals can also be used in place of explicit Peano
arithmetic.</p>
<p>GHC 7.6 is very conservative about performing reduction, GHC 7.8 is
much less so and will can solve many typelevel constraints involving
natural numbers but sometimes still needs a little coaxing.</p>
<div class="sourceCode" id="cb667"
data-include="src/17-promotion/typenat.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb667-1"><a href="#cb667-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb667-2"><a href="#cb667-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb667-3"><a href="#cb667-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb667-4"><a href="#cb667-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb667-5"><a href="#cb667-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb667-6"><a href="#cb667-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb667-7"><a href="#cb667-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb667-8"><a href="#cb667-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb667-9"><a href="#cb667-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Vec</span> <span class="dv">0</span> a</span>
<span id="cb667-10"><a href="#cb667-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> n a <span class="ot">-&gt;</span> <span class="dt">Vec</span> (<span class="dv">1</span> <span class="op">+</span> n) a</span>
<span id="cb667-11"><a href="#cb667-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb667-12"><a href="#cb667-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- GHC 7.6 will not reduce</span></span>
<span id="cb667-13"><a href="#cb667-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- vec3 :: Vec (1 + (1 + (1 + 0))) Int</span></span>
<span id="cb667-14"><a href="#cb667-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb667-15"><a href="#cb667-15" aria-hidden="true" tabindex="-1"></a><span class="ot">vec3 ::</span> <span class="dt">Vec</span> <span class="dv">3</span> <span class="dt">Int</span></span>
<span id="cb667-16"><a href="#cb667-16" aria-hidden="true" tabindex="-1"></a>vec3 <span class="ot">=</span> <span class="dv">0</span> <span class="ot">`Cons`</span> (<span class="dv">1</span> <span class="ot">`Cons`</span> (<span class="dv">2</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>))</span></code></pre></div>
<div class="sourceCode" id="cb668"
data-include="src/17-promotion/typenat_cmp.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb668-1"><a href="#cb668-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb668-2"><a href="#cb668-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb668-3"><a href="#cb668-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb668-4"><a href="#cb668-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb668-5"><a href="#cb668-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb668-6"><a href="#cb668-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb668-7"><a href="#cb668-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb668-8"><a href="#cb668-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb668-9"><a href="#cb668-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb668-10"><a href="#cb668-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Foo</span><span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb668-11"><a href="#cb668-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Small</span><span class="ot">    ::</span> (n <span class="op">&lt;=</span> <span class="dv">2</span>)  <span class="ot">=&gt;</span> <span class="dt">Foo</span> n</span>
<span id="cb668-12"><a href="#cb668-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Big</span><span class="ot">      ::</span> (<span class="dv">3</span> <span class="op">&lt;=</span> n) <span class="ot">=&gt;</span> <span class="dt">Foo</span> n</span>
<span id="cb668-13"><a href="#cb668-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb668-14"><a href="#cb668-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Empty</span><span class="ot">    ::</span> ((n <span class="op">==</span> <span class="dv">0</span>) <span class="op">~</span> <span class="dt">True</span>) <span class="ot">=&gt;</span> <span class="dt">Foo</span> n</span>
<span id="cb668-15"><a href="#cb668-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">NonEmpty</span><span class="ot"> ::</span> ((n <span class="op">==</span> <span class="dv">0</span>) <span class="op">~</span> <span class="dt">False</span>) <span class="ot">=&gt;</span> <span class="dt">Foo</span> n</span>
<span id="cb668-16"><a href="#cb668-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb668-17"><a href="#cb668-17" aria-hidden="true" tabindex="-1"></a><span class="ot">big ::</span> <span class="dt">Foo</span> <span class="dv">10</span></span>
<span id="cb668-18"><a href="#cb668-18" aria-hidden="true" tabindex="-1"></a>big <span class="ot">=</span> <span class="dt">Big</span></span>
<span id="cb668-19"><a href="#cb668-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb668-20"><a href="#cb668-20" aria-hidden="true" tabindex="-1"></a><span class="ot">small ::</span> <span class="dt">Foo</span> <span class="dv">2</span></span>
<span id="cb668-21"><a href="#cb668-21" aria-hidden="true" tabindex="-1"></a>small <span class="ot">=</span> <span class="dt">Small</span></span>
<span id="cb668-22"><a href="#cb668-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb668-23"><a href="#cb668-23" aria-hidden="true" tabindex="-1"></a><span class="ot">empty ::</span> <span class="dt">Foo</span> <span class="dv">0</span></span>
<span id="cb668-24"><a href="#cb668-24" aria-hidden="true" tabindex="-1"></a>empty <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb668-25"><a href="#cb668-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb668-26"><a href="#cb668-26" aria-hidden="true" tabindex="-1"></a><span class="ot">nonempty ::</span> <span class="dt">Foo</span> <span class="dv">3</span></span>
<span id="cb668-27"><a href="#cb668-27" aria-hidden="true" tabindex="-1"></a>nonempty <span class="ot">=</span> <span class="dt">NonEmpty</span></span></code></pre></div>
<p>See: <a
href="http://www.haskell.org/ghc/docs/7.8.2/html/users_guide/type-level-literals.html">Type-Level
Literals</a></p>
<h2 id="typelevel-strings">Typelevel Strings</h2>
<p>Since GHC 8.0 we have been able to work with typelevel strings values
represented at the typelevel as <code>Symbol</code> with kind
<code>Symbol</code>. The <code>GHC.TypeLits</code> module defines a set
of a typeclases for lifting these values to and from the value level and
comparing and computing over the values at typelevel.</p>
<div class="sourceCode" id="cb669"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb669-1"><a href="#cb669-1" aria-hidden="true" tabindex="-1"></a><span class="ot">symbolVal ::</span> <span class="kw">forall</span> n proxy<span class="op">.</span> <span class="dt">KnownSymbol</span> n <span class="ot">=&gt;</span> proxy n <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb669-2"><a href="#cb669-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">AppendSymbol</span> (<span class="ot">m ::</span> <span class="dt">Symbol</span>) (<span class="ot">n ::</span> <span class="dt">Symbol</span>)<span class="ot"> ::</span> <span class="dt">Symbol</span></span>
<span id="cb669-3"><a href="#cb669-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">CmpSymbol</span> (<span class="ot">m ::</span> <span class="dt">Symbol</span>) (<span class="ot">n ::</span> <span class="dt">Symbol</span>)<span class="ot"> ::</span> <span class="dt">Ordering</span></span>
<span id="cb669-4"><a href="#cb669-4" aria-hidden="true" tabindex="-1"></a><span class="ot">sameSymbol ::</span> (<span class="dt">KnownSymbol</span> a, <span class="dt">KnownSymbol</span> b) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">Proxy</span> b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a <span class="op">:~:</span> b)</span></code></pre></div>
<p>These can be used to tag specific data at the typelevel with
compile-time information encoded in the strings. For example we can
construct a simple unit system which allows us to attach units to
numerical quantities and perform basic dimensional analysis.</p>
<div class="sourceCode" id="cb670"
data-include="src/17-promotion/typelevel_strings.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb670-1"><a href="#cb670-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb670-2"><a href="#cb670-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb670-3"><a href="#cb670-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb670-4"><a href="#cb670-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb670-5"><a href="#cb670-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb670-6"><a href="#cb670-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb670-7"><a href="#cb670-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb670-8"><a href="#cb670-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tagged</span> (<span class="ot">l ::</span> <span class="dt">Symbol</span>) a <span class="ot">=</span> <span class="dt">Tag</span> a</span>
<span id="cb670-9"><a href="#cb670-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb670-10"><a href="#cb670-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb670-11"><a href="#cb670-11" aria-hidden="true" tabindex="-1"></a><span class="ot">m ::</span> <span class="dt">Tagged</span> <span class="st">&quot;m&quot;</span> <span class="dt">Double</span></span>
<span id="cb670-12"><a href="#cb670-12" aria-hidden="true" tabindex="-1"></a>m <span class="ot">=</span> <span class="dt">Tag</span> <span class="fl">10.0</span></span>
<span id="cb670-13"><a href="#cb670-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb670-14"><a href="#cb670-14" aria-hidden="true" tabindex="-1"></a><span class="ot">s ::</span> <span class="dt">Tagged</span> <span class="st">&quot;s&quot;</span> <span class="dt">Double</span></span>
<span id="cb670-15"><a href="#cb670-15" aria-hidden="true" tabindex="-1"></a>s <span class="ot">=</span> <span class="dt">Tag</span> <span class="fl">20.0</span></span>
<span id="cb670-16"><a href="#cb670-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb670-17"><a href="#cb670-17" aria-hidden="true" tabindex="-1"></a><span class="ot">divUnits ::</span></span>
<span id="cb670-18"><a href="#cb670-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Fractional</span> a <span class="ot">=&gt;</span></span>
<span id="cb670-19"><a href="#cb670-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tagged</span> u1 a <span class="ot">-&gt;</span></span>
<span id="cb670-20"><a href="#cb670-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tagged</span> u2 a <span class="ot">-&gt;</span></span>
<span id="cb670-21"><a href="#cb670-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tagged</span> (u1 <span class="ot">`AppendSymbol`</span> u2) a</span>
<span id="cb670-22"><a href="#cb670-22" aria-hidden="true" tabindex="-1"></a>divUnits (<span class="dt">Tag</span> x) (<span class="dt">Tag</span> y) <span class="ot">=</span> <span class="dt">Tag</span> (x <span class="op">/</span> y)</span>
<span id="cb670-23"><a href="#cb670-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb670-24"><a href="#cb670-24" aria-hidden="true" tabindex="-1"></a><span class="ot">addUnits ::</span></span>
<span id="cb670-25"><a href="#cb670-25" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Num</span> a, u1 <span class="ot">`CmpSymbol`</span> u2 <span class="op">~</span> <span class="dt">&#39;EQ</span>) <span class="ot">=&gt;</span></span>
<span id="cb670-26"><a href="#cb670-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tagged</span> u1 a <span class="ot">-&gt;</span></span>
<span id="cb670-27"><a href="#cb670-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tagged</span> u2 a <span class="ot">-&gt;</span></span>
<span id="cb670-28"><a href="#cb670-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tagged</span> u1 a</span>
<span id="cb670-29"><a href="#cb670-29" aria-hidden="true" tabindex="-1"></a>addUnits (<span class="dt">Tag</span> x) (<span class="dt">Tag</span> y) <span class="ot">=</span> <span class="dt">Tag</span> (x <span class="op">+</span> y)</span></code></pre></div>
<h2 id="custom-errors">Custom Errors</h2>
<p>As of GHC 8.0 we have the capacity to provide custom type error using
type families. The messages themselves hook into GHC and are expressed
using the small datatype found in <code>GHC.TypeLits</code></p>
<div class="sourceCode" id="cb671"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb671-1"><a href="#cb671-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ErrorMessage</span> <span class="kw">where</span></span>
<span id="cb671-2"><a href="#cb671-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Text</span><span class="ot"> ::</span> <span class="dt">Symbol</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span></span>
<span id="cb671-3"><a href="#cb671-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ShowType</span><span class="ot"> ::</span> t <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span></span>
<span id="cb671-4"><a href="#cb671-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb671-5"><a href="#cb671-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Put two messages next to each other</span></span>
<span id="cb671-6"><a href="#cb671-6" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:&lt;&gt;:) ::</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span></span>
<span id="cb671-7"><a href="#cb671-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb671-8"><a href="#cb671-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Put two messages on top of each other</span></span>
<span id="cb671-9"><a href="#cb671-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:$$:) ::</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span> <span class="ot">-&gt;</span> <span class="dt">ErrorMessage</span></span></code></pre></div>
<p>If one of these expressions is found in the signature of an
expression GHC reports an error message of the form:</p>
<div class="sourceCode" id="cb672"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb672-1"><a href="#cb672-1" aria-hidden="true" tabindex="-1"></a>example<span class="op">.</span>hs<span class="op">:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="fu">error</span><span class="op">:</span></span>
<span id="cb672-2"><a href="#cb672-2" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">My</span> custom <span class="fu">error</span> message line <span class="dv">1</span><span class="op">.</span></span>
<span id="cb672-3"><a href="#cb672-3" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">My</span> custom <span class="fu">error</span> message line <span class="dv">2</span><span class="op">.</span></span>
<span id="cb672-4"><a href="#cb672-4" aria-hidden="true" tabindex="-1"></a>    • <span class="dt">In</span> the expression<span class="op">:</span> example</span>
<span id="cb672-5"><a href="#cb672-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">In</span> an equation for ‘foo’<span class="op">:</span> foo <span class="ot">=</span> <span class="dt">ECoerce</span> (<span class="dt">EFloat</span> <span class="dv">3</span>) (<span class="dt">EInt</span> <span class="dv">4</span>)</span></code></pre></div>
<div class="sourceCode" id="cb673"
data-include="src/17-promotion/errors.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb673-1"><a href="#cb673-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb673-2"><a href="#cb673-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb673-3"><a href="#cb673-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb673-4"><a href="#cb673-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb673-5"><a href="#cb673-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb673-6"><a href="#cb673-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb673-7"><a href="#cb673-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span><span class="co">-- Error Message</span></span>
<span id="cb673-8"><a href="#cb673-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb673-9"><a href="#cb673-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TypeError</span></span>
<span id="cb673-10"><a href="#cb673-10" aria-hidden="true" tabindex="-1"></a>    ( <span class="dt">Text</span> <span class="st">&quot;Equality is not defined for functions&quot;</span></span>
<span id="cb673-11"><a href="#cb673-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">:$$:</span> (<span class="dt">ShowType</span> a <span class="op">:&lt;&gt;:</span> <span class="dt">Text</span> <span class="st">&quot; -&gt; &quot;</span> <span class="op">:&lt;&gt;:</span> <span class="dt">ShowType</span> b)</span>
<span id="cb673-12"><a href="#cb673-12" aria-hidden="true" tabindex="-1"></a>    ) <span class="ot">=&gt;</span></span>
<span id="cb673-13"><a href="#cb673-13" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Instance head</span></span>
<span id="cb673-14"><a href="#cb673-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Eq</span> (a <span class="ot">-&gt;</span> b)</span>
<span id="cb673-15"><a href="#cb673-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb673-16"><a href="#cb673-16" aria-hidden="true" tabindex="-1"></a>  (<span class="op">==</span>) <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb673-17"><a href="#cb673-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb673-18"><a href="#cb673-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- Fail when we try to equate two functions</span></span>
<span id="cb673-19"><a href="#cb673-19" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="fu">id</span> <span class="op">==</span> <span class="fu">id</span></span></code></pre></div>
<p>A less contrived example would be creating a type-safe embedded DSL
that enforces invariants about the semantics at the type-level. We’ve
been able to do this sort of thing using GADTs and type-families for a
while but the error reporting has been horrible. With 8.0 we can have
type-families that emit useful type errors that reflect what actually
goes wrong and integrate this inside of GHC.</p>
<div class="sourceCode" id="cb674"
data-include="src/17-promotion/errors_dsl.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb674-1"><a href="#cb674-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb674-2"><a href="#cb674-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb674-3"><a href="#cb674-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb674-4"><a href="#cb674-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb674-5"><a href="#cb674-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb674-6"><a href="#cb674-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb674-7"><a href="#cb674-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb674-8"><a href="#cb674-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb674-9"><a href="#cb674-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Coerce</span> a b <span class="kw">where</span></span>
<span id="cb674-10"><a href="#cb674-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Coerce</span> <span class="dt">Int</span> <span class="dt">Int</span>     <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb674-11"><a href="#cb674-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Coerce</span> <span class="dt">Float</span> <span class="dt">Float</span> <span class="ot">=</span> <span class="dt">Float</span></span>
<span id="cb674-12"><a href="#cb674-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Coerce</span> <span class="dt">Int</span> <span class="dt">Float</span>   <span class="ot">=</span> <span class="dt">Float</span></span>
<span id="cb674-13"><a href="#cb674-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Coerce</span> <span class="dt">Float</span> <span class="dt">Int</span>   <span class="ot">=</span> <span class="dt">TypeError</span> (<span class="dt">Text</span> <span class="st">&quot;Cannot cast to smaller type&quot;</span>)</span>
<span id="cb674-14"><a href="#cb674-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb674-15"><a href="#cb674-15" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> a <span class="kw">where</span></span>
<span id="cb674-16"><a href="#cb674-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EInt</span><span class="ot">    ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Int</span></span>
<span id="cb674-17"><a href="#cb674-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EFloat</span><span class="ot">  ::</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="dt">Float</span></span>
<span id="cb674-18"><a href="#cb674-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ECoerce</span><span class="ot"> ::</span> <span class="dt">Expr</span> b <span class="ot">-&gt;</span> <span class="dt">Expr</span> c <span class="ot">-&gt;</span> <span class="dt">Expr</span> (<span class="dt">Coerce</span> b c)</span>
<span id="cb674-19"><a href="#cb674-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb674-20"><a href="#cb674-20" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> <span class="dt">Expr</span> <span class="dt">Int</span></span>
<span id="cb674-21"><a href="#cb674-21" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> <span class="dt">ECoerce</span> (<span class="dt">EFloat</span> <span class="dv">3</span>) (<span class="dt">EInt</span> <span class="dv">4</span>)</span></code></pre></div>
<h2 id="type-equality">Type Equality</h2>
<p>Continuing with the theme of building more elaborate proofs in
Haskell, GHC 7.8 recently shipped with the
<code>Data.Type.Equality</code> module which provides us with an
extended set of type-level operations for expressing the equality of
types as values, constraints, and promoted booleans.</p>
<div class="sourceCode" id="cb675"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb675-1"><a href="#cb675-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(~)   ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb675-2"><a href="#cb675-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(==)  ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb675-3"><a href="#cb675-3" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;=)  ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Constraint</span></span>
<span id="cb675-4"><a href="#cb675-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;=?) ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb675-5"><a href="#cb675-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(+)   ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb675-6"><a href="#cb675-6" aria-hidden="true" tabindex="-1"></a><span class="ot">(-)   ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb675-7"><a href="#cb675-7" aria-hidden="true" tabindex="-1"></a><span class="ot">(*)   ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb675-8"><a href="#cb675-8" aria-hidden="true" tabindex="-1"></a><span class="ot">(^)   ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span></span></code></pre></div>
<div class="sourceCode" id="cb676"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb676-1"><a href="#cb676-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(:~:)     ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb676-2"><a href="#cb676-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Refl</span><span class="ot">      ::</span> a1 <span class="op">:~:</span> a1</span>
<span id="cb676-3"><a href="#cb676-3" aria-hidden="true" tabindex="-1"></a><span class="ot">sym       ::</span> (a <span class="op">:~:</span> b) <span class="ot">-&gt;</span> b <span class="op">:~:</span> a</span>
<span id="cb676-4"><a href="#cb676-4" aria-hidden="true" tabindex="-1"></a><span class="ot">trans     ::</span> (a <span class="op">:~:</span> b) <span class="ot">-&gt;</span> (b <span class="op">:~:</span> c) <span class="ot">-&gt;</span> a <span class="op">:~:</span> c</span>
<span id="cb676-5"><a href="#cb676-5" aria-hidden="true" tabindex="-1"></a><span class="ot">castWith  ::</span> (a <span class="op">:~:</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb676-6"><a href="#cb676-6" aria-hidden="true" tabindex="-1"></a><span class="ot">gcastWith ::</span> (a <span class="op">:~:</span> b) <span class="ot">-&gt;</span> (a <span class="op">~</span> b <span class="ot">=&gt;</span> r) <span class="ot">-&gt;</span> r</span></code></pre></div>
<p>With this we have a much stronger language for writing restrictions
that can be checked at a compile-time, and a mechanism that will later
allow us to write more advanced proofs.</p>
<div class="sourceCode" id="cb677"
data-include="src/17-promotion/type_equality.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb677-1"><a href="#cb677-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb677-2"><a href="#cb677-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb677-3"><a href="#cb677-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb677-4"><a href="#cb677-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb677-5"><a href="#cb677-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb677-6"><a href="#cb677-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb677-7"><a href="#cb677-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb677-8"><a href="#cb677-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb677-9"><a href="#cb677-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Not</span> a b <span class="ot">=</span> ((b <span class="op">==</span> a) <span class="op">~</span> <span class="dt">False</span>)</span>
<span id="cb677-10"><a href="#cb677-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb677-11"><a href="#cb677-11" aria-hidden="true" tabindex="-1"></a><span class="ot">restrictUnit ::</span> <span class="dt">Not</span> () a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb677-12"><a href="#cb677-12" aria-hidden="true" tabindex="-1"></a>restrictUnit <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb677-13"><a href="#cb677-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb677-14"><a href="#cb677-14" aria-hidden="true" tabindex="-1"></a><span class="ot">restrictChar ::</span> <span class="dt">Not</span> <span class="dt">Char</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb677-15"><a href="#cb677-15" aria-hidden="true" tabindex="-1"></a>restrictChar <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<h2 id="proxies">Proxies</h2>
<p>Using kind polymorphism with phantom types allows us to express the
Proxy type which is inhabited by a single constructor with no arguments
but with a polykinded phantom type variable which carries an arbitrary
type.</p>
<div class="sourceCode" id="cb678"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb678-1"><a href="#cb678-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb678-2"><a href="#cb678-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb678-3"><a href="#cb678-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A concrete, poly-kinded proxy type</span></span>
<span id="cb678-4"><a href="#cb678-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Proxy</span> t <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<div class="sourceCode" id="cb679"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb679-1"><a href="#cb679-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb679-2"><a href="#cb679-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb679-3"><a href="#cb679-3" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Proxy</span> ()</span>
<span id="cb679-4"><a href="#cb679-4" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb679-5"><a href="#cb679-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb679-6"><a href="#cb679-6" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">Proxy</span> <span class="dv">3</span></span>
<span id="cb679-7"><a href="#cb679-7" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb679-8"><a href="#cb679-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb679-9"><a href="#cb679-9" aria-hidden="true" tabindex="-1"></a><span class="ot">c ::</span> <span class="dt">Proxy</span> <span class="st">&quot;symbol&quot;</span></span>
<span id="cb679-10"><a href="#cb679-10" aria-hidden="true" tabindex="-1"></a>c <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb679-11"><a href="#cb679-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb679-12"><a href="#cb679-12" aria-hidden="true" tabindex="-1"></a><span class="ot">d ::</span> <span class="dt">Proxy</span> <span class="dt">Maybe</span></span>
<span id="cb679-13"><a href="#cb679-13" aria-hidden="true" tabindex="-1"></a>d <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb679-14"><a href="#cb679-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb679-15"><a href="#cb679-15" aria-hidden="true" tabindex="-1"></a><span class="ot">e ::</span> <span class="dt">Proxy</span> (<span class="dt">Maybe</span> ())</span>
<span id="cb679-16"><a href="#cb679-16" aria-hidden="true" tabindex="-1"></a>e <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>In cases where we’d normally pass around a <code>undefined</code> as
a witness of a typeclass dictionary, we can instead pass a Proxy object
which carries the phantom type without the need for the bottom. Using
scoped type variables we can then operate with the phantom parameter and
manipulate wherever is needed.</p>
<div class="sourceCode" id="cb680"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb680-1"><a href="#cb680-1" aria-hidden="true" tabindex="-1"></a><span class="ot">t1 ::</span> a</span>
<span id="cb680-2"><a href="#cb680-2" aria-hidden="true" tabindex="-1"></a>t1 <span class="ot">=</span> (<span class="fu">undefined</span><span class="ot"> ::</span> a)</span>
<span id="cb680-3"><a href="#cb680-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb680-4"><a href="#cb680-4" aria-hidden="true" tabindex="-1"></a><span class="ot">t2 ::</span> <span class="dt">Proxy</span> a</span>
<span id="cb680-5"><a href="#cb680-5" aria-hidden="true" tabindex="-1"></a>t2 <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a</span></code></pre></div>
<h2 id="promoted-syntax">Promoted Syntax</h2>
<p>We’ve seen constructors promoted using DataKinds, but just like at
the value-level GHC also allows us some syntactic sugar for list and
tuples instead of explicit cons’ing and pair’ing. This is enabled with
the <code>-XTypeOperators</code> extension, which introduces list syntax
and tuples of arbitrary arity at the type-level.</p>
<div class="sourceCode" id="cb681"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb681-1"><a href="#cb681-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">HList</span><span class="ot"> ::</span> [<span class="op">*</span>] <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb681-2"><a href="#cb681-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">HNil</span><span class="ot">  ::</span> <span class="dt">HList</span> &#39;[]</span>
<span id="cb681-3"><a href="#cb681-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">HCons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">HList</span> t <span class="ot">-&gt;</span> <span class="dt">HList</span> (a &#39;<span class="op">:</span> t)</span>
<span id="cb681-4"><a href="#cb681-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb681-5"><a href="#cb681-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Tuple</span><span class="ot"> ::</span> (<span class="op">*</span>,<span class="op">*</span>) <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb681-6"><a href="#cb681-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Tuple</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Tuple</span> &#39;(a,b)</span></code></pre></div>
<p>Using this we can construct all variety of composite type-level
objects.</p>
<div class="sourceCode" id="cb682"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb682-1"><a href="#cb682-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind <span class="dv">1</span></span>
<span id="cb682-2"><a href="#cb682-2" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb682-3"><a href="#cb682-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb682-4"><a href="#cb682-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind <span class="st">&quot;foo&quot;</span></span>
<span id="cb682-5"><a href="#cb682-5" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;foo&quot;</span><span class="ot"> ::</span> <span class="dt">Symbol</span></span>
<span id="cb682-6"><a href="#cb682-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb682-7"><a href="#cb682-7" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb682-8"><a href="#cb682-8" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Nat</span>]</span>
<span id="cb682-9"><a href="#cb682-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb682-10"><a href="#cb682-10" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind [<span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Char</span>]</span>
<span id="cb682-11"><a href="#cb682-11" aria-hidden="true" tabindex="-1"></a>[<span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Char</span>]<span class="ot"> ::</span> [<span class="op">*</span>]</span>
<span id="cb682-12"><a href="#cb682-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb682-13"><a href="#cb682-13" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind <span class="dt">Just</span> [<span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Char</span>]</span>
<span id="cb682-14"><a href="#cb682-14" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> [<span class="dt">Int</span>, <span class="dt">Bool</span>, <span class="dt">Char</span>]<span class="ot"> ::</span> <span class="dt">Maybe</span> [<span class="op">*</span>]</span>
<span id="cb682-15"><a href="#cb682-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb682-16"><a href="#cb682-16" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind &#39;(<span class="st">&quot;a&quot;</span>, <span class="dt">Int</span>)</span>
<span id="cb682-17"><a href="#cb682-17" aria-hidden="true" tabindex="-1"></a>(,) <span class="dt">Symbol</span> <span class="op">*</span></span>
<span id="cb682-18"><a href="#cb682-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb682-19"><a href="#cb682-19" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind [ &#39;(<span class="st">&quot;a&quot;</span>, <span class="dt">Int</span>), &#39;(<span class="st">&quot;b&quot;</span>, <span class="dt">Bool</span>) ]</span>
<span id="cb682-20"><a href="#cb682-20" aria-hidden="true" tabindex="-1"></a>[ &#39;(<span class="st">&quot;a&quot;</span>, <span class="dt">Int</span>), &#39;(<span class="st">&quot;b&quot;</span>, <span class="dt">Bool</span>) ]<span class="ot"> ::</span> [(,) <span class="dt">Symbol</span> <span class="op">*</span>]</span></code></pre></div>
<h2 id="singleton-types">Singleton Types</h2>
<p>A singleton type is a type with a single value inhabitant. Singleton
types can be constructed in a variety of ways using GADTs or with data
families.</p>
<div class="sourceCode" id="cb683"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb683-1"><a href="#cb683-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb683-2"><a href="#cb683-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SZ</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">&#39;Z</span></span>
<span id="cb683-3"><a href="#cb683-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SS</span><span class="ot"> ::</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">&#39;S</span> n)</span>
<span id="cb683-4"><a href="#cb683-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb683-5"><a href="#cb683-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> <span class="dt">Maybe</span> k) <span class="kw">where</span></span>
<span id="cb683-6"><a href="#cb683-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SNothing</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">&#39;Nothing</span></span>
<span id="cb683-7"><a href="#cb683-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SJust</span><span class="ot"> ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">&#39;Just</span> x)</span>
<span id="cb683-8"><a href="#cb683-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb683-9"><a href="#cb683-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> <span class="dt">Bool</span>) <span class="kw">where</span></span>
<span id="cb683-10"><a href="#cb683-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">STrue</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">True</span></span>
<span id="cb683-11"><a href="#cb683-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SFalse</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">False</span></span></code></pre></div>
<p><strong>Promoted Naturals</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Value-level</th>
<th style="text-align: left;">Type-level</th>
<th style="text-align: left;">Models</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>SZ</code></td>
<td style="text-align: left;"><code>Sing 'Z</code></td>
<td style="text-align: left;"><code>0</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SS SZ</code></td>
<td style="text-align: left;"><code>Sing ('S 'Z)</code></td>
<td style="text-align: left;"><code>1</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>SS (SS SZ)</code></td>
<td style="text-align: left;"><code>Sing ('S ('S 'Z))</code></td>
<td style="text-align: left;"><code>2</code></td>
</tr>
</tbody>
</table>
<p><strong>Promoted Booleans</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Value-level</th>
<th style="text-align: left;">Type-level</th>
<th style="text-align: left;">Models</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>SFalse</code></td>
<td style="text-align: left;"><code>Sing 'False</code></td>
<td style="text-align: left;"><code>False</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>STrue</code></td>
<td style="text-align: left;"><code>Sing 'True</code></td>
<td style="text-align: left;"><code>True</code></td>
</tr>
</tbody>
</table>
<p><strong>Promoted Maybe</strong></p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Value-level</th>
<th style="text-align: left;">Type-level</th>
<th style="text-align: left;">Models</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>SJust a</code></td>
<td style="text-align: left;"><code>Sing (SJust 'a)</code></td>
<td style="text-align: left;"><code>Just a</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>SNothing</code></td>
<td style="text-align: left;"><code>Sing Nothing</code></td>
<td style="text-align: left;"><code>Nothing</code></td>
</tr>
</tbody>
</table>
<p>Singleton types are an integral part of the small cottage industry of
faking dependent types in Haskell, i.e. constructing types with terms
predicated upon values. Singleton types are a way of “cheating” by
modeling the map between types and values as a structural property of
the type.</p>
<div class="sourceCode" id="cb684"
data-include="src/17-promotion/singleton_class.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb684-1"><a href="#cb684-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb684-2"><a href="#cb684-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb684-3"><a href="#cb684-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb684-4"><a href="#cb684-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb684-5"><a href="#cb684-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb684-6"><a href="#cb684-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb684-7"><a href="#cb684-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb684-8"><a href="#cb684-8" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span></span>
<span id="cb684-9"><a href="#cb684-9" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></span>
<span id="cb684-10"><a href="#cb684-10" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb684-11"><a href="#cb684-11" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb684-12"><a href="#cb684-12" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb684-13"><a href="#cb684-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-14"><a href="#cb684-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb684-15"><a href="#cb684-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">Any</span>)</span>
<span id="cb684-16"><a href="#cb684-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (succ)</span>
<span id="cb684-17"><a href="#cb684-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-18"><a href="#cb684-18" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Z</span> <span class="op">|</span> <span class="dt">S</span> <span class="dt">Nat</span></span>
<span id="cb684-19"><a href="#cb684-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-20"><a href="#cb684-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- kind-indexed data family</span></span>
<span id="cb684-21"><a href="#cb684-21" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">family</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> k)</span>
<span id="cb684-22"><a href="#cb684-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-23"><a href="#cb684-23" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb684-24"><a href="#cb684-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SZ</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">&#39;Z</span></span>
<span id="cb684-25"><a href="#cb684-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SS</span><span class="ot"> ::</span> <span class="dt">Sing</span> n <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">&#39;S</span> n)</span>
<span id="cb684-26"><a href="#cb684-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-27"><a href="#cb684-27" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> <span class="dt">Maybe</span> k) <span class="kw">where</span></span>
<span id="cb684-28"><a href="#cb684-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SNothing</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">&#39;Nothing</span></span>
<span id="cb684-29"><a href="#cb684-29" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SJust</span><span class="ot"> ::</span> <span class="dt">Sing</span> x <span class="ot">-&gt;</span> <span class="dt">Sing</span> (<span class="dt">&#39;Just</span> x)</span>
<span id="cb684-30"><a href="#cb684-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-31"><a href="#cb684-31" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="kw">instance</span> <span class="dt">Sing</span> (<span class="ot">a ::</span> <span class="dt">Bool</span>) <span class="kw">where</span></span>
<span id="cb684-32"><a href="#cb684-32" aria-hidden="true" tabindex="-1"></a>  <span class="dt">STrue</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">True</span></span>
<span id="cb684-33"><a href="#cb684-33" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SFalse</span><span class="ot"> ::</span> <span class="dt">Sing</span> <span class="dt">False</span></span>
<span id="cb684-34"><a href="#cb684-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-35"><a href="#cb684-35" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Fin</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) <span class="kw">where</span></span>
<span id="cb684-36"><a href="#cb684-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">FZ</span><span class="ot"> ::</span> <span class="dt">Fin</span> (<span class="dt">S</span> n)</span>
<span id="cb684-37"><a href="#cb684-37" aria-hidden="true" tabindex="-1"></a>  <span class="dt">FS</span><span class="ot"> ::</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> <span class="dt">Fin</span> (<span class="dt">S</span> n)</span>
<span id="cb684-38"><a href="#cb684-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-39"><a href="#cb684-39" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vec</span> a n <span class="kw">where</span></span>
<span id="cb684-40"><a href="#cb684-40" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot">  ::</span> <span class="dt">Vec</span> a <span class="dt">Z</span></span>
<span id="cb684-41"><a href="#cb684-41" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a (<span class="dt">S</span> n)</span>
<span id="cb684-42"><a href="#cb684-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-43"><a href="#cb684-43" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">SingI</span> (<span class="ot">a ::</span> k) <span class="kw">where</span></span>
<span id="cb684-44"><a href="#cb684-44" aria-hidden="true" tabindex="-1"></a><span class="ot">  sing ::</span> <span class="dt">Sing</span> a</span>
<span id="cb684-45"><a href="#cb684-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-46"><a href="#cb684-46" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SingI</span> <span class="dt">Z</span> <span class="kw">where</span></span>
<span id="cb684-47"><a href="#cb684-47" aria-hidden="true" tabindex="-1"></a>  sing <span class="ot">=</span> <span class="dt">SZ</span></span>
<span id="cb684-48"><a href="#cb684-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-49"><a href="#cb684-49" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SingI</span> n <span class="ot">=&gt;</span> <span class="dt">SingI</span> (<span class="dt">S</span> n) <span class="kw">where</span></span>
<span id="cb684-50"><a href="#cb684-50" aria-hidden="true" tabindex="-1"></a>  sing <span class="ot">=</span> <span class="dt">SS</span> sing</span>
<span id="cb684-51"><a href="#cb684-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-52"><a href="#cb684-52" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Nat</span></span>
<span id="cb684-53"><a href="#cb684-53" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">SNat</span> a)</span>
<span id="cb684-54"><a href="#cb684-54" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">SBool</span> a)</span>
<span id="cb684-55"><a href="#cb684-55" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">Fin</span> a)</span>
<span id="cb684-56"><a href="#cb684-56" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Vec</span> a n)</span>
<span id="cb684-57"><a href="#cb684-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-58"><a href="#cb684-58" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>) <span class="op">:+</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb684-59"><a href="#cb684-59" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Z</span> <span class="op">:+</span> n <span class="ot">=</span> n</span>
<span id="cb684-60"><a href="#cb684-60" aria-hidden="true" tabindex="-1"></a>  <span class="dt">S</span> m <span class="op">:+</span> n <span class="ot">=</span> <span class="dt">S</span> (m <span class="op">:+</span> n)</span>
<span id="cb684-61"><a href="#cb684-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-62"><a href="#cb684-62" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SNat</span> (<span class="ot">k ::</span> <span class="dt">Nat</span>) <span class="ot">=</span> <span class="dt">Sing</span> k</span>
<span id="cb684-63"><a href="#cb684-63" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SBool</span> (<span class="ot">k ::</span> <span class="dt">Bool</span>) <span class="ot">=</span> <span class="dt">Sing</span> k</span>
<span id="cb684-64"><a href="#cb684-64" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SMaybe</span> (<span class="ot">b ::</span> a) (<span class="ot">k ::</span> <span class="dt">Maybe</span> a) <span class="ot">=</span> <span class="dt">Sing</span> k</span>
<span id="cb684-65"><a href="#cb684-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-66"><a href="#cb684-66" aria-hidden="true" tabindex="-1"></a><span class="ot">size ::</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">SNat</span> n</span>
<span id="cb684-67"><a href="#cb684-67" aria-hidden="true" tabindex="-1"></a>size <span class="dt">Nil</span>         <span class="ot">=</span> <span class="dt">SZ</span></span>
<span id="cb684-68"><a href="#cb684-68" aria-hidden="true" tabindex="-1"></a>size (<span class="dt">Cons</span> x xs) <span class="ot">=</span> <span class="dt">SS</span> (size xs)</span>
<span id="cb684-69"><a href="#cb684-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-70"><a href="#cb684-70" aria-hidden="true" tabindex="-1"></a><span class="ot">forget ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb684-71"><a href="#cb684-71" aria-hidden="true" tabindex="-1"></a>forget <span class="dt">SZ</span> <span class="ot">=</span> <span class="dt">Z</span></span>
<span id="cb684-72"><a href="#cb684-72" aria-hidden="true" tabindex="-1"></a>forget (<span class="dt">SS</span> n) <span class="ot">=</span> <span class="dt">S</span> (forget n)</span>
<span id="cb684-73"><a href="#cb684-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-74"><a href="#cb684-74" aria-hidden="true" tabindex="-1"></a><span class="ot">natToInt ::</span> <span class="dt">Integral</span> n <span class="ot">=&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> n</span>
<span id="cb684-75"><a href="#cb684-75" aria-hidden="true" tabindex="-1"></a>natToInt <span class="dt">Z</span>     <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb684-76"><a href="#cb684-76" aria-hidden="true" tabindex="-1"></a>natToInt (<span class="dt">S</span> n) <span class="ot">=</span> natToInt n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb684-77"><a href="#cb684-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-78"><a href="#cb684-78" aria-hidden="true" tabindex="-1"></a><span class="ot">intToNat ::</span> (<span class="dt">Integral</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Nat</span></span>
<span id="cb684-79"><a href="#cb684-79" aria-hidden="true" tabindex="-1"></a>intToNat <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Z</span></span>
<span id="cb684-80"><a href="#cb684-80" aria-hidden="true" tabindex="-1"></a>intToNat n <span class="ot">=</span> <span class="dt">S</span> <span class="op">$</span> intToNat (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb684-81"><a href="#cb684-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-82"><a href="#cb684-82" aria-hidden="true" tabindex="-1"></a><span class="ot">sNatToInt ::</span> <span class="dt">Num</span> n <span class="ot">=&gt;</span> <span class="dt">SNat</span> x <span class="ot">-&gt;</span> n</span>
<span id="cb684-83"><a href="#cb684-83" aria-hidden="true" tabindex="-1"></a>sNatToInt <span class="dt">SZ</span>     <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb684-84"><a href="#cb684-84" aria-hidden="true" tabindex="-1"></a>sNatToInt (<span class="dt">SS</span> n) <span class="ot">=</span> sNatToInt n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb684-85"><a href="#cb684-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-86"><a href="#cb684-86" aria-hidden="true" tabindex="-1"></a><span class="fu">index</span><span class="ot"> ::</span> <span class="dt">Fin</span> n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> a</span>
<span id="cb684-87"><a href="#cb684-87" aria-hidden="true" tabindex="-1"></a><span class="fu">index</span> <span class="dt">FZ</span> (<span class="dt">Cons</span> x _)      <span class="ot">=</span> x</span>
<span id="cb684-88"><a href="#cb684-88" aria-hidden="true" tabindex="-1"></a><span class="fu">index</span> (<span class="dt">FS</span> n) (<span class="dt">Cons</span> _ xs) <span class="ot">=</span> <span class="fu">index</span> n xs</span>
<span id="cb684-89"><a href="#cb684-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-90"><a href="#cb684-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-91"><a href="#cb684-91" aria-hidden="true" tabindex="-1"></a><span class="ot">test1 ::</span> <span class="dt">Fin</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))</span>
<span id="cb684-92"><a href="#cb684-92" aria-hidden="true" tabindex="-1"></a>test1 <span class="ot">=</span> <span class="dt">FS</span> (<span class="dt">FS</span> <span class="dt">FZ</span>)</span>
<span id="cb684-93"><a href="#cb684-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-94"><a href="#cb684-94" aria-hidden="true" tabindex="-1"></a><span class="ot">test2 ::</span> <span class="dt">Int</span></span>
<span id="cb684-95"><a href="#cb684-95" aria-hidden="true" tabindex="-1"></a>test2 <span class="ot">=</span> <span class="fu">index</span> <span class="dt">FZ</span> (<span class="dv">1</span> <span class="ot">`Cons`</span> (<span class="dv">2</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>))</span>
<span id="cb684-96"><a href="#cb684-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-97"><a href="#cb684-97" aria-hidden="true" tabindex="-1"></a><span class="ot">test3 ::</span> <span class="dt">Sing</span> (<span class="dt">&#39;Just</span> (<span class="dt">&#39;S</span> (<span class="dt">&#39;S</span> <span class="dt">Z</span>)))</span>
<span id="cb684-98"><a href="#cb684-98" aria-hidden="true" tabindex="-1"></a>test3 <span class="ot">=</span> <span class="dt">SJust</span> (<span class="dt">SS</span> (<span class="dt">SS</span> <span class="dt">SZ</span>))</span>
<span id="cb684-99"><a href="#cb684-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-100"><a href="#cb684-100" aria-hidden="true" tabindex="-1"></a><span class="ot">test4 ::</span> <span class="dt">Sing</span> (<span class="dt">&#39;S</span> (<span class="dt">&#39;S</span> <span class="dt">Z</span>))</span>
<span id="cb684-101"><a href="#cb684-101" aria-hidden="true" tabindex="-1"></a>test4 <span class="ot">=</span> <span class="dt">SS</span> (<span class="dt">SS</span> <span class="dt">SZ</span>)</span>
<span id="cb684-102"><a href="#cb684-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb684-103"><a href="#cb684-103" aria-hidden="true" tabindex="-1"></a><span class="co">-- polymorphic constructor SingI</span></span>
<span id="cb684-104"><a href="#cb684-104" aria-hidden="true" tabindex="-1"></a><span class="ot">test5 ::</span> <span class="dt">Sing</span> (<span class="dt">&#39;S</span> (<span class="dt">&#39;S</span> <span class="dt">Z</span>))</span>
<span id="cb684-105"><a href="#cb684-105" aria-hidden="true" tabindex="-1"></a>test5 <span class="ot">=</span> sing</span></code></pre></div>
<p>The builtin singleton types provided in <code>GHC.TypeLits</code>
have the useful implementation that type-level values can be reflected
to the value-level and back up to the type-level, albeit under an
existential.</p>
<div class="sourceCode" id="cb685"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb685-1"><a href="#cb685-1" aria-hidden="true" tabindex="-1"></a><span class="ot">someNatVal ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">SomeNat</span></span>
<span id="cb685-2"><a href="#cb685-2" aria-hidden="true" tabindex="-1"></a><span class="ot">someSymbolVal ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">SomeSymbol</span></span>
<span id="cb685-3"><a href="#cb685-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb685-4"><a href="#cb685-4" aria-hidden="true" tabindex="-1"></a><span class="ot">natVal ::</span> <span class="dt">KnownNat</span> n <span class="ot">=&gt;</span> proxy n <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb685-5"><a href="#cb685-5" aria-hidden="true" tabindex="-1"></a><span class="ot">symbolVal ::</span> <span class="dt">KnownSymbol</span> n <span class="ot">=&gt;</span> proxy n <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<div class="sourceCode" id="cb686"
data-include="src/17-promotion/singleton.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb686-1"><a href="#cb686-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb686-2"><a href="#cb686-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb686-3"><a href="#cb686-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb686-4"><a href="#cb686-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb686-5"><a href="#cb686-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb686-6"><a href="#cb686-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb686-7"><a href="#cb686-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb686-8"><a href="#cb686-8" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Integer</span></span>
<span id="cb686-9"><a href="#cb686-9" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dv">1</span>)</span>
<span id="cb686-10"><a href="#cb686-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1</span></span>
<span id="cb686-11"><a href="#cb686-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb686-12"><a href="#cb686-12" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">String</span></span>
<span id="cb686-13"><a href="#cb686-13" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> symbolVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="st">&quot;foo&quot;</span>)</span>
<span id="cb686-14"><a href="#cb686-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- &quot;foo&quot;</span></span>
<span id="cb686-15"><a href="#cb686-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb686-16"><a href="#cb686-16" aria-hidden="true" tabindex="-1"></a><span class="ot">c ::</span> <span class="dt">Integer</span></span>
<span id="cb686-17"><a href="#cb686-17" aria-hidden="true" tabindex="-1"></a>c <span class="ot">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dv">2</span> <span class="op">+</span> <span class="dv">3</span>))</span>
<span id="cb686-18"><a href="#cb686-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- 5</span></span></code></pre></div>
<h2 id="closed-type-families">Closed Type Families</h2>
<p>In the type families we’ve used so far (called open type families)
there is no notion of ordering of the equations involved in the
type-level function. The type family can be extended at any point in the
code resolution simply proceeds sequentially through the available
definitions. Closed type-families allow an alternative declaration that
allows for a base case for the resolution allowing us to actually write
recursive functions over types.</p>
<p>For example consider if we wanted to write a function which counts
the arguments in the type of a function and reifies at the
value-level.</p>
<div class="sourceCode" id="cb687"
data-include="src/17-promotion/countargs.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb687-1"><a href="#cb687-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb687-2"><a href="#cb687-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb687-3"><a href="#cb687-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb687-4"><a href="#cb687-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb687-5"><a href="#cb687-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb687-6"><a href="#cb687-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb687-7"><a href="#cb687-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb687-8"><a href="#cb687-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb687-9"><a href="#cb687-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Count</span> (<span class="ot">f ::</span> <span class="op">*</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb687-10"><a href="#cb687-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Count</span> (a <span class="ot">-&gt;</span> b) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> (<span class="dt">Count</span> b)</span>
<span id="cb687-11"><a href="#cb687-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Count</span> x <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb687-12"><a href="#cb687-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb687-13"><a href="#cb687-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Fn1</span> <span class="ot">=</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb687-14"><a href="#cb687-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Fn2</span> <span class="ot">=</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb687-15"><a href="#cb687-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb687-16"><a href="#cb687-16" aria-hidden="true" tabindex="-1"></a><span class="ot">fn1 ::</span> <span class="dt">Integer</span></span>
<span id="cb687-17"><a href="#cb687-17" aria-hidden="true" tabindex="-1"></a>fn1 <span class="ot">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Count</span> <span class="dt">Fn1</span>))</span>
<span id="cb687-18"><a href="#cb687-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- 2</span></span>
<span id="cb687-19"><a href="#cb687-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb687-20"><a href="#cb687-20" aria-hidden="true" tabindex="-1"></a><span class="ot">fn2 ::</span> <span class="dt">Integer</span></span>
<span id="cb687-21"><a href="#cb687-21" aria-hidden="true" tabindex="-1"></a>fn2 <span class="ot">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Count</span> <span class="dt">Fn2</span>))</span>
<span id="cb687-22"><a href="#cb687-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- 4</span></span></code></pre></div>
<p>The variety of functions we can now write down are rather remarkable,
allowing us to write meaningful logic at the type level.</p>
<div class="sourceCode" id="cb688"
data-include="src/17-promotion/closed_typefamily.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb688-1"><a href="#cb688-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb688-2"><a href="#cb688-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb688-3"><a href="#cb688-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb688-4"><a href="#cb688-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb688-5"><a href="#cb688-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb688-6"><a href="#cb688-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb688-7"><a href="#cb688-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-8"><a href="#cb688-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb688-9"><a href="#cb688-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb688-10"><a href="#cb688-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb688-11"><a href="#cb688-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-12"><a href="#cb688-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Type-level functions over type-level lists.</span></span>
<span id="cb688-13"><a href="#cb688-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-14"><a href="#cb688-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Reverse</span> (<span class="ot">xs ::</span> [k])<span class="ot"> ::</span> [k] <span class="kw">where</span></span>
<span id="cb688-15"><a href="#cb688-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Reverse</span> &#39;[] <span class="ot">=</span> &#39;[]</span>
<span id="cb688-16"><a href="#cb688-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Reverse</span> xs <span class="ot">=</span> <span class="dt">Rev</span> xs &#39;[]</span>
<span id="cb688-17"><a href="#cb688-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-18"><a href="#cb688-18" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Rev</span> (<span class="ot">xs ::</span> [k]) (<span class="ot">ys ::</span> [k])<span class="ot"> ::</span> [k] <span class="kw">where</span></span>
<span id="cb688-19"><a href="#cb688-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Rev</span> &#39;[] i <span class="ot">=</span> i</span>
<span id="cb688-20"><a href="#cb688-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Rev</span> (x &#39;<span class="op">:</span> xs) i <span class="ot">=</span> <span class="dt">Rev</span> xs (x &#39;<span class="op">:</span> i)</span>
<span id="cb688-21"><a href="#cb688-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-22"><a href="#cb688-22" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Length</span> (<span class="ot">as ::</span> [k])<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb688-23"><a href="#cb688-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Length</span> &#39;[] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb688-24"><a href="#cb688-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Length</span> (x &#39;<span class="op">:</span> xs) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dt">Length</span> xs</span>
<span id="cb688-25"><a href="#cb688-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-26"><a href="#cb688-26" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">If</span> (<span class="ot">p ::</span> <span class="dt">Bool</span>) (<span class="ot">a ::</span> k) (<span class="ot">b ::</span> k)<span class="ot"> ::</span> k <span class="kw">where</span></span>
<span id="cb688-27"><a href="#cb688-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">If</span> <span class="dt">True</span> a b <span class="ot">=</span> a</span>
<span id="cb688-28"><a href="#cb688-28" aria-hidden="true" tabindex="-1"></a>  <span class="dt">If</span> <span class="dt">False</span> a b <span class="ot">=</span> b</span>
<span id="cb688-29"><a href="#cb688-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-30"><a href="#cb688-30" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Concat</span> (<span class="ot">as ::</span> [k]) (<span class="ot">bs ::</span> [k])<span class="ot"> ::</span> [k] <span class="kw">where</span></span>
<span id="cb688-31"><a href="#cb688-31" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Concat</span> a &#39;[] <span class="ot">=</span> a</span>
<span id="cb688-32"><a href="#cb688-32" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Concat</span> &#39;[] b <span class="ot">=</span> b</span>
<span id="cb688-33"><a href="#cb688-33" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Concat</span> (a &#39;<span class="op">:</span> as) bs <span class="ot">=</span> a &#39;<span class="op">:</span> <span class="dt">Concat</span> as bs</span>
<span id="cb688-34"><a href="#cb688-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-35"><a href="#cb688-35" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Map</span> (<span class="ot">f ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">as ::</span> [a])<span class="ot"> ::</span> [b] <span class="kw">where</span></span>
<span id="cb688-36"><a href="#cb688-36" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Map</span> f &#39;[] <span class="ot">=</span> &#39;[]</span>
<span id="cb688-37"><a href="#cb688-37" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Map</span> f (x &#39;<span class="op">:</span> xs) <span class="ot">=</span> f x &#39;<span class="op">:</span> <span class="dt">Map</span> f xs</span>
<span id="cb688-38"><a href="#cb688-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-39"><a href="#cb688-39" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Sum</span> (<span class="ot">xs ::</span> [<span class="dt">Nat</span>])<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb688-40"><a href="#cb688-40" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Sum</span> &#39;[] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb688-41"><a href="#cb688-41" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Sum</span> (x &#39;<span class="op">:</span> xs) <span class="ot">=</span> x <span class="op">+</span> <span class="dt">Sum</span> xs</span>
<span id="cb688-42"><a href="#cb688-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-43"><a href="#cb688-43" aria-hidden="true" tabindex="-1"></a><span class="ot">ex1 ::</span> <span class="dt">Reverse</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">~</span> [<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>] <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a</span>
<span id="cb688-44"><a href="#cb688-44" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb688-45"><a href="#cb688-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-46"><a href="#cb688-46" aria-hidden="true" tabindex="-1"></a><span class="ot">ex2 ::</span> <span class="dt">Length</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">~</span> <span class="dv">3</span> <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a</span>
<span id="cb688-47"><a href="#cb688-47" aria-hidden="true" tabindex="-1"></a>ex2 <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb688-48"><a href="#cb688-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-49"><a href="#cb688-49" aria-hidden="true" tabindex="-1"></a><span class="ot">ex3 ::</span> (<span class="dt">Length</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]) <span class="op">~</span> (<span class="dt">Length</span> (<span class="dt">Reverse</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>])) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a</span>
<span id="cb688-50"><a href="#cb688-50" aria-hidden="true" tabindex="-1"></a>ex3 <span class="ot">=</span> <span class="dt">Proxy</span></span>
<span id="cb688-51"><a href="#cb688-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-52"><a href="#cb688-52" aria-hidden="true" tabindex="-1"></a><span class="co">-- Reflecting type level computations back to the value level.</span></span>
<span id="cb688-53"><a href="#cb688-53" aria-hidden="true" tabindex="-1"></a><span class="ot">ex4 ::</span> <span class="dt">Integer</span></span>
<span id="cb688-54"><a href="#cb688-54" aria-hidden="true" tabindex="-1"></a>ex4 <span class="ot">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Length</span> (<span class="dt">Concat</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>])))</span>
<span id="cb688-55"><a href="#cb688-55" aria-hidden="true" tabindex="-1"></a><span class="co">-- 6</span></span>
<span id="cb688-56"><a href="#cb688-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-57"><a href="#cb688-57" aria-hidden="true" tabindex="-1"></a><span class="ot">ex5 ::</span> <span class="dt">Integer</span></span>
<span id="cb688-58"><a href="#cb688-58" aria-hidden="true" tabindex="-1"></a>ex5 <span class="ot">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Sum</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]))</span>
<span id="cb688-59"><a href="#cb688-59" aria-hidden="true" tabindex="-1"></a><span class="co">-- 6</span></span>
<span id="cb688-60"><a href="#cb688-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb688-61"><a href="#cb688-61" aria-hidden="true" tabindex="-1"></a><span class="co">-- Couldn&#39;t match type ‘2’ with ‘1’</span></span>
<span id="cb688-62"><a href="#cb688-62" aria-hidden="true" tabindex="-1"></a><span class="ot">ex6 ::</span> <span class="dt">Reverse</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="op">~</span> [<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">2</span>] <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a</span>
<span id="cb688-63"><a href="#cb688-63" aria-hidden="true" tabindex="-1"></a>ex6 <span class="ot">=</span> <span class="dt">Proxy</span></span></code></pre></div>
<p>The results of type family functions need not necessarily be kinded
as <code>(*)</code> either. For example using Nat or Constraint is
permitted.</p>
<div class="sourceCode" id="cb689"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb689-1"><a href="#cb689-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Elem</span> (<span class="ot">a ::</span> k) (<span class="ot">bs ::</span> [k])<span class="ot"> ::</span> <span class="dt">Constraint</span> <span class="kw">where</span></span>
<span id="cb689-2"><a href="#cb689-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Elem</span> a (a &#39;<span class="op">:</span> bs) <span class="ot">=</span> (<span class="ot">() ::</span> <span class="dt">Constraint</span>)</span>
<span id="cb689-3"><a href="#cb689-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Elem</span> a (b &#39;<span class="op">:</span> bs) <span class="ot">=</span> a <span class="ot">`Elem`</span> bs</span>
<span id="cb689-4"><a href="#cb689-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb689-5"><a href="#cb689-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Sum</span> (<span class="ot">ns ::</span> [<span class="dt">Nat</span>])<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb689-6"><a href="#cb689-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Sum</span> &#39;[] <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb689-7"><a href="#cb689-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Sum</span> (n &#39;<span class="op">:</span> ns) <span class="ot">=</span> n <span class="op">+</span> <span class="dt">Sum</span> ns</span></code></pre></div>
<h2 id="kind-indexed-type-families">Kind Indexed Type Families</h2>
<p>Just as typeclasses are normally indexed on types, type families can
also be indexed on kinds with the kinds given as explicit kind
signatures on type variables.</p>
<div class="sourceCode" id="cb690"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb690-1"><a href="#cb690-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="ot">a ::</span> k) <span class="op">==</span> (<span class="ot">b ::</span> k)<span class="ot"> ::</span> <span class="dt">Bool</span></span>
<span id="cb690-2"><a href="#cb690-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> a <span class="op">==</span> b <span class="ot">=</span> <span class="dt">EqStar</span> a b</span>
<span id="cb690-3"><a href="#cb690-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> a <span class="op">==</span> b <span class="ot">=</span> <span class="dt">EqArrow</span> a b</span>
<span id="cb690-4"><a href="#cb690-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> a <span class="op">==</span> b <span class="ot">=</span> <span class="dt">EqBool</span> a b</span>
<span id="cb690-5"><a href="#cb690-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb690-6"><a href="#cb690-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">EqStar</span> (<span class="ot">a ::</span> <span class="op">*</span>) (<span class="ot">b ::</span> <span class="op">*</span>) <span class="kw">where</span></span>
<span id="cb690-7"><a href="#cb690-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqStar</span> a a <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb690-8"><a href="#cb690-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqStar</span> a b <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb690-9"><a href="#cb690-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb690-10"><a href="#cb690-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">EqArrow</span> (<span class="ot">a ::</span> k1 <span class="ot">-&gt;</span> k2) (<span class="ot">b ::</span> k1 <span class="ot">-&gt;</span> k2) <span class="kw">where</span></span>
<span id="cb690-11"><a href="#cb690-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqArrow</span> a a <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb690-12"><a href="#cb690-12" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqArrow</span> a b <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb690-13"><a href="#cb690-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb690-14"><a href="#cb690-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">EqBool</span> a b <span class="kw">where</span></span>
<span id="cb690-15"><a href="#cb690-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqBool</span> <span class="dt">True</span>  <span class="dt">True</span>  <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb690-16"><a href="#cb690-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqBool</span> <span class="dt">False</span> <span class="dt">False</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb690-17"><a href="#cb690-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqBool</span> a     b     <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb690-18"><a href="#cb690-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb690-19"><a href="#cb690-19" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">EqList</span> a b <span class="kw">where</span></span>
<span id="cb690-20"><a href="#cb690-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqList</span> &#39;[]        &#39;[]        <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb690-21"><a href="#cb690-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqList</span> (h1 &#39;<span class="op">:</span> t1) (h2 &#39;<span class="op">:</span> t2) <span class="ot">=</span> (h1 <span class="op">==</span> h2) <span class="op">&amp;&amp;</span> (t1 <span class="op">==</span> t2)</span>
<span id="cb690-22"><a href="#cb690-22" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EqList</span> a          b          <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb690-23"><a href="#cb690-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb690-24"><a href="#cb690-24" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> a <span class="op">&amp;&amp;</span> b <span class="kw">where</span></span>
<span id="cb690-25"><a href="#cb690-25" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span> <span class="op">&amp;&amp;</span> <span class="dt">True</span> <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb690-26"><a href="#cb690-26" aria-hidden="true" tabindex="-1"></a>  a    <span class="op">&amp;&amp;</span> a    <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<h2 id="hlists">HLists</h2>
<p>A heterogeneous list is a cons list whose type statically encodes the
ordered types of its values.</p>
<div class="sourceCode" id="cb691"
data-include="src/17-promotion/hlist.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb691-1"><a href="#cb691-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb691-2"><a href="#cb691-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb691-3"><a href="#cb691-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb691-4"><a href="#cb691-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb691-5"><a href="#cb691-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb691-6"><a href="#cb691-6" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:::</span></span>
<span id="cb691-7"><a href="#cb691-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb691-8"><a href="#cb691-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">HList</span> (<span class="ot">ts ::</span> [ <span class="op">*</span> ]) <span class="kw">where</span></span>
<span id="cb691-9"><a href="#cb691-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">HList</span> &#39;[]</span>
<span id="cb691-10"><a href="#cb691-10" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:::) ::</span> t <span class="ot">-&gt;</span> <span class="dt">HList</span> ts <span class="ot">-&gt;</span> <span class="dt">HList</span> (t &#39;<span class="op">:</span> ts)</span>
<span id="cb691-11"><a href="#cb691-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb691-12"><a href="#cb691-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Take the head of a non-empty list with the first value as Bool type.</span></span>
<span id="cb691-13"><a href="#cb691-13" aria-hidden="true" tabindex="-1"></a><span class="ot">headBool ::</span> <span class="dt">HList</span> (<span class="dt">Bool</span> &#39;<span class="op">:</span> xs) <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb691-14"><a href="#cb691-14" aria-hidden="true" tabindex="-1"></a>headBool hlist <span class="ot">=</span> <span class="kw">case</span> hlist <span class="kw">of</span></span>
<span id="cb691-15"><a href="#cb691-15" aria-hidden="true" tabindex="-1"></a>  (a <span class="op">:::</span> _) <span class="ot">-&gt;</span> a</span>
<span id="cb691-16"><a href="#cb691-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb691-17"><a href="#cb691-17" aria-hidden="true" tabindex="-1"></a><span class="ot">hlength ::</span> <span class="dt">HList</span> x <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb691-18"><a href="#cb691-18" aria-hidden="true" tabindex="-1"></a>hlength <span class="dt">Nil</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb691-19"><a href="#cb691-19" aria-hidden="true" tabindex="-1"></a>hlength (_ <span class="op">:::</span> b) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> (hlength b)</span>
<span id="cb691-20"><a href="#cb691-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb691-21"><a href="#cb691-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb691-22"><a href="#cb691-22" aria-hidden="true" tabindex="-1"></a><span class="ot">tuple ::</span> (<span class="dt">Bool</span>, (<span class="dt">String</span>, (<span class="dt">Double</span>, ())))</span>
<span id="cb691-23"><a href="#cb691-23" aria-hidden="true" tabindex="-1"></a>tuple <span class="ot">=</span> (<span class="dt">True</span>, (<span class="st">&quot;foo&quot;</span>, (<span class="fl">3.14</span>, ())))</span>
<span id="cb691-24"><a href="#cb691-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb691-25"><a href="#cb691-25" aria-hidden="true" tabindex="-1"></a><span class="ot">hlist ::</span> <span class="dt">HList</span> &#39;[<span class="dt">Bool</span>, <span class="dt">String</span> , <span class="dt">Double</span> , ()]</span>
<span id="cb691-26"><a href="#cb691-26" aria-hidden="true" tabindex="-1"></a>hlist <span class="ot">=</span> <span class="dt">True</span> <span class="op">:::</span> <span class="st">&quot;foo&quot;</span> <span class="op">:::</span> <span class="fl">3.14</span> <span class="op">:::</span> () <span class="op">:::</span> <span class="dt">Nil</span></span></code></pre></div>
<p>Of course this immediately begs the question of how to print such a
list out to a string in the presence of type-heterogeneity. In this case
we can use type-families combined with constraint kinds to apply the
Show over the HLists parameters to generate the aggregate constraint
that all types in the HList are Showable, and then derive the Show
instance.</p>
<div class="sourceCode" id="cb692"
data-include="src/17-promotion/constraint_list.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb692-1"><a href="#cb692-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb692-2"><a href="#cb692-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb692-3"><a href="#cb692-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb692-4"><a href="#cb692-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb692-5"><a href="#cb692-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb692-6"><a href="#cb692-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb692-7"><a href="#cb692-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb692-8"><a href="#cb692-8" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb692-9"><a href="#cb692-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-10"><a href="#cb692-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span> (<span class="dt">Constraint</span>)</span>
<span id="cb692-11"><a href="#cb692-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-12"><a href="#cb692-12" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:::</span></span>
<span id="cb692-13"><a href="#cb692-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-14"><a href="#cb692-14" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">HList</span> (<span class="ot">ts ::</span> [ <span class="op">*</span> ]) <span class="kw">where</span></span>
<span id="cb692-15"><a href="#cb692-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">HList</span> &#39;[]</span>
<span id="cb692-16"><a href="#cb692-16" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:::) ::</span> t <span class="ot">-&gt;</span> <span class="dt">HList</span> ts <span class="ot">-&gt;</span> <span class="dt">HList</span> (t &#39;<span class="op">:</span> ts)</span>
<span id="cb692-17"><a href="#cb692-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-18"><a href="#cb692-18" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Map</span> (<span class="ot">f ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">xs ::</span> [a])<span class="ot"> ::</span> [b]</span>
<span id="cb692-19"><a href="#cb692-19" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Map</span> f &#39;[] <span class="ot">=</span> &#39;[]</span>
<span id="cb692-20"><a href="#cb692-20" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Map</span> f (x &#39;<span class="op">:</span> xs) <span class="ot">=</span> f x &#39;<span class="op">:</span> <span class="dt">Map</span> f xs</span>
<span id="cb692-21"><a href="#cb692-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-22"><a href="#cb692-22" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Constraints</span> (<span class="ot">cs ::</span> [<span class="dt">Constraint</span>])<span class="ot"> ::</span> <span class="dt">Constraint</span></span>
<span id="cb692-23"><a href="#cb692-23" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Constraints</span> &#39;[] <span class="ot">=</span> ()</span>
<span id="cb692-24"><a href="#cb692-24" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Constraints</span> (c &#39;<span class="op">:</span> cs) <span class="ot">=</span> (c, <span class="dt">Constraints</span> cs)</span>
<span id="cb692-25"><a href="#cb692-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-26"><a href="#cb692-26" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">AllHave</span> (<span class="ot">c ::</span> k <span class="ot">-&gt;</span> <span class="dt">Constraint</span>) (<span class="ot">xs ::</span> [k]) <span class="ot">=</span> <span class="dt">Constraints</span> (<span class="dt">Map</span> c xs)</span>
<span id="cb692-27"><a href="#cb692-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-28"><a href="#cb692-28" aria-hidden="true" tabindex="-1"></a><span class="ot">showHList ::</span> <span class="dt">AllHave</span> <span class="dt">Show</span> xs <span class="ot">=&gt;</span> <span class="dt">HList</span> xs <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb692-29"><a href="#cb692-29" aria-hidden="true" tabindex="-1"></a>showHList <span class="dt">Nil</span> <span class="ot">=</span> []</span>
<span id="cb692-30"><a href="#cb692-30" aria-hidden="true" tabindex="-1"></a>showHList (x <span class="op">:::</span> xs) <span class="ot">=</span> (<span class="fu">show</span> x) <span class="op">:</span> showHList xs</span>
<span id="cb692-31"><a href="#cb692-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-32"><a href="#cb692-32" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">AllHave</span> <span class="dt">Show</span> xs <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">HList</span> xs) <span class="kw">where</span></span>
<span id="cb692-33"><a href="#cb692-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> <span class="ot">=</span> <span class="fu">show</span> <span class="op">.</span> showHList</span>
<span id="cb692-34"><a href="#cb692-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb692-35"><a href="#cb692-35" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">HList</span> &#39;[<span class="dt">Bool</span>, <span class="dt">String</span> , <span class="dt">Double</span> , ()]</span>
<span id="cb692-36"><a href="#cb692-36" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> <span class="dt">True</span> <span class="op">:::</span> <span class="st">&quot;foo&quot;</span> <span class="op">:::</span> <span class="fl">3.14</span> <span class="op">:::</span> () <span class="op">:::</span> <span class="dt">Nil</span></span>
<span id="cb692-37"><a href="#cb692-37" aria-hidden="true" tabindex="-1"></a><span class="co">-- [&quot;True&quot;,&quot;\&quot;foo\&quot;&quot;,&quot;3.14&quot;,&quot;()&quot;]</span></span></code></pre></div>
<h2 id="typelevel-dictionaries">Typelevel Dictionaries</h2>
<p>Much of this discussion of promotion begs the question whether we can
create data structures at the type-level to store information at
compile-time. For example a type-level association list can be used to
model a map between type-level symbols and any other promotable types.
Together with type-families we can write down type-level traversal and
lookup functions.</p>
<div class="sourceCode" id="cb693"
data-include="src/17-promotion/typemap.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb693-1"><a href="#cb693-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb693-2"><a href="#cb693-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb693-3"><a href="#cb693-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb693-4"><a href="#cb693-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb693-5"><a href="#cb693-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb693-6"><a href="#cb693-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb693-7"><a href="#cb693-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb693-8"><a href="#cb693-8" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ConstraintKinds #-}</span></span>
<span id="cb693-9"><a href="#cb693-9" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb693-10"><a href="#cb693-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb693-11"><a href="#cb693-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb693-12"><a href="#cb693-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb693-13"><a href="#cb693-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb693-14"><a href="#cb693-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb693-15"><a href="#cb693-15" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">If</span> (<span class="ot">p ::</span> <span class="dt">Bool</span>) (<span class="ot">a ::</span> k) (<span class="ot">b ::</span> k)<span class="ot"> ::</span> k <span class="kw">where</span></span>
<span id="cb693-16"><a href="#cb693-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">If</span> <span class="dt">True</span> a b <span class="ot">=</span> a</span>
<span id="cb693-17"><a href="#cb693-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">If</span> <span class="dt">False</span> a b <span class="ot">=</span> b</span>
<span id="cb693-18"><a href="#cb693-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb693-19"><a href="#cb693-19" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Lookup</span> (<span class="ot">k ::</span> a) (<span class="ot">ls ::</span> [(a, b)])<span class="ot"> ::</span> <span class="dt">Maybe</span> b <span class="kw">where</span></span>
<span id="cb693-20"><a href="#cb693-20" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lookup</span> k &#39;[] <span class="ot">=</span> <span class="dt">&#39;Nothing</span></span>
<span id="cb693-21"><a href="#cb693-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lookup</span> k (&#39;(a, b) &#39;<span class="op">:</span> xs) <span class="ot">=</span> <span class="dt">If</span> (a <span class="op">==</span> k) (<span class="dt">&#39;Just</span> b) (<span class="dt">Lookup</span> k xs)</span>
<span id="cb693-22"><a href="#cb693-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb693-23"><a href="#cb693-23" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">M</span> <span class="ot">=</span> [</span>
<span id="cb693-24"><a href="#cb693-24" aria-hidden="true" tabindex="-1"></a>    &#39;(<span class="st">&quot;a&quot;</span>, <span class="dv">1</span>)</span>
<span id="cb693-25"><a href="#cb693-25" aria-hidden="true" tabindex="-1"></a>  , &#39;(<span class="st">&quot;b&quot;</span>, <span class="dv">2</span>)</span>
<span id="cb693-26"><a href="#cb693-26" aria-hidden="true" tabindex="-1"></a>  , &#39;(<span class="st">&quot;c&quot;</span>, <span class="dv">3</span>)</span>
<span id="cb693-27"><a href="#cb693-27" aria-hidden="true" tabindex="-1"></a>  , &#39;(<span class="st">&quot;d&quot;</span>, <span class="dv">4</span>)</span>
<span id="cb693-28"><a href="#cb693-28" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb693-29"><a href="#cb693-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb693-30"><a href="#cb693-30" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">K</span> <span class="ot">=</span> <span class="st">&quot;a&quot;</span></span>
<span id="cb693-31"><a href="#cb693-31" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (<span class="op">!!</span>) m (<span class="ot">k ::</span> <span class="dt">Symbol</span>) a <span class="ot">=</span> (<span class="dt">Lookup</span> k m) <span class="op">~</span> <span class="dt">Just</span> a</span>
<span id="cb693-32"><a href="#cb693-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb693-33"><a href="#cb693-33" aria-hidden="true" tabindex="-1"></a><span class="ot">value ::</span> <span class="dt">Integer</span></span>
<span id="cb693-34"><a href="#cb693-34" aria-hidden="true" tabindex="-1"></a>value <span class="ot">=</span> natVal ( <span class="dt">Proxy</span><span class="ot"> ::</span> (<span class="dt">M</span> <span class="op">!!</span> <span class="st">&quot;a&quot;</span>) a <span class="ot">=&gt;</span> <span class="dt">Proxy</span> a )</span></code></pre></div>
<p>If we ask GHC to expand out the type signature we can view the
explicit implementation of the type-level map lookup function.</p>
<div class="sourceCode" id="cb694"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb694-1"><a href="#cb694-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">!!</span>)</span>
<span id="cb694-2"><a href="#cb694-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">If</span></span>
<span id="cb694-3"><a href="#cb694-3" aria-hidden="true" tabindex="-1"></a>       (<span class="dt">GHC.TypeLits.EqSymbol</span> <span class="st">&quot;a&quot;</span> k)</span>
<span id="cb694-4"><a href="#cb694-4" aria-hidden="true" tabindex="-1"></a>       (<span class="dt">&#39;Just</span> <span class="dv">1</span>)</span>
<span id="cb694-5"><a href="#cb694-5" aria-hidden="true" tabindex="-1"></a>       (<span class="dt">If</span></span>
<span id="cb694-6"><a href="#cb694-6" aria-hidden="true" tabindex="-1"></a>          (<span class="dt">GHC.TypeLits.EqSymbol</span> <span class="st">&quot;b&quot;</span> k)</span>
<span id="cb694-7"><a href="#cb694-7" aria-hidden="true" tabindex="-1"></a>          (<span class="dt">&#39;Just</span> <span class="dv">2</span>)</span>
<span id="cb694-8"><a href="#cb694-8" aria-hidden="true" tabindex="-1"></a>          (<span class="dt">If</span></span>
<span id="cb694-9"><a href="#cb694-9" aria-hidden="true" tabindex="-1"></a>             (<span class="dt">GHC.TypeLits.EqSymbol</span> <span class="st">&quot;c&quot;</span> k)</span>
<span id="cb694-10"><a href="#cb694-10" aria-hidden="true" tabindex="-1"></a>             (<span class="dt">&#39;Just</span> <span class="dv">3</span>)</span>
<span id="cb694-11"><a href="#cb694-11" aria-hidden="true" tabindex="-1"></a>             (<span class="dt">If</span> (<span class="dt">GHC.TypeLits.EqSymbol</span> <span class="st">&quot;d&quot;</span> k) (<span class="dt">&#39;Just</span> <span class="dv">4</span>) <span class="dt">&#39;Nothing</span>)))</span>
<span id="cb694-12"><a href="#cb694-12" aria-hidden="true" tabindex="-1"></a>     <span class="op">~</span> <span class="dt">&#39;Just</span> v <span class="ot">=&gt;</span></span>
<span id="cb694-13"><a href="#cb694-13" aria-hidden="true" tabindex="-1"></a>     <span class="dt">Proxy</span> k <span class="ot">-&gt;</span> <span class="dt">Proxy</span> v</span></code></pre></div>
<h2 id="advanced-proofs">Advanced Proofs</h2>
<p>Now that we have the length-indexed vector let’s go write the reverse
function, how hard could it be?</p>
<p>So we go and write down something like this:</p>
<div class="sourceCode" id="cb695"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb695-1"><a href="#cb695-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reverseNaive ::</span> <span class="kw">forall</span> n a<span class="op">.</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n</span>
<span id="cb695-2"><a href="#cb695-2" aria-hidden="true" tabindex="-1"></a>reverseNaive xs <span class="ot">=</span> go <span class="dt">Nil</span> xs <span class="co">-- Error: n + 0 != n</span></span>
<span id="cb695-3"><a href="#cb695-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb695-4"><a href="#cb695-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Vec</span> a m <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a (n <span class="op">:+</span> m)</span>
<span id="cb695-5"><a href="#cb695-5" aria-hidden="true" tabindex="-1"></a>    go acc <span class="dt">Nil</span> <span class="ot">=</span> acc</span>
<span id="cb695-6"><a href="#cb695-6" aria-hidden="true" tabindex="-1"></a>    go acc (<span class="dt">Cons</span> x xs) <span class="ot">=</span> go (<span class="dt">Cons</span> x acc) xs <span class="co">-- Error: n + succ m != succ (n + m)</span></span></code></pre></div>
<p>Running this we find that GHC is unhappy about two lines in the
code:</p>
<div class="sourceCode" id="cb696"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb696-1"><a href="#cb696-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> ‘n’ with ‘n <span class="op">:+</span> <span class="dt">&#39;Z</span>’</span>
<span id="cb696-2"><a href="#cb696-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Expected</span> <span class="kw">type</span><span class="op">:</span> <span class="dt">Vec</span> a n</span>
<span id="cb696-3"><a href="#cb696-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Actual</span> <span class="kw">type</span><span class="op">:</span> <span class="dt">Vec</span> a (n <span class="op">:+</span> <span class="dt">&#39;Z</span>)</span>
<span id="cb696-4"><a href="#cb696-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb696-5"><a href="#cb696-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Could</span> <span class="fu">not</span> deduce ((n1 <span class="op">:+</span> <span class="dt">&#39;S</span> m) <span class="op">~</span> <span class="dt">&#39;S</span> (n1 <span class="op">:+</span> m))</span>
<span id="cb696-6"><a href="#cb696-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Expected</span> <span class="kw">type</span><span class="op">:</span> <span class="dt">Vec</span> a1 (k <span class="op">:+</span> m)</span>
<span id="cb696-7"><a href="#cb696-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Actual</span> <span class="kw">type</span><span class="op">:</span> <span class="dt">Vec</span> a1 (n1 <span class="op">:+</span> <span class="dt">&#39;S</span> m)</span></code></pre></div>
<p>As we unfold elements out of the vector we’ll end up doing a lot of
type-level arithmetic over indices as we combine the subparts of the
vector backwards, but as a consequence we find that GHC will run into
some unification errors because it doesn’t know about basic arithmetic
properties of the natural numbers. Namely that
<code>forall n. n + 0 = 0</code> and
<code>forall n m. n + (1 + m) = 1 + (n + m)</code>. Which of course it
really shouldn’t be given that we’ve constructed a system at the
type-level which intuitively <em>models</em> arithmetic but GHC is just
a dumb compiler, it can’t automatically deduce the isomorphism between
natural numbers and Peano numbers.</p>
<p>So at each of these call sites we now have a proof obligation to
construct proof terms. Recall from our discussion of propositional
equality from GADTs that we actually have such machinery to construct
this now.</p>
<div class="sourceCode" id="cb697"
data-include="src/17-promotion/reverse.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb697-1"><a href="#cb697-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb697-2"><a href="#cb697-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb697-3"><a href="#cb697-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb697-4"><a href="#cb697-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb697-5"><a href="#cb697-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb697-6"><a href="#cb697-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb697-7"><a href="#cb697-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span></span>
<span id="cb697-8"><a href="#cb697-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-9"><a href="#cb697-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb697-10"><a href="#cb697-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-11"><a href="#cb697-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Nat</span> <span class="ot">=</span> <span class="dt">Z</span> <span class="op">|</span> <span class="dt">S</span> <span class="dt">Nat</span></span>
<span id="cb697-12"><a href="#cb697-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-13"><a href="#cb697-13" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SNat</span> n <span class="kw">where</span></span>
<span id="cb697-14"><a href="#cb697-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Zero</span><span class="ot"> ::</span> <span class="dt">SNat</span> <span class="dt">Z</span></span>
<span id="cb697-15"><a href="#cb697-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Succ</span><span class="ot"> ::</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> (<span class="dt">S</span> n)</span>
<span id="cb697-16"><a href="#cb697-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-17"><a href="#cb697-17" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vec</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="op">*</span> <span class="kw">where</span></span>
<span id="cb697-18"><a href="#cb697-18" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">Vec</span> a <span class="dt">Z</span></span>
<span id="cb697-19"><a href="#cb697-19" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Cons</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a (<span class="dt">S</span> n)</span>
<span id="cb697-20"><a href="#cb697-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-21"><a href="#cb697-21" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Vec</span> a n) <span class="kw">where</span></span>
<span id="cb697-22"><a href="#cb697-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> <span class="dt">Nil</span>         <span class="ot">=</span> <span class="st">&quot;Nil&quot;</span></span>
<span id="cb697-23"><a href="#cb697-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">Cons</span> x xs) <span class="ot">=</span> <span class="st">&quot;Cons &quot;</span> <span class="op">++</span> <span class="fu">show</span> x <span class="op">++</span> <span class="st">&quot; (&quot;</span> <span class="op">++</span> <span class="fu">show</span> xs <span class="op">++</span> <span class="st">&quot;)&quot;</span></span>
<span id="cb697-24"><a href="#cb697-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-25"><a href="#cb697-25" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>) <span class="op">:+</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb697-26"><a href="#cb697-26" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Z</span> <span class="op">:+</span> n <span class="ot">=</span> n</span>
<span id="cb697-27"><a href="#cb697-27" aria-hidden="true" tabindex="-1"></a>  <span class="dt">S</span> m <span class="op">:+</span> n <span class="ot">=</span> <span class="dt">S</span> (m <span class="op">:+</span> n)</span>
<span id="cb697-28"><a href="#cb697-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-29"><a href="#cb697-29" aria-hidden="true" tabindex="-1"></a><span class="co">-- (a ~ b) implies (f a ~ f b)</span></span>
<span id="cb697-30"><a href="#cb697-30" aria-hidden="true" tabindex="-1"></a><span class="ot">cong ::</span> a <span class="op">:~:</span> b <span class="ot">-&gt;</span> f a <span class="op">:~:</span> f b</span>
<span id="cb697-31"><a href="#cb697-31" aria-hidden="true" tabindex="-1"></a>cong <span class="dt">Refl</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb697-32"><a href="#cb697-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-33"><a href="#cb697-33" aria-hidden="true" tabindex="-1"></a><span class="co">-- (a ~ b) implies (f a) implies (f b)</span></span>
<span id="cb697-34"><a href="#cb697-34" aria-hidden="true" tabindex="-1"></a><span class="ot">subst ::</span> a <span class="op">:~:</span> b <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb697-35"><a href="#cb697-35" aria-hidden="true" tabindex="-1"></a>subst <span class="dt">Refl</span> <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb697-36"><a href="#cb697-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-37"><a href="#cb697-37" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_zero ::</span> <span class="kw">forall</span> n<span class="op">.</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> (n <span class="op">:+</span> <span class="dt">Z</span>) <span class="op">:~:</span> n</span>
<span id="cb697-38"><a href="#cb697-38" aria-hidden="true" tabindex="-1"></a>plus_zero <span class="dt">Zero</span> <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb697-39"><a href="#cb697-39" aria-hidden="true" tabindex="-1"></a>plus_zero (<span class="dt">Succ</span> n) <span class="ot">=</span> cong (plus_zero n)</span>
<span id="cb697-40"><a href="#cb697-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-41"><a href="#cb697-41" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_suc ::</span> <span class="kw">forall</span> n m<span class="op">.</span> <span class="dt">SNat</span> n <span class="ot">-&gt;</span> <span class="dt">SNat</span> m <span class="ot">-&gt;</span> (n <span class="op">:+</span> (<span class="dt">S</span> m)) <span class="op">:~:</span> (<span class="dt">S</span> (n <span class="op">:+</span> m))</span>
<span id="cb697-42"><a href="#cb697-42" aria-hidden="true" tabindex="-1"></a>plus_suc <span class="dt">Zero</span> m <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb697-43"><a href="#cb697-43" aria-hidden="true" tabindex="-1"></a>plus_suc (<span class="dt">Succ</span> n) m <span class="ot">=</span> cong (plus_suc n m)</span>
<span id="cb697-44"><a href="#cb697-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-45"><a href="#cb697-45" aria-hidden="true" tabindex="-1"></a><span class="ot">size ::</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">SNat</span> n</span>
<span id="cb697-46"><a href="#cb697-46" aria-hidden="true" tabindex="-1"></a>size <span class="dt">Nil</span>         <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb697-47"><a href="#cb697-47" aria-hidden="true" tabindex="-1"></a>size (<span class="dt">Cons</span> _ xs) <span class="ot">=</span> <span class="dt">Succ</span> <span class="op">$</span> size xs</span>
<span id="cb697-48"><a href="#cb697-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-49"><a href="#cb697-49" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span><span class="ot"> ::</span> <span class="kw">forall</span> n a<span class="op">.</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a n</span>
<span id="cb697-50"><a href="#cb697-50" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> xs <span class="ot">=</span> subst (plus_zero (size xs)) <span class="op">$</span> go <span class="dt">Nil</span> xs</span>
<span id="cb697-51"><a href="#cb697-51" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb697-52"><a href="#cb697-52" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Vec</span> a m <span class="ot">-&gt;</span> <span class="dt">Vec</span> a k <span class="ot">-&gt;</span> <span class="dt">Vec</span> a (k <span class="op">:+</span> m)</span>
<span id="cb697-53"><a href="#cb697-53" aria-hidden="true" tabindex="-1"></a>    go acc <span class="dt">Nil</span> <span class="ot">=</span> acc</span>
<span id="cb697-54"><a href="#cb697-54" aria-hidden="true" tabindex="-1"></a>    go acc (<span class="dt">Cons</span> x xs) <span class="ot">=</span> subst (plus_suc (size xs) (size acc)) <span class="op">$</span> go (<span class="dt">Cons</span> x acc) xs</span>
<span id="cb697-55"><a href="#cb697-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-56"><a href="#cb697-56" aria-hidden="true" tabindex="-1"></a><span class="ot">append ::</span> <span class="dt">Vec</span> a n <span class="ot">-&gt;</span> <span class="dt">Vec</span> a m <span class="ot">-&gt;</span> <span class="dt">Vec</span> a (n <span class="op">:+</span> m)</span>
<span id="cb697-57"><a href="#cb697-57" aria-hidden="true" tabindex="-1"></a>append (<span class="dt">Cons</span> x xs) ys <span class="ot">=</span> <span class="dt">Cons</span> x (append xs ys)</span>
<span id="cb697-58"><a href="#cb697-58" aria-hidden="true" tabindex="-1"></a>append <span class="dt">Nil</span>         ys <span class="ot">=</span> ys</span>
<span id="cb697-59"><a href="#cb697-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-60"><a href="#cb697-60" aria-hidden="true" tabindex="-1"></a><span class="ot">vec ::</span> <span class="dt">Vec</span> <span class="dt">Int</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))</span>
<span id="cb697-61"><a href="#cb697-61" aria-hidden="true" tabindex="-1"></a>vec <span class="ot">=</span> <span class="dv">1</span> <span class="ot">`Cons`</span> (<span class="dv">2</span> <span class="ot">`Cons`</span> (<span class="dv">3</span> <span class="ot">`Cons`</span> <span class="dt">Nil</span>))</span>
<span id="cb697-62"><a href="#cb697-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb697-63"><a href="#cb697-63" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">Vec</span> <span class="dt">Int</span> (<span class="dt">S</span> (<span class="dt">S</span> (<span class="dt">S</span> <span class="dt">Z</span>)))</span>
<span id="cb697-64"><a href="#cb697-64" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> Main.reverse vec</span></code></pre></div>
<p>One might consider whether we could avoid using the singleton trick
and just use type-level natural numbers, and technically this approach
should be feasible although it seems that the natural number solver in
GHC 7.8 can decide some properties but not the ones needed to complete
the natural number proofs for the reverse functions.</p>
<div class="sourceCode" id="cb698"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb698-1"><a href="#cb698-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb698-2"><a href="#cb698-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span></span>
<span id="cb698-3"><a href="#cb698-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb698-4"><a href="#cb698-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb698-5"><a href="#cb698-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb698-6"><a href="#cb698-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb698-7"><a href="#cb698-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">Eq</span>)</span>
<span id="cb698-8"><a href="#cb698-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span></span>
<span id="cb698-9"><a href="#cb698-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Type.Equality</span></span>
<span id="cb698-10"><a href="#cb698-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb698-11"><a href="#cb698-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Z</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb698-12"><a href="#cb698-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb698-13"><a href="#cb698-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">S</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span></span>
<span id="cb698-14"><a href="#cb698-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">S</span> n <span class="ot">=</span> n <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb698-15"><a href="#cb698-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb698-16"><a href="#cb698-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- Yes!</span></span>
<span id="cb698-17"><a href="#cb698-17" aria-hidden="true" tabindex="-1"></a><span class="ot">eq_zero ::</span> <span class="dt">Z</span> <span class="op">:~:</span> <span class="dt">Z</span></span>
<span id="cb698-18"><a href="#cb698-18" aria-hidden="true" tabindex="-1"></a>eq_zero <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb698-19"><a href="#cb698-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb698-20"><a href="#cb698-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- Yes!</span></span>
<span id="cb698-21"><a href="#cb698-21" aria-hidden="true" tabindex="-1"></a><span class="ot">zero_plus_one ::</span> (<span class="dt">Z</span> <span class="op">+</span> <span class="dv">1</span>) <span class="op">:~:</span> (<span class="dv">1</span> <span class="op">+</span> <span class="dt">Z</span>)</span>
<span id="cb698-22"><a href="#cb698-22" aria-hidden="true" tabindex="-1"></a>zero_plus_one <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb698-23"><a href="#cb698-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb698-24"><a href="#cb698-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- Yes!</span></span>
<span id="cb698-25"><a href="#cb698-25" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_zero ::</span> <span class="kw">forall</span> n<span class="op">.</span> (n <span class="op">+</span> <span class="dt">Z</span>) <span class="op">:~:</span> n</span>
<span id="cb698-26"><a href="#cb698-26" aria-hidden="true" tabindex="-1"></a>plus_zero <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb698-27"><a href="#cb698-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb698-28"><a href="#cb698-28" aria-hidden="true" tabindex="-1"></a><span class="co">-- Yes!</span></span>
<span id="cb698-29"><a href="#cb698-29" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_one ::</span> <span class="kw">forall</span> n<span class="op">.</span> (n <span class="op">+</span> <span class="dt">S</span> <span class="dt">Z</span>) <span class="op">:~:</span> <span class="dt">S</span> n</span>
<span id="cb698-30"><a href="#cb698-30" aria-hidden="true" tabindex="-1"></a>plus_one <span class="ot">=</span> <span class="dt">Refl</span></span>
<span id="cb698-31"><a href="#cb698-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb698-32"><a href="#cb698-32" aria-hidden="true" tabindex="-1"></a><span class="co">-- No.</span></span>
<span id="cb698-33"><a href="#cb698-33" aria-hidden="true" tabindex="-1"></a><span class="ot">plus_suc ::</span> <span class="kw">forall</span> n m<span class="op">.</span> (n <span class="op">+</span> (<span class="dt">S</span> m)) <span class="op">:~:</span> (<span class="dt">S</span> (n <span class="op">+</span> m))</span>
<span id="cb698-34"><a href="#cb698-34" aria-hidden="true" tabindex="-1"></a>plus_suc <span class="ot">=</span> <span class="dt">Refl</span></span></code></pre></div>
<p>Caveat should be that there might be a way to do this in GHC 7.6 that
I’m not aware of. In GHC 7.10 there are some planned changes to solver
that should be able to resolve these issues. In particular there are
plans to allow pluggable type system extensions that could outsource
these kind of problems to third party SMT solvers which can solve these
kind of numeric relations and return this information back to GHC’s
typechecker.</p>
<p>As an aside this is a direct transliteration of the equivalent proof
in Agda, which is accomplished via the same method but without the song
and dance to get around the lack of dependent types.</p>
<div class="sourceCode" id="cb699"
data-include="src/17-promotion/Vector.agda"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb699-1"><a href="#cb699-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Vector</span> <span class="kw">where</span></span>
<span id="cb699-2"><a href="#cb699-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-3"><a href="#cb699-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">10</span> _∷_</span>
<span id="cb699-4"><a href="#cb699-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-5"><a href="#cb699-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> ℕ <span class="op">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb699-6"><a href="#cb699-6" aria-hidden="true" tabindex="-1"></a>  zero <span class="op">:</span> ℕ</span>
<span id="cb699-7"><a href="#cb699-7" aria-hidden="true" tabindex="-1"></a>  suc  <span class="op">:</span> ℕ → ℕ</span>
<span id="cb699-8"><a href="#cb699-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-9"><a href="#cb699-9" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# BUILTIN NATURAL ℕ    #-}</span></span>
<span id="cb699-10"><a href="#cb699-10" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# BUILTIN ZERO    zero #-}</span></span>
<span id="cb699-11"><a href="#cb699-11" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# BUILTIN SUC     suc  #-}</span></span>
<span id="cb699-12"><a href="#cb699-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-13"><a href="#cb699-13" aria-hidden="true" tabindex="-1"></a><span class="kw">infixl</span> <span class="dv">6</span> _<span class="op">+</span>_</span>
<span id="cb699-14"><a href="#cb699-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-15"><a href="#cb699-15" aria-hidden="true" tabindex="-1"></a>_<span class="op">+</span>_ <span class="op">:</span> ℕ → ℕ → ℕ</span>
<span id="cb699-16"><a href="#cb699-16" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">+</span> n <span class="ot">=</span> n</span>
<span id="cb699-17"><a href="#cb699-17" aria-hidden="true" tabindex="-1"></a>suc m <span class="op">+</span> n <span class="ot">=</span> suc (m <span class="op">+</span> n)</span>
<span id="cb699-18"><a href="#cb699-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-19"><a href="#cb699-19" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Vec</span> (<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>) <span class="op">:</span> ℕ → <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb699-20"><a href="#cb699-20" aria-hidden="true" tabindex="-1"></a>  []  <span class="op">:</span> <span class="dt">Vec</span> <span class="dt">A</span> <span class="dv">0</span></span>
<span id="cb699-21"><a href="#cb699-21" aria-hidden="true" tabindex="-1"></a>  _∷_ <span class="op">:</span> ∀ {n} → <span class="dt">A</span> → <span class="dt">Vec</span> <span class="dt">A</span> n → <span class="dt">Vec</span> <span class="dt">A</span> (suc n)</span>
<span id="cb699-22"><a href="#cb699-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-23"><a href="#cb699-23" aria-hidden="true" tabindex="-1"></a>_<span class="op">++</span>_ <span class="op">:</span> ∀ {<span class="dt">A</span> n m} → <span class="dt">Vec</span> <span class="dt">A</span> n → <span class="dt">Vec</span> <span class="dt">A</span> m → <span class="dt">Vec</span> <span class="dt">A</span> (n <span class="op">+</span> m)</span>
<span id="cb699-24"><a href="#cb699-24" aria-hidden="true" tabindex="-1"></a>[] <span class="op">++</span> ys <span class="ot">=</span> ys</span>
<span id="cb699-25"><a href="#cb699-25" aria-hidden="true" tabindex="-1"></a>(x ∷ xs) <span class="op">++</span> ys <span class="ot">=</span> x ∷ (xs <span class="op">++</span> ys)</span>
<span id="cb699-26"><a href="#cb699-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-27"><a href="#cb699-27" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> _≡_</span>
<span id="cb699-28"><a href="#cb699-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-29"><a href="#cb699-29" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> _≡_ {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} (x <span class="op">:</span> <span class="dt">A</span>) <span class="op">:</span> <span class="dt">A</span> → <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb699-30"><a href="#cb699-30" aria-hidden="true" tabindex="-1"></a>  refl <span class="op">:</span> x ≡ x</span>
<span id="cb699-31"><a href="#cb699-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-32"><a href="#cb699-32" aria-hidden="true" tabindex="-1"></a>subst <span class="op">:</span> {<span class="dt">A</span> <span class="op">:</span> <span class="dt">Set</span>} → (<span class="dt">P</span> <span class="op">:</span> <span class="dt">A</span> → <span class="dt">Set</span>) → ∀{x y} → x ≡ y → <span class="dt">P</span> x → <span class="dt">P</span> y</span>
<span id="cb699-33"><a href="#cb699-33" aria-hidden="true" tabindex="-1"></a>subst <span class="dt">P</span> refl p <span class="ot">=</span> p</span>
<span id="cb699-34"><a href="#cb699-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-35"><a href="#cb699-35" aria-hidden="true" tabindex="-1"></a>cong <span class="op">:</span> {<span class="dt">A</span> <span class="dt">B</span> <span class="op">:</span> <span class="dt">Set</span>} (f <span class="op">:</span> <span class="dt">A</span> → <span class="dt">B</span>) → {x y <span class="op">:</span> <span class="dt">A</span>} → x ≡ y → f x ≡ f y</span>
<span id="cb699-36"><a href="#cb699-36" aria-hidden="true" tabindex="-1"></a>cong f refl <span class="ot">=</span> refl</span>
<span id="cb699-37"><a href="#cb699-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-38"><a href="#cb699-38" aria-hidden="true" tabindex="-1"></a>vec <span class="op">:</span> ∀ {<span class="dt">A</span>} (k <span class="op">:</span> ℕ) → <span class="dt">Set</span></span>
<span id="cb699-39"><a href="#cb699-39" aria-hidden="true" tabindex="-1"></a>vec {<span class="dt">A</span>} k <span class="ot">=</span> <span class="dt">Vec</span> <span class="dt">A</span> k</span>
<span id="cb699-40"><a href="#cb699-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-41"><a href="#cb699-41" aria-hidden="true" tabindex="-1"></a>plus_zero <span class="op">:</span> {n <span class="op">:</span> ℕ} → n <span class="op">+</span> <span class="dv">0</span> ≡ n </span>
<span id="cb699-42"><a href="#cb699-42" aria-hidden="true" tabindex="-1"></a>plus_zero {zero}  <span class="ot">=</span> refl</span>
<span id="cb699-43"><a href="#cb699-43" aria-hidden="true" tabindex="-1"></a>plus_zero {suc n} <span class="ot">=</span> cong suc plus_zero</span>
<span id="cb699-44"><a href="#cb699-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-45"><a href="#cb699-45" aria-hidden="true" tabindex="-1"></a>plus_suc <span class="op">:</span> {n <span class="op">:</span> ℕ} → n <span class="op">+</span> (suc <span class="dv">0</span>) ≡ suc n </span>
<span id="cb699-46"><a href="#cb699-46" aria-hidden="true" tabindex="-1"></a>plus_suc {zero}  <span class="ot">=</span> refl</span>
<span id="cb699-47"><a href="#cb699-47" aria-hidden="true" tabindex="-1"></a>plus_suc {suc n} <span class="ot">=</span> cong suc (plus_suc {n})</span>
<span id="cb699-48"><a href="#cb699-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb699-49"><a href="#cb699-49" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> <span class="op">:</span> ∀ {<span class="dt">A</span> n} → <span class="dt">Vec</span> <span class="dt">A</span> n → <span class="dt">Vec</span> <span class="dt">A</span> n</span>
<span id="cb699-50"><a href="#cb699-50" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> []       <span class="ot">=</span> []</span>
<span id="cb699-51"><a href="#cb699-51" aria-hidden="true" tabindex="-1"></a><span class="fu">reverse</span> {<span class="dt">A</span>} {suc n} (x ∷ xs) <span class="ot">=</span> subst vec (plus_suc {n}) (<span class="fu">reverse</span> xs <span class="op">++</span> (x ∷ []))</span></code></pre></div>
<h2 id="liquid-haskell">Liquid Haskell</h2>
<p>LiquidHaskell is an extension to GHC’s typesystem that adds the
capacity for refinement types using the annotation syntax. The type
signatures of functions can be checked by the external for richer type
semantics than default GHC provides, including non-exhaustive patterns
and complex arithmetic properties that require external SMT solvers to
verify. For instance LiquidHaskell can statically verify that a function
that operates over a <code>Maybe a</code> is always given a
<code>Just</code> or that an arithmetic function always yields an Int
that is an even positive number.</p>
<p>LiquidHaskell analyses the modules and discharges proof obligations
to an SMT solver to see if the conditions are satisfiable. This allows
us to prove the absence of a family of errors around memory safety,
arithmetic exceptions and information flow.</p>
<p>You will need <em>either</em> the Microsoft Research <a
href="https://github.com/Z3Prover/z3">Z3 SMT solver</a> or Stanford <a
href="https://cvc4.github.io/">CVC4 SMT solver</a>.</p>
<p>For Linux:</p>
<div class="sourceCode" id="cb700"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb700-1"><a href="#cb700-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> apt install z3 <span class="co"># z3</span></span>
<span id="cb700-2"><a href="#cb700-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> apt install cvc4 <span class="co"># cvc4</span></span></code></pre></div>
<p>For Mac:</p>
<div class="sourceCode" id="cb701"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb701-1"><a href="#cb701-1" aria-hidden="true" tabindex="-1"></a><span class="ex">brew</span> tap z3 <span class="co"># z3</span></span>
<span id="cb701-2"><a href="#cb701-2" aria-hidden="true" tabindex="-1"></a><span class="ex">brew</span> tap cvc4/cvc4 <span class="co"># cvc4</span></span>
<span id="cb701-3"><a href="#cb701-3" aria-hidden="true" tabindex="-1"></a><span class="ex">brew</span> install cvc4/cvc4/cvc4</span></code></pre></div>
<p>Then install LiquidHaskell either with Cabal or Stack:</p>
<div class="sourceCode" id="cb702"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb702-1"><a href="#cb702-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Run one of the following</span></span>
<span id="cb702-2"><a href="#cb702-2" aria-hidden="true" tabindex="-1"></a><span class="ex">cabal</span> install liquidhaskell</span>
<span id="cb702-3"><a href="#cb702-3" aria-hidden="true" tabindex="-1"></a><span class="ex">stack</span> install liquidhaskell</span></code></pre></div>
<p>Then with the LiquidHaskell framework installed you can annotate your
Haskell modules with refinement types and run the
<code>liquid</code></p>
<div class="sourceCode" id="cb703"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb703-1"><a href="#cb703-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (mod, gcd)</span>
<span id="cb703-2"><a href="#cb703-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb703-3"><a href="#cb703-3" aria-hidden="true" tabindex="-1"></a><span class="co">{-@ mod :: a:Nat -&gt; b:{v:Nat| 0 &lt; v} -&gt; {v:Nat | v &lt; b} @-}</span></span>
<span id="cb703-4"><a href="#cb703-4" aria-hidden="true" tabindex="-1"></a><span class="fu">mod</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb703-5"><a href="#cb703-5" aria-hidden="true" tabindex="-1"></a><span class="fu">mod</span> a b</span>
<span id="cb703-6"><a href="#cb703-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> a <span class="op">&lt;</span> b <span class="ot">=</span> a</span>
<span id="cb703-7"><a href="#cb703-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">mod</span> (a <span class="op">-</span> b) b</span>
<span id="cb703-8"><a href="#cb703-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb703-9"><a href="#cb703-9" aria-hidden="true" tabindex="-1"></a><span class="co">{-@ gcd :: a:Nat -&gt; b:{v:Nat | v &lt; a} -&gt; Int @-}</span></span>
<span id="cb703-10"><a href="#cb703-10" aria-hidden="true" tabindex="-1"></a><span class="fu">gcd</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb703-11"><a href="#cb703-11" aria-hidden="true" tabindex="-1"></a><span class="fu">gcd</span> a <span class="dv">0</span> <span class="ot">=</span> a</span>
<span id="cb703-12"><a href="#cb703-12" aria-hidden="true" tabindex="-1"></a><span class="fu">gcd</span> a b <span class="ot">=</span> <span class="fu">gcd</span> b (a <span class="ot">`mod`</span> b)</span></code></pre></div>
<p>The module can be run through the solver using the
<code>liquid</code> command line tool.</p>
<div class="sourceCode" id="cb704"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb704-1"><a href="#cb704-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> liquid example.hs</span>
<span id="cb704-2"><a href="#cb704-2" aria-hidden="true" tabindex="-1"></a><span class="ex">Done</span> solving.</span>
<span id="cb704-3"><a href="#cb704-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb704-4"><a href="#cb704-4" aria-hidden="true" tabindex="-1"></a><span class="ex">****</span> DONE:  solve <span class="pp">**************************************************************</span></span>
<span id="cb704-5"><a href="#cb704-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb704-6"><a href="#cb704-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb704-7"><a href="#cb704-7" aria-hidden="true" tabindex="-1"></a><span class="ex">****</span> DONE:  annotate <span class="pp">***********************************************************</span></span>
<span id="cb704-8"><a href="#cb704-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb704-9"><a href="#cb704-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb704-10"><a href="#cb704-10" aria-hidden="true" tabindex="-1"></a><span class="ex">****</span> RESULT: SAFE <span class="pp">**************************************************************</span></span></code></pre></div>
<p>To run Liquid Haskell over a Cabal project you can include the cabal
directory by passing <code>cabaldir</code> flag and then including the
source directory which contains your application code. You can specify
additional specification for external modules by including a
<code>spec</code> folder containing special LH modules with
definitions.</p>
<p>An example specification module.</p>
<div class="sourceCode" id="cb705"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb705-1"><a href="#cb705-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> spec <span class="dt">MySpec</span> <span class="kw">where</span></span>
<span id="cb705-2"><a href="#cb705-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb705-3"><a href="#cb705-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Base</span></span>
<span id="cb705-4"><a href="#cb705-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Integer</span></span>
<span id="cb705-5"><a href="#cb705-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span></span>
<span id="cb705-6"><a href="#cb705-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb705-7"><a href="#cb705-7" aria-hidden="true" tabindex="-1"></a>assume<span class="ot"> length ::</span> <span class="dt">Data.Foldable.Foldable</span> f <span class="ot">=&gt;</span> xs<span class="op">:</span>f a <span class="ot">-&gt;</span> {v<span class="op">:</span><span class="dt">Nat</span> <span class="op">|</span> v <span class="ot">=</span> len xs}</span></code></pre></div>
<p>To run the checker over your project:</p>
<div class="sourceCode" id="cb706"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb706-1"><a href="#cb706-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> liquid <span class="at">-f</span> <span class="at">--cabaldir</span> <span class="at">-i</span> src <span class="at">-i</span> spec src/<span class="pp">*</span>.hs</span></code></pre></div>
<p>For more extensive documentation and further use cases see the
official documentation:</p>
<ul>
<li><a
href="https://ucsd-progsys.github.io/liquidhaskell-tutorial/Tutorial_01_Introduction.html">Liquid
Haskell Documentation</a></li>
</ul>
</hr>
<h1 id="generics">Generics</h1>
<p>Haskell has several techniques for automatic generation of type
classes for a variety of tasks that consist largely of boilerplate code
generation such as:</p>
<ul>
<li>Pretty Printing</li>
<li>Equality</li>
<li>Serialization</li>
<li>Ordering</li>
<li>Traversals</li>
</ul>
<h2 id="generic">Generic</h2>
<p>The most modern method of doing generic programming uses type
families to achieve a better method of deriving the structural
properties of arbitrary type classes. Generic implements a typeclass
with an associated type <code>Rep</code> ( Representation ) together
with a pair of functions that form a 2-sided inverse ( isomorphism ) for
converting to and from the associated type and the derived type in
question.</p>
<div class="sourceCode" id="cb707"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb707-1"><a href="#cb707-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Generic</span> a <span class="kw">where</span></span>
<span id="cb707-2"><a href="#cb707-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Rep</span> a</span>
<span id="cb707-3"><a href="#cb707-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  from ::</span> a <span class="ot">-&gt;</span> <span class="dt">Rep</span> a</span>
<span id="cb707-4"><a href="#cb707-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  to ::</span> <span class="dt">Rep</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb707-5"><a href="#cb707-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb707-6"><a href="#cb707-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Datatype</span> d <span class="kw">where</span></span>
<span id="cb707-7"><a href="#cb707-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  datatypeName ::</span> t d f a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb707-8"><a href="#cb707-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  moduleName ::</span> t d f a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb707-9"><a href="#cb707-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb707-10"><a href="#cb707-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Constructor</span> c <span class="kw">where</span></span>
<span id="cb707-11"><a href="#cb707-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  conName ::</span> t c f a <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<p><a
href="https://www.haskell.org/ghc/docs/7.4.1/html/libraries/ghc-prim-0.2.0.0/GHC-Generics.html">GHC.Generics</a>
defines a set of named types for modeling the various structural
properties of types in available in Haskell.</p>
<div class="sourceCode" id="cb708"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb708-1"><a href="#cb708-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Sums: encode choice between constructors</span></span>
<span id="cb708-2"><a href="#cb708-2" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:+:</span></span>
<span id="cb708-3"><a href="#cb708-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> (<span class="op">:+:</span>) f g p <span class="ot">=</span> <span class="dt">L1</span> (f p) <span class="op">|</span> <span class="dt">R1</span> (g p)</span>
<span id="cb708-4"><a href="#cb708-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb708-5"><a href="#cb708-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Products: encode multiple arguments to constructors</span></span>
<span id="cb708-6"><a href="#cb708-6" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">6</span> <span class="op">:*:</span></span>
<span id="cb708-7"><a href="#cb708-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> (<span class="op">:*:</span>) f g p <span class="ot">=</span> f p <span class="op">:*:</span> g p</span>
<span id="cb708-8"><a href="#cb708-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb708-9"><a href="#cb708-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Tag for M1: datatype</span></span>
<span id="cb708-10"><a href="#cb708-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">D</span></span>
<span id="cb708-11"><a href="#cb708-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Tag for M1: constructor</span></span>
<span id="cb708-12"><a href="#cb708-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">C</span></span>
<span id="cb708-13"><a href="#cb708-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb708-14"><a href="#cb708-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Constants, additional parameters and recursion of kind *</span></span>
<span id="cb708-15"><a href="#cb708-15" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">K1</span> i c p <span class="ot">=</span> <span class="dt">K1</span> {<span class="ot"> unK1 ::</span> c }</span>
<span id="cb708-16"><a href="#cb708-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb708-17"><a href="#cb708-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Meta-information (constructor names, etc.)</span></span>
<span id="cb708-18"><a href="#cb708-18" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">M1</span> i c f p <span class="ot">=</span> <span class="dt">M1</span> {<span class="ot"> unM1 ::</span> f p }</span>
<span id="cb708-19"><a href="#cb708-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb708-20"><a href="#cb708-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Type synonym for encoding meta-information for datatypes</span></span>
<span id="cb708-21"><a href="#cb708-21" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">D1</span> <span class="ot">=</span> <span class="dt">M1</span> <span class="dt">D</span></span>
<span id="cb708-22"><a href="#cb708-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb708-23"><a href="#cb708-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Type synonym for encoding meta-information for constructors</span></span>
<span id="cb708-24"><a href="#cb708-24" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">C1</span> <span class="ot">=</span> <span class="dt">M1</span> <span class="dt">C</span></span></code></pre></div>
<p>Using the deriving mechanics GHC can generate this Generic instance
for us mechanically, if we were to write it by hand for a simple type it
might look like this:</p>
<div class="sourceCode" id="cb709"
data-include="src/18-generics/generics.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb709-1"><a href="#cb709-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb709-2"><a href="#cb709-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb709-3"><a href="#cb709-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb709-4"><a href="#cb709-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb709-5"><a href="#cb709-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb709-6"><a href="#cb709-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb709-7"><a href="#cb709-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Animal</span></span>
<span id="cb709-8"><a href="#cb709-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Dog</span></span>
<span id="cb709-9"><a href="#cb709-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Cat</span></span>
<span id="cb709-10"><a href="#cb709-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb709-11"><a href="#cb709-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Generic</span> <span class="dt">Animal</span> <span class="kw">where</span></span>
<span id="cb709-12"><a href="#cb709-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span></span>
<span id="cb709-13"><a href="#cb709-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Rep</span> <span class="dt">Animal</span> <span class="ot">=</span></span>
<span id="cb709-14"><a href="#cb709-14" aria-hidden="true" tabindex="-1"></a>      <span class="dt">D1</span> ( <span class="dt">&#39;MetaData</span> <span class="st">&quot;Animal&quot;</span> <span class="st">&quot;Main&quot;</span> <span class="st">&quot;main&quot;</span> <span class="dt">&#39;False</span> )</span>
<span id="cb709-15"><a href="#cb709-15" aria-hidden="true" tabindex="-1"></a>         ( <span class="dt">C1</span> ( <span class="dt">&#39;MetaCons</span> <span class="st">&quot;Dog&quot;</span> <span class="dt">&#39;PrefixI</span> <span class="dt">&#39;False</span>)</span>
<span id="cb709-16"><a href="#cb709-16" aria-hidden="true" tabindex="-1"></a>           <span class="dt">U1</span> <span class="op">:+:</span> <span class="dt">C1</span> ( <span class="dt">&#39;MetaCons</span> <span class="st">&quot;Cat&quot;</span> <span class="dt">&#39;PrefixI</span> <span class="dt">&#39;False</span>) <span class="dt">U1</span></span>
<span id="cb709-17"><a href="#cb709-17" aria-hidden="true" tabindex="-1"></a>         )</span>
<span id="cb709-18"><a href="#cb709-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb709-19"><a href="#cb709-19" aria-hidden="true" tabindex="-1"></a>  from <span class="dt">Dog</span> <span class="ot">=</span> <span class="dt">M1</span> (<span class="dt">L1</span> (<span class="dt">M1</span> <span class="dt">U1</span>))</span>
<span id="cb709-20"><a href="#cb709-20" aria-hidden="true" tabindex="-1"></a>  from <span class="dt">Cat</span> <span class="ot">=</span> <span class="dt">M1</span> (<span class="dt">R1</span> (<span class="dt">M1</span> <span class="dt">U1</span>))</span>
<span id="cb709-21"><a href="#cb709-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb709-22"><a href="#cb709-22" aria-hidden="true" tabindex="-1"></a>  to (<span class="dt">M1</span> (<span class="dt">L1</span> (<span class="dt">M1</span> <span class="dt">U1</span>))) <span class="ot">=</span> <span class="dt">Dog</span></span>
<span id="cb709-23"><a href="#cb709-23" aria-hidden="true" tabindex="-1"></a>  to (<span class="dt">M1</span> (<span class="dt">R1</span> (<span class="dt">M1</span> <span class="dt">U1</span>))) <span class="ot">=</span> <span class="dt">Cat</span></span>
<span id="cb709-24"><a href="#cb709-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb709-25"><a href="#cb709-25" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">T_Animal</span> <span class="co">-- Animal type</span></span>
<span id="cb709-26"><a href="#cb709-26" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">C_Dog</span> <span class="co">-- Dog Constructor</span></span>
<span id="cb709-27"><a href="#cb709-27" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">C_Cat</span> <span class="co">-- Cat Constructor</span></span>
<span id="cb709-28"><a href="#cb709-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb709-29"><a href="#cb709-29" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Datatype</span> <span class="dt">T_Animal</span> <span class="kw">where</span></span>
<span id="cb709-30"><a href="#cb709-30" aria-hidden="true" tabindex="-1"></a>  datatypeName _ <span class="ot">=</span> <span class="st">&quot;Animal&quot;</span></span>
<span id="cb709-31"><a href="#cb709-31" aria-hidden="true" tabindex="-1"></a>  moduleName _ <span class="ot">=</span> <span class="st">&quot;Main&quot;</span></span>
<span id="cb709-32"><a href="#cb709-32" aria-hidden="true" tabindex="-1"></a>  packageName _ <span class="ot">=</span> <span class="st">&quot;main&quot;</span></span>
<span id="cb709-33"><a href="#cb709-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb709-34"><a href="#cb709-34" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Constructor</span> <span class="dt">C_Dog</span> <span class="kw">where</span></span>
<span id="cb709-35"><a href="#cb709-35" aria-hidden="true" tabindex="-1"></a>  conName _ <span class="ot">=</span> <span class="st">&quot;Dog&quot;</span></span>
<span id="cb709-36"><a href="#cb709-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb709-37"><a href="#cb709-37" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Constructor</span> <span class="dt">C_Cat</span> <span class="kw">where</span></span>
<span id="cb709-38"><a href="#cb709-38" aria-hidden="true" tabindex="-1"></a>  conName _ <span class="ot">=</span> <span class="st">&quot;Cat&quot;</span></span></code></pre></div>
<p>Use <code>kind!</code> in GHCi we can look at the type family
<code>Rep</code> associated with a Generic instance.</p>
<div class="sourceCode" id="cb710"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb710-1"><a href="#cb710-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Rep</span> <span class="dt">Animal</span></span>
<span id="cb710-2"><a href="#cb710-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Rep</span> <span class="dt">Animal</span><span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb710-3"><a href="#cb710-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">M1</span> <span class="dt">D</span> <span class="dt">T_Animal</span> (<span class="dt">M1</span> <span class="dt">C</span> <span class="dt">C_Dog</span> <span class="dt">U1</span> <span class="op">:+:</span> <span class="dt">M1</span> <span class="dt">C</span> <span class="dt">C_Cat</span> <span class="dt">U1</span>)</span>
<span id="cb710-4"><a href="#cb710-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb710-5"><a href="#cb710-5" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Rep</span> ()</span>
<span id="cb710-6"><a href="#cb710-6" aria-hidden="true" tabindex="-1"></a><span class="dt">Rep</span><span class="ot"> () ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb710-7"><a href="#cb710-7" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">M1</span> <span class="dt">D</span> <span class="dt">GHC.Generics.D1</span>() (<span class="dt">M1</span> <span class="dt">C</span> <span class="dt">GHC.Generics.C1_0</span>() <span class="dt">U1</span>)</span>
<span id="cb710-8"><a href="#cb710-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb710-9"><a href="#cb710-9" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">:</span>kind<span class="op">!</span> <span class="dt">Rep</span> [()]</span>
<span id="cb710-10"><a href="#cb710-10" aria-hidden="true" tabindex="-1"></a><span class="dt">Rep</span> [()]<span class="ot"> ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb710-11"><a href="#cb710-11" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">M1</span></span>
<span id="cb710-12"><a href="#cb710-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">D</span></span>
<span id="cb710-13"><a href="#cb710-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GHC.Generics.D1</span>[]</span>
<span id="cb710-14"><a href="#cb710-14" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">M1</span> <span class="dt">C</span> <span class="dt">GHC.Generics.C1_0</span>[] <span class="dt">U1</span></span>
<span id="cb710-15"><a href="#cb710-15" aria-hidden="true" tabindex="-1"></a>     <span class="op">:+:</span> <span class="dt">M1</span></span>
<span id="cb710-16"><a href="#cb710-16" aria-hidden="true" tabindex="-1"></a>           <span class="dt">C</span></span>
<span id="cb710-17"><a href="#cb710-17" aria-hidden="true" tabindex="-1"></a>           <span class="dt">GHC.Generics.C1_1</span>[]</span>
<span id="cb710-18"><a href="#cb710-18" aria-hidden="true" tabindex="-1"></a>           (<span class="dt">M1</span> <span class="dt">S</span> <span class="dt">NoSelector</span> (<span class="dt">K1</span> <span class="dt">R</span> ()) <span class="op">:*:</span> <span class="dt">M1</span> <span class="dt">S</span> <span class="dt">NoSelector</span> (<span class="dt">K1</span> <span class="dt">R</span> [()])))</span></code></pre></div>
<p>Now the clever bit, instead writing our generic function over the
datatype we instead write it over the Rep and then reify the result
using <code>from</code>. So for an equivalent version of Haskell’s
default <code>Eq</code> that instead uses generic deriving we could
write:</p>
<div class="sourceCode" id="cb711"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb711-1"><a href="#cb711-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">GEq&#39;</span> f <span class="kw">where</span></span>
<span id="cb711-2"><a href="#cb711-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  geq&#39; ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb711-3"><a href="#cb711-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb711-4"><a href="#cb711-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">GEq&#39;</span> <span class="dt">U1</span> <span class="kw">where</span></span>
<span id="cb711-5"><a href="#cb711-5" aria-hidden="true" tabindex="-1"></a>  geq&#39; _ _ <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb711-6"><a href="#cb711-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb711-7"><a href="#cb711-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">GEq</span> c) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (<span class="dt">K1</span> i c) <span class="kw">where</span></span>
<span id="cb711-8"><a href="#cb711-8" aria-hidden="true" tabindex="-1"></a>  geq&#39; (<span class="dt">K1</span> a) (<span class="dt">K1</span> b) <span class="ot">=</span> geq a b</span>
<span id="cb711-9"><a href="#cb711-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb711-10"><a href="#cb711-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">GEq&#39;</span> a) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (<span class="dt">M1</span> i c a) <span class="kw">where</span></span>
<span id="cb711-11"><a href="#cb711-11" aria-hidden="true" tabindex="-1"></a>  geq&#39; (<span class="dt">M1</span> a) (<span class="dt">M1</span> b) <span class="ot">=</span> geq&#39; a b</span>
<span id="cb711-12"><a href="#cb711-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb711-13"><a href="#cb711-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Equality for sums.</span></span>
<span id="cb711-14"><a href="#cb711-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">GEq&#39;</span> a, <span class="dt">GEq&#39;</span> b) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (a <span class="op">:+:</span> b) <span class="kw">where</span></span>
<span id="cb711-15"><a href="#cb711-15" aria-hidden="true" tabindex="-1"></a>  geq&#39; (<span class="dt">L1</span> a) (<span class="dt">L1</span> b) <span class="ot">=</span> geq&#39; a b</span>
<span id="cb711-16"><a href="#cb711-16" aria-hidden="true" tabindex="-1"></a>  geq&#39; (<span class="dt">R1</span> a) (<span class="dt">R1</span> b) <span class="ot">=</span> geq&#39; a b</span>
<span id="cb711-17"><a href="#cb711-17" aria-hidden="true" tabindex="-1"></a>  geq&#39; _      _      <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb711-18"><a href="#cb711-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb711-19"><a href="#cb711-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- Equality for products.</span></span>
<span id="cb711-20"><a href="#cb711-20" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">GEq&#39;</span> a, <span class="dt">GEq&#39;</span> b) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (a <span class="op">:*:</span> b) <span class="kw">where</span></span>
<span id="cb711-21"><a href="#cb711-21" aria-hidden="true" tabindex="-1"></a>  geq&#39; (a1 <span class="op">:*:</span> b1) (a2 <span class="op">:*:</span> b2) <span class="ot">=</span> geq&#39; a1 a2 <span class="op">&amp;&amp;</span> geq&#39; b1 b2</span></code></pre></div>
<p>To accommodate the two methods of writing classes (generic-deriving
or custom implementations) we can use the <code>DefaultSignatures</code>
extension to allow the user to leave typeclass functions blank and defer
to Generic or to define their own.</p>
<div class="sourceCode" id="cb712"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb712-1"><a href="#cb712-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DefaultSignatures #-}</span></span>
<span id="cb712-2"><a href="#cb712-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb712-3"><a href="#cb712-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">GEq</span> a <span class="kw">where</span></span>
<span id="cb712-4"><a href="#cb712-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  geq ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb712-5"><a href="#cb712-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb712-6"><a href="#cb712-6" aria-hidden="true" tabindex="-1"></a>  default<span class="ot"> geq ::</span> (<span class="dt">Generic</span> a, <span class="dt">GEq&#39;</span> (<span class="dt">Rep</span> a)) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb712-7"><a href="#cb712-7" aria-hidden="true" tabindex="-1"></a>  geq x y <span class="ot">=</span> geq&#39; (from x) (from y)</span></code></pre></div>
<p>Now anyone using our library need only derive Generic and create an
empty instance of our typeclass instance without writing any boilerplate
for <code>GEq</code>.</p>
<p>Here is a complete example for deriving equality generics:</p>
<div class="sourceCode" id="cb713"
data-include="src/18-generics/generic_impl.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb713-1"><a href="#cb713-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb713-2"><a href="#cb713-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb713-3"><a href="#cb713-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DefaultSignatures #-}</span></span>
<span id="cb713-4"><a href="#cb713-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb713-5"><a href="#cb713-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb713-6"><a href="#cb713-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb713-7"><a href="#cb713-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Auxiliary class</span></span>
<span id="cb713-8"><a href="#cb713-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">GEq&#39;</span> f <span class="kw">where</span></span>
<span id="cb713-9"><a href="#cb713-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  geq&#39; ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb713-10"><a href="#cb713-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb713-11"><a href="#cb713-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">GEq&#39;</span> <span class="dt">U1</span> <span class="kw">where</span></span>
<span id="cb713-12"><a href="#cb713-12" aria-hidden="true" tabindex="-1"></a>  geq&#39; _ _ <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb713-13"><a href="#cb713-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb713-14"><a href="#cb713-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">GEq</span> c) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (<span class="dt">K1</span> i c) <span class="kw">where</span></span>
<span id="cb713-15"><a href="#cb713-15" aria-hidden="true" tabindex="-1"></a>  geq&#39; (<span class="dt">K1</span> a) (<span class="dt">K1</span> b) <span class="ot">=</span> geq a b</span>
<span id="cb713-16"><a href="#cb713-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb713-17"><a href="#cb713-17" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">GEq&#39;</span> a) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (<span class="dt">M1</span> i c a) <span class="kw">where</span></span>
<span id="cb713-18"><a href="#cb713-18" aria-hidden="true" tabindex="-1"></a>  geq&#39; (<span class="dt">M1</span> a) (<span class="dt">M1</span> b) <span class="ot">=</span> geq&#39; a b</span>
<span id="cb713-19"><a href="#cb713-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb713-20"><a href="#cb713-20" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">GEq&#39;</span> a, <span class="dt">GEq&#39;</span> b) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (a <span class="op">:+:</span> b) <span class="kw">where</span></span>
<span id="cb713-21"><a href="#cb713-21" aria-hidden="true" tabindex="-1"></a>  geq&#39; (<span class="dt">L1</span> a) (<span class="dt">L1</span> b) <span class="ot">=</span> geq&#39; a b</span>
<span id="cb713-22"><a href="#cb713-22" aria-hidden="true" tabindex="-1"></a>  geq&#39; (<span class="dt">R1</span> a) (<span class="dt">R1</span> b) <span class="ot">=</span> geq&#39; a b</span>
<span id="cb713-23"><a href="#cb713-23" aria-hidden="true" tabindex="-1"></a>  geq&#39; _      _      <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb713-24"><a href="#cb713-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb713-25"><a href="#cb713-25" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">GEq&#39;</span> a, <span class="dt">GEq&#39;</span> b) <span class="ot">=&gt;</span> <span class="dt">GEq&#39;</span> (a <span class="op">:*:</span> b) <span class="kw">where</span></span>
<span id="cb713-26"><a href="#cb713-26" aria-hidden="true" tabindex="-1"></a>  geq&#39; (a1 <span class="op">:*:</span> b1) (a2 <span class="op">:*:</span> b2) <span class="ot">=</span> geq&#39; a1 a2 <span class="op">&amp;&amp;</span> geq&#39; b1 b2</span>
<span id="cb713-27"><a href="#cb713-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb713-28"><a href="#cb713-28" aria-hidden="true" tabindex="-1"></a><span class="co">--</span></span>
<span id="cb713-29"><a href="#cb713-29" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">GEq</span> a <span class="kw">where</span></span>
<span id="cb713-30"><a href="#cb713-30" aria-hidden="true" tabindex="-1"></a><span class="ot">  geq ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb713-31"><a href="#cb713-31" aria-hidden="true" tabindex="-1"></a>  default<span class="ot"> geq ::</span> (<span class="dt">Generic</span> a, <span class="dt">GEq&#39;</span> (<span class="dt">Rep</span> a)) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb713-32"><a href="#cb713-32" aria-hidden="true" tabindex="-1"></a>  geq x y <span class="ot">=</span> geq&#39; (from x) (from y)</span>
<span id="cb713-33"><a href="#cb713-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb713-34"><a href="#cb713-34" aria-hidden="true" tabindex="-1"></a><span class="co">-- Base equalities</span></span>
<span id="cb713-35"><a href="#cb713-35" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">GEq</span> <span class="dt">Char</span> <span class="kw">where</span> geq <span class="ot">=</span> (<span class="op">==</span>)</span>
<span id="cb713-36"><a href="#cb713-36" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">GEq</span> <span class="dt">Int</span> <span class="kw">where</span> geq <span class="ot">=</span> (<span class="op">==</span>)</span>
<span id="cb713-37"><a href="#cb713-37" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">GEq</span> <span class="dt">Float</span> <span class="kw">where</span> geq <span class="ot">=</span> (<span class="op">==</span>)</span>
<span id="cb713-38"><a href="#cb713-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb713-39"><a href="#cb713-39" aria-hidden="true" tabindex="-1"></a><span class="co">-- Equalities derived from structure of (:+:) and (:*:)</span></span>
<span id="cb713-40"><a href="#cb713-40" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">GEq</span> a <span class="ot">=&gt;</span> <span class="dt">GEq</span> (<span class="dt">Maybe</span> a)</span>
<span id="cb713-41"><a href="#cb713-41" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">GEq</span> a, <span class="dt">GEq</span> b) <span class="ot">=&gt;</span> <span class="dt">GEq</span> (a,b)</span>
<span id="cb713-42"><a href="#cb713-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb713-43"><a href="#cb713-43" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb713-44"><a href="#cb713-44" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb713-45"><a href="#cb713-45" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> geq <span class="dv">2</span> (<span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb713-46"><a href="#cb713-46" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> geq <span class="ch">&#39;a&#39;</span> <span class="ch">&#39;b&#39;</span></span>
<span id="cb713-47"><a href="#cb713-47" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> geq (<span class="dt">Just</span> <span class="ch">&#39;a&#39;</span>) (<span class="dt">Just</span> <span class="ch">&#39;a&#39;</span>)</span>
<span id="cb713-48"><a href="#cb713-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> geq (<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;b&#39;</span>) (<span class="ch">&#39;a&#39;</span>, <span class="ch">&#39;b&#39;</span>)</span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="http://www.stephendiehl.com/posts/generics.html">Cooking
Classes with Datatype Generic Programming</a></li>
<li><a href="http://www.andres-loeh.de/DGP-Intro.pdf">Datatype-generic
Programming in Haskell</a></li>
<li><a
href="http://hackage.haskell.org/package/generic-deriving-1.6.3">generic-deriving</a></li>
</ul>
<h2 id="generic-deriving">Generic Deriving</h2>
<p>Using Generics many common libraries provide a mechanisms to derive
common typeclass instances. Some real world examples:</p>
<p>The <a
href="http://hackage.haskell.org/package/hashable">hashable</a> library
allows us to derive hashing functions.</p>
<div class="sourceCode" id="cb714"
data-include="src/18-generics/hashable.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb714-1"><a href="#cb714-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb714-2"><a href="#cb714-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb714-3"><a href="#cb714-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span> (<span class="dt">Generic</span>)</span>
<span id="cb714-4"><a href="#cb714-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Hashable</span></span>
<span id="cb714-5"><a href="#cb714-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb714-6"><a href="#cb714-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Green</span> <span class="op">|</span> <span class="dt">Blue</span> <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)</span>
<span id="cb714-7"><a href="#cb714-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb714-8"><a href="#cb714-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Hashable</span> <span class="dt">Color</span> <span class="kw">where</span></span>
<span id="cb714-9"><a href="#cb714-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb714-10"><a href="#cb714-10" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Int</span></span>
<span id="cb714-11"><a href="#cb714-11" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> hash <span class="dt">Red</span></span>
<span id="cb714-12"><a href="#cb714-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- 839657738087498284</span></span>
<span id="cb714-13"><a href="#cb714-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb714-14"><a href="#cb714-14" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Int</span></span>
<span id="cb714-15"><a href="#cb714-15" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> hashWithSalt <span class="bn">0xDEADBEEF</span> <span class="dt">Red</span></span>
<span id="cb714-16"><a href="#cb714-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- 62679985974121021</span></span></code></pre></div>
<p>The <a
href="http://hackage.haskell.org/package/cereal-0.4.0.1">cereal</a>
library allows us to automatically derive a binary representation.</p>
<div class="sourceCode" id="cb715"
data-include="src/18-generics/cereal.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb715-1"><a href="#cb715-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb715-2"><a href="#cb715-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb715-3"><a href="#cb715-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Word</span></span>
<span id="cb715-4"><a href="#cb715-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString</span></span>
<span id="cb715-5"><a href="#cb715-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Serialize</span></span>
<span id="cb715-6"><a href="#cb715-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb715-7"><a href="#cb715-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb715-8"><a href="#cb715-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb715-9"><a href="#cb715-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Val</span> <span class="ot">=</span> <span class="dt">A</span> [<span class="dt">Val</span>] <span class="op">|</span> <span class="dt">B</span> [(<span class="dt">Val</span>, <span class="dt">Val</span>)] <span class="op">|</span> <span class="dt">C</span></span>
<span id="cb715-10"><a href="#cb715-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)</span>
<span id="cb715-11"><a href="#cb715-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb715-12"><a href="#cb715-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Serialize</span> <span class="dt">Val</span> <span class="kw">where</span></span>
<span id="cb715-13"><a href="#cb715-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb715-14"><a href="#cb715-14" aria-hidden="true" tabindex="-1"></a><span class="ot">encoded ::</span> <span class="dt">ByteString</span></span>
<span id="cb715-15"><a href="#cb715-15" aria-hidden="true" tabindex="-1"></a>encoded <span class="ot">=</span> encode (<span class="dt">A</span> [<span class="dt">B</span> [(<span class="dt">C</span>, <span class="dt">C</span>)]])</span>
<span id="cb715-16"><a href="#cb715-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- &quot;\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\STX\STX&quot;</span></span>
<span id="cb715-17"><a href="#cb715-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb715-18"><a href="#cb715-18" aria-hidden="true" tabindex="-1"></a><span class="ot">bytes ::</span> [<span class="dt">Word8</span>]</span>
<span id="cb715-19"><a href="#cb715-19" aria-hidden="true" tabindex="-1"></a>bytes <span class="ot">=</span> unpack encoded</span>
<span id="cb715-20"><a href="#cb715-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- [0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,2,2]</span></span>
<span id="cb715-21"><a href="#cb715-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb715-22"><a href="#cb715-22" aria-hidden="true" tabindex="-1"></a><span class="ot">decoded ::</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Val</span></span>
<span id="cb715-23"><a href="#cb715-23" aria-hidden="true" tabindex="-1"></a>decoded <span class="ot">=</span> decode encoded</span></code></pre></div>
<p>The <a href="http://hackage.haskell.org/package/aeson">aeson</a>
library allows us to derive JSON representations for JSON instances.</p>
<div class="sourceCode" id="cb716"
data-include="src/18-generics/derive_aeson.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb716-1"><a href="#cb716-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb716-2"><a href="#cb716-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb716-3"><a href="#cb716-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb716-4"><a href="#cb716-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson</span></span>
<span id="cb716-5"><a href="#cb716-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb716-6"><a href="#cb716-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb716-7"><a href="#cb716-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">Point</span> {<span class="ot"> _x ::</span> <span class="dt">Double</span>,<span class="ot"> _y ::</span> <span class="dt">Double</span> }</span>
<span id="cb716-8"><a href="#cb716-8" aria-hidden="true" tabindex="-1"></a>   <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>)</span>
<span id="cb716-9"><a href="#cb716-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb716-10"><a href="#cb716-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Point</span></span>
<span id="cb716-11"><a href="#cb716-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Point</span></span>
<span id="cb716-12"><a href="#cb716-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb716-13"><a href="#cb716-13" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Maybe</span> <span class="dt">Point</span></span>
<span id="cb716-14"><a href="#cb716-14" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> decode <span class="st">&quot;{\&quot;x\&quot;:3.0,\&quot;y\&quot;:-1.0}&quot;</span></span>
<span id="cb716-15"><a href="#cb716-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb716-16"><a href="#cb716-16" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> encode <span class="op">$</span> <span class="dt">Point</span> <span class="fl">123.4</span> <span class="dv">20</span></span></code></pre></div>
<p>See: <a href="http://dreixel.net/research/pdf/gdmh.pdf">A Generic
Deriving Mechanism for Haskell</a></p>
<h5 id="higher-kinded-generics">Higher Kinded Generics</h5>
<p>Using the same interface GHC.Generics provides a separate typeclass
for higher-kinded generics.</p>
<div class="sourceCode" id="cb717"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb717-1"><a href="#cb717-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Generic1</span> f <span class="kw">where</span></span>
<span id="cb717-2"><a href="#cb717-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">Rep1</span><span class="ot"> f ::</span> <span class="op">*</span> <span class="ot">-&gt;</span> <span class="op">*</span></span>
<span id="cb717-3"><a href="#cb717-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  from1  ::</span> f a <span class="ot">-&gt;</span> (<span class="dt">Rep1</span> f) a</span>
<span id="cb717-4"><a href="#cb717-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  to1    ::</span> (<span class="dt">Rep1</span> f) a <span class="ot">-&gt;</span> f a</span></code></pre></div>
<p>So for instance <code>Maybe</code> has <code>Rep1</code> of the
form:</p>
<div class="sourceCode" id="cb718"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb718-1"><a href="#cb718-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Rep1</span> <span class="dt">Maybe</span></span>
<span id="cb718-2"><a href="#cb718-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">D1</span></span>
<span id="cb718-3"><a href="#cb718-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">GHC.Generics.D1Maybe</span></span>
<span id="cb718-4"><a href="#cb718-4" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">C1</span> <span class="dt">C1_0Maybe</span> <span class="dt">U1</span></span>
<span id="cb718-5"><a href="#cb718-5" aria-hidden="true" tabindex="-1"></a>       <span class="op">:+:</span> <span class="dt">C1</span> <span class="dt">C1_1Maybe</span> (<span class="dt">S1</span> <span class="dt">NoSelector</span> <span class="dt">Par1</span>))</span></code></pre></div>
<h2 id="typeable">Typeable</h2>
<p>The <code>Typeable</code> class be used to create runtime type
information for arbitrary types.</p>
<div class="sourceCode" id="cb719"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb719-1"><a href="#cb719-1" aria-hidden="true" tabindex="-1"></a><span class="ot">typeOf ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">TypeRep</span></span></code></pre></div>
<div class="sourceCode" id="cb720"
data-include="src/18-generics/typeable.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb720-1"><a href="#cb720-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb720-2"><a href="#cb720-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb720-3"><a href="#cb720-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Typeable</span></span>
<span id="cb720-4"><a href="#cb720-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb720-5"><a href="#cb720-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Animal</span> <span class="ot">=</span> <span class="dt">Cat</span> <span class="op">|</span> <span class="dt">Dog</span> <span class="kw">deriving</span> <span class="dt">Typeable</span></span>
<span id="cb720-6"><a href="#cb720-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Zoo</span> a <span class="ot">=</span> <span class="dt">Zoo</span> [a] <span class="kw">deriving</span> <span class="dt">Typeable</span></span>
<span id="cb720-7"><a href="#cb720-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb720-8"><a href="#cb720-8" aria-hidden="true" tabindex="-1"></a><span class="ot">equal ::</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb720-9"><a href="#cb720-9" aria-hidden="true" tabindex="-1"></a>equal a b <span class="ot">=</span> typeOf a <span class="op">==</span> typeOf b</span>
<span id="cb720-10"><a href="#cb720-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb720-11"><a href="#cb720-11" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">TypeRep</span></span>
<span id="cb720-12"><a href="#cb720-12" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> typeOf <span class="dt">Cat</span></span>
<span id="cb720-13"><a href="#cb720-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Animal</span></span>
<span id="cb720-14"><a href="#cb720-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb720-15"><a href="#cb720-15" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">TypeRep</span></span>
<span id="cb720-16"><a href="#cb720-16" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> typeOf (<span class="dt">Zoo</span> [<span class="dt">Cat</span>, <span class="dt">Dog</span>])</span>
<span id="cb720-17"><a href="#cb720-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- Zoo Animal</span></span>
<span id="cb720-18"><a href="#cb720-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb720-19"><a href="#cb720-19" aria-hidden="true" tabindex="-1"></a><span class="ot">example3 ::</span> <span class="dt">TypeRep</span></span>
<span id="cb720-20"><a href="#cb720-20" aria-hidden="true" tabindex="-1"></a>example3 <span class="ot">=</span> typeOf ((<span class="dv">1</span>, <span class="fl">6.636e-34</span>, <span class="st">&quot;foo&quot;</span>)<span class="ot"> ::</span> (<span class="dt">Int</span>, <span class="dt">Double</span>, <span class="dt">String</span>))</span>
<span id="cb720-21"><a href="#cb720-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- (Int,Double,[Char])</span></span>
<span id="cb720-22"><a href="#cb720-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb720-23"><a href="#cb720-23" aria-hidden="true" tabindex="-1"></a><span class="ot">example4 ::</span> <span class="dt">Bool</span></span>
<span id="cb720-24"><a href="#cb720-24" aria-hidden="true" tabindex="-1"></a>example4 <span class="ot">=</span> equal <span class="dt">False</span> ()</span>
<span id="cb720-25"><a href="#cb720-25" aria-hidden="true" tabindex="-1"></a><span class="co">-- False</span></span></code></pre></div>
<p>Using the Typeable instance allows us to write down a type safe cast
function which can safely use <code>unsafeCast</code> and provide a
proof that the resulting type matches the input.</p>
<div class="sourceCode" id="cb721"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb721-1"><a href="#cb721-1" aria-hidden="true" tabindex="-1"></a><span class="ot">cast ::</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb721-2"><a href="#cb721-2" aria-hidden="true" tabindex="-1"></a>cast x</span>
<span id="cb721-3"><a href="#cb721-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> typeOf x <span class="op">==</span> typeOf ret <span class="ot">=</span> <span class="dt">Just</span> ret</span>
<span id="cb721-4"><a href="#cb721-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb721-5"><a href="#cb721-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb721-6"><a href="#cb721-6" aria-hidden="true" tabindex="-1"></a>    ret <span class="ot">=</span> unsafeCast x</span></code></pre></div>
<p>Of historical note is that writing our own Typeable classes is
currently possible of GHC 7.6 but allows us to introduce dangerous
behavior that can cause crashes, and shouldn’t be done except by GHC
itself. As of 7.8 GHC forbids hand-written Typeable instances. As of
7.10 <code>-XAutoDeriveTypeable</code> is enabled by default.</p>
<p>See: <a href="http://chrisdone.com/posts/data-typeable">Typeable and
Data in Haskell</a></p>
<h2 id="dynamic-types">Dynamic Types</h2>
<p>Since we have a way of querying runtime type information we can use
this machinery to implement a <code>Dynamic</code> type. This allows us
to box up any monotype into a uniform type that can be passed to any
function taking a Dynamic type which can then unpack the underlying
value in a type-safe way.</p>
<div class="sourceCode" id="cb722"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb722-1"><a href="#cb722-1" aria-hidden="true" tabindex="-1"></a><span class="ot">toDyn ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Dynamic</span></span>
<span id="cb722-2"><a href="#cb722-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fromDyn ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">Dynamic</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb722-3"><a href="#cb722-3" aria-hidden="true" tabindex="-1"></a><span class="ot">fromDynamic ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">Dynamic</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb722-4"><a href="#cb722-4" aria-hidden="true" tabindex="-1"></a><span class="ot">cast ::</span> (<span class="dt">Typeable</span> a, <span class="dt">Typeable</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span></code></pre></div>
<div class="sourceCode" id="cb723"
data-include="src/18-generics/dynamic.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb723-1"><a href="#cb723-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Dynamic</span></span>
<span id="cb723-2"><a href="#cb723-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb723-3"><a href="#cb723-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb723-4"><a href="#cb723-4" aria-hidden="true" tabindex="-1"></a><span class="ot">dynamicBox ::</span> <span class="dt">Dynamic</span></span>
<span id="cb723-5"><a href="#cb723-5" aria-hidden="true" tabindex="-1"></a>dynamicBox <span class="ot">=</span> toDyn (<span class="fl">6.62</span><span class="ot"> ::</span> <span class="dt">Double</span>)</span>
<span id="cb723-6"><a href="#cb723-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb723-7"><a href="#cb723-7" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span></span>
<span id="cb723-8"><a href="#cb723-8" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> fromDynamic dynamicBox</span>
<span id="cb723-9"><a href="#cb723-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Nothing</span></span>
<span id="cb723-10"><a href="#cb723-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb723-11"><a href="#cb723-11" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Maybe</span> <span class="dt">Double</span></span>
<span id="cb723-12"><a href="#cb723-12" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> fromDynamic dynamicBox</span>
<span id="cb723-13"><a href="#cb723-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Just 6.62</span></span>
<span id="cb723-14"><a href="#cb723-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb723-15"><a href="#cb723-15" aria-hidden="true" tabindex="-1"></a><span class="ot">example3 ::</span> <span class="dt">Int</span></span>
<span id="cb723-16"><a href="#cb723-16" aria-hidden="true" tabindex="-1"></a>example3 <span class="ot">=</span> fromDyn dynamicBox <span class="dv">0</span></span>
<span id="cb723-17"><a href="#cb723-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- 0</span></span>
<span id="cb723-18"><a href="#cb723-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb723-19"><a href="#cb723-19" aria-hidden="true" tabindex="-1"></a><span class="ot">example4 ::</span> <span class="dt">Double</span></span>
<span id="cb723-20"><a href="#cb723-20" aria-hidden="true" tabindex="-1"></a>example4 <span class="ot">=</span> fromDyn dynamicBox <span class="fl">0.0</span></span>
<span id="cb723-21"><a href="#cb723-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- 6.62</span></span></code></pre></div>
<p>In GHC 7.8 the Typeable class is poly-kinded so polymorphic functions
can be applied over functions and higher kinded types.</p>
<div class="alert alert-danger">
<p>Use of Dynamic is somewhat rare, except in odd cases that have to
deal with foreign memory and FFI interfaces. Using it for business logic
is considered a code smell. Consider a more idiomatic solution.</p>
</div>
<h2 id="data">Data</h2>
<p>Just as Typeable lets us create runtime type information, the Data
class allows us to reflect information about the structure of datatypes
to runtime as needed.</p>
<div class="sourceCode" id="cb724"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb724-1"><a href="#cb724-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> <span class="dt">Data</span> a <span class="kw">where</span></span>
<span id="cb724-2"><a href="#cb724-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  gfoldl  ::</span> (<span class="kw">forall</span> d b<span class="op">.</span> <span class="dt">Data</span> d <span class="ot">=&gt;</span> c (d <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> d <span class="ot">-&gt;</span> c b)</span>
<span id="cb724-3"><a href="#cb724-3" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> (<span class="kw">forall</span> g<span class="op">.</span> g <span class="ot">-&gt;</span> c g)</span>
<span id="cb724-4"><a href="#cb724-4" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> a</span>
<span id="cb724-5"><a href="#cb724-5" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> c a</span>
<span id="cb724-6"><a href="#cb724-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb724-7"><a href="#cb724-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  gunfold ::</span> (<span class="kw">forall</span> b r<span class="op">.</span> <span class="dt">Data</span> b <span class="ot">=&gt;</span> c (b <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> c r)</span>
<span id="cb724-8"><a href="#cb724-8" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> (<span class="kw">forall</span> r<span class="op">.</span> r <span class="ot">-&gt;</span> c r)</span>
<span id="cb724-9"><a href="#cb724-9" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Constr</span></span>
<span id="cb724-10"><a href="#cb724-10" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> c a</span>
<span id="cb724-11"><a href="#cb724-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb724-12"><a href="#cb724-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  toConstr ::</span> a <span class="ot">-&gt;</span> <span class="dt">Constr</span></span>
<span id="cb724-13"><a href="#cb724-13" aria-hidden="true" tabindex="-1"></a><span class="ot">  dataTypeOf ::</span> a <span class="ot">-&gt;</span> <span class="dt">DataType</span></span>
<span id="cb724-14"><a href="#cb724-14" aria-hidden="true" tabindex="-1"></a><span class="ot">  gmapQl ::</span> (r <span class="ot">-&gt;</span> r&#39; <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r <span class="ot">-&gt;</span> (<span class="kw">forall</span> d<span class="op">.</span> <span class="dt">Data</span> d <span class="ot">=&gt;</span> d <span class="ot">-&gt;</span> r&#39;) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> r</span></code></pre></div>
<p>The types for <code>gfoldl</code> and <code>gunfold</code> are a
little intimidating ( and depend on <code>RankNTypes</code> ), the best
way to understand is to look at some examples. First the most trivial
case a simple sum type <code>Animal</code> would produce the following
code:</p>
<div class="sourceCode" id="cb725"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb725-1"><a href="#cb725-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Animal</span> <span class="ot">=</span> <span class="dt">Cat</span> <span class="op">|</span> <span class="dt">Dog</span> <span class="kw">deriving</span> <span class="dt">Typeable</span></span></code></pre></div>
<div class="sourceCode" id="cb726"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb726-1"><a href="#cb726-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Data</span> <span class="dt">Animal</span> <span class="kw">where</span></span>
<span id="cb726-2"><a href="#cb726-2" aria-hidden="true" tabindex="-1"></a>  gfoldl k z <span class="dt">Cat</span> <span class="ot">=</span> z <span class="dt">Cat</span></span>
<span id="cb726-3"><a href="#cb726-3" aria-hidden="true" tabindex="-1"></a>  gfoldl k z <span class="dt">Dog</span> <span class="ot">=</span> z <span class="dt">Dog</span></span>
<span id="cb726-4"><a href="#cb726-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb726-5"><a href="#cb726-5" aria-hidden="true" tabindex="-1"></a>  gunfold k z c</span>
<span id="cb726-6"><a href="#cb726-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="kw">case</span> constrIndex c <span class="kw">of</span></span>
<span id="cb726-7"><a href="#cb726-7" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span> <span class="ot">-&gt;</span> z <span class="dt">Cat</span></span>
<span id="cb726-8"><a href="#cb726-8" aria-hidden="true" tabindex="-1"></a>        <span class="dv">2</span> <span class="ot">-&gt;</span> z <span class="dt">Dog</span></span>
<span id="cb726-9"><a href="#cb726-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb726-10"><a href="#cb726-10" aria-hidden="true" tabindex="-1"></a>  toConstr <span class="dt">Cat</span> <span class="ot">=</span> cCat</span>
<span id="cb726-11"><a href="#cb726-11" aria-hidden="true" tabindex="-1"></a>  toConstr <span class="dt">Dog</span> <span class="ot">=</span> cDog</span>
<span id="cb726-12"><a href="#cb726-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb726-13"><a href="#cb726-13" aria-hidden="true" tabindex="-1"></a>  dataTypeOf _ <span class="ot">=</span> tAnimal</span>
<span id="cb726-14"><a href="#cb726-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb726-15"><a href="#cb726-15" aria-hidden="true" tabindex="-1"></a><span class="ot">tAnimal ::</span> <span class="dt">DataType</span></span>
<span id="cb726-16"><a href="#cb726-16" aria-hidden="true" tabindex="-1"></a>tAnimal <span class="ot">=</span> mkDataType <span class="st">&quot;Main.Animal&quot;</span> [cCat, cDog]</span>
<span id="cb726-17"><a href="#cb726-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb726-18"><a href="#cb726-18" aria-hidden="true" tabindex="-1"></a><span class="ot">cCat ::</span> <span class="dt">Constr</span></span>
<span id="cb726-19"><a href="#cb726-19" aria-hidden="true" tabindex="-1"></a>cCat <span class="ot">=</span> mkConstr tAnimal <span class="st">&quot;Cat&quot;</span> [] <span class="dt">Prefix</span></span>
<span id="cb726-20"><a href="#cb726-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb726-21"><a href="#cb726-21" aria-hidden="true" tabindex="-1"></a><span class="ot">cDog ::</span> <span class="dt">Constr</span></span>
<span id="cb726-22"><a href="#cb726-22" aria-hidden="true" tabindex="-1"></a>cDog <span class="ot">=</span> mkConstr tAnimal <span class="st">&quot;Dog&quot;</span> [] <span class="dt">Prefix</span></span></code></pre></div>
<p>For a type with non-empty containers we get something a little more
interesting. Consider the list type:</p>
<div class="sourceCode" id="cb727"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb727-1"><a href="#cb727-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> <span class="dt">Data</span> [a] <span class="kw">where</span></span>
<span id="cb727-2"><a href="#cb727-2" aria-hidden="true" tabindex="-1"></a>  gfoldl _ z []     <span class="ot">=</span> z []</span>
<span id="cb727-3"><a href="#cb727-3" aria-hidden="true" tabindex="-1"></a>  gfoldl k z (x<span class="op">:</span>xs) <span class="ot">=</span> z (<span class="op">:</span>) <span class="ot">`k`</span> x <span class="ot">`k`</span> xs</span>
<span id="cb727-4"><a href="#cb727-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb727-5"><a href="#cb727-5" aria-hidden="true" tabindex="-1"></a>  toConstr []    <span class="ot">=</span> nilConstr</span>
<span id="cb727-6"><a href="#cb727-6" aria-hidden="true" tabindex="-1"></a>  toConstr (_<span class="op">:</span>_) <span class="ot">=</span> consConstr</span>
<span id="cb727-7"><a href="#cb727-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb727-8"><a href="#cb727-8" aria-hidden="true" tabindex="-1"></a>  gunfold k z c</span>
<span id="cb727-9"><a href="#cb727-9" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="kw">case</span> constrIndex c <span class="kw">of</span></span>
<span id="cb727-10"><a href="#cb727-10" aria-hidden="true" tabindex="-1"></a>        <span class="dv">1</span> <span class="ot">-&gt;</span> z []</span>
<span id="cb727-11"><a href="#cb727-11" aria-hidden="true" tabindex="-1"></a>        <span class="dv">2</span> <span class="ot">-&gt;</span> k (k (z (<span class="op">:</span>)))</span>
<span id="cb727-12"><a href="#cb727-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb727-13"><a href="#cb727-13" aria-hidden="true" tabindex="-1"></a>  dataTypeOf _ <span class="ot">=</span> listDataType</span>
<span id="cb727-14"><a href="#cb727-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb727-15"><a href="#cb727-15" aria-hidden="true" tabindex="-1"></a><span class="ot">nilConstr ::</span> <span class="dt">Constr</span></span>
<span id="cb727-16"><a href="#cb727-16" aria-hidden="true" tabindex="-1"></a>nilConstr <span class="ot">=</span> mkConstr listDataType <span class="st">&quot;[]&quot;</span> [] <span class="dt">Prefix</span></span>
<span id="cb727-17"><a href="#cb727-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb727-18"><a href="#cb727-18" aria-hidden="true" tabindex="-1"></a><span class="ot">consConstr ::</span> <span class="dt">Constr</span></span>
<span id="cb727-19"><a href="#cb727-19" aria-hidden="true" tabindex="-1"></a>consConstr <span class="ot">=</span> mkConstr listDataType <span class="st">&quot;(:)&quot;</span> [] <span class="dt">Infix</span></span>
<span id="cb727-20"><a href="#cb727-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb727-21"><a href="#cb727-21" aria-hidden="true" tabindex="-1"></a><span class="ot">listDataType ::</span> <span class="dt">DataType</span></span>
<span id="cb727-22"><a href="#cb727-22" aria-hidden="true" tabindex="-1"></a>listDataType <span class="ot">=</span> mkDataType <span class="st">&quot;Prelude.[]&quot;</span> [nilConstr,consConstr]</span></code></pre></div>
<p>Looking at <code>gfoldl</code> we see the Data has an implementation
of a function for us to walk an applicative over the elements of the
constructor by applying a function <code>k</code> over each element and
applying <code>z</code> at the spine. For example look at the instance
for a 2-tuple as well:</p>
<div class="sourceCode" id="cb728"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb728-1"><a href="#cb728-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> (<span class="dt">Data</span> a, <span class="dt">Data</span> b) <span class="ot">=&gt;</span> <span class="dt">Data</span> (a,b) <span class="kw">where</span></span>
<span id="cb728-2"><a href="#cb728-2" aria-hidden="true" tabindex="-1"></a>  gfoldl k z (a,b) <span class="ot">=</span> z (,) <span class="ot">`k`</span> a <span class="ot">`k`</span> b</span>
<span id="cb728-3"><a href="#cb728-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb728-4"><a href="#cb728-4" aria-hidden="true" tabindex="-1"></a>  toConstr (_,_) <span class="ot">=</span> tuple2Constr</span>
<span id="cb728-5"><a href="#cb728-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb728-6"><a href="#cb728-6" aria-hidden="true" tabindex="-1"></a>  gunfold k z c</span>
<span id="cb728-7"><a href="#cb728-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="kw">case</span> constrIndex c <span class="kw">of</span></span>
<span id="cb728-8"><a href="#cb728-8" aria-hidden="true" tabindex="-1"></a>      <span class="dv">1</span> <span class="ot">-&gt;</span> k (k (z (,)))</span>
<span id="cb728-9"><a href="#cb728-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb728-10"><a href="#cb728-10" aria-hidden="true" tabindex="-1"></a>  dataTypeOf _  <span class="ot">=</span> tuple2DataType</span>
<span id="cb728-11"><a href="#cb728-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb728-12"><a href="#cb728-12" aria-hidden="true" tabindex="-1"></a><span class="ot">tuple2Constr ::</span> <span class="dt">Constr</span></span>
<span id="cb728-13"><a href="#cb728-13" aria-hidden="true" tabindex="-1"></a>tuple2Constr <span class="ot">=</span> mkConstr tuple2DataType <span class="st">&quot;(,)&quot;</span> [] <span class="dt">Infix</span></span>
<span id="cb728-14"><a href="#cb728-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb728-15"><a href="#cb728-15" aria-hidden="true" tabindex="-1"></a><span class="ot">tuple2DataType ::</span> <span class="dt">DataType</span></span>
<span id="cb728-16"><a href="#cb728-16" aria-hidden="true" tabindex="-1"></a>tuple2DataType <span class="ot">=</span> mkDataType <span class="st">&quot;Prelude.(,)&quot;</span> [tuple2Constr]</span></code></pre></div>
<p>This is pretty neat, now within the same typeclass we have a generic
way to introspect any <code>Data</code> instance and write logic that
depends on the structure and types of its subterms. We can now write a
function which allows us to traverse an arbitrary instance of Data and
twiddle values based on pattern matching on the runtime types. So let’s
write down a function <code>over</code> which increments a
<code>Value</code> type for both for n-tuples and lists.</p>
<div class="sourceCode" id="cb729"
data-include="src/18-generics/data.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb729-1"><a href="#cb729-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb729-2"><a href="#cb729-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb729-3"><a href="#cb729-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Data</span></span>
<span id="cb729-4"><a href="#cb729-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Identity</span></span>
<span id="cb729-5"><a href="#cb729-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb729-6"><a href="#cb729-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb729-7"><a href="#cb729-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Animal</span> <span class="ot">=</span> <span class="dt">Cat</span> <span class="op">|</span> <span class="dt">Dog</span> <span class="kw">deriving</span> (<span class="dt">Data</span>, <span class="dt">Typeable</span>)</span>
<span id="cb729-8"><a href="#cb729-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb729-9"><a href="#cb729-9" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Val</span> <span class="ot">=</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Data</span>, <span class="dt">Typeable</span>)</span>
<span id="cb729-10"><a href="#cb729-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb729-11"><a href="#cb729-11" aria-hidden="true" tabindex="-1"></a><span class="ot">incr ::</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb729-12"><a href="#cb729-12" aria-hidden="true" tabindex="-1"></a>incr <span class="ot">=</span> <span class="fu">maybe</span> <span class="fu">id</span> <span class="fu">id</span> (cast f)</span>
<span id="cb729-13"><a href="#cb729-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> f (<span class="dt">Val</span> x) <span class="ot">=</span> <span class="dt">Val</span> (x <span class="op">*</span> <span class="dv">100</span>)</span>
<span id="cb729-14"><a href="#cb729-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb729-15"><a href="#cb729-15" aria-hidden="true" tabindex="-1"></a><span class="ot">over ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb729-16"><a href="#cb729-16" aria-hidden="true" tabindex="-1"></a>over x <span class="ot">=</span> runIdentity <span class="op">$</span> gfoldl cont base (incr x)</span>
<span id="cb729-17"><a href="#cb729-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb729-18"><a href="#cb729-18" aria-hidden="true" tabindex="-1"></a>    cont k d <span class="ot">=</span> k <span class="op">&lt;*&gt;</span> (<span class="fu">pure</span> <span class="op">$</span> over d)</span>
<span id="cb729-19"><a href="#cb729-19" aria-hidden="true" tabindex="-1"></a>    base <span class="ot">=</span> <span class="fu">pure</span></span>
<span id="cb729-20"><a href="#cb729-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb729-21"><a href="#cb729-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb729-22"><a href="#cb729-22" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Constr</span></span>
<span id="cb729-23"><a href="#cb729-23" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> toConstr <span class="dt">Dog</span></span>
<span id="cb729-24"><a href="#cb729-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- Dog</span></span>
<span id="cb729-25"><a href="#cb729-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb729-26"><a href="#cb729-26" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">DataType</span></span>
<span id="cb729-27"><a href="#cb729-27" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> dataTypeOf <span class="dt">Cat</span></span>
<span id="cb729-28"><a href="#cb729-28" aria-hidden="true" tabindex="-1"></a><span class="co">-- DataType {tycon = &quot;Main.Animal&quot;, datarep = AlgRep [Cat,Dog]}</span></span>
<span id="cb729-29"><a href="#cb729-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb729-30"><a href="#cb729-30" aria-hidden="true" tabindex="-1"></a><span class="ot">example3 ::</span> [<span class="dt">Val</span>]</span>
<span id="cb729-31"><a href="#cb729-31" aria-hidden="true" tabindex="-1"></a>example3 <span class="ot">=</span> over [<span class="dt">Val</span> <span class="dv">1</span>, <span class="dt">Val</span> <span class="dv">2</span>, <span class="dt">Val</span> <span class="dv">3</span>]</span>
<span id="cb729-32"><a href="#cb729-32" aria-hidden="true" tabindex="-1"></a><span class="co">-- [Val 100,Val 200,Val 300]</span></span>
<span id="cb729-33"><a href="#cb729-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb729-34"><a href="#cb729-34" aria-hidden="true" tabindex="-1"></a><span class="ot">example4 ::</span> (<span class="dt">Val</span>, <span class="dt">Val</span>, <span class="dt">Val</span>)</span>
<span id="cb729-35"><a href="#cb729-35" aria-hidden="true" tabindex="-1"></a>example4 <span class="ot">=</span> over (<span class="dt">Val</span> <span class="dv">1</span>, <span class="dt">Val</span> <span class="dv">2</span>, <span class="dt">Val</span> <span class="dv">3</span>)</span>
<span id="cb729-36"><a href="#cb729-36" aria-hidden="true" tabindex="-1"></a><span class="co">-- (Val 100,Val 200,Val 300)</span></span></code></pre></div>
<p>We can also write generic operations, for example to count the number
of parameters in a data type.</p>
<div class="sourceCode" id="cb730"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb730-1"><a href="#cb730-1" aria-hidden="true" tabindex="-1"></a><span class="ot">numHoles ::</span> <span class="dt">Data</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb730-2"><a href="#cb730-2" aria-hidden="true" tabindex="-1"></a>numHoles <span class="ot">=</span> gmapQl (<span class="op">+</span>) <span class="dv">0</span> (<span class="fu">const</span> <span class="dv">1</span>)</span>
<span id="cb730-3"><a href="#cb730-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb730-4"><a href="#cb730-4" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Int</span></span>
<span id="cb730-5"><a href="#cb730-5" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> numHoles (<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>)</span>
<span id="cb730-6"><a href="#cb730-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- 7</span></span>
<span id="cb730-7"><a href="#cb730-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb730-8"><a href="#cb730-8" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Int</span></span>
<span id="cb730-9"><a href="#cb730-9" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> numHoles (<span class="dt">Just</span> <span class="dv">3</span>)</span>
<span id="cb730-10"><a href="#cb730-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1</span></span></code></pre></div>
<h2 id="uniplate">Uniplate</h2>
<p>Uniplate is a generics library for writing traversals and
transformation for arbitrary data structures. It is extremely useful for
writing AST transformations and rewriting systems.</p>
<div class="sourceCode" id="cb731"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb731-1"><a href="#cb731-1" aria-hidden="true" tabindex="-1"></a><span class="ot">plate ::</span> from <span class="ot">-&gt;</span> <span class="dt">Type</span> from to</span>
<span id="cb731-2"><a href="#cb731-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(|*)  ::</span> <span class="dt">Type</span> (to <span class="ot">-&gt;</span> from) to <span class="ot">-&gt;</span> to <span class="ot">-&gt;</span> <span class="dt">Type</span> from to</span>
<span id="cb731-3"><a href="#cb731-3" aria-hidden="true" tabindex="-1"></a><span class="ot">(|-)  ::</span> <span class="dt">Type</span> (item <span class="ot">-&gt;</span> from) to <span class="ot">-&gt;</span> item <span class="ot">-&gt;</span> <span class="dt">Type</span> from to</span>
<span id="cb731-4"><a href="#cb731-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb731-5"><a href="#cb731-5" aria-hidden="true" tabindex="-1"></a><span class="ot">descend   ::</span> <span class="dt">Uniplate</span> on <span class="ot">=&gt;</span> (on <span class="ot">-&gt;</span> on) <span class="ot">-&gt;</span> on <span class="ot">-&gt;</span> on</span>
<span id="cb731-6"><a href="#cb731-6" aria-hidden="true" tabindex="-1"></a><span class="ot">transform ::</span> <span class="dt">Uniplate</span> on <span class="ot">=&gt;</span> (on <span class="ot">-&gt;</span> on) <span class="ot">-&gt;</span> on <span class="ot">-&gt;</span> on</span>
<span id="cb731-7"><a href="#cb731-7" aria-hidden="true" tabindex="-1"></a><span class="ot">rewrite   ::</span> <span class="dt">Uniplate</span> on <span class="ot">=&gt;</span> (on <span class="ot">-&gt;</span> <span class="dt">Maybe</span> on) <span class="ot">-&gt;</span> on <span class="ot">-&gt;</span> on</span></code></pre></div>
<p>The <code>descend</code> function will apply a function to each
immediate descendant of an expression and then combines them up into the
parent expression.</p>
<p>The <code>transform</code> function will perform a single pass
bottom-up transformation of all terms in the expression.</p>
<p>The <code>rewrite</code> function will perform an exhaustive
transformation of all terms in the expression to fixed point, using
Maybe to signify termination.</p>
<div class="sourceCode" id="cb732"
data-include="src/18-generics/uniplate.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb732-1"><a href="#cb732-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Generics.Uniplate.Direct</span></span>
<span id="cb732-2"><a href="#cb732-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb732-3"><a href="#cb732-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> a</span>
<span id="cb732-4"><a href="#cb732-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Fls</span></span>
<span id="cb732-5"><a href="#cb732-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Tru</span></span>
<span id="cb732-6"><a href="#cb732-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Var</span> a</span>
<span id="cb732-7"><a href="#cb732-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Not</span> (<span class="dt">Expr</span> a)</span>
<span id="cb732-8"><a href="#cb732-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">And</span> (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)</span>
<span id="cb732-9"><a href="#cb732-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Or</span>  (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)</span>
<span id="cb732-10"><a href="#cb732-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb732-11"><a href="#cb732-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb732-12"><a href="#cb732-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Uniplate</span> (<span class="dt">Expr</span> a) <span class="kw">where</span></span>
<span id="cb732-13"><a href="#cb732-13" aria-hidden="true" tabindex="-1"></a>  uniplate (<span class="dt">Not</span> f)     <span class="ot">=</span> plate <span class="dt">Not</span> <span class="op">|*</span> f</span>
<span id="cb732-14"><a href="#cb732-14" aria-hidden="true" tabindex="-1"></a>  uniplate (<span class="dt">And</span> f1 f2) <span class="ot">=</span> plate <span class="dt">And</span> <span class="op">|*</span> f1 <span class="op">|*</span> f2</span>
<span id="cb732-15"><a href="#cb732-15" aria-hidden="true" tabindex="-1"></a>  uniplate (<span class="dt">Or</span> f1 f2)  <span class="ot">=</span> plate <span class="dt">Or</span> <span class="op">|*</span> f1 <span class="op">|*</span> f2</span>
<span id="cb732-16"><a href="#cb732-16" aria-hidden="true" tabindex="-1"></a>  uniplate x           <span class="ot">=</span> plate x</span>
<span id="cb732-17"><a href="#cb732-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb732-18"><a href="#cb732-18" aria-hidden="true" tabindex="-1"></a><span class="ot">simplify ::</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</span>
<span id="cb732-19"><a href="#cb732-19" aria-hidden="true" tabindex="-1"></a>simplify <span class="ot">=</span> transform simp</span>
<span id="cb732-20"><a href="#cb732-20" aria-hidden="true" tabindex="-1"></a> <span class="kw">where</span></span>
<span id="cb732-21"><a href="#cb732-21" aria-hidden="true" tabindex="-1"></a>   simp (<span class="dt">Not</span> (<span class="dt">Not</span> f)) <span class="ot">=</span> f</span>
<span id="cb732-22"><a href="#cb732-22" aria-hidden="true" tabindex="-1"></a>   simp (<span class="dt">Not</span> <span class="dt">Fls</span>) <span class="ot">=</span> <span class="dt">Tru</span></span>
<span id="cb732-23"><a href="#cb732-23" aria-hidden="true" tabindex="-1"></a>   simp (<span class="dt">Not</span> <span class="dt">Tru</span>) <span class="ot">=</span> <span class="dt">Fls</span></span>
<span id="cb732-24"><a href="#cb732-24" aria-hidden="true" tabindex="-1"></a>   simp x <span class="ot">=</span> x</span>
<span id="cb732-25"><a href="#cb732-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb732-26"><a href="#cb732-26" aria-hidden="true" tabindex="-1"></a><span class="ot">reduce ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Expr</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span> a</span>
<span id="cb732-27"><a href="#cb732-27" aria-hidden="true" tabindex="-1"></a>reduce <span class="ot">=</span> rewrite cnf</span>
<span id="cb732-28"><a href="#cb732-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb732-29"><a href="#cb732-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- double negation</span></span>
<span id="cb732-30"><a href="#cb732-30" aria-hidden="true" tabindex="-1"></a>    cnf (<span class="dt">Not</span> (<span class="dt">Not</span> p)) <span class="ot">=</span> <span class="dt">Just</span> p</span>
<span id="cb732-31"><a href="#cb732-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb732-32"><a href="#cb732-32" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- de Morgan</span></span>
<span id="cb732-33"><a href="#cb732-33" aria-hidden="true" tabindex="-1"></a>    cnf (<span class="dt">Not</span> (p <span class="ot">`Or`</span> q))  <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> (<span class="dt">Not</span> p) <span class="ot">`And`</span> (<span class="dt">Not</span> q)</span>
<span id="cb732-34"><a href="#cb732-34" aria-hidden="true" tabindex="-1"></a>    cnf (<span class="dt">Not</span> (p <span class="ot">`And`</span> q)) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> (<span class="dt">Not</span> p) <span class="ot">`Or`</span> (<span class="dt">Not</span> q)</span>
<span id="cb732-35"><a href="#cb732-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb732-36"><a href="#cb732-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- distribute conjunctions</span></span>
<span id="cb732-37"><a href="#cb732-37" aria-hidden="true" tabindex="-1"></a>    cnf (p <span class="ot">`Or`</span> (q <span class="ot">`And`</span> r)) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> (p <span class="ot">`Or`</span> q) <span class="ot">`And`</span> (p <span class="ot">`Or`</span> r)</span>
<span id="cb732-38"><a href="#cb732-38" aria-hidden="true" tabindex="-1"></a>    cnf ((p <span class="ot">`And`</span> q) <span class="ot">`Or`</span> r) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> (p <span class="ot">`Or`</span> q) <span class="ot">`And`</span> (p <span class="ot">`Or`</span> r)</span>
<span id="cb732-39"><a href="#cb732-39" aria-hidden="true" tabindex="-1"></a>    cnf _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb732-40"><a href="#cb732-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb732-41"><a href="#cb732-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb732-42"><a href="#cb732-42" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Expr</span> <span class="dt">String</span></span>
<span id="cb732-43"><a href="#cb732-43" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> simplify (<span class="dt">Not</span> (<span class="dt">Not</span> (<span class="dt">Not</span> (<span class="dt">Not</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>)))))</span>
<span id="cb732-44"><a href="#cb732-44" aria-hidden="true" tabindex="-1"></a><span class="co">-- Var &quot;a&quot;</span></span>
<span id="cb732-45"><a href="#cb732-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb732-46"><a href="#cb732-46" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> [<span class="dt">String</span>]</span>
<span id="cb732-47"><a href="#cb732-47" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> [a <span class="op">|</span> <span class="dt">Var</span> a <span class="ot">&lt;-</span> universe ex]</span>
<span id="cb732-48"><a href="#cb732-48" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb732-49"><a href="#cb732-49" aria-hidden="true" tabindex="-1"></a>    ex <span class="ot">=</span> <span class="dt">Or</span> (<span class="dt">And</span> (<span class="dt">Var</span> <span class="st">&quot;a&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;b&quot;</span>)) (<span class="dt">Not</span> (<span class="dt">And</span> (<span class="dt">Var</span> <span class="st">&quot;c&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;d&quot;</span>)))</span>
<span id="cb732-50"><a href="#cb732-50" aria-hidden="true" tabindex="-1"></a><span class="co">-- [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span></span>
<span id="cb732-51"><a href="#cb732-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb732-52"><a href="#cb732-52" aria-hidden="true" tabindex="-1"></a><span class="ot">example3 ::</span> <span class="dt">Expr</span> <span class="dt">String</span></span>
<span id="cb732-53"><a href="#cb732-53" aria-hidden="true" tabindex="-1"></a>example3 <span class="ot">=</span> reduce <span class="op">$</span> ((a <span class="ot">`And`</span> b) <span class="ot">`Or`</span> (c <span class="ot">`And`</span> d)) <span class="ot">`Or`</span> e</span>
<span id="cb732-54"><a href="#cb732-54" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb732-55"><a href="#cb732-55" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;a&quot;</span></span>
<span id="cb732-56"><a href="#cb732-56" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;b&quot;</span></span>
<span id="cb732-57"><a href="#cb732-57" aria-hidden="true" tabindex="-1"></a>    c <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;c&quot;</span></span>
<span id="cb732-58"><a href="#cb732-58" aria-hidden="true" tabindex="-1"></a>    d <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;d&quot;</span></span>
<span id="cb732-59"><a href="#cb732-59" aria-hidden="true" tabindex="-1"></a>    e <span class="ot">=</span> <span class="dt">Var</span> <span class="st">&quot;e&quot;</span></span></code></pre></div>
<p>Alternatively Uniplate instances can be derived automatically from
instances of Data without the need to explicitly write a Uniplate
instance. This approach carries a slight amount of overhead over an
explicit hand-written instance.</p>
<div class="sourceCode" id="cb733"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb733-1"><a href="#cb733-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Data</span></span>
<span id="cb733-2"><a href="#cb733-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Typeable</span></span>
<span id="cb733-3"><a href="#cb733-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Generics.Uniplate.Data</span></span>
<span id="cb733-4"><a href="#cb733-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb733-5"><a href="#cb733-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> a</span>
<span id="cb733-6"><a href="#cb733-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Fls</span></span>
<span id="cb733-7"><a href="#cb733-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Tru</span></span>
<span id="cb733-8"><a href="#cb733-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lit</span> a</span>
<span id="cb733-9"><a href="#cb733-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Not</span> (<span class="dt">Expr</span> a)</span>
<span id="cb733-10"><a href="#cb733-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">And</span> (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)</span>
<span id="cb733-11"><a href="#cb733-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Or</span> (<span class="dt">Expr</span> a) (<span class="dt">Expr</span> a)</span>
<span id="cb733-12"><a href="#cb733-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Data</span>, <span class="dt">Typeable</span>, <span class="dt">Show</span>, <span class="dt">Eq</span>)</span></code></pre></div>
<p><strong>Biplate</strong></p>
<p>Biplates generalize plates where the target type isn’t necessarily
the same as the source, it uses multiparameter typeclasses to indicate
the type sub of the sub-target. The Uniplate functions all have an
equivalent generalized biplate form.</p>
<div class="sourceCode" id="cb734"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb734-1"><a href="#cb734-1" aria-hidden="true" tabindex="-1"></a><span class="ot">descendBi   ::</span> <span class="dt">Biplate</span> from to <span class="ot">=&gt;</span> (to <span class="ot">-&gt;</span> to) <span class="ot">-&gt;</span> from <span class="ot">-&gt;</span> from</span>
<span id="cb734-2"><a href="#cb734-2" aria-hidden="true" tabindex="-1"></a><span class="ot">transformBi ::</span> <span class="dt">Biplate</span> from to <span class="ot">=&gt;</span> (to <span class="ot">-&gt;</span> to) <span class="ot">-&gt;</span> from <span class="ot">-&gt;</span> from</span>
<span id="cb734-3"><a href="#cb734-3" aria-hidden="true" tabindex="-1"></a><span class="ot">rewriteBi   ::</span> <span class="dt">Biplate</span> from to <span class="ot">=&gt;</span> (to <span class="ot">-&gt;</span> <span class="dt">Maybe</span> to) <span class="ot">-&gt;</span> from <span class="ot">-&gt;</span> from</span>
<span id="cb734-4"><a href="#cb734-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb734-5"><a href="#cb734-5" aria-hidden="true" tabindex="-1"></a><span class="ot">descendBiM   ::</span> (<span class="dt">Monad</span> m, <span class="dt">Biplate</span> from to) <span class="ot">=&gt;</span> (to <span class="ot">-&gt;</span> m to) <span class="ot">-&gt;</span> from <span class="ot">-&gt;</span> m from</span>
<span id="cb734-6"><a href="#cb734-6" aria-hidden="true" tabindex="-1"></a><span class="ot">transformBiM ::</span> (<span class="dt">Monad</span> m, <span class="dt">Biplate</span> from to) <span class="ot">=&gt;</span> (to <span class="ot">-&gt;</span> m to) <span class="ot">-&gt;</span> from <span class="ot">-&gt;</span> m from</span>
<span id="cb734-7"><a href="#cb734-7" aria-hidden="true" tabindex="-1"></a><span class="ot">rewriteBiM   ::</span> (<span class="dt">Monad</span> m, <span class="dt">Biplate</span> from to) <span class="ot">=&gt;</span> (to <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> to)) <span class="ot">-&gt;</span> from <span class="ot">-&gt;</span> m from</span></code></pre></div>
<div class="sourceCode" id="cb735"
data-include="src/18-generics/biplate.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb735-1"><a href="#cb735-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb735-2"><a href="#cb735-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb735-3"><a href="#cb735-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb735-4"><a href="#cb735-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Generics.Uniplate.Direct</span></span>
<span id="cb735-5"><a href="#cb735-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb735-6"><a href="#cb735-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb735-7"><a href="#cb735-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb735-8"><a href="#cb735-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb735-9"><a href="#cb735-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Name</span></span>
<span id="cb735-10"><a href="#cb735-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Name</span> <span class="dt">Expr</span></span>
<span id="cb735-11"><a href="#cb735-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb735-12"><a href="#cb735-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb735-13"><a href="#cb735-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb735-14"><a href="#cb735-14" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stmt</span></span>
<span id="cb735-15"><a href="#cb735-15" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Decl</span> [<span class="dt">Stmt</span>]</span>
<span id="cb735-16"><a href="#cb735-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Let</span> <span class="dt">Name</span> <span class="dt">Expr</span></span>
<span id="cb735-17"><a href="#cb735-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb735-18"><a href="#cb735-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb735-19"><a href="#cb735-19" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Uniplate</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb735-20"><a href="#cb735-20" aria-hidden="true" tabindex="-1"></a>  uniplate (<span class="dt">Var</span> x  ) <span class="ot">=</span> plate <span class="dt">Var</span> <span class="op">|-</span> x</span>
<span id="cb735-21"><a href="#cb735-21" aria-hidden="true" tabindex="-1"></a>  uniplate (<span class="dt">App</span> x y) <span class="ot">=</span> plate <span class="dt">App</span> <span class="op">|*</span> x <span class="op">|*</span> y</span>
<span id="cb735-22"><a href="#cb735-22" aria-hidden="true" tabindex="-1"></a>  uniplate (<span class="dt">Lam</span> x y) <span class="ot">=</span> plate <span class="dt">Lam</span> <span class="op">|-</span> x <span class="op">|*</span> y</span>
<span id="cb735-23"><a href="#cb735-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb735-24"><a href="#cb735-24" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Biplate</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb735-25"><a href="#cb735-25" aria-hidden="true" tabindex="-1"></a>  biplate <span class="ot">=</span> plateSelf</span>
<span id="cb735-26"><a href="#cb735-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb735-27"><a href="#cb735-27" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Uniplate</span> <span class="dt">Stmt</span> <span class="kw">where</span></span>
<span id="cb735-28"><a href="#cb735-28" aria-hidden="true" tabindex="-1"></a>  uniplate (<span class="dt">Decl</span> x  ) <span class="ot">=</span> plate <span class="dt">Decl</span> <span class="op">||*</span> x</span>
<span id="cb735-29"><a href="#cb735-29" aria-hidden="true" tabindex="-1"></a>  uniplate (<span class="dt">Let</span> x y) <span class="ot">=</span> plate <span class="dt">Let</span> <span class="op">|-</span>  x <span class="op">|-</span> y</span>
<span id="cb735-30"><a href="#cb735-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb735-31"><a href="#cb735-31" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Biplate</span> <span class="dt">Stmt</span> <span class="dt">Stmt</span> <span class="kw">where</span></span>
<span id="cb735-32"><a href="#cb735-32" aria-hidden="true" tabindex="-1"></a>  biplate <span class="ot">=</span> plateSelf</span>
<span id="cb735-33"><a href="#cb735-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb735-34"><a href="#cb735-34" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Biplate</span> <span class="dt">Stmt</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb735-35"><a href="#cb735-35" aria-hidden="true" tabindex="-1"></a>  biplate (<span class="dt">Decl</span> x) <span class="ot">=</span> plate <span class="dt">Decl</span> <span class="op">||+</span> x</span>
<span id="cb735-36"><a href="#cb735-36" aria-hidden="true" tabindex="-1"></a>  biplate (<span class="dt">Let</span> x y) <span class="ot">=</span> plate <span class="dt">Let</span> <span class="op">|-</span> x <span class="op">|*</span> y</span>
<span id="cb735-37"><a href="#cb735-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb735-38"><a href="#cb735-38" aria-hidden="true" tabindex="-1"></a><span class="ot">rename ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb735-39"><a href="#cb735-39" aria-hidden="true" tabindex="-1"></a>rename from to <span class="ot">=</span> rewrite f</span>
<span id="cb735-40"><a href="#cb735-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb735-41"><a href="#cb735-41" aria-hidden="true" tabindex="-1"></a>    f (<span class="dt">Var</span> a) <span class="op">|</span> a <span class="op">==</span> from <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Var</span> to)</span>
<span id="cb735-42"><a href="#cb735-42" aria-hidden="true" tabindex="-1"></a>    f (<span class="dt">Lam</span> a b) <span class="op">|</span> a <span class="op">==</span> from <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Lam</span> to b)</span>
<span id="cb735-43"><a href="#cb735-43" aria-hidden="true" tabindex="-1"></a>    f _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb735-44"><a href="#cb735-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb735-45"><a href="#cb735-45" aria-hidden="true" tabindex="-1"></a>s, k,<span class="ot"> sk ::</span> <span class="dt">Expr</span></span>
<span id="cb735-46"><a href="#cb735-46" aria-hidden="true" tabindex="-1"></a>s <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;z&quot;</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;z&quot;</span>)) (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;y&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;z&quot;</span>)))))</span>
<span id="cb735-47"><a href="#cb735-47" aria-hidden="true" tabindex="-1"></a>k <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))</span>
<span id="cb735-48"><a href="#cb735-48" aria-hidden="true" tabindex="-1"></a>sk <span class="ot">=</span> <span class="dt">App</span> s k</span>
<span id="cb735-49"><a href="#cb735-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb735-50"><a href="#cb735-50" aria-hidden="true" tabindex="-1"></a><span class="ot">m ::</span> <span class="dt">Stmt</span></span>
<span id="cb735-51"><a href="#cb735-51" aria-hidden="true" tabindex="-1"></a>m <span class="ot">=</span> descendBi f <span class="op">$</span> <span class="dt">Decl</span> [ (<span class="dt">Let</span> <span class="st">&quot;s&quot;</span> s) , <span class="dt">Let</span> <span class="st">&quot;k&quot;</span> k , <span class="dt">Let</span> <span class="st">&quot;sk&quot;</span> sk ]</span>
<span id="cb735-52"><a href="#cb735-52" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb735-53"><a href="#cb735-53" aria-hidden="true" tabindex="-1"></a>    f <span class="ot">=</span> rename <span class="st">&quot;x&quot;</span> <span class="st">&quot;a&quot;</span></span>
<span id="cb735-54"><a href="#cb735-54" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span> rename <span class="st">&quot;y&quot;</span> <span class="st">&quot;b&quot;</span></span>
<span id="cb735-55"><a href="#cb735-55" aria-hidden="true" tabindex="-1"></a>      <span class="op">.</span> rename <span class="st">&quot;z&quot;</span> <span class="st">&quot;c&quot;</span></span></code></pre></div>
</hr>
<h1 id="mathematics">Mathematics</h1>
<h2 id="numeric-tower">Numeric Tower</h2>
<p>Haskell’s numeric tower is unusual and the source of some confusion
for novices. Haskell is one of the few languages to incorporate
statically typed overloaded literals without a mechanism for “coercions”
often found in other languages.</p>
<p>To add to the confusion numerical literals in Haskell are desugared
into a function from a numeric typeclass which yields a polymorphic
value that can be instantiated to any instance of the <code>Num</code>
or <code>Fractional</code> typeclass at the call-site, depending on the
inferred type.</p>
<p>To use a blunt metaphor, we’re effectively placing an object in a
hole and the size and shape of the hole defines the object you place
there. This is very different than in other languages where a numeric
literal like <code>2.718</code> is hard coded in the compiler to be a
specific type ( double or something ) and you cast the value at runtime
to be something smaller or larger as needed.</p>
<div class="sourceCode" id="cb736"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb736-1"><a href="#cb736-1" aria-hidden="true" tabindex="-1"></a><span class="dv">42</span><span class="ot"> ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a</span>
<span id="cb736-2"><a href="#cb736-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fromInteger</span> (<span class="dv">42</span><span class="ot"> ::</span> <span class="dt">Integer</span>)</span>
<span id="cb736-3"><a href="#cb736-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb736-4"><a href="#cb736-4" aria-hidden="true" tabindex="-1"></a><span class="fl">2.71</span><span class="ot"> ::</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> a</span>
<span id="cb736-5"><a href="#cb736-5" aria-hidden="true" tabindex="-1"></a><span class="fu">fromRational</span> (<span class="fl">2.71</span><span class="ot"> ::</span> <span class="dt">Rational</span>)</span></code></pre></div>
<p>The numeric typeclass hierarchy is defined as such:</p>
<div class="sourceCode" id="cb737"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb737-1"><a href="#cb737-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Num</span> a</span>
<span id="cb737-2"><a href="#cb737-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Num</span> a, <span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Real</span> a</span>
<span id="cb737-3"><a href="#cb737-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Fractional</span> a</span>
<span id="cb737-4"><a href="#cb737-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Real</span> a, <span class="dt">Enum</span> a) <span class="ot">=&gt;</span> <span class="dt">Integral</span> a</span>
<span id="cb737-5"><a href="#cb737-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Real</span> a, <span class="dt">Fractional</span> a) <span class="ot">=&gt;</span> <span class="dt">RealFrac</span> a</span>
<span id="cb737-6"><a href="#cb737-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Fractional</span> a <span class="ot">=&gt;</span> <span class="dt">Floating</span> a</span>
<span id="cb737-7"><a href="#cb737-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">RealFrac</span> a, <span class="dt">Floating</span> a) <span class="ot">=&gt;</span> <span class="dt">RealFloat</span> a</span></code></pre></div>
<center>
<img src="img/numerics.png" width="400" />
</center>
<p>Conversions between concrete numeric types ( from : left column, to :
top row ) is accomplished with several generic functions.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;">Double</th>
<th style="text-align: left;">Float</th>
<th style="text-align: left;">Int</th>
<th style="text-align: left;">Word</th>
<th style="text-align: left;">Integer</th>
<th style="text-align: left;">Rational</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Double</td>
<td style="text-align: left;">id</td>
<td style="text-align: left;">fromRational</td>
<td style="text-align: left;">truncate</td>
<td style="text-align: left;">truncate</td>
<td style="text-align: left;">truncate</td>
<td style="text-align: left;">toRational</td>
</tr>
<tr class="even">
<td>Float</td>
<td style="text-align: left;">fromRational</td>
<td style="text-align: left;">id</td>
<td style="text-align: left;">truncate</td>
<td style="text-align: left;">truncate</td>
<td style="text-align: left;">truncate</td>
<td style="text-align: left;">toRational</td>
</tr>
<tr class="odd">
<td>Int</td>
<td style="text-align: left;">fromIntegral</td>
<td style="text-align: left;">fromIntegral</td>
<td style="text-align: left;">id</td>
<td style="text-align: left;">fromIntegral</td>
<td style="text-align: left;">fromIntegral</td>
<td style="text-align: left;">fromIntegral</td>
</tr>
<tr class="even">
<td>Word</td>
<td style="text-align: left;">fromIntegral</td>
<td style="text-align: left;">fromIntegral</td>
<td style="text-align: left;">fromIntegral</td>
<td style="text-align: left;">id</td>
<td style="text-align: left;">fromIntegral</td>
<td style="text-align: left;">fromIntegral</td>
</tr>
<tr class="odd">
<td>Integer</td>
<td style="text-align: left;">fromIntegral</td>
<td style="text-align: left;">fromIntegral</td>
<td style="text-align: left;">fromIntegral</td>
<td style="text-align: left;">fromIntegral</td>
<td style="text-align: left;">id</td>
<td style="text-align: left;">fromIntegral</td>
</tr>
<tr class="even">
<td>Rational</td>
<td style="text-align: left;">fromRational</td>
<td style="text-align: left;">fromRational</td>
<td style="text-align: left;">truncate</td>
<td style="text-align: left;">truncate</td>
<td style="text-align: left;">truncate</td>
<td style="text-align: left;">id</td>
</tr>
</tbody>
</table>
<h2 id="gmp-integers">GMP Integers</h2>
<p>The <code>Integer</code> type in GHC is implemented by the GMP
(<code>libgmp</code>) arbitrary precision arithmetic library. Unlike the
<code>Int</code> type, the size of Integer values is bounded only by the
available memory.</p>
<div class="sourceCode" id="cb738"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb738-1"><a href="#cb738-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> (<span class="dv">2</span><span class="op">^</span><span class="dv">64</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb738-2"><a href="#cb738-2" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span></span>
<span id="cb738-3"><a href="#cb738-3" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> (<span class="dv">2</span><span class="op">^</span><span class="dv">64</span><span class="ot"> ::</span> <span class="dt">Integer</span>)</span>
<span id="cb738-4"><a href="#cb738-4" aria-hidden="true" tabindex="-1"></a><span class="dv">18446744073709551616</span></span></code></pre></div>
<p>Most notably <code>libgmp</code> is one of the few libraries that
compiled Haskell binaries are dynamically linked against. An alternative
library <code>integer-simple</code> can be linked in place of
libgmp.</p>
<h2 id="complex-numbers">Complex Numbers</h2>
<p>Haskell supports arithmetic with complex numbers via a Complex
datatype from the <code>Data.Complex</code> module. The first argument
is the real part, while the second is the imaginary part. The type has a
single parameter and inherits its numerical typeclass components (Num,
Fractional, Floating) from the type of this parameter.</p>
<div class="sourceCode" id="cb739"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb739-1"><a href="#cb739-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1 + 2i</span></span>
<span id="cb739-2"><a href="#cb739-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> complex <span class="ot">=</span> <span class="dv">1</span> <span class="op">:+</span> <span class="dv">2</span></span></code></pre></div>
<div class="sourceCode" id="cb740"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb740-1"><a href="#cb740-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Complex</span> a <span class="ot">=</span> a <span class="op">:+</span> a</span>
<span id="cb740-2"><a href="#cb740-2" aria-hidden="true" tabindex="-1"></a><span class="ot">mkPolar ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Complex</span> a</span></code></pre></div>
<p>The <code>Num</code> instance for <code>Complex</code> is only
defined if parameter of <code>Complex</code> is an instance of
<code>RealFloat</code>.</p>
<div class="sourceCode" id="cb741"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb741-1"><a href="#cb741-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="dv">0</span> <span class="op">:+</span> <span class="dv">1</span></span>
<span id="cb741-2"><a href="#cb741-2" aria-hidden="true" tabindex="-1"></a><span class="dv">0</span> <span class="op">:+</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Complex</span> <span class="dt">Integer</span></span>
<span id="cb741-3"><a href="#cb741-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb741-4"><a href="#cb741-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> (<span class="dv">0</span> <span class="op">:+</span> <span class="dv">1</span>) <span class="op">+</span> (<span class="dv">1</span> <span class="op">:+</span> <span class="dv">0</span>)</span>
<span id="cb741-5"><a href="#cb741-5" aria-hidden="true" tabindex="-1"></a><span class="fl">1.0</span> <span class="op">:+</span> <span class="fl">1.0</span><span class="ot"> ::</span> <span class="dt">Complex</span> <span class="dt">Integer</span></span>
<span id="cb741-6"><a href="#cb741-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb741-7"><a href="#cb741-7" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="fu">exp</span> (<span class="dv">0</span> <span class="op">:+</span> <span class="dv">2</span> <span class="op">*</span> <span class="fu">pi</span>)</span>
<span id="cb741-8"><a href="#cb741-8" aria-hidden="true" tabindex="-1"></a><span class="fl">1.0</span> <span class="op">:+</span> (<span class="op">-</span><span class="fl">2.4492935982947064e-16</span>)<span class="ot"> ::</span> <span class="dt">Complex</span> <span class="dt">Double</span></span>
<span id="cb741-9"><a href="#cb741-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb741-10"><a href="#cb741-10" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> mkPolar <span class="dv">1</span> (<span class="dv">2</span><span class="op">*</span><span class="fu">pi</span>)</span>
<span id="cb741-11"><a href="#cb741-11" aria-hidden="true" tabindex="-1"></a><span class="fl">1.0</span> <span class="op">:+</span> (<span class="op">-</span><span class="fl">2.4492935982947064e-16</span>)<span class="ot"> ::</span> <span class="dt">Complex</span> <span class="dt">Double</span></span>
<span id="cb741-12"><a href="#cb741-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb741-13"><a href="#cb741-13" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="kw">let</span> f x n <span class="ot">=</span> (<span class="fu">cos</span> x <span class="op">:+</span> <span class="fu">sin</span> x)<span class="op">^</span>n</span>
<span id="cb741-14"><a href="#cb741-14" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="kw">let</span> g x n <span class="ot">=</span> <span class="fu">cos</span> (n<span class="op">*</span>x) <span class="op">:+</span> <span class="fu">sin</span> (n<span class="op">*</span>x)</span></code></pre></div>
<h2 id="decimal-scientific-types">Decimal &amp; Scientific Types</h2>
<p>Scientific provides arbitrary-precision numbers represented using
scientific notation. The constructor takes an arbitrarily sized Integer
argument for the digits and an Int for the exponent. Alternatively the
value can be parsed from a String or coerced from either
Double/Float.</p>
<div class="sourceCode" id="cb742"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb742-1"><a href="#cb742-1" aria-hidden="true" tabindex="-1"></a><span class="ot">scientific ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Scientific</span></span>
<span id="cb742-2"><a href="#cb742-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fromFloatDigits ::</span> <span class="dt">RealFloat</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Scientific</span></span></code></pre></div>
<div class="sourceCode" id="cb743"
data-include="src/19-numbers/scientific.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb743-1"><a href="#cb743-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Scientific</span></span>
<span id="cb743-2"><a href="#cb743-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb743-3"><a href="#cb743-3" aria-hidden="true" tabindex="-1"></a>c , h, g, a,<span class="ot"> k ::</span> <span class="dt">Scientific</span></span>
<span id="cb743-4"><a href="#cb743-4" aria-hidden="true" tabindex="-1"></a>c <span class="ot">=</span> scientific <span class="dv">299792458</span> (<span class="dv">0</span>) <span class="co">-- Speed of light</span></span>
<span id="cb743-5"><a href="#cb743-5" aria-hidden="true" tabindex="-1"></a>h <span class="ot">=</span> scientific <span class="dv">662606957</span> (<span class="op">-</span><span class="dv">42</span>) <span class="co">-- Planck&#39;s constant</span></span>
<span id="cb743-6"><a href="#cb743-6" aria-hidden="true" tabindex="-1"></a>g <span class="ot">=</span> scientific <span class="dv">667384</span> (<span class="op">-</span><span class="dv">16</span>) <span class="co">-- Gravitational constant</span></span>
<span id="cb743-7"><a href="#cb743-7" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> scientific <span class="dv">729735257</span> (<span class="op">-</span><span class="dv">11</span>) <span class="co">-- Fine structure constant</span></span>
<span id="cb743-8"><a href="#cb743-8" aria-hidden="true" tabindex="-1"></a>k <span class="ot">=</span> scientific <span class="dv">268545200</span> (<span class="op">-</span><span class="dv">9</span>) <span class="co">-- Khinchin-Levy Constant</span></span>
<span id="cb743-9"><a href="#cb743-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb743-10"><a href="#cb743-10" aria-hidden="true" tabindex="-1"></a><span class="ot">tau ::</span> <span class="dt">Scientific</span></span>
<span id="cb743-11"><a href="#cb743-11" aria-hidden="true" tabindex="-1"></a>tau <span class="ot">=</span> fromFloatDigits (<span class="dv">2</span> <span class="op">*</span> <span class="fu">pi</span>)</span>
<span id="cb743-12"><a href="#cb743-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb743-13"><a href="#cb743-13" aria-hidden="true" tabindex="-1"></a><span class="ot">maxDouble64 ::</span> <span class="dt">Double</span></span>
<span id="cb743-14"><a href="#cb743-14" aria-hidden="true" tabindex="-1"></a>maxDouble64 <span class="ot">=</span> <span class="fu">read</span> <span class="st">&quot;1.7976931348623159e308&quot;</span></span>
<span id="cb743-15"><a href="#cb743-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb743-16"><a href="#cb743-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- Infinity</span></span>
<span id="cb743-17"><a href="#cb743-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb743-18"><a href="#cb743-18" aria-hidden="true" tabindex="-1"></a><span class="ot">maxScientific ::</span> <span class="dt">Scientific</span></span>
<span id="cb743-19"><a href="#cb743-19" aria-hidden="true" tabindex="-1"></a>maxScientific <span class="ot">=</span> <span class="fu">read</span> <span class="st">&quot;1.7976931348623159e308&quot;</span></span>
<span id="cb743-20"><a href="#cb743-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- 1.7976931348623159e308</span></span></code></pre></div>
<h2 id="polynomial-arithmetic">Polynomial Arithmetic</h2>
<p>The standard library for working with symbolic polynomials is the
<code>poly</code> library. It exposes a interface for working with
univariate polynomials which are backed by an efficient vector library.
This allows us to efficiently manipulate and perform arithmetic
operations over univariate polynomails.</p>
<p>For example we can instantiate symbolic polynomials, write recurrence
rules and generators over them and factor them.</p>
<div class="sourceCode" id="cb744"
data-include="src/19-numbers/polynomial.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb744-1"><a href="#cb744-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Poly</span></span>
<span id="cb744-2"><a href="#cb744-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb744-3"><a href="#cb744-3" aria-hidden="true" tabindex="-1"></a><span class="ot">abel ::</span> <span class="dt">VPoly</span> <span class="dt">Integer</span></span>
<span id="cb744-4"><a href="#cb744-4" aria-hidden="true" tabindex="-1"></a>abel <span class="ot">=</span> <span class="dt">X</span> <span class="op">^</span> <span class="dv">5</span> <span class="op">-</span> <span class="dt">X</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb744-5"><a href="#cb744-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb744-6"><a href="#cb744-6" aria-hidden="true" tabindex="-1"></a><span class="ot">fibPoly ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">VPoly</span> <span class="dt">Integer</span></span>
<span id="cb744-7"><a href="#cb744-7" aria-hidden="true" tabindex="-1"></a>fibPoly <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb744-8"><a href="#cb744-8" aria-hidden="true" tabindex="-1"></a>fibPoly <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb744-9"><a href="#cb744-9" aria-hidden="true" tabindex="-1"></a>fibPoly n <span class="ot">=</span> <span class="dt">X</span> <span class="op">*</span> fibPoly (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> fibPoly (n <span class="op">-</span> <span class="dv">2</span>)</span>
<span id="cb744-10"><a href="#cb744-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb744-11"><a href="#cb744-11" aria-hidden="true" tabindex="-1"></a><span class="ot">division ::</span> (<span class="dt">VPoly</span> <span class="dt">Double</span>, <span class="dt">VPoly</span> <span class="dt">Double</span>)</span>
<span id="cb744-12"><a href="#cb744-12" aria-hidden="true" tabindex="-1"></a>division <span class="ot">=</span> gcdExt (<span class="dt">X</span> <span class="op">^</span> <span class="dv">3</span> <span class="op">-</span> <span class="dv">2</span> <span class="op">*</span> <span class="dt">X</span> <span class="op">^</span> <span class="dv">2</span> <span class="op">-</span> <span class="dv">4</span>) (<span class="dt">X</span> <span class="op">-</span> <span class="dv">3</span>)</span></code></pre></div>
<p>See: <a href="https://hackage.haskell.org/package/poly">poly</a></p>
<h2 id="combinatorics">Combinatorics</h2>
<p>Combinat is the standard Haskell library for doing combinatorial
calculations. It provides a variety of functions for computing:</p>
<ul>
<li><a
href="https://hackage.haskell.org/package/combinat-0.2.9.0/docs/Math-Combinat-Permutations.html">Permutations
&amp; Combinations</a></li>
<li><a
href="https://hackage.haskell.org/package/combinat-0.2.9.0/docs/Math-Combinat-Groups-Braid.html">Braid
Groups</a></li>
<li><a
href="https://hackage.haskell.org/package/combinat-0.2.9.0/docs/Math-Combinat-Partitions-Integer.html">Integer
Partitions</a></li>
<li><a
href="https://hackage.haskell.org/package/combinat-0.2.9.0/docs/Math-Combinat-Tableaux.html">Young’s
Tableux</a></li>
<li><a
href="https://hackage.haskell.org/package/combinat-0.2.9.0/docs/Math-Combinat-LatticePaths.html#t:LatticePath">Lattice
Paths</a></li>
</ul>
<p>See: <a
href="https://hackage.haskell.org/package/combinat">combinat</a></p>
<h2 id="number-theory">Number Theory</h2>
<p>Arithmoi is the standard number theory library for Haskell. It
provides functions for calculing common number theory operations used in
combinators and cryptography applications in Haskell. Including:</p>
<ul>
<li><a
href="https://hackage.haskell.org/package/arithmoi-0.10.0.0/docs/Math-NumberTheory-Moduli-Sqrt.html">Modular
square roots</a></li>
<li><a
href="https://hackage.haskell.org/package/arithmoi-0.10.0.0/docs/Math-NumberTheory-MoebiusInversion.html">Möbius
Inversions</a></li>
<li><a
href="https://hackage.haskell.org/package/arithmoi-0.10.0.0/docs/Math-NumberTheory-Primes.html">Primarily
Testing</a></li>
<li><a
href="https://hackage.haskell.org/package/arithmoi-0.10.0.0/docs/Math-NumberTheory-Zeta.html">Riemann
Zeta Functions</a></li>
<li><a
href="https://hackage.haskell.org/package/arithmoi-0.10.0.0/docs/Math-NumberTheory-Moduli-DiscreteLogarithm.html">Pollard’s
Rho Algorithm</a></li>
<li><a
href="https://hackage.haskell.org/package/arithmoi-0.10.0.0/docs/Math-NumberTheory-Moduli-Jacobi.html">Jacobi
symbols</a></li>
<li>Meijer-G Functions</li>
</ul>
<div class="sourceCode" id="cb745"
data-include="src/19-numbers/arithmoi.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb745-1"><a href="#cb745-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb745-2"><a href="#cb745-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Math.NumberTheory.ArithmeticFunctions</span></span>
<span id="cb745-3"><a href="#cb745-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Math.NumberTheory.Moduli.Sqrt</span></span>
<span id="cb745-4"><a href="#cb745-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Math.NumberTheory.Primes</span></span>
<span id="cb745-5"><a href="#cb745-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Math.NumberTheory.Zeta</span></span>
<span id="cb745-6"><a href="#cb745-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb745-7"><a href="#cb745-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Riemann zeta function</span></span>
<span id="cb745-8"><a href="#cb745-8" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleZeta ::</span> <span class="dt">Double</span></span>
<span id="cb745-9"><a href="#cb745-9" aria-hidden="true" tabindex="-1"></a>exampleZeta <span class="ot">=</span> zetas <span class="fl">1e-10</span> <span class="op">!!</span> <span class="dv">10</span></span>
<span id="cb745-10"><a href="#cb745-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb745-11"><a href="#cb745-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- Euler totient function</span></span>
<span id="cb745-12"><a href="#cb745-12" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleEuler ::</span> <span class="dt">Integer</span></span>
<span id="cb745-13"><a href="#cb745-13" aria-hidden="true" tabindex="-1"></a>exampleEuler <span class="ot">=</span> totient <span class="dv">25</span></span>
<span id="cb745-14"><a href="#cb745-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb745-15"><a href="#cb745-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- Ramanujan tau function</span></span>
<span id="cb745-16"><a href="#cb745-16" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleRamanujan ::</span> <span class="dt">Integer</span></span>
<span id="cb745-17"><a href="#cb745-17" aria-hidden="true" tabindex="-1"></a>exampleRamanujan <span class="ot">=</span> ramanujan <span class="dv">16</span></span>
<span id="cb745-18"><a href="#cb745-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb745-19"><a href="#cb745-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- Primality testing</span></span>
<span id="cb745-20"><a href="#cb745-20" aria-hidden="true" tabindex="-1"></a><span class="ot">examplePrimality ::</span> <span class="dt">Maybe</span> (<span class="dt">Prime</span> <span class="dt">Integer</span>)</span>
<span id="cb745-21"><a href="#cb745-21" aria-hidden="true" tabindex="-1"></a>examplePrimality <span class="ot">=</span> isPrime <span class="dv">2147483647</span></span>
<span id="cb745-22"><a href="#cb745-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb745-23"><a href="#cb745-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- Square roots moduluo prime</span></span>
<span id="cb745-24"><a href="#cb745-24" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleSqrt ::</span> [<span class="dt">Integer</span>]</span>
<span id="cb745-25"><a href="#cb745-25" aria-hidden="true" tabindex="-1"></a>exampleSqrt <span class="ot">=</span> sqrtsModPrime <span class="dv">42</span> (fromJust examplePrimality)</span></code></pre></div>
<p>See: <a
href="https://hackage.haskell.org/package/arithmoi">arithmoi</a></p>
<h2 id="stochastic-calculus">Stochastic Calculus</h2>
<p><code>HQuantLib</code> provides a variety of functions for working
with stochastic processes. This primarily applies to stochastic calculus
applied to pricing financial products such as the Black-Scholes pricing
engine and routines for calculating volatility smiles of options
products.</p>
<p>See: <a
href="https://hackage.haskell.org/package/hquantlib">HQuantLib</a></p>
<h2 id="differential-equations">Differential Equations</h2>
<p>There are several Haskell libraries for finding numerical solutions
to systems of differential equations. These kind of problems show up
quite frequently in scientific computing problems.</p>
<p>For example a simple differential equation is Van der Pol oscillator
which occurs frequently in physics. This is a second order differential
equation which relates the position of a oscillator <span
class="math inline"><em>x</em></span> in terms of time, acceleration
<span class="math inline">${d^{2}x
\over dt^{2}}$</span>, and the velocity <span class="math inline">$dx
\over dt$</span> a scalar parameter <span
class="math inline"><em>μ</em></span>. It is given by the equation.</p>
<p><span class="math display">$${\displaystyle {d^{2}x \over dt^{2}}-\mu
(1-x^{2}){dx \over dt}+x=0,}$$</span></p>
<p>For example this equation can be solved for a fixed <span
class="math inline"><em>μ</em></span> and set of boundary conditions for
the time parameter <span class="math inline"><em>t</em></span>. The
solution is returned as an HMatrix vector.</p>
<div class="sourceCode" id="cb746"
data-include="src/19-numbers/diffeq/Main.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb746-1"><a href="#cb746-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedLists #-}</span></span>
<span id="cb746-2"><a href="#cb746-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb746-3"><a href="#cb746-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb746-4"><a href="#cb746-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb746-5"><a href="#cb746-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Numeric.GSL.ODE</span></span>
<span id="cb746-6"><a href="#cb746-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Numeric.LinearAlgebra</span></span>
<span id="cb746-7"><a href="#cb746-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb746-8"><a href="#cb746-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Differential equation</span></span>
<span id="cb746-9"><a href="#cb746-9" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> [<span class="dt">Double</span>] <span class="ot">-&gt;</span> [<span class="dt">Double</span>]</span>
<span id="cb746-10"><a href="#cb746-10" aria-hidden="true" tabindex="-1"></a>f t [x, v] <span class="ot">=</span> [v, <span class="op">-</span> x <span class="op">+</span> mu <span class="op">*</span> v <span class="op">*</span> (<span class="dv">1</span> <span class="op">-</span> x <span class="op">^</span> <span class="dv">2</span>)]</span>
<span id="cb746-11"><a href="#cb746-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb746-12"><a href="#cb746-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Mu scalar, dampening strenth</span></span>
<span id="cb746-13"><a href="#cb746-13" aria-hidden="true" tabindex="-1"></a><span class="ot">mu ::</span> <span class="dt">Double</span></span>
<span id="cb746-14"><a href="#cb746-14" aria-hidden="true" tabindex="-1"></a>mu <span class="ot">=</span> <span class="fl">0.1</span></span>
<span id="cb746-15"><a href="#cb746-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb746-16"><a href="#cb746-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- Boundary conditions</span></span>
<span id="cb746-17"><a href="#cb746-17" aria-hidden="true" tabindex="-1"></a><span class="ot">ts ::</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb746-18"><a href="#cb746-18" aria-hidden="true" tabindex="-1"></a>ts <span class="ot">=</span> linspace <span class="dv">1000</span> (<span class="dv">0</span>, <span class="dv">50</span>)</span>
<span id="cb746-19"><a href="#cb746-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb746-20"><a href="#cb746-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- Use default solver: Embedded Runge-Kutta-Fehlberg (4, 5) method.</span></span>
<span id="cb746-21"><a href="#cb746-21" aria-hidden="true" tabindex="-1"></a><span class="ot">vanderpol1 ::</span> [<span class="dt">Vector</span> <span class="dt">Double</span>]</span>
<span id="cb746-22"><a href="#cb746-22" aria-hidden="true" tabindex="-1"></a>vanderpol1 <span class="ot">=</span> toColumns <span class="op">$</span> odeSolve f [<span class="dv">1</span>, <span class="dv">0</span>] ts</span>
<span id="cb746-23"><a href="#cb746-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb746-24"><a href="#cb746-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- Use Runge-Kutta (2,3) solver</span></span>
<span id="cb746-25"><a href="#cb746-25" aria-hidden="true" tabindex="-1"></a><span class="ot">vanderpol2 ::</span> [<span class="dt">Vector</span> <span class="dt">Double</span>]</span>
<span id="cb746-26"><a href="#cb746-26" aria-hidden="true" tabindex="-1"></a>vanderpol2 <span class="ot">=</span> toColumns <span class="op">$</span> odeSolveV <span class="dt">RK2</span> hi epsAbs epsRel (l2v f) [<span class="dv">1</span>, <span class="dv">0</span>] ts</span>
<span id="cb746-27"><a href="#cb746-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb746-28"><a href="#cb746-28" aria-hidden="true" tabindex="-1"></a>    epsAbs <span class="ot">=</span> <span class="fl">1.49012e-08</span></span>
<span id="cb746-29"><a href="#cb746-29" aria-hidden="true" tabindex="-1"></a>    epsRel <span class="ot">=</span> epsAbs</span>
<span id="cb746-30"><a href="#cb746-30" aria-hidden="true" tabindex="-1"></a>    hi <span class="ot">=</span> (ts <span class="op">!</span> <span class="dv">1</span> <span class="op">-</span> ts <span class="op">!</span> <span class="dv">0</span>) <span class="op">/</span> <span class="dv">100</span></span>
<span id="cb746-31"><a href="#cb746-31" aria-hidden="true" tabindex="-1"></a>    l2v f <span class="ot">=</span> \t <span class="ot">-&gt;</span> fromList <span class="op">.</span> f t <span class="op">.</span> toList</span>
<span id="cb746-32"><a href="#cb746-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb746-33"><a href="#cb746-33" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb746-34"><a href="#cb746-34" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb746-35"><a href="#cb746-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> vanderpol1</span>
<span id="cb746-36"><a href="#cb746-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> vanderpol2</span></code></pre></div>
<h2 id="statistics-probability">Statistics &amp; Probability</h2>
<p>Haskell has a basic statistics library for calculating descriptive
statistics, generating and sampling probability distributions and
performing statistical tests.</p>
<div class="sourceCode" id="cb747"
data-include="src/19-numbers/stats.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb747-1"><a href="#cb747-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector</span></span>
<span id="cb747-2"><a href="#cb747-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Statistics.Sample</span></span>
<span id="cb747-3"><a href="#cb747-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb747-4"><a href="#cb747-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Statistics.Distribution.Normal</span></span>
<span id="cb747-5"><a href="#cb747-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Statistics.Distribution.Poisson</span></span>
<span id="cb747-6"><a href="#cb747-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Statistics.Distribution</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb747-7"><a href="#cb747-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb747-8"><a href="#cb747-8" aria-hidden="true" tabindex="-1"></a><span class="ot">s1 ::</span> <span class="dt">Vector</span> <span class="dt">Double</span></span>
<span id="cb747-9"><a href="#cb747-9" aria-hidden="true" tabindex="-1"></a>s1 <span class="ot">=</span> fromList [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">10</span>]</span>
<span id="cb747-10"><a href="#cb747-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb747-11"><a href="#cb747-11" aria-hidden="true" tabindex="-1"></a><span class="ot">s2 ::</span> <span class="dt">PoissonDistribution</span></span>
<span id="cb747-12"><a href="#cb747-12" aria-hidden="true" tabindex="-1"></a>s2 <span class="ot">=</span> poisson <span class="fl">2.5</span></span>
<span id="cb747-13"><a href="#cb747-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb747-14"><a href="#cb747-14" aria-hidden="true" tabindex="-1"></a><span class="ot">s3 ::</span> <span class="dt">NormalDistribution</span></span>
<span id="cb747-15"><a href="#cb747-15" aria-hidden="true" tabindex="-1"></a>s3 <span class="ot">=</span> normalDistr mean stdDev</span>
<span id="cb747-16"><a href="#cb747-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb747-17"><a href="#cb747-17" aria-hidden="true" tabindex="-1"></a>    mean   <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb747-18"><a href="#cb747-18" aria-hidden="true" tabindex="-1"></a>    stdDev <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb747-19"><a href="#cb747-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb747-20"><a href="#cb747-20" aria-hidden="true" tabindex="-1"></a><span class="ot">descriptive ::</span> <span class="dt">IO</span> ()</span>
<span id="cb747-21"><a href="#cb747-21" aria-hidden="true" tabindex="-1"></a>descriptive <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb747-22"><a href="#cb747-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="fu">range</span> s1</span>
<span id="cb747-23"><a href="#cb747-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 9.0</span></span>
<span id="cb747-24"><a href="#cb747-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> mean s1</span>
<span id="cb747-25"><a href="#cb747-25" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 5.5</span></span>
<span id="cb747-26"><a href="#cb747-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> stdDev s1</span>
<span id="cb747-27"><a href="#cb747-27" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 3.0276503540974917</span></span>
<span id="cb747-28"><a href="#cb747-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> variance s1</span>
<span id="cb747-29"><a href="#cb747-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 8.25</span></span>
<span id="cb747-30"><a href="#cb747-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> harmonicMean s1</span>
<span id="cb747-31"><a href="#cb747-31" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 3.414171521474055</span></span>
<span id="cb747-32"><a href="#cb747-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> geometricMean s1</span>
<span id="cb747-33"><a href="#cb747-33" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 4.5287286881167645</span></span>
<span id="cb747-34"><a href="#cb747-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb747-35"><a href="#cb747-35" aria-hidden="true" tabindex="-1"></a><span class="ot">discrete ::</span> <span class="dt">IO</span> ()</span>
<span id="cb747-36"><a href="#cb747-36" aria-hidden="true" tabindex="-1"></a>discrete <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb747-37"><a href="#cb747-37" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> S.cumulative s2 <span class="dv">0</span></span>
<span id="cb747-38"><a href="#cb747-38" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 8.208499862389884e-2</span></span>
<span id="cb747-39"><a href="#cb747-39" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> S.mean s2</span>
<span id="cb747-40"><a href="#cb747-40" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 2.5</span></span>
<span id="cb747-41"><a href="#cb747-41" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> S.variance s2</span>
<span id="cb747-42"><a href="#cb747-42" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 2.5</span></span>
<span id="cb747-43"><a href="#cb747-43" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> S.stdDev s2</span>
<span id="cb747-44"><a href="#cb747-44" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 1.5811388300841898</span></span>
<span id="cb747-45"><a href="#cb747-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb747-46"><a href="#cb747-46" aria-hidden="true" tabindex="-1"></a><span class="ot">continuous ::</span> <span class="dt">IO</span> ()</span>
<span id="cb747-47"><a href="#cb747-47" aria-hidden="true" tabindex="-1"></a>continuous <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb747-48"><a href="#cb747-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> S.cumulative s3 <span class="dv">0</span></span>
<span id="cb747-49"><a href="#cb747-49" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 0.15865525393145707</span></span>
<span id="cb747-50"><a href="#cb747-50" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> S.quantile s3 <span class="fl">0.5</span></span>
<span id="cb747-51"><a href="#cb747-51" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 1.0</span></span>
<span id="cb747-52"><a href="#cb747-52" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> S.density s3 <span class="dv">0</span></span>
<span id="cb747-53"><a href="#cb747-53" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 0.24197072451914334</span></span>
<span id="cb747-54"><a href="#cb747-54" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> S.mean s3</span>
<span id="cb747-55"><a href="#cb747-55" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 1.0</span></span>
<span id="cb747-56"><a href="#cb747-56" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> S.variance s3</span>
<span id="cb747-57"><a href="#cb747-57" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 1.0</span></span>
<span id="cb747-58"><a href="#cb747-58" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> S.stdDev s3</span>
<span id="cb747-59"><a href="#cb747-59" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 1.0</span></span></code></pre></div>
<h2 id="constructive-reals">Constructive Reals</h2>
<p>Instead of modeling the real numbers on finite precision floating
point numbers we alternatively work with <code>Num</code> which
internally manipulates the power series expansions for the expressions
when performing operations like arithmetic or transcendental functions
without losing precision when performing intermediate computations. Then
we simply slice off a fixed number of terms and approximate the
resulting number to a desired precision. This approach is not without
its limitations and caveats ( notably that it may diverge ).</p>
<div class="sourceCode" id="cb748"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb748-1"><a href="#cb748-1" aria-hidden="true" tabindex="-1"></a><span class="fu">exp</span>(x)    <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> x <span class="op">+</span> <span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">*</span>x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span><span class="op">/</span><span class="dv">6</span><span class="op">*</span>x<span class="op">^</span><span class="dv">3</span> <span class="op">+</span> <span class="dv">1</span><span class="op">/</span><span class="dv">24</span><span class="op">*</span>x<span class="op">^</span><span class="dv">4</span> <span class="op">+</span> <span class="dv">1</span><span class="op">/</span><span class="dv">120</span><span class="op">*</span>x<span class="op">^</span><span class="dv">5</span> <span class="op">...</span></span>
<span id="cb748-2"><a href="#cb748-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sqrt</span>(<span class="dv">1</span><span class="op">+</span>x) <span class="ot">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">*</span>x <span class="op">-</span> <span class="dv">1</span><span class="op">/</span><span class="dv">8</span><span class="op">*</span>x<span class="op">^</span><span class="dv">2</span> <span class="op">+</span> <span class="dv">1</span><span class="op">/</span><span class="dv">16</span><span class="op">*</span>x<span class="op">^</span><span class="dv">3</span> <span class="op">-</span> <span class="dv">5</span><span class="op">/</span><span class="dv">128</span><span class="op">*</span>x<span class="op">^</span><span class="dv">4</span> <span class="op">+</span> <span class="dv">7</span><span class="op">/</span><span class="dv">256</span><span class="op">*</span>x<span class="op">^</span><span class="dv">5</span> <span class="op">...</span></span>
<span id="cb748-3"><a href="#cb748-3" aria-hidden="true" tabindex="-1"></a><span class="fu">atan</span>(x)   <span class="ot">=</span> x <span class="op">-</span> <span class="dv">1</span><span class="op">/</span><span class="dv">3</span><span class="op">*</span>x<span class="op">^</span><span class="dv">3</span> <span class="op">+</span> <span class="dv">1</span><span class="op">/</span><span class="dv">5</span><span class="op">*</span>x<span class="op">^</span><span class="dv">5</span> <span class="op">-</span> <span class="dv">1</span><span class="op">/</span><span class="dv">7</span><span class="op">*</span>x<span class="op">^</span><span class="dv">7</span> <span class="op">+</span> <span class="dv">1</span><span class="op">/</span><span class="dv">9</span><span class="op">*</span>x<span class="op">^</span><span class="dv">9</span> <span class="op">-</span> <span class="dv">1</span><span class="op">/</span><span class="dv">11</span><span class="op">*</span>x<span class="op">^</span><span class="dv">11</span> <span class="op">...</span></span>
<span id="cb748-4"><a href="#cb748-4" aria-hidden="true" tabindex="-1"></a><span class="fu">pi</span>        <span class="ot">=</span> <span class="dv">16</span> <span class="op">*</span> <span class="fu">atan</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">5</span>) <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span> <span class="fu">atan</span> (<span class="dv">1</span><span class="op">/</span><span class="dv">239</span>)</span></code></pre></div>
<div class="sourceCode" id="cb749"
data-include="src/19-numbers/creal.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb749-1"><a href="#cb749-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Number.CReal</span></span>
<span id="cb749-2"><a href="#cb749-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb749-3"><a href="#cb749-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- algebraic</span></span>
<span id="cb749-4"><a href="#cb749-4" aria-hidden="true" tabindex="-1"></a><span class="ot">phi ::</span> <span class="dt">CReal</span></span>
<span id="cb749-5"><a href="#cb749-5" aria-hidden="true" tabindex="-1"></a>phi <span class="ot">=</span> (<span class="dv">1</span> <span class="op">+</span> <span class="fu">sqrt</span> <span class="dv">5</span>) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb749-6"><a href="#cb749-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb749-7"><a href="#cb749-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- transcendental</span></span>
<span id="cb749-8"><a href="#cb749-8" aria-hidden="true" tabindex="-1"></a><span class="ot">ramanujan ::</span> <span class="dt">CReal</span></span>
<span id="cb749-9"><a href="#cb749-9" aria-hidden="true" tabindex="-1"></a>ramanujan <span class="ot">=</span> <span class="fu">exp</span> (<span class="fu">pi</span> <span class="op">*</span> <span class="fu">sqrt</span> <span class="dv">163</span>)</span>
<span id="cb749-10"><a href="#cb749-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb749-11"><a href="#cb749-11" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb749-12"><a href="#cb749-12" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb749-13"><a href="#cb749-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> showCReal <span class="dv">30</span> <span class="fu">pi</span></span>
<span id="cb749-14"><a href="#cb749-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 3.141592653589793238462643383279</span></span>
<span id="cb749-15"><a href="#cb749-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> showCReal <span class="dv">30</span> phi</span>
<span id="cb749-16"><a href="#cb749-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 1.618033988749894848204586834366</span></span>
<span id="cb749-17"><a href="#cb749-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> showCReal <span class="dv">15</span> ramanujan</span>
<span id="cb749-18"><a href="#cb749-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- 262537412640768743.99999999999925</span></span></code></pre></div>
<h2 id="sat-solvers">SAT Solvers</h2>
<p>A collection of constraint problems known as satisfiability problems
show up in a number of different disciplines from type checking to
package management. Simply put a satisfiability problem attempts to find
solutions to a statement of conjoined conjunctions and disjunctions in
terms of a series of variables. For example:</p>
<pre class="text"><code>(A v ¬B v C) ∧ (B v D v E) ∧ (D v F)</code></pre>
<p>To use the picosat library to solve this, it can be written as
zero-terminated lists of integers and fed to the solver according to a
number-to-variable relation:</p>
<div class="sourceCode" id="cb751"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb751-1"><a href="#cb751-1" aria-hidden="true" tabindex="-1"></a><span class="dv">1</span> <span class="op">-</span><span class="dv">2</span> <span class="dv">3</span>  <span class="co">-- (A v ¬B v C)</span></span>
<span id="cb751-2"><a href="#cb751-2" aria-hidden="true" tabindex="-1"></a><span class="dv">2</span> <span class="dv">4</span> <span class="dv">5</span>   <span class="co">-- (B v D v E)</span></span>
<span id="cb751-3"><a href="#cb751-3" aria-hidden="true" tabindex="-1"></a><span class="dv">4</span> <span class="dv">6</span>     <span class="co">-- (D v F)</span></span></code></pre></div>
<div class="sourceCode" id="cb752"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb752-1"><a href="#cb752-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Picosat</span></span>
<span id="cb752-2"><a href="#cb752-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb752-3"><a href="#cb752-3" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> [<span class="dt">Int</span>]</span>
<span id="cb752-4"><a href="#cb752-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb752-5"><a href="#cb752-5" aria-hidden="true" tabindex="-1"></a>  solve [[<span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>], [<span class="dv">4</span>,<span class="dv">6</span>]]</span>
<span id="cb752-6"><a href="#cb752-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Solution [1,-2,3,4,5,6]</span></span></code></pre></div>
<p>The SAT solver itself can be used to solve satisfiability problems
with millions of variables in this form and is finely tuned.</p>
<p>See:</p>
<ul>
<li><a
href="http://hackage.haskell.org/package/picosat-0.1.1">picosat</a></li>
</ul>
<h2 id="smt-solvers">SMT Solvers</h2>
<p>A generalization of the SAT problem to include predicates other
theories gives rise to the very sophisticated domain of “Satisfiability
Modulo Theory” problems. The existing SMT solvers are very sophisticated
projects ( usually bankrolled by large institutions ) and usually have
to be called out to via foreign function interface or via a common
interface called SMT-lib. The two most common of use in Haskell are
<code>cvc4</code> from Stanford and <code>z3</code> from Microsoft
Research.</p>
<p>The SBV library can abstract over different SMT solvers to allow us
to express the problem in an embedded domain language in Haskell and
then offload the solving work to the third party library.</p>
<p>As an example, here’s how you can solve a simple <a
href="https://en.wikipedia.org/wiki/Verbal_arithmetic">cryptarithm</a></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: right;"><code>M</code> <code>O</code>
<code>N</code> <code>A</code> <code>D</code></td>
</tr>
<tr class="even">
<td style="text-align: right;">+ <code>B</code> <code>U</code>
<code>R</code> <code>R</code> <code>I</code> <code>T</code>
<code>O</code></td>
</tr>
<tr class="odd">
<td style="text-align: right;">= <code>B</code> <code>A</code>
<code>N</code> <code>D</code> <code>A</code> <code>I</code>
<code>D</code></td>
</tr>
</tbody>
</table>
<p>using SBV library:</p>
<div class="sourceCode" id="cb753"
data-include="src/19-numbers/puzzle.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb753-1"><a href="#cb753-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Foldable</span></span>
<span id="cb753-2"><a href="#cb753-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.SBV</span></span>
<span id="cb753-3"><a href="#cb753-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb753-4"><a href="#cb753-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- | val [4,2] == 42</span></span>
<span id="cb753-5"><a href="#cb753-5" aria-hidden="true" tabindex="-1"></a><span class="ot">val ::</span> [<span class="dt">SInteger</span>] <span class="ot">-&gt;</span> <span class="dt">SInteger</span></span>
<span id="cb753-6"><a href="#cb753-6" aria-hidden="true" tabindex="-1"></a>val <span class="ot">=</span> <span class="fu">foldr1</span> (\d r <span class="ot">-&gt;</span> d <span class="op">+</span> <span class="dv">10</span><span class="op">*</span>r) <span class="op">.</span> <span class="fu">reverse</span></span>
<span id="cb753-7"><a href="#cb753-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb753-8"><a href="#cb753-8" aria-hidden="true" tabindex="-1"></a><span class="ot">puzzle ::</span> <span class="dt">Symbolic</span> <span class="dt">SBool</span></span>
<span id="cb753-9"><a href="#cb753-9" aria-hidden="true" tabindex="-1"></a>puzzle <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb753-10"><a href="#cb753-10" aria-hidden="true" tabindex="-1"></a>  ds<span class="op">@</span>[b,u,r,i,t,o,m,n,a,d] <span class="ot">&lt;-</span> <span class="fu">sequenceA</span> [ sInteger [v] <span class="op">|</span> v <span class="ot">&lt;-</span> <span class="st">&quot;buritomnad&quot;</span> ]</span>
<span id="cb753-11"><a href="#cb753-11" aria-hidden="true" tabindex="-1"></a>  constrain <span class="op">$</span> distinct ds</span>
<span id="cb753-12"><a href="#cb753-12" aria-hidden="true" tabindex="-1"></a>  for_ ds <span class="op">$</span> \d <span class="ot">-&gt;</span> constrain <span class="op">$</span> <span class="fu">inRange</span> d (<span class="dv">0</span>,<span class="dv">9</span>)</span>
<span id="cb753-13"><a href="#cb753-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span>    val [b,u,r,r,i,t,o]</span>
<span id="cb753-14"><a href="#cb753-14" aria-hidden="true" tabindex="-1"></a>          <span class="op">+</span> val     [m,o,n,a,d]</span>
<span id="cb753-15"><a href="#cb753-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">.==</span> val [b,a,n,d,a,i,d]</span></code></pre></div>
<p>Let’s look at all possible solutions,</p>
<div class="sourceCode" id="cb754"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb754-1"><a href="#cb754-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> allSat puzzle</span>
<span id="cb754-2"><a href="#cb754-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Solution</span> <span class="op">#</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb754-3"><a href="#cb754-3" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">=</span> <span class="dv">4</span><span class="ot"> ::</span> <span class="dt">Integer</span></span>
<span id="cb754-4"><a href="#cb754-4" aria-hidden="true" tabindex="-1"></a>  u <span class="ot">=</span> <span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Integer</span></span>
<span id="cb754-5"><a href="#cb754-5" aria-hidden="true" tabindex="-1"></a>  r <span class="ot">=</span> <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Integer</span></span>
<span id="cb754-6"><a href="#cb754-6" aria-hidden="true" tabindex="-1"></a>  i <span class="ot">=</span> <span class="dv">9</span><span class="ot"> ::</span> <span class="dt">Integer</span></span>
<span id="cb754-7"><a href="#cb754-7" aria-hidden="true" tabindex="-1"></a>  t <span class="ot">=</span> <span class="dv">7</span><span class="ot"> ::</span> <span class="dt">Integer</span></span>
<span id="cb754-8"><a href="#cb754-8" aria-hidden="true" tabindex="-1"></a>  o <span class="ot">=</span> <span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Integer</span></span>
<span id="cb754-9"><a href="#cb754-9" aria-hidden="true" tabindex="-1"></a>  m <span class="ot">=</span> <span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Integer</span></span>
<span id="cb754-10"><a href="#cb754-10" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">=</span> <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Integer</span></span>
<span id="cb754-11"><a href="#cb754-11" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">=</span> <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Integer</span></span>
<span id="cb754-12"><a href="#cb754-12" aria-hidden="true" tabindex="-1"></a>  d <span class="ot">=</span> <span class="dv">6</span><span class="ot"> ::</span> <span class="dt">Integer</span></span>
<span id="cb754-13"><a href="#cb754-13" aria-hidden="true" tabindex="-1"></a><span class="dt">This</span> is the only solution<span class="op">.</span></span></code></pre></div>
<hr/>
<h1 id="data-structures">Data Structures</h1>
<h2 id="map">Map</h2>
<p>A map is an associative array mapping any instance of
<code>Ord</code> keys to values of any type.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Functionality</th>
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Initialization</td>
<td style="text-align: left;"><code>empty</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Size</td>
<td style="text-align: left;"><code>size</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Lookup</td>
<td style="text-align: left;"><code>lookup</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(log (<em>n</em>))</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Insertion</td>
<td style="text-align: left;"><code>insert</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(log (<em>n</em>))</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Traversal</td>
<td style="text-align: left;"><code>traverse</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(<em>n</em>)</span></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb755"
data-include="src/20-data-structures/map.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb755-1"><a href="#cb755-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb755-2"><a href="#cb755-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb755-3"><a href="#cb755-3" aria-hidden="true" tabindex="-1"></a><span class="ot">kv ::</span> <span class="dt">Map.Map</span> <span class="dt">Integer</span> <span class="dt">String</span></span>
<span id="cb755-4"><a href="#cb755-4" aria-hidden="true" tabindex="-1"></a>kv <span class="ot">=</span> Map.fromList [(<span class="dv">1</span>, <span class="st">&quot;a&quot;</span>), (<span class="dv">2</span>, <span class="st">&quot;b&quot;</span>)]</span>
<span id="cb755-5"><a href="#cb755-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb755-6"><a href="#cb755-6" aria-hidden="true" tabindex="-1"></a><span class="ot">lkup ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb755-7"><a href="#cb755-7" aria-hidden="true" tabindex="-1"></a>lkup key def <span class="ot">=</span></span>
<span id="cb755-8"><a href="#cb755-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> Map.lookup key kv <span class="kw">of</span></span>
<span id="cb755-9"><a href="#cb755-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> val <span class="ot">-&gt;</span> val</span>
<span id="cb755-10"><a href="#cb755-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> def</span></code></pre></div>
<h2 id="tree">Tree</h2>
<p>A tree is directed graph with a single root.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Functionality</th>
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Initialization</td>
<td style="text-align: left;"><code>empty</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Size</td>
<td style="text-align: left;"><code>size</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Lookup</td>
<td style="text-align: left;"><code>lookup</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(log (<em>n</em>))</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Insertion</td>
<td style="text-align: left;"><code>insert</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(log (<em>n</em>))</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Traversal</td>
<td style="text-align: left;"><code>traverse</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(<em>n</em>)</span></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb756"
data-include="src/20-data-structures/tree.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb756-1"><a href="#cb756-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Tree</span></span>
<span id="cb756-2"><a href="#cb756-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb756-3"><a href="#cb756-3" aria-hidden="true" tabindex="-1"></a><span class="co">{-</span></span>
<span id="cb756-4"><a href="#cb756-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb756-5"><a href="#cb756-5" aria-hidden="true" tabindex="-1"></a><span class="co">   A</span></span>
<span id="cb756-6"><a href="#cb756-6" aria-hidden="true" tabindex="-1"></a><span class="co">  / \</span></span>
<span id="cb756-7"><a href="#cb756-7" aria-hidden="true" tabindex="-1"></a><span class="co"> B   C</span></span>
<span id="cb756-8"><a href="#cb756-8" aria-hidden="true" tabindex="-1"></a><span class="co">    / \</span></span>
<span id="cb756-9"><a href="#cb756-9" aria-hidden="true" tabindex="-1"></a><span class="co">   D   E</span></span>
<span id="cb756-10"><a href="#cb756-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb756-11"><a href="#cb756-11" aria-hidden="true" tabindex="-1"></a><span class="co">-}</span></span>
<span id="cb756-12"><a href="#cb756-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb756-13"><a href="#cb756-13" aria-hidden="true" tabindex="-1"></a><span class="ot">tree ::</span> <span class="dt">Tree</span> <span class="dt">String</span></span>
<span id="cb756-14"><a href="#cb756-14" aria-hidden="true" tabindex="-1"></a>tree <span class="ot">=</span> <span class="dt">Node</span> <span class="st">&quot;A&quot;</span> [<span class="dt">Node</span> <span class="st">&quot;B&quot;</span> [], <span class="dt">Node</span> <span class="st">&quot;C&quot;</span> [<span class="dt">Node</span> <span class="st">&quot;D&quot;</span> [], <span class="dt">Node</span> <span class="st">&quot;E&quot;</span> []]]</span>
<span id="cb756-15"><a href="#cb756-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb756-16"><a href="#cb756-16" aria-hidden="true" tabindex="-1"></a><span class="ot">postorder ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb756-17"><a href="#cb756-17" aria-hidden="true" tabindex="-1"></a>postorder (<span class="dt">Node</span> a ts) <span class="ot">=</span> elts <span class="op">++</span> [a]</span>
<span id="cb756-18"><a href="#cb756-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> elts <span class="ot">=</span> <span class="fu">concat</span> (<span class="fu">map</span> postorder ts)</span>
<span id="cb756-19"><a href="#cb756-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb756-20"><a href="#cb756-20" aria-hidden="true" tabindex="-1"></a><span class="ot">preorder ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb756-21"><a href="#cb756-21" aria-hidden="true" tabindex="-1"></a>preorder (<span class="dt">Node</span> a ts) <span class="ot">=</span> a <span class="op">:</span> elts</span>
<span id="cb756-22"><a href="#cb756-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> elts <span class="ot">=</span> <span class="fu">concat</span> (<span class="fu">map</span> preorder ts)</span>
<span id="cb756-23"><a href="#cb756-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb756-24"><a href="#cb756-24" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> drawTree tree</span>
<span id="cb756-25"><a href="#cb756-25" aria-hidden="true" tabindex="-1"></a>ex2 <span class="ot">=</span> drawForest (subForest tree)</span>
<span id="cb756-26"><a href="#cb756-26" aria-hidden="true" tabindex="-1"></a>ex3 <span class="ot">=</span> flatten tree</span>
<span id="cb756-27"><a href="#cb756-27" aria-hidden="true" tabindex="-1"></a>ex4 <span class="ot">=</span> levels tree</span>
<span id="cb756-28"><a href="#cb756-28" aria-hidden="true" tabindex="-1"></a>ex5 <span class="ot">=</span> preorder tree</span>
<span id="cb756-29"><a href="#cb756-29" aria-hidden="true" tabindex="-1"></a>ex6 <span class="ot">=</span> postorder tree</span></code></pre></div>
<h2 id="set">Set</h2>
<p>Sets are unordered data structures containing <code>Ord</code> values
of any type and guaranteeing uniqueness with in the structure. They are
not identical to the mathematical notion of a Set even though they share
the same namesake.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Functionality</th>
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Initialization</td>
<td style="text-align: left;"><code>empty</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Size</td>
<td style="text-align: left;"><code>size</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Insertion</td>
<td style="text-align: left;"><code>insert</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(log (<em>n</em>))</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Deletion</td>
<td style="text-align: left;"><code>delete</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(log (<em>n</em>))</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Traversal</td>
<td style="text-align: left;"><code>traverse</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(<em>n</em>)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Membership Test</td>
<td style="text-align: left;"><code>member</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(log (<em>n</em>))</span></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb757"
data-include="src/20-data-structures/set.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb757-1"><a href="#cb757-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">Set</span></span>
<span id="cb757-2"><a href="#cb757-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb757-3"><a href="#cb757-3" aria-hidden="true" tabindex="-1"></a><span class="ot">set ::</span> <span class="dt">Set.Set</span> <span class="dt">Integer</span></span>
<span id="cb757-4"><a href="#cb757-4" aria-hidden="true" tabindex="-1"></a>set <span class="ot">=</span> Set.fromList [<span class="dv">1</span><span class="op">..</span><span class="dv">1000</span>]</span>
<span id="cb757-5"><a href="#cb757-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb757-6"><a href="#cb757-6" aria-hidden="true" tabindex="-1"></a><span class="ot">memtest ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb757-7"><a href="#cb757-7" aria-hidden="true" tabindex="-1"></a>memtest elt <span class="ot">=</span> Set.member elt set</span></code></pre></div>
<h2 id="vector">Vector</h2>
<p>Vectors are high performance single dimensional arrays that come come
in six variants, two for each of the following types of a mutable and an
immutable variant.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Functionality</th>
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Initialization</td>
<td style="text-align: left;"><code>empty</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Size</td>
<td style="text-align: left;"><code>length</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Indexing</td>
<td style="text-align: left;"><code>(!)</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Append</td>
<td style="text-align: left;"><code>append</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(<em>n</em>)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Traversal</td>
<td style="text-align: left;"><code>traverse</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(<em>n</em>)</span></td>
</tr>
</tbody>
</table>
<ul>
<li>Data.Vector</li>
<li>Data.Vector.Storable</li>
<li>Data.Vector.Unboxed</li>
</ul>
<p>The most notable feature of vectors is constant time memory access
with (<code>(!)</code>) as well as variety of efficient map, fold and
scan operations on top of a fusion framework that generates surprisingly
optimal code.</p>
<div class="sourceCode" id="cb758"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb758-1"><a href="#cb758-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</span>
<span id="cb758-2"><a href="#cb758-2" aria-hidden="true" tabindex="-1"></a><span class="ot">toList ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb758-3"><a href="#cb758-3" aria-hidden="true" tabindex="-1"></a><span class="ot">(!) ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a</span>
<span id="cb758-4"><a href="#cb758-4" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b</span>
<span id="cb758-5"><a href="#cb758-5" aria-hidden="true" tabindex="-1"></a><span class="fu">foldl</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b <span class="ot">-&gt;</span> a</span>
<span id="cb758-6"><a href="#cb758-6" aria-hidden="true" tabindex="-1"></a><span class="fu">scanl</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</span>
<span id="cb758-7"><a href="#cb758-7" aria-hidden="true" tabindex="-1"></a><span class="fu">zipWith</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> b <span class="ot">-&gt;</span> <span class="dt">Vector</span> c</span>
<span id="cb758-8"><a href="#cb758-8" aria-hidden="true" tabindex="-1"></a><span class="ot">iterateN ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Vector</span> a</span></code></pre></div>
<div class="sourceCode" id="cb759"
data-include="src/20-data-structures/vector.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb759-1"><a href="#cb759-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb759-2"><a href="#cb759-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb759-3"><a href="#cb759-3" aria-hidden="true" tabindex="-1"></a><span class="ot">norm ::</span>  <span class="dt">Vector</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></span>
<span id="cb759-4"><a href="#cb759-4" aria-hidden="true" tabindex="-1"></a>norm <span class="ot">=</span> <span class="fu">sqrt</span> <span class="op">.</span> V.sum <span class="op">.</span> V.map (\x <span class="ot">-&gt;</span> x<span class="op">*</span>x)</span>
<span id="cb759-5"><a href="#cb759-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb759-6"><a href="#cb759-6" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Double</span></span>
<span id="cb759-7"><a href="#cb759-7" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> norm <span class="op">$</span> V.iterateN <span class="dv">100000000</span> (<span class="op">+</span><span class="dv">1</span>) <span class="fl">0.0</span></span></code></pre></div>
<h2 id="mutable-vectors">Mutable Vectors</h2>
<p>Mutable vectors are variants of vectors which allow inplace
updates.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Functionality</th>
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Initialization</td>
<td style="text-align: left;"><code>empty</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Size</td>
<td style="text-align: left;"><code>length</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Indexing</td>
<td style="text-align: left;"><code>(!)</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Append</td>
<td style="text-align: left;"><code>append</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(<em>n</em>)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Traversal</td>
<td style="text-align: left;"><code>traverse</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(<em>n</em>)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Update</td>
<td style="text-align: left;"><code>modify</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Read</td>
<td style="text-align: left;"><code>read</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Write</td>
<td style="text-align: left;"><code>write</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb760"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb760-1"><a href="#cb760-1" aria-hidden="true" tabindex="-1"></a><span class="ot">freeze ::</span> <span class="dt">MVector</span> (<span class="dt">PrimState</span> m) a <span class="ot">-&gt;</span> m (<span class="dt">Vector</span> a)</span>
<span id="cb760-2"><a href="#cb760-2" aria-hidden="true" tabindex="-1"></a><span class="ot">thaw ::</span> <span class="dt">Vector</span> a <span class="ot">-&gt;</span> <span class="dt">MVector</span> (<span class="dt">PrimState</span> m) a</span></code></pre></div>
<p>Within the IO monad we can perform arbitrary read and writes on the
mutable vector with constant time reads and writes. When needed a static
Vector can be created to/from the <code>MVector</code> using the
freeze/thaw functions.</p>
<div class="sourceCode" id="cb761"
data-include="src/20-data-structures/vector_mutable.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb761-1"><a href="#cb761-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Prim</span></span>
<span id="cb761-2"><a href="#cb761-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb761-3"><a href="#cb761-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb761-4"><a href="#cb761-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Primitive</span></span>
<span id="cb761-5"><a href="#cb761-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb761-6"><a href="#cb761-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector.Unboxed</span> (freeze)</span>
<span id="cb761-7"><a href="#cb761-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector.Unboxed.Mutable</span></span>
<span id="cb761-8"><a href="#cb761-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector.Unboxed</span> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb761-9"><a href="#cb761-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb761-10"><a href="#cb761-10" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">PrimMonad</span> m <span class="ot">=&gt;</span> m (<span class="dt">V.Vector</span> <span class="dt">Int</span>)</span>
<span id="cb761-11"><a href="#cb761-11" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb761-12"><a href="#cb761-12" aria-hidden="true" tabindex="-1"></a>  v <span class="ot">&lt;-</span> new <span class="dv">10</span></span>
<span id="cb761-13"><a href="#cb761-13" aria-hidden="true" tabindex="-1"></a>  forM_ [<span class="dv">0</span><span class="op">..</span><span class="dv">9</span>] <span class="op">$</span> \i <span class="ot">-&gt;</span></span>
<span id="cb761-14"><a href="#cb761-14" aria-hidden="true" tabindex="-1"></a>     write v i (<span class="dv">2</span><span class="op">*</span>i)</span>
<span id="cb761-15"><a href="#cb761-15" aria-hidden="true" tabindex="-1"></a>  freeze v</span>
<span id="cb761-16"><a href="#cb761-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb761-17"><a href="#cb761-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- vector computation in IO</span></span>
<span id="cb761-18"><a href="#cb761-18" aria-hidden="true" tabindex="-1"></a><span class="ot">vecIO ::</span> <span class="dt">IO</span> (<span class="dt">V.Vector</span> <span class="dt">Int</span>)</span>
<span id="cb761-19"><a href="#cb761-19" aria-hidden="true" tabindex="-1"></a>vecIO <span class="ot">=</span> example</span>
<span id="cb761-20"><a href="#cb761-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb761-21"><a href="#cb761-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- vector computation in ST</span></span>
<span id="cb761-22"><a href="#cb761-22" aria-hidden="true" tabindex="-1"></a><span class="ot">vecST ::</span> <span class="dt">ST</span> s (<span class="dt">V.Vector</span> <span class="dt">Int</span>)</span>
<span id="cb761-23"><a href="#cb761-23" aria-hidden="true" tabindex="-1"></a>vecST <span class="ot">=</span> example</span>
<span id="cb761-24"><a href="#cb761-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb761-25"><a href="#cb761-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb761-26"><a href="#cb761-26" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb761-27"><a href="#cb761-27" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb761-28"><a href="#cb761-28" aria-hidden="true" tabindex="-1"></a>  vecIO <span class="op">&gt;&gt;=</span> <span class="fu">print</span></span>
<span id="cb761-29"><a href="#cb761-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> runST vecST</span></code></pre></div>
<p>The vector library itself normally does bounds checks on index
operations to protect against memory corruption. This can be enabled or
disabled on the library level by compiling with
<code>boundschecks</code> cabal flag.</p>
<h2 id="unordered-containers">Unordered Containers</h2>
<p>Both the <code>HashMap</code> and <code>HashSet</code> are purely
functional data structures that are drop in replacements for the
<code>containers</code> equivalents but with more efficient space and
time performance. Additionally all stored elements must have a
<code>Hashable</code> instance. These structures have different time
complexities for insertions and lookups.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Functionality</th>
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Initialization</td>
<td style="text-align: left;"><code>empty</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Size</td>
<td style="text-align: left;"><code>size</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Lookup</td>
<td style="text-align: left;"><code>lookup</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(log (<em>n</em>))</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Insertion</td>
<td style="text-align: left;"><code>insert</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(log (<em>n</em>))</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Traversal</td>
<td style="text-align: left;"><code>traverse</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(<em>n</em>)</span></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb762"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb762-1"><a href="#cb762-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fromList ::</span> (<span class="dt">Eq</span> k, <span class="dt">Hashable</span> k) <span class="ot">=&gt;</span> [(k, v)] <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v</span>
<span id="cb762-2"><a href="#cb762-2" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span><span class="ot"> ::</span> (<span class="dt">Eq</span> k, <span class="dt">Hashable</span> k) <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v <span class="ot">-&gt;</span> <span class="dt">Maybe</span> v</span>
<span id="cb762-3"><a href="#cb762-3" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> (<span class="dt">Eq</span> k, <span class="dt">Hashable</span> k) <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v <span class="ot">-&gt;</span> <span class="dt">HashMap</span> k v</span></code></pre></div>
<div class="sourceCode" id="cb763"
data-include="src/20-data-structures/unordered.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb763-1"><a href="#cb763-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashSet</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb763-2"><a href="#cb763-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashMap.Lazy</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb763-3"><a href="#cb763-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb763-4"><a href="#cb763-4" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">M.HashMap</span> <span class="dt">Int</span> <span class="dt">Char</span></span>
<span id="cb763-5"><a href="#cb763-5" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> M.fromList <span class="op">$</span> <span class="fu">zip</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>] [<span class="ch">&#39;a&#39;</span><span class="op">..</span>]</span>
<span id="cb763-6"><a href="#cb763-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb763-7"><a href="#cb763-7" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">S.HashSet</span> <span class="dt">Int</span></span>
<span id="cb763-8"><a href="#cb763-8" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> S.fromList [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]</span></code></pre></div>
<p>See: <a
href="http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html">Announcing
Unordered Containers</a></p>
<h2 id="hashtables">Hashtables</h2>
<p>Hashtables provides hashtables with efficient lookup within the ST or
IO monad. These have constant time lookup like most languages:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Functionality</th>
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Initialization</td>
<td style="text-align: left;"><code>empty</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Size</td>
<td style="text-align: left;"><code>size</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Lookup</td>
<td style="text-align: left;"><code>lookup</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Insertion</td>
<td style="text-align: left;"><code>insert</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span> amortized</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Traversal</td>
<td style="text-align: left;"><code>traverse</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(<em>n</em>)</span></td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb764"
data-include="src/20-data-structures/hashtables.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb764-1"><a href="#cb764-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (lookup)</span>
<span id="cb764-2"><a href="#cb764-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb764-3"><a href="#cb764-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.ST</span></span>
<span id="cb764-4"><a href="#cb764-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.HashTable.ST.Basic</span></span>
<span id="cb764-5"><a href="#cb764-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb764-6"><a href="#cb764-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Hashtable parameterized by ST &quot;thread&quot;</span></span>
<span id="cb764-7"><a href="#cb764-7" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">HT</span> s <span class="ot">=</span> <span class="dt">HashTable</span> s <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb764-8"><a href="#cb764-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb764-9"><a href="#cb764-9" aria-hidden="true" tabindex="-1"></a><span class="ot">set ::</span> <span class="dt">ST</span> s (<span class="dt">HT</span> s)</span>
<span id="cb764-10"><a href="#cb764-10" aria-hidden="true" tabindex="-1"></a>set <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb764-11"><a href="#cb764-11" aria-hidden="true" tabindex="-1"></a>  ht <span class="ot">&lt;-</span> new</span>
<span id="cb764-12"><a href="#cb764-12" aria-hidden="true" tabindex="-1"></a>  insert ht <span class="st">&quot;key&quot;</span> <span class="st">&quot;value1&quot;</span></span>
<span id="cb764-13"><a href="#cb764-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ht</span>
<span id="cb764-14"><a href="#cb764-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb764-15"><a href="#cb764-15" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">HT</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> <span class="dt">String</span>)</span>
<span id="cb764-16"><a href="#cb764-16" aria-hidden="true" tabindex="-1"></a>get ht <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb764-17"><a href="#cb764-17" aria-hidden="true" tabindex="-1"></a>  val <span class="ot">&lt;-</span> <span class="fu">lookup</span> ht <span class="st">&quot;key&quot;</span></span>
<span id="cb764-18"><a href="#cb764-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> val</span>
<span id="cb764-19"><a href="#cb764-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb764-20"><a href="#cb764-20" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">Maybe</span> <span class="dt">String</span></span>
<span id="cb764-21"><a href="#cb764-21" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> runST (set <span class="op">&gt;&gt;=</span> get)</span></code></pre></div>
<div class="sourceCode" id="cb765"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb765-1"><a href="#cb765-1" aria-hidden="true" tabindex="-1"></a><span class="ot">new ::</span> <span class="dt">ST</span> s (<span class="dt">HashTable</span> s k v)</span>
<span id="cb765-2"><a href="#cb765-2" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> (<span class="dt">Eq</span> k, <span class="dt">Hashable</span> k) <span class="ot">=&gt;</span> <span class="dt">HashTable</span> s k v <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()</span>
<span id="cb765-3"><a href="#cb765-3" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span><span class="ot"> ::</span> (<span class="dt">Eq</span> k, <span class="dt">Hashable</span> k) <span class="ot">=&gt;</span> <span class="dt">HashTable</span> s k v <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Maybe</span> v)</span></code></pre></div>
<h2 id="graphs">Graphs</h2>
<p>The Graph module in the containers library is a somewhat antiquated
API for working with directed graphs. A little bit of data wrapping
makes it a little more straightforward to use. The library is not
necessarily well-suited for large graph-theoretic operations but is
perfectly fine for example, to use in a typechecker which needs to
resolve strongly connected components of the module definition
graph.</p>
<div class="sourceCode" id="cb766"
data-include="src/20-data-structures/graph.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb766-1"><a href="#cb766-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Tree</span></span>
<span id="cb766-2"><a href="#cb766-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Graph</span></span>
<span id="cb766-3"><a href="#cb766-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb766-4"><a href="#cb766-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Grph</span> node key <span class="ot">=</span> <span class="dt">Grph</span></span>
<span id="cb766-5"><a href="#cb766-5" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> _graph ::</span> <span class="dt">Graph</span></span>
<span id="cb766-6"><a href="#cb766-6" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _vertices ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> (node, key, [key])</span>
<span id="cb766-7"><a href="#cb766-7" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb766-8"><a href="#cb766-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb766-9"><a href="#cb766-9" aria-hidden="true" tabindex="-1"></a><span class="ot">fromList ::</span> <span class="dt">Ord</span> key <span class="ot">=&gt;</span> [(node, key, [key])] <span class="ot">-&gt;</span> <span class="dt">Grph</span> node key</span>
<span id="cb766-10"><a href="#cb766-10" aria-hidden="true" tabindex="-1"></a>fromList <span class="ot">=</span> <span class="fu">uncurry</span> <span class="dt">Grph</span> <span class="op">.</span> graphFromEdges&#39;</span>
<span id="cb766-11"><a href="#cb766-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb766-12"><a href="#cb766-12" aria-hidden="true" tabindex="-1"></a><span class="ot">vertexLabels ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Grph</span> b t <span class="ot">-&gt;</span> (f <span class="dt">Vertex</span>) <span class="ot">-&gt;</span> f b</span>
<span id="cb766-13"><a href="#cb766-13" aria-hidden="true" tabindex="-1"></a>vertexLabels g <span class="ot">=</span> <span class="fu">fmap</span> (vertexLabel g)</span>
<span id="cb766-14"><a href="#cb766-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb766-15"><a href="#cb766-15" aria-hidden="true" tabindex="-1"></a><span class="ot">vertexLabel ::</span> <span class="dt">Grph</span> b t <span class="ot">-&gt;</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> b</span>
<span id="cb766-16"><a href="#cb766-16" aria-hidden="true" tabindex="-1"></a>vertexLabel g <span class="ot">=</span> (\(vi, _, _) <span class="ot">-&gt;</span> vi) <span class="op">.</span> (_vertices g)</span>
<span id="cb766-17"><a href="#cb766-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb766-18"><a href="#cb766-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- Topologically sort graph</span></span>
<span id="cb766-19"><a href="#cb766-19" aria-hidden="true" tabindex="-1"></a><span class="ot">topo&#39; ::</span> <span class="dt">Grph</span> node key <span class="ot">-&gt;</span> [node]</span>
<span id="cb766-20"><a href="#cb766-20" aria-hidden="true" tabindex="-1"></a>topo&#39; g <span class="ot">=</span> vertexLabels g <span class="op">$</span> topSort (_graph g)</span>
<span id="cb766-21"><a href="#cb766-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb766-22"><a href="#cb766-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- Strongly connected components of graph</span></span>
<span id="cb766-23"><a href="#cb766-23" aria-hidden="true" tabindex="-1"></a><span class="ot">scc&#39; ::</span> <span class="dt">Grph</span> node key <span class="ot">-&gt;</span> [[node]]</span>
<span id="cb766-24"><a href="#cb766-24" aria-hidden="true" tabindex="-1"></a>scc&#39; g <span class="ot">=</span> <span class="fu">fmap</span> (vertexLabels g <span class="op">.</span> flatten) <span class="op">$</span> scc (_graph g)</span></code></pre></div>
<p>So for example we can construct a simple graph:</p>
<p><img src="img/graph1.png" width="100" /></p>
<div class="sourceCode" id="cb767"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb767-1"><a href="#cb767-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ex1 ::</span> [(<span class="dt">String</span>, <span class="dt">String</span>, [<span class="dt">String</span>])]</span>
<span id="cb767-2"><a href="#cb767-2" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> [</span>
<span id="cb767-3"><a href="#cb767-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;a&quot;</span>,<span class="st">&quot;a&quot;</span>,[<span class="st">&quot;b&quot;</span>]),</span>
<span id="cb767-4"><a href="#cb767-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;b&quot;</span>,<span class="st">&quot;b&quot;</span>,[<span class="st">&quot;c&quot;</span>]),</span>
<span id="cb767-5"><a href="#cb767-5" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;c&quot;</span>,<span class="st">&quot;c&quot;</span>,[<span class="st">&quot;a&quot;</span>])</span>
<span id="cb767-6"><a href="#cb767-6" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb767-7"><a href="#cb767-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb767-8"><a href="#cb767-8" aria-hidden="true" tabindex="-1"></a><span class="ot">ts1 ::</span> [<span class="dt">String</span>]</span>
<span id="cb767-9"><a href="#cb767-9" aria-hidden="true" tabindex="-1"></a>ts1 <span class="ot">=</span> topo&#39; (fromList ex1)</span>
<span id="cb767-10"><a href="#cb767-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span>
<span id="cb767-11"><a href="#cb767-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb767-12"><a href="#cb767-12" aria-hidden="true" tabindex="-1"></a><span class="ot">sc1 ::</span> [[<span class="dt">String</span>]]</span>
<span id="cb767-13"><a href="#cb767-13" aria-hidden="true" tabindex="-1"></a>sc1 <span class="ot">=</span> scc&#39; (fromList ex1)</span>
<span id="cb767-14"><a href="#cb767-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- [[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]]</span></span></code></pre></div>
<p>Or with two strongly connected subgraphs:</p>
<p><img src="img/graph2.png" width="250" /></p>
<div class="sourceCode" id="cb768"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb768-1"><a href="#cb768-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ex2 ::</span> [(<span class="dt">String</span>, <span class="dt">String</span>, [<span class="dt">String</span>])]</span>
<span id="cb768-2"><a href="#cb768-2" aria-hidden="true" tabindex="-1"></a>ex2 <span class="ot">=</span> [</span>
<span id="cb768-3"><a href="#cb768-3" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;a&quot;</span>,<span class="st">&quot;a&quot;</span>,[<span class="st">&quot;b&quot;</span>]),</span>
<span id="cb768-4"><a href="#cb768-4" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;b&quot;</span>,<span class="st">&quot;b&quot;</span>,[<span class="st">&quot;c&quot;</span>]),</span>
<span id="cb768-5"><a href="#cb768-5" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;c&quot;</span>,<span class="st">&quot;c&quot;</span>,[<span class="st">&quot;a&quot;</span>]),</span>
<span id="cb768-6"><a href="#cb768-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb768-7"><a href="#cb768-7" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;d&quot;</span>,<span class="st">&quot;d&quot;</span>,[<span class="st">&quot;e&quot;</span>]),</span>
<span id="cb768-8"><a href="#cb768-8" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;e&quot;</span>,<span class="st">&quot;e&quot;</span>,[<span class="st">&quot;f&quot;</span>, <span class="st">&quot;e&quot;</span>]),</span>
<span id="cb768-9"><a href="#cb768-9" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;f&quot;</span>,<span class="st">&quot;f&quot;</span>,[<span class="st">&quot;d&quot;</span>, <span class="st">&quot;e&quot;</span>])</span>
<span id="cb768-10"><a href="#cb768-10" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb768-11"><a href="#cb768-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb768-12"><a href="#cb768-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb768-13"><a href="#cb768-13" aria-hidden="true" tabindex="-1"></a><span class="ot">ts2 ::</span> [<span class="dt">String</span>]</span>
<span id="cb768-14"><a href="#cb768-14" aria-hidden="true" tabindex="-1"></a>ts2 <span class="ot">=</span> topo&#39; (fromList ex2)</span>
<span id="cb768-15"><a href="#cb768-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- [&quot;d&quot;,&quot;e&quot;,&quot;f&quot;,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span></span>
<span id="cb768-16"><a href="#cb768-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb768-17"><a href="#cb768-17" aria-hidden="true" tabindex="-1"></a><span class="ot">sc2 ::</span> [[<span class="dt">String</span>]]</span>
<span id="cb768-18"><a href="#cb768-18" aria-hidden="true" tabindex="-1"></a>sc2 <span class="ot">=</span> scc&#39; (fromList ex2)</span>
<span id="cb768-19"><a href="#cb768-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- [[&quot;d&quot;,&quot;e&quot;,&quot;f&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]]</span></span></code></pre></div>
<p>See: <a
href="http://hackage.haskell.org/package/GraphSCC">GraphSCC</a></p>
<h2 id="graph-theory">Graph Theory</h2>
<p>The <code>fgl</code> library provides a more efficient graph
structure and a wide variety of common graph-theoretic operations. For
example calculating the dominance frontier of a graph shows up quite
frequently in control flow analysis for compiler design.</p>
<div class="sourceCode" id="cb769"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb769-1"><a href="#cb769-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Graph.Inductive</span> <span class="kw">as</span> <span class="dt">G</span></span>
<span id="cb769-2"><a href="#cb769-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb769-3"><a href="#cb769-3" aria-hidden="true" tabindex="-1"></a><span class="ot">cyc3 ::</span> <span class="dt">G.Gr</span> <span class="dt">Char</span> <span class="dt">String</span></span>
<span id="cb769-4"><a href="#cb769-4" aria-hidden="true" tabindex="-1"></a>cyc3 <span class="ot">=</span> G.buildGr</span>
<span id="cb769-5"><a href="#cb769-5" aria-hidden="true" tabindex="-1"></a>       [([(<span class="st">&quot;ca&quot;</span>,<span class="dv">3</span>)],<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>,[(<span class="st">&quot;ab&quot;</span>,<span class="dv">2</span>)]),</span>
<span id="cb769-6"><a href="#cb769-6" aria-hidden="true" tabindex="-1"></a>                ([],<span class="dv">2</span>,<span class="ch">&#39;b&#39;</span>,[(<span class="st">&quot;bc&quot;</span>,<span class="dv">3</span>)]),</span>
<span id="cb769-7"><a href="#cb769-7" aria-hidden="true" tabindex="-1"></a>                ([],<span class="dv">3</span>,<span class="ch">&#39;c&#39;</span>,[])]</span>
<span id="cb769-8"><a href="#cb769-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb769-9"><a href="#cb769-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Loop query</span></span>
<span id="cb769-10"><a href="#cb769-10" aria-hidden="true" tabindex="-1"></a><span class="ot">ex1 ::</span> <span class="dt">Bool</span></span>
<span id="cb769-11"><a href="#cb769-11" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> G.hasLoop x</span>
<span id="cb769-12"><a href="#cb769-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb769-13"><a href="#cb769-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- Dominators</span></span>
<span id="cb769-14"><a href="#cb769-14" aria-hidden="true" tabindex="-1"></a><span class="ot">ex2 ::</span> [(<span class="dt">G.Node</span>, [<span class="dt">G.Node</span>])]</span>
<span id="cb769-15"><a href="#cb769-15" aria-hidden="true" tabindex="-1"></a>ex2 <span class="ot">=</span> G.dom x <span class="dv">0</span></span></code></pre></div>
<div class="sourceCode" id="cb770"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb770-1"><a href="#cb770-1" aria-hidden="true" tabindex="-1"></a><span class="ot">x ::</span> <span class="dt">G.Gr</span> <span class="dt">Int</span> ()</span>
<span id="cb770-2"><a href="#cb770-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> G.insEdges edges gr</span>
<span id="cb770-3"><a href="#cb770-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb770-4"><a href="#cb770-4" aria-hidden="true" tabindex="-1"></a>  gr <span class="ot">=</span> G.insNodes nodes G.empty</span>
<span id="cb770-5"><a href="#cb770-5" aria-hidden="true" tabindex="-1"></a>  edges <span class="ot">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>,()), (<span class="dv">0</span>,<span class="dv">2</span>,()), (<span class="dv">2</span>,<span class="dv">1</span>,()), (<span class="dv">2</span>,<span class="dv">3</span>,())]</span>
<span id="cb770-6"><a href="#cb770-6" aria-hidden="true" tabindex="-1"></a>  nodes <span class="ot">=</span> <span class="fu">zip</span> [<span class="dv">0</span>,<span class="dv">1</span> <span class="op">..</span>] [<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">1</span>]</span></code></pre></div>
<p><img src="img/graphviz.png" width="100" /></p>
<h2 id="dlist">DList</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Functionality</th>
<th style="text-align: left;">Function</th>
<th style="text-align: left;">Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Initialization</td>
<td style="text-align: left;"><code>empty</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Size</td>
<td style="text-align: left;"><code>size</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Lookup</td>
<td style="text-align: left;"><code>lookup</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(log (<em>n</em>))</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Insertion</td>
<td style="text-align: left;"><code>insert</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(log (<em>n</em>))</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Traversal</td>
<td style="text-align: left;"><code>traverse</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(<em>n</em>)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Append</td>
<td style="text-align: left;"><code>(|&gt;)</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Prepend</td>
<td style="text-align: left;"><code>(&lt;|)</code></td>
<td style="text-align: left;"><span
class="math inline"><em>O</em>(1)</span></td>
</tr>
</tbody>
</table>
<p>A dlist is a list-like structure that is optimized for O(1) append
operations, internally it uses a Church encoding of the list structure.
It is specifically suited for operations which are append-only and need
only access it when manifesting the entire structure. It is particularly
well-suited for use in the Writer monad.</p>
<div class="sourceCode" id="cb771"
data-include="src/20-data-structures/dlist.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb771-1"><a href="#cb771-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.DList</span></span>
<span id="cb771-2"><a href="#cb771-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb771-3"><a href="#cb771-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Writer</span></span>
<span id="cb771-4"><a href="#cb771-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb771-5"><a href="#cb771-5" aria-hidden="true" tabindex="-1"></a><span class="ot">logger ::</span> <span class="dt">Writer</span> (<span class="dt">DList</span> <span class="dt">Int</span>) ()</span>
<span id="cb771-6"><a href="#cb771-6" aria-hidden="true" tabindex="-1"></a>logger <span class="ot">=</span> replicateM_ <span class="dv">100000</span> <span class="op">$</span> tell (singleton <span class="dv">0</span>)</span></code></pre></div>
<h2 id="sequence">Sequence</h2>
<p>The sequence data structure behaves structurally similar to list but
is optimized for append/prepend operations and traversal.</p>
<div class="sourceCode" id="cb772"
data-include="src/20-data-structures/sequence.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb772-1"><a href="#cb772-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Sequence</span></span>
<span id="cb772-2"><a href="#cb772-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb772-3"><a href="#cb772-3" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Seq</span> <span class="dt">Int</span></span>
<span id="cb772-4"><a href="#cb772-4" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> fromList [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</span>
<span id="cb772-5"><a href="#cb772-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb772-6"><a href="#cb772-6" aria-hidden="true" tabindex="-1"></a><span class="ot">a0 ::</span> <span class="dt">Seq</span> <span class="dt">Int</span></span>
<span id="cb772-7"><a href="#cb772-7" aria-hidden="true" tabindex="-1"></a>a0 <span class="ot">=</span> a <span class="op">|&gt;</span> <span class="dv">4</span></span>
<span id="cb772-8"><a href="#cb772-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- [1,2,3,4]</span></span>
<span id="cb772-9"><a href="#cb772-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb772-10"><a href="#cb772-10" aria-hidden="true" tabindex="-1"></a><span class="ot">a1 ::</span> <span class="dt">Seq</span> <span class="dt">Int</span></span>
<span id="cb772-11"><a href="#cb772-11" aria-hidden="true" tabindex="-1"></a>a1 <span class="ot">=</span> <span class="dv">0</span> <span class="op">&lt;|</span> a</span>
<span id="cb772-12"><a href="#cb772-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- [0,1,2,3]</span></span></code></pre></div>
<h1 id="ffi">FFI</h1>
<p>Haskell does not exist in a vacuum and will quite often need to
interact with or offload computation to another programming language.
Since GHC itself is built on the GCC ecosystem interfacing with
libraries that can be linked via a C ABI is quite natural. Indeed many
high performance libraries will call out to Fortran, C, or C++ code to
perform numerical computations that can be linked seamlessly into the
Haskell runtime. There are several approaches to combining Haskell with
other languages in the via the <em>Foreign Function Interface</em> or
FFI.</p>
<h2 id="pure-functions">Pure Functions</h2>
<p>Wrapping pure C functions with primitive types is trivial.</p>
<div class="sourceCode" id="cb773"
data-include="src/21-ffi/simple.c"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb773-1"><a href="#cb773-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* $(CC) -c simple.c -o simple.o */</span></span>
<span id="cb773-2"><a href="#cb773-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb773-3"><a href="#cb773-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> example<span class="op">(</span><span class="dt">int</span> a<span class="op">,</span> <span class="dt">int</span> b<span class="op">)</span></span>
<span id="cb773-4"><a href="#cb773-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb773-5"><a href="#cb773-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb773-6"><a href="#cb773-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb774"
data-include="src/21-ffi/simple_ffi.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb774-1"><a href="#cb774-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ghc simple.o simple_ffi.hs -o simple_ffi</span></span>
<span id="cb774-2"><a href="#cb774-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ForeignFunctionInterface #-}</span></span>
<span id="cb774-3"><a href="#cb774-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb774-4"><a href="#cb774-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Foreign.C.Types</span></span>
<span id="cb774-5"><a href="#cb774-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb774-6"><a href="#cb774-6" aria-hidden="true" tabindex="-1"></a>foreign <span class="kw">import</span> ccall safe &quot;example&quot; example</span>
<span id="cb774-7"><a href="#cb774-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span></span>
<span id="cb774-8"><a href="#cb774-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb774-9"><a href="#cb774-9" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (example <span class="dv">42</span> <span class="dv">27</span>)</span></code></pre></div>
<h2 id="storable-arrays">Storable Arrays</h2>
<p>There exists a <code>Storable</code> typeclass that can be used to
provide low-level access to the memory underlying Haskell values.
<code>Ptr</code> objects in Haskell behave much like C pointers although
arithmetic with them is in terms of bytes only, not the size of the type
associated with the pointer ( this differs from C).</p>
<p>The Prelude defines Storable interfaces for most of the basic types
as well as types in the <code>Foreign.Storable</code> module.</p>
<div class="sourceCode" id="cb775"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb775-1"><a href="#cb775-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Storable</span> a <span class="kw">where</span></span>
<span id="cb775-2"><a href="#cb775-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  sizeOf ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb775-3"><a href="#cb775-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  alignment ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb775-4"><a href="#cb775-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  peek ::</span> <span class="dt">Ptr</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb775-5"><a href="#cb775-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  poke ::</span> <span class="dt">Ptr</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>To pass arrays from Haskell to C we can again use Storable Vector and
several unsafe operations to grab a foreign pointer to the underlying
data that can be handed off to C. Once we’re in C land, nothing will
protect us from doing evil things to memory!</p>
<div class="sourceCode" id="cb776"
data-include="src/21-ffi/qsort.c"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb776-1"><a href="#cb776-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* $(CC) -c qsort.c -o qsort.o */</span></span>
<span id="cb776-2"><a href="#cb776-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> swap<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>a<span class="op">,</span> <span class="dt">int</span> <span class="op">*</span>b<span class="op">)</span></span>
<span id="cb776-3"><a href="#cb776-3" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb776-4"><a href="#cb776-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> t <span class="op">=</span> <span class="op">*</span>a<span class="op">;</span></span>
<span id="cb776-5"><a href="#cb776-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>a <span class="op">=</span> <span class="op">*</span>b<span class="op">;</span></span>
<span id="cb776-6"><a href="#cb776-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>b <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb776-7"><a href="#cb776-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb776-8"><a href="#cb776-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb776-9"><a href="#cb776-9" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> sort<span class="op">(</span><span class="dt">int</span> <span class="op">*</span>xs<span class="op">,</span> <span class="dt">int</span> beg<span class="op">,</span> <span class="dt">int</span> end<span class="op">)</span></span>
<span id="cb776-10"><a href="#cb776-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb776-11"><a href="#cb776-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>end <span class="op">&gt;</span> beg <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb776-12"><a href="#cb776-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> piv <span class="op">=</span> xs<span class="op">[</span>beg<span class="op">],</span> l <span class="op">=</span> beg <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> r <span class="op">=</span> end<span class="op">;</span></span>
<span id="cb776-13"><a href="#cb776-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb776-14"><a href="#cb776-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>l <span class="op">&lt;</span> r<span class="op">)</span> <span class="op">{</span></span>
<span id="cb776-15"><a href="#cb776-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>xs<span class="op">[</span>l<span class="op">]</span> <span class="op">&lt;=</span> piv<span class="op">)</span> <span class="op">{</span></span>
<span id="cb776-16"><a href="#cb776-16" aria-hidden="true" tabindex="-1"></a>                l<span class="op">++;</span></span>
<span id="cb776-17"><a href="#cb776-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb776-18"><a href="#cb776-18" aria-hidden="true" tabindex="-1"></a>                swap<span class="op">(&amp;</span>xs<span class="op">[</span>l<span class="op">],</span> <span class="op">&amp;</span>xs<span class="op">[--</span>r<span class="op">]);</span></span>
<span id="cb776-19"><a href="#cb776-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb776-20"><a href="#cb776-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb776-21"><a href="#cb776-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb776-22"><a href="#cb776-22" aria-hidden="true" tabindex="-1"></a>        swap<span class="op">(&amp;</span>xs<span class="op">[--</span>l<span class="op">],</span> <span class="op">&amp;</span>xs<span class="op">[</span>beg<span class="op">]);</span></span>
<span id="cb776-23"><a href="#cb776-23" aria-hidden="true" tabindex="-1"></a>        sort<span class="op">(</span>xs<span class="op">,</span> beg<span class="op">,</span> l<span class="op">);</span></span>
<span id="cb776-24"><a href="#cb776-24" aria-hidden="true" tabindex="-1"></a>        sort<span class="op">(</span>xs<span class="op">,</span> r<span class="op">,</span> end<span class="op">);</span></span>
<span id="cb776-25"><a href="#cb776-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb776-26"><a href="#cb776-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb777" data-include="src/21-ffi/ffi.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb777-1"><a href="#cb777-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ghc qsort.o ffi.hs -o ffi</span></span>
<span id="cb777-2"><a href="#cb777-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ForeignFunctionInterface #-}</span></span>
<span id="cb777-3"><a href="#cb777-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb777-4"><a href="#cb777-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Foreign.Ptr</span></span>
<span id="cb777-5"><a href="#cb777-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Foreign.C.Types</span></span>
<span id="cb777-6"><a href="#cb777-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb777-7"><a href="#cb777-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector.Storable</span> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb777-8"><a href="#cb777-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector.Storable.Mutable</span> <span class="kw">as</span> <span class="dt">VM</span></span>
<span id="cb777-9"><a href="#cb777-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb777-10"><a href="#cb777-10" aria-hidden="true" tabindex="-1"></a>foreign <span class="kw">import</span> ccall safe &quot;sort&quot; qsort</span>
<span id="cb777-11"><a href="#cb777-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Ptr</span> a <span class="ot">-&gt;</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb777-12"><a href="#cb777-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb777-13"><a href="#cb777-13" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb777-14"><a href="#cb777-14" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb777-15"><a href="#cb777-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> vs <span class="ot">=</span> V.fromList ([<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">9</span>,<span class="dv">6</span>]<span class="ot"> ::</span> [<span class="dt">CInt</span>])</span>
<span id="cb777-16"><a href="#cb777-16" aria-hidden="true" tabindex="-1"></a>  v <span class="ot">&lt;-</span> V.thaw vs</span>
<span id="cb777-17"><a href="#cb777-17" aria-hidden="true" tabindex="-1"></a>  VM.unsafeWith v <span class="op">$</span> \ptr <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb777-18"><a href="#cb777-18" aria-hidden="true" tabindex="-1"></a>    qsort ptr <span class="dv">0</span> <span class="dv">9</span></span>
<span id="cb777-19"><a href="#cb777-19" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> V.freeze v</span>
<span id="cb777-20"><a href="#cb777-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> out</span></code></pre></div>
<p>The names of foreign functions from a C specific header file can be
qualified.</p>
<div class="sourceCode" id="cb778"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb778-1"><a href="#cb778-1" aria-hidden="true" tabindex="-1"></a>foreign <span class="kw">import</span> ccall unsafe &quot;stdlib.h malloc&quot;</span>
<span id="cb778-2"><a href="#cb778-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    malloc ::</span> <span class="dt">CSize</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Ptr</span> a)</span></code></pre></div>
<p>Prepending the function name with a <code>&amp;</code> allows us to
create a reference to the function pointer itself.</p>
<div class="sourceCode" id="cb779"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb779-1"><a href="#cb779-1" aria-hidden="true" tabindex="-1"></a>foreign <span class="kw">import</span> ccall unsafe &quot;stdlib.h &amp;malloc&quot;</span>
<span id="cb779-2"><a href="#cb779-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    malloc ::</span> <span class="dt">FunPtr</span> a</span></code></pre></div>
<h2 id="function-pointers">Function Pointers</h2>
<p>Using the above FFI functionality, it’s trivial to pass C function
pointers into Haskell, but what about the inverse passing a function
pointer to a Haskell function into C using
<code>foreign import ccall "wrapper"</code>.</p>
<div class="sourceCode" id="cb780"
data-include="src/21-ffi/pointer.c"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb780-1"><a href="#cb780-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb780-2"><a href="#cb780-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb780-3"><a href="#cb780-3" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> invoke<span class="op">(</span><span class="dt">void</span> <span class="op">(*</span>fn<span class="op">)(</span><span class="dt">int</span><span class="op">))</span></span>
<span id="cb780-4"><a href="#cb780-4" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb780-5"><a href="#cb780-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> n <span class="op">=</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb780-6"><a href="#cb780-6" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;Inside of C, now we&#39;ll call Haskell.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb780-7"><a href="#cb780-7" aria-hidden="true" tabindex="-1"></a>  fn<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb780-8"><a href="#cb780-8" aria-hidden="true" tabindex="-1"></a>  printf<span class="op">(</span><span class="st">&quot;Back inside of C again.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb780-9"><a href="#cb780-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb781"
data-include="src/21-ffi/pointer_use.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb781-1"><a href="#cb781-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ForeignFunctionInterface #-}</span></span>
<span id="cb781-2"><a href="#cb781-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb781-3"><a href="#cb781-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Foreign</span></span>
<span id="cb781-4"><a href="#cb781-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span></span>
<span id="cb781-5"><a href="#cb781-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Foreign.C.Types</span>(<span class="dt">CInt</span>(..))</span>
<span id="cb781-6"><a href="#cb781-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb781-7"><a href="#cb781-7" aria-hidden="true" tabindex="-1"></a>foreign <span class="kw">import</span> ccall &quot;wrapper&quot;</span>
<span id="cb781-8"><a href="#cb781-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  makeFunPtr ::</span> (<span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">FunPtr</span> (<span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()))</span>
<span id="cb781-9"><a href="#cb781-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb781-10"><a href="#cb781-10" aria-hidden="true" tabindex="-1"></a>foreign <span class="kw">import</span> ccall &quot;pointer.c invoke&quot;</span>
<span id="cb781-11"><a href="#cb781-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  invoke ::</span> <span class="dt">FunPtr</span> (<span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb781-12"><a href="#cb781-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb781-13"><a href="#cb781-13" aria-hidden="true" tabindex="-1"></a><span class="ot">fn ::</span> <span class="dt">CInt</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb781-14"><a href="#cb781-14" aria-hidden="true" tabindex="-1"></a>fn n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb781-15"><a href="#cb781-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Hello from Haskell, here&#39;s a number passed between runtimes:&quot;</span></span>
<span id="cb781-16"><a href="#cb781-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> n</span>
<span id="cb781-17"><a href="#cb781-17" aria-hidden="true" tabindex="-1"></a>  hFlush stdout</span>
<span id="cb781-18"><a href="#cb781-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb781-19"><a href="#cb781-19" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb781-20"><a href="#cb781-20" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb781-21"><a href="#cb781-21" aria-hidden="true" tabindex="-1"></a>  fptr <span class="ot">&lt;-</span> makeFunPtr fn</span>
<span id="cb781-22"><a href="#cb781-22" aria-hidden="true" tabindex="-1"></a>  invoke fptr</span></code></pre></div>
<p>Will yield the following output:</p>
<div class="sourceCode" id="cb782"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb782-1"><a href="#cb782-1" aria-hidden="true" tabindex="-1"></a><span class="ex">Inside</span> of C, now we<span class="st">&#39;ll call Haskell</span></span>
<span id="cb782-2"><a href="#cb782-2" aria-hidden="true" tabindex="-1"></a><span class="st">Hello from Haskell, here&#39;</span>s a number passed between runtimes:</span>
<span id="cb782-3"><a href="#cb782-3" aria-hidden="true" tabindex="-1"></a><span class="ex">42</span></span>
<span id="cb782-4"><a href="#cb782-4" aria-hidden="true" tabindex="-1"></a><span class="ex">Back</span> inside of C again.</span></code></pre></div>
<h2 id="hsc2hs">hsc2hs</h2>
<p>When doing socket level programming, when handling UDP packets there
is a packed C struct with a set of fields defined by the Linux kernel.
These fields are defined in the following C pseudocode.</p>
<div class="sourceCode" id="cb783"
data-include="src/21-ffi/mini-hsc/msghdr.c"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb783-1"><a href="#cb783-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> msghdr <span class="op">{</span></span>
<span id="cb783-2"><a href="#cb783-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span>         <span class="op">*</span>msg_name<span class="op">;</span>        <span class="co">/* protocol address */</span></span>
<span id="cb783-3"><a href="#cb783-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">socklen_t</span>     msg_namelen<span class="op">;</span>     <span class="co">/* size of protocol address */</span></span>
<span id="cb783-4"><a href="#cb783-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">struct</span> iovec <span class="op">*</span>msg_iov<span class="op">;</span>         <span class="co">/* scatter/gather array */</span></span>
<span id="cb783-5"><a href="#cb783-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>           msg_iovlen<span class="op">;</span>      <span class="co">/* # elements in msg_iov */</span></span>
<span id="cb783-6"><a href="#cb783-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">void</span>         <span class="op">*</span>msg_control<span class="op">;</span>     <span class="co">/* ancillary data (cmsghdr struct) */</span></span>
<span id="cb783-7"><a href="#cb783-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">socklen_t</span>     msg_controllen<span class="op">;</span>  <span class="co">/* length of ancillary data */</span></span>
<span id="cb783-8"><a href="#cb783-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span>           msg_flags<span class="op">;</span>       <span class="co">/* flags returned by recvmsg() */</span></span>
<span id="cb783-9"><a href="#cb783-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>If we want to marshall packets to and from Haskell datatypes we need
to be able to be able to take a pointer to memory holding the packet
message header and scan the memory into native Haskell types. This
involves knowing some information about the memory offsets for the
packet structure. GHC ships with a tool known as <code>hsc2hs</code>
which can be used to read information from C header files to
automatically generate the boilerplate instances of
<code>Storable</code> to perform this marshalling. The
<code>hsc2hs</code> library acts a preprocessor over <code>.hsc</code>
files and can fill in information as specific by several macros to
generate Haskell source.</p>
<div class="sourceCode" id="cb784"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb784-1"><a href="#cb784-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include &lt;file.h&gt;</span></span>
<span id="cb784-2"><a href="#cb784-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#const &lt;C_expression&gt;</span></span>
<span id="cb784-3"><a href="#cb784-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#peek &lt;struct_type&gt;, &lt;field&gt;</span></span>
<span id="cb784-4"><a href="#cb784-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#poke &lt;struct_type&gt;, &lt;field&gt;</span></span></code></pre></div>
<p>For example the following module from the <code>network</code>
library must introspect the <code>msghdr</code> struct from
<code>&lt;sys/socket.h&gt;</code>.</p>
<div class="sourceCode" id="cb785"
data-include="src/21-ffi/mini-hsc/Example.hsc"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb785-1"><a href="#cb785-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include &lt;sys/types.h&gt;</span></span>
<span id="cb785-2"><a href="#cb785-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include &lt;sys/socket.h&gt;</span></span>
<span id="cb785-3"><a href="#cb785-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb785-4"><a href="#cb785-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Socket.Imports</span></span>
<span id="cb785-5"><a href="#cb785-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Socket.Internal</span> (zeroMemory)</span>
<span id="cb785-6"><a href="#cb785-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Socket.Types</span> (<span class="dt">SockAddr</span>)</span>
<span id="cb785-7"><a href="#cb785-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb785-8"><a href="#cb785-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Socket.ByteString.IOVec</span> (<span class="dt">IOVec</span>)</span>
<span id="cb785-9"><a href="#cb785-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb785-10"><a href="#cb785-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MsgHdr</span> <span class="ot">=</span> <span class="dt">MsgHdr</span></span>
<span id="cb785-11"><a href="#cb785-11" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> msgName    ::</span> <span class="op">!</span>(<span class="dt">Ptr</span> <span class="dt">SockAddr</span>)</span>
<span id="cb785-12"><a href="#cb785-12" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> msgNameLen ::</span> <span class="op">!</span><span class="dt">CUInt</span></span>
<span id="cb785-13"><a href="#cb785-13" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> msgIov     ::</span> <span class="op">!</span>(<span class="dt">Ptr</span> <span class="dt">IOVec</span>)</span>
<span id="cb785-14"><a href="#cb785-14" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> msgIovLen  ::</span> <span class="op">!</span><span class="dt">CSize</span></span>
<span id="cb785-15"><a href="#cb785-15" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb785-16"><a href="#cb785-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb785-17"><a href="#cb785-17" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Storable</span> <span class="dt">MsgHdr</span> <span class="kw">where</span></span>
<span id="cb785-18"><a href="#cb785-18" aria-hidden="true" tabindex="-1"></a>  sizeOf _    <span class="ot">=</span> (<span class="op">#</span>const sizeof(struct msghdr))</span>
<span id="cb785-19"><a href="#cb785-19" aria-hidden="true" tabindex="-1"></a>  alignment _ <span class="ot">=</span> alignment (<span class="fu">undefined</span><span class="ot"> ::</span> <span class="dt">CInt</span>)</span>
<span id="cb785-20"><a href="#cb785-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb785-21"><a href="#cb785-21" aria-hidden="true" tabindex="-1"></a>  peek p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb785-22"><a href="#cb785-22" aria-hidden="true" tabindex="-1"></a>    name       <span class="ot">&lt;-</span> (<span class="op">#</span>peek struct msghdr, msg_name)       p</span>
<span id="cb785-23"><a href="#cb785-23" aria-hidden="true" tabindex="-1"></a>    nameLen    <span class="ot">&lt;-</span> (<span class="op">#</span>peek struct msghdr, msg_namelen)    p</span>
<span id="cb785-24"><a href="#cb785-24" aria-hidden="true" tabindex="-1"></a>    iov        <span class="ot">&lt;-</span> (<span class="op">#</span>peek struct msghdr, msg_iov)        p</span>
<span id="cb785-25"><a href="#cb785-25" aria-hidden="true" tabindex="-1"></a>    iovLen     <span class="ot">&lt;-</span> (<span class="op">#</span>peek struct msghdr, msg_iovlen)     p</span>
<span id="cb785-26"><a href="#cb785-26" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> <span class="dt">MsgHdr</span> name nameLen iov iovLen</span>
<span id="cb785-27"><a href="#cb785-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb785-28"><a href="#cb785-28" aria-hidden="true" tabindex="-1"></a>  poke p mh <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb785-29"><a href="#cb785-29" aria-hidden="true" tabindex="-1"></a>    zeroMemory p (<span class="op">#</span>const sizeof(struct msghdr))</span>
<span id="cb785-30"><a href="#cb785-30" aria-hidden="true" tabindex="-1"></a>    (<span class="op">#</span>poke struct msghdr, msg_name)       p (msgName       mh)</span>
<span id="cb785-31"><a href="#cb785-31" aria-hidden="true" tabindex="-1"></a>    (<span class="op">#</span>poke struct msghdr, msg_namelen)    p (msgNameLen    mh)</span>
<span id="cb785-32"><a href="#cb785-32" aria-hidden="true" tabindex="-1"></a>    (<span class="op">#</span>poke struct msghdr, msg_iov)        p (msgIov        mh)</span>
<span id="cb785-33"><a href="#cb785-33" aria-hidden="true" tabindex="-1"></a>    (<span class="op">#</span>poke struct msghdr, msg_iovlen)     p (msgIovLen     mh)</span></code></pre></div>
<p>Running the command line tool over this module we get the following
Haskell output <code>Example.hs</code>. This can also be run as part of
a Cabal build step by including <code>hsc2hs</code> in your
<code>build-tools</code>.</p>
<div class="sourceCode" id="cb786"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb786-1"><a href="#cb786-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> hsc2hs Example.hsc</span></code></pre></div>
<div class="sourceCode" id="cb787"
data-include="src/21-ffi/mini-hsc/Example.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb787-1"><a href="#cb787-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Socket.ByteString.IOVec</span> (<span class="dt">IOVec</span>)</span>
<span id="cb787-2"><a href="#cb787-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Socket.Imports</span></span>
<span id="cb787-3"><a href="#cb787-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Socket.Internal</span> (zeroMemory)</span>
<span id="cb787-4"><a href="#cb787-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Socket.Types</span> (<span class="dt">SockAddr</span>)</span>
<span id="cb787-5"><a href="#cb787-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb787-6"><a href="#cb787-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MsgHdr</span></span>
<span id="cb787-7"><a href="#cb787-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">MsgHdr</span></span>
<span id="cb787-8"><a href="#cb787-8" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> msgName ::</span> <span class="op">!</span>(<span class="dt">Ptr</span> <span class="dt">SockAddr</span>),</span>
<span id="cb787-9"><a href="#cb787-9" aria-hidden="true" tabindex="-1"></a><span class="ot">        msgNameLen ::</span> <span class="op">!</span><span class="dt">CUInt</span>,</span>
<span id="cb787-10"><a href="#cb787-10" aria-hidden="true" tabindex="-1"></a><span class="ot">        msgIov ::</span> <span class="op">!</span>(<span class="dt">Ptr</span> <span class="dt">IOVec</span>),</span>
<span id="cb787-11"><a href="#cb787-11" aria-hidden="true" tabindex="-1"></a><span class="ot">        msgIovLen ::</span> <span class="op">!</span><span class="dt">CSize</span></span>
<span id="cb787-12"><a href="#cb787-12" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb787-13"><a href="#cb787-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb787-14"><a href="#cb787-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Storable</span> <span class="dt">MsgHdr</span> <span class="kw">where</span></span>
<span id="cb787-15"><a href="#cb787-15" aria-hidden="true" tabindex="-1"></a>  sizeOf _ <span class="ot">=</span> (<span class="dv">56</span>)</span>
<span id="cb787-16"><a href="#cb787-16" aria-hidden="true" tabindex="-1"></a>  alignment _ <span class="ot">=</span> alignment (<span class="fu">undefined</span><span class="ot"> ::</span> <span class="dt">CInt</span>)</span>
<span id="cb787-17"><a href="#cb787-17" aria-hidden="true" tabindex="-1"></a>  peek p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb787-18"><a href="#cb787-18" aria-hidden="true" tabindex="-1"></a>    name <span class="ot">&lt;-</span> ((\hsc_ptr <span class="ot">-&gt;</span> peekByteOff hsc_ptr <span class="dv">0</span>)) p</span>
<span id="cb787-19"><a href="#cb787-19" aria-hidden="true" tabindex="-1"></a>    nameLen <span class="ot">&lt;-</span> ((\hsc_ptr <span class="ot">-&gt;</span> peekByteOff hsc_ptr <span class="dv">8</span>)) p</span>
<span id="cb787-20"><a href="#cb787-20" aria-hidden="true" tabindex="-1"></a>    iov <span class="ot">&lt;-</span> ((\hsc_ptr <span class="ot">-&gt;</span> peekByteOff hsc_ptr <span class="dv">16</span>)) p</span>
<span id="cb787-21"><a href="#cb787-21" aria-hidden="true" tabindex="-1"></a>    iovLen <span class="ot">&lt;-</span> ((\hsc_ptr <span class="ot">-&gt;</span> peekByteOff hsc_ptr <span class="dv">24</span>)) p</span>
<span id="cb787-22"><a href="#cb787-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> <span class="dt">MsgHdr</span> name nameLen iov iovLen</span>
<span id="cb787-23"><a href="#cb787-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb787-24"><a href="#cb787-24" aria-hidden="true" tabindex="-1"></a>  poke p mh <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb787-25"><a href="#cb787-25" aria-hidden="true" tabindex="-1"></a>    zeroMemory p (<span class="dv">56</span>)</span>
<span id="cb787-26"><a href="#cb787-26" aria-hidden="true" tabindex="-1"></a>    ((\hsc_ptr <span class="ot">-&gt;</span> pokeByteOff hsc_ptr <span class="dv">0</span>)) p (msgName mh)</span>
<span id="cb787-27"><a href="#cb787-27" aria-hidden="true" tabindex="-1"></a>    ((\hsc_ptr <span class="ot">-&gt;</span> pokeByteOff hsc_ptr <span class="dv">8</span>)) p (msgNameLen mh)</span>
<span id="cb787-28"><a href="#cb787-28" aria-hidden="true" tabindex="-1"></a>    ((\hsc_ptr <span class="ot">-&gt;</span> pokeByteOff hsc_ptr <span class="dv">16</span>)) p (msgIov mh)</span>
<span id="cb787-29"><a href="#cb787-29" aria-hidden="true" tabindex="-1"></a>    ((\hsc_ptr <span class="ot">-&gt;</span> pokeByteOff hsc_ptr <span class="dv">24</span>)) p (msgIovLen mh)</span></code></pre></div>
<hr/>
<h1 id="concurrency">Concurrency</h1>
<p>GHC Haskell has an extremely advanced parallel runtime that embraces
several different models of concurrency to adapt to needs for different
domains. Unlike other languages Haskell does not have any Global
Interpreter Lock or equivalent. Haskell code can be executed in a
multi-threaded context and have shared mutable state and communication
channels between threads.</p>
<p>A thread in Haskell is created by forking off from the main process
using the <code>forkIO</code> command. This is performed within the IO
monad and yields a ThreadId which can be used to communicate with the
new thread.</p>
<div class="sourceCode" id="cb788"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb788-1"><a href="#cb788-1" aria-hidden="true" tabindex="-1"></a><span class="ot">forkIO ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></span></code></pre></div>
<p>Haskell threads are extremely cheap to spawn, using only 1.5KB of RAM
depending on the platform and are much cheaper than a pthread in C.
Calling forkIO 10<sup>6</sup> times completes just short of 1s.
Additionally, functional purity in Haskell also guarantees that a thread
can almost always be terminated even in the middle of a computation
without concern.</p>
<p>See:</p>
<ul>
<li><a
href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Rts/Scheduler#TheScheduler">The
Scheduler</a></li>
</ul>
<h2 id="sparks">Sparks</h2>
<p>The most basic “atom” of parallelism in Haskell is a spark. It is a
hint to the GHC runtime that a computation can be evaluated to weak head
normal form in parallel.</p>
<div class="sourceCode" id="cb789"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb789-1"><a href="#cb789-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rpar ::</span> a <span class="ot">-&gt;</span> <span class="dt">Eval</span> a</span>
<span id="cb789-2"><a href="#cb789-2" aria-hidden="true" tabindex="-1"></a><span class="ot">rseq ::</span> <span class="dt">Strategy</span> a</span>
<span id="cb789-3"><a href="#cb789-3" aria-hidden="true" tabindex="-1"></a><span class="ot">rdeepseq ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">Strategy</span> a</span>
<span id="cb789-4"><a href="#cb789-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb789-5"><a href="#cb789-5" aria-hidden="true" tabindex="-1"></a><span class="ot">runEval ::</span> <span class="dt">Eval</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p><code>rpar a</code> spins off a separate spark that evaluates a to
weak head normal form and places the computation in the spark pool. When
the runtime determines that there is an available CPU to evaluate the
computation it will evaluate ( <em>convert</em> ) the spark. If the main
thread of the program is the evaluator for the spark, the spark is said
to have <em>fizzled</em>. Fizzling is generally bad and indicates that
the logic or parallelism strategy is not well suited to the work that is
being evaluated.</p>
<p>The spark pool is also limited ( but user-adjustable ) to a default
of 8000 (as of GHC 7.8.3 ). Sparks that are created beyond that limit
are said to <em>overflow</em>.</p>
<div class="sourceCode" id="cb790"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb790-1"><a href="#cb790-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Evaluates the arguments to f in parallel before application.</span></span>
<span id="cb790-2"><a href="#cb790-2" aria-hidden="true" tabindex="-1"></a>par2 f x y <span class="ot">=</span> x <span class="ot">`rpar`</span> y <span class="ot">`rpar`</span> f x y</span></code></pre></div>
<p>An argument to <code>rseq</code> forces the evaluation of a spark
before evaluation continues.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Action</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Fizzled</code></td>
<td style="text-align: left;">The resulting value has already been
evaluated by the main thread so the spark need not be converted.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Dud</code></td>
<td style="text-align: left;">The expression has already been evaluated,
the computed value is returned and the spark is not converted.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>GC'd</code></td>
<td style="text-align: left;">The spark is added to the spark pool but
the result is not referenced, so it is garbage collected.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Overflowed</code></td>
<td style="text-align: left;">Insufficient space in the spark pool when
spawning.</td>
</tr>
</tbody>
</table>
<p>The parallel runtime is necessary to use sparks, and the resulting
program must be compiled with <code>-threaded</code>. Additionally the
program itself can be specified to take runtime options with
<code>-rtsopts</code> such as the number of cores to use.</p>
<div class="sourceCode" id="cb791"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb791-1"><a href="#cb791-1" aria-hidden="true" tabindex="-1"></a>ghc <span class="op">-</span>threaded <span class="op">-</span>rtsopts program<span class="op">.</span>hs</span>
<span id="cb791-2"><a href="#cb791-2" aria-hidden="true" tabindex="-1"></a><span class="op">./</span>program <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span>s <span class="dt">N8</span> <span class="co">-- use 8 cores</span></span></code></pre></div>
<p>The runtime can be asked to dump information about the spark
evaluation by passing the <code>-s</code> flag.</p>
<div class="sourceCode" id="cb792"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb792-1"><a href="#cb792-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> <span class="op">./</span>spark <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span><span class="dt">N4</span> <span class="op">-</span>s</span>
<span id="cb792-2"><a href="#cb792-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb792-3"><a href="#cb792-3" aria-hidden="true" tabindex="-1"></a>                                    <span class="dt">Tot</span> time (elapsed)  <span class="dt">Avg</span> pause  <span class="dt">Max</span> pause</span>
<span id="cb792-4"><a href="#cb792-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Gen</span>  <span class="dv">0</span>         <span class="dv">5</span> colls,     <span class="dv">5</span> par    <span class="fl">0.02</span>s    <span class="fl">0.01</span>s     <span class="fl">0.0017</span>s    <span class="fl">0.0048</span>s</span>
<span id="cb792-5"><a href="#cb792-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Gen</span>  <span class="dv">1</span>         <span class="dv">3</span> colls,     <span class="dv">2</span> par    <span class="fl">0.00</span>s    <span class="fl">0.00</span>s     <span class="fl">0.0004</span>s    <span class="fl">0.0007</span>s</span>
<span id="cb792-6"><a href="#cb792-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb792-7"><a href="#cb792-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Parallel</span> <span class="dt">GC</span> work balance<span class="op">:</span> <span class="fl">1.83</span><span class="op">%</span> (serial <span class="dv">0</span><span class="op">%</span>, perfect <span class="dv">100</span><span class="op">%</span>)</span>
<span id="cb792-8"><a href="#cb792-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb792-9"><a href="#cb792-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">TASKS</span><span class="op">:</span> <span class="dv">6</span> (<span class="dv">1</span> bound, <span class="dv">5</span> peak workers (<span class="dv">5</span> total), using <span class="op">-</span><span class="dt">N4</span>)</span>
<span id="cb792-10"><a href="#cb792-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb792-11"><a href="#cb792-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">SPARKS</span><span class="op">:</span> <span class="dv">20000</span> (<span class="dv">20000</span> converted, <span class="dv">0</span> overflowed, <span class="dv">0</span> dud, <span class="dv">0</span> <span class="dt">GC&#39;d</span>, <span class="dv">0</span> fizzled)</span></code></pre></div>
<p>The parallel computations themselves are sequenced in the
<code>Eval</code> monad, whose evaluation with <code>runEval</code> is
itself a pure computation.</p>
<div class="sourceCode" id="cb793"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb793-1"><a href="#cb793-1" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (b, b)</span>
<span id="cb793-2"><a href="#cb793-2" aria-hidden="true" tabindex="-1"></a>example f x y <span class="ot">=</span> runEval <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb793-3"><a href="#cb793-3" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> rpar <span class="op">$</span> f x</span>
<span id="cb793-4"><a href="#cb793-4" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> rpar <span class="op">$</span> f y</span>
<span id="cb793-5"><a href="#cb793-5" aria-hidden="true" tabindex="-1"></a>  rseq a</span>
<span id="cb793-6"><a href="#cb793-6" aria-hidden="true" tabindex="-1"></a>  rseq b</span>
<span id="cb793-7"><a href="#cb793-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (a, b)</span></code></pre></div>
<h2 id="threads">Threads</h2>
<p>For fine-grained concurrency and parallelism, Haskell has a
lightweight thread system that schedules logical threads on the
available operating system threads. These lightweight threads are called
<em>unbound threads</em>, while native operating systems are called
<em>bound threads</em> since they are bound to a single operating system
thread. The functions to spawn an run tasks inside these threads all
live in the IO monad. The number of possible simultaneous threads is
given by the <code>getNumCapabilities</code> functions based on the
system environment.</p>
<div class="sourceCode" id="cb794"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb794-1"><a href="#cb794-1" aria-hidden="true" tabindex="-1"></a><span class="ot">forkIO ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></span>
<span id="cb794-2"><a href="#cb794-2" aria-hidden="true" tabindex="-1"></a><span class="ot">forkOS ::</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></span>
<span id="cb794-3"><a href="#cb794-3" aria-hidden="true" tabindex="-1"></a><span class="ot">runInBoundThread ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb794-4"><a href="#cb794-4" aria-hidden="true" tabindex="-1"></a><span class="ot">runInUnboundThread ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb794-5"><a href="#cb794-5" aria-hidden="true" tabindex="-1"></a><span class="ot">getNumCapabilities ::</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb794-6"><a href="#cb794-6" aria-hidden="true" tabindex="-1"></a><span class="ot">isCurrentThreadBound ::</span> <span class="dt">IO</span> <span class="dt">Bool</span></span></code></pre></div>
<p>Managed threads work with the runtime system’s IO manager which will
schedule and manage cooperative multitaksing and polling. When a
individual unbound thread is blocked polling on a file description or
lock it will yield to another runnable thread managed by the runtime.
This yield action can also be explicitly invoked with the
<code>yield</code> function. A thread can also schedule a wait using
<code>threadDelay</code> to yield to the scheduler for a fixed interval
given in microseconds.</p>
<div class="sourceCode" id="cb795"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb795-1"><a href="#cb795-1" aria-hidden="true" tabindex="-1"></a><span class="ot">yield ::</span> <span class="dt">IO</span> ()</span>
<span id="cb795-2"><a href="#cb795-2" aria-hidden="true" tabindex="-1"></a><span class="ot">threadDelay ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>Once a thread is forked the fork action will give back a
<code>ThreadId</code> which can be used to call actions and kill the
thread from another context. Inside of a running thread the current
ThreadId can be queried with <code>myThreadId</code>.</p>
<div class="sourceCode" id="cb796"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb796-1"><a href="#cb796-1" aria-hidden="true" tabindex="-1"></a><span class="ot">myThreadId ::</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></span>
<span id="cb796-2"><a href="#cb796-2" aria-hidden="true" tabindex="-1"></a><span class="ot">killThread ::</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>An exception can also be raised in a given <code>ThreadId</code>
given an instance of <code>Exception</code> typeclass.</p>
<div class="sourceCode" id="cb797"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb797-1"><a href="#cb797-1" aria-hidden="true" tabindex="-1"></a><span class="ot">throwTo ::</span> <span class="dt">Exception</span> e <span class="ot">=&gt;</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> e <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>When individually polling on file descriptors there are several
functions that can schedule the thread to wake up again when the given
file is given a wake event from the kernel. The following functions will
yield the current thread waiting on either a read or write event on the
given file description <code>Fd</code>.</p>
<div class="sourceCode" id="cb798"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb798-1"><a href="#cb798-1" aria-hidden="true" tabindex="-1"></a><span class="ot">threadWaitRead ::</span> <span class="dt">Fd</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb798-2"><a href="#cb798-2" aria-hidden="true" tabindex="-1"></a><span class="ot">threadWaitWrite ::</span> <span class="dt">Fd</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<h2 id="ioref">IORef</h2>
<p><code>IORef</code> is a mutable reference that can be read and writen
to within the IO monad. It is the simplest most low-level mutable
reference provided by the base library.</p>
<div class="sourceCode" id="cb799"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb799-1"><a href="#cb799-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newIORef ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">IORef</span> a)</span>
<span id="cb799-2"><a href="#cb799-2" aria-hidden="true" tabindex="-1"></a><span class="ot">writeIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb799-3"><a href="#cb799-3" aria-hidden="true" tabindex="-1"></a><span class="ot">readIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb799-4"><a href="#cb799-4" aria-hidden="true" tabindex="-1"></a><span class="ot">modifyIORef&#39; ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>For example we could construct two <code>IORef</code>s which mutably
hold the balances for two imaginary bank accounts. These references can
be passed to another <code>IO</code> function which can update the
values in place.</p>
<div class="sourceCode" id="cb800"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb800-1"><a href="#cb800-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.IORef</span></span>
<span id="cb800-2"><a href="#cb800-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb800-3"><a href="#cb800-3" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></span>
<span id="cb800-4"><a href="#cb800-4" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb800-5"><a href="#cb800-5" aria-hidden="true" tabindex="-1"></a>  account1 <span class="ot">&lt;-</span> newIORef <span class="dv">5000</span></span>
<span id="cb800-6"><a href="#cb800-6" aria-hidden="true" tabindex="-1"></a>  account2 <span class="ot">&lt;-</span> newIORef <span class="dv">1000</span></span>
<span id="cb800-7"><a href="#cb800-7" aria-hidden="true" tabindex="-1"></a>  transfer <span class="dv">500</span> account1 account2</span>
<span id="cb800-8"><a href="#cb800-8" aria-hidden="true" tabindex="-1"></a>  readIORef account1</span>
<span id="cb800-9"><a href="#cb800-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb800-10"><a href="#cb800-10" aria-hidden="true" tabindex="-1"></a><span class="ot">transfer ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IORef</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IORef</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb800-11"><a href="#cb800-11" aria-hidden="true" tabindex="-1"></a>transfer n from to <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb800-12"><a href="#cb800-12" aria-hidden="true" tabindex="-1"></a>  modifyIORef from (<span class="op">+</span> (<span class="op">-</span>n))</span>
<span id="cb800-13"><a href="#cb800-13" aria-hidden="true" tabindex="-1"></a>  modifyIORef to (<span class="op">+</span> n)</span></code></pre></div>
<p>There are also several atomic functions to update <code>IORef</code>
when working with the threaded runtime.</p>
<div class="sourceCode" id="cb801"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb801-1"><a href="#cb801-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atomicWriteIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb801-2"><a href="#cb801-2" aria-hidden="true" tabindex="-1"></a><span class="ot">atomicModifyIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> (a, b)) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span></code></pre></div>
<p>The atomic modify function <code>atomicModifyIORef</code> reads the
value of <code>r</code> and applies the function <code>f</code> to
<code>r</code> giving back <code>(a',b)</code>. Then value
<code>r</code> is updated with the new value <code>a'</code> and
<code>b</code> is the return value. Both the read and the write are done
atomically so it is not possible that any value will alter the
underlying <code>IORef</code> between the read and write.</p>
<p>Normally <code>IORef</code> is garbage collected like any other
value. Once it is out of scope and the runtime has no more references to
it, the runtime will collect the thunk holding the <code>IORef</code> as
well as the value the underlying pointer points at. Sometimes when
working with these references will require adding additional
finalisation logic.</p>
<div class="sourceCode" id="cb802"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb802-1"><a href="#cb802-1" aria-hidden="true" tabindex="-1"></a><span class="ot">mkWeakIORef ::</span> <span class="dt">IORef</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Weak</span> (<span class="dt">IORef</span> a))</span></code></pre></div>
<p>The <code>mkWeakIORef</code> attaches a finalizer function in the
second argument which is run when the value is garbage collected.</p>
<h2 id="mvars">MVars</h2>
<p>MVars are mutable references like IORefs that can be used to share
mutable state between threads. An <code>MVar</code> has two states
<em>empty</em> and <em>full</em>. Reading from an empty MVar will block
the current thread. Writing to a full MVar will also block the current
thread. Thus only one value can be held inside the MVar allowing us to
synchronize the value across threads. MVars are building blocks for many
higher concurrent primitives which use them under the hood.</p>
<p>An MVar can either be initialised in an empty state or with a
supplied value.</p>
<div class="sourceCode" id="cb803"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb803-1"><a href="#cb803-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newEmptyMVar ::</span> <span class="dt">IO</span> (<span class="dt">MVar</span> a)</span>
<span id="cb803-2"><a href="#cb803-2" aria-hidden="true" tabindex="-1"></a><span class="ot">newMVar ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">MVar</span> a)</span></code></pre></div>
<p>The function <code>takeMVar</code> operates like a read returning the
value, but once the value is read the state of the underlying MVar is
left empty. This read is performed once for the first thread to wake up
polling for the read.</p>
<div class="sourceCode" id="cb804"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb804-1"><a href="#cb804-1" aria-hidden="true" tabindex="-1"></a><span class="ot">takeMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb804-2"><a href="#cb804-2" aria-hidden="true" tabindex="-1"></a><span class="ot">putMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb804-3"><a href="#cb804-3" aria-hidden="true" tabindex="-1"></a><span class="ot">readMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb804-4"><a href="#cb804-4" aria-hidden="true" tabindex="-1"></a><span class="ot">swapMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb804-5"><a href="#cb804-5" aria-hidden="true" tabindex="-1"></a><span class="ot">isEmptyMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Bool</span></span></code></pre></div>
<p>As an example consider a multithreaded scenario where a second thread
is created which polls on atomically on an MVar update.</p>
<div class="sourceCode" id="cb805"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb805-1"><a href="#cb805-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb805-2"><a href="#cb805-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb805-3"><a href="#cb805-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (take)</span>
<span id="cb805-4"><a href="#cb805-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb805-5"><a href="#cb805-5" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span><span class="ot"> ::</span> <span class="dt">MVar</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb805-6"><a href="#cb805-6" aria-hidden="true" tabindex="-1"></a><span class="fu">take</span> m <span class="ot">=</span> forever <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb805-7"><a href="#cb805-7" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> takeMVar m</span>
<span id="cb805-8"><a href="#cb805-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> x</span>
<span id="cb805-9"><a href="#cb805-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb805-10"><a href="#cb805-10" aria-hidden="true" tabindex="-1"></a><span class="ot">put ::</span> <span class="dt">MVar</span> [<span class="dt">Char</span>] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb805-11"><a href="#cb805-11" aria-hidden="true" tabindex="-1"></a>put m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb805-12"><a href="#cb805-12" aria-hidden="true" tabindex="-1"></a>  replicateM_ <span class="dv">10</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb805-13"><a href="#cb805-13" aria-hidden="true" tabindex="-1"></a>    threadDelay <span class="dv">100000</span></span>
<span id="cb805-14"><a href="#cb805-14" aria-hidden="true" tabindex="-1"></a>    putMVar m <span class="st">&quot;Value set.&quot;</span></span>
<span id="cb805-15"><a href="#cb805-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb805-16"><a href="#cb805-16" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> ()</span>
<span id="cb805-17"><a href="#cb805-17" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb805-18"><a href="#cb805-18" aria-hidden="true" tabindex="-1"></a>  m <span class="ot">&lt;-</span> newEmptyMVar</span>
<span id="cb805-19"><a href="#cb805-19" aria-hidden="true" tabindex="-1"></a>  forkIO (<span class="fu">take</span> m)</span>
<span id="cb805-20"><a href="#cb805-20" aria-hidden="true" tabindex="-1"></a>  put m</span></code></pre></div>
<p>If a thread is left sleeping waiting on an MVar and the runtime no
longer has any references to code which can write to the MRef (i.e. all
references to the MVar are garbage collected) the thread will be thrown
the exception <code>BlockedIndefinitelyOnMVar</code> since no value can
subsequently be written to it.</p>
<h2 id="tvar">TVar</h2>
<p>TVars are transactional mutable variables which can be read and
written to within in the STM monad. The STM monad provides support for
<em>Software Transactional Memory</em> which is a higher level
abstraction for concurrent communication that doesn’t require explict
thread maintenance and has lovely easy compositional nature.</p>
<p>The STM monad magically hooks into the runtime system and provides
two key operations <code>atomically</code> and <code>retry</code> which
allow monadic blocks of STM actions to be performed atomically and
passed around symbolically. In the event that the runtime fails to
commit a transaction, the <code>retry</code> function can rerun the
logic contained in a <code>STM a</code>.</p>
<div class="sourceCode" id="cb806"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb806-1"><a href="#cb806-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atomically ::</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb806-2"><a href="#cb806-2" aria-hidden="true" tabindex="-1"></a><span class="ot">retry ::</span> <span class="dt">STM</span> a</span></code></pre></div>
<p>TVars can be created just like IORefs but instead of being in IO they
can also be created with the STM monad.</p>
<div class="sourceCode" id="cb807"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb807-1"><a href="#cb807-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newTVar ::</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> (<span class="dt">TVar</span> a)</span>
<span id="cb807-2"><a href="#cb807-2" aria-hidden="true" tabindex="-1"></a><span class="ot">newTVarIO ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">TVar</span> a)</span></code></pre></div>
<p>Read, writes and updates proceed exactly like IORef updates but
inside of STM.</p>
<div class="sourceCode" id="cb808"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb808-1"><a href="#cb808-1" aria-hidden="true" tabindex="-1"></a><span class="ot">readTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a</span>
<span id="cb808-2"><a href="#cb808-2" aria-hidden="true" tabindex="-1"></a><span class="ot">writeTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</span>
<span id="cb808-3"><a href="#cb808-3" aria-hidden="true" tabindex="-1"></a><span class="ot">modifyTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</span></code></pre></div>
<p>As an example consider the IORef account transfers from above, but
instead the two <code>modifyTVar</code> actions are performed atomically
inside of the transfer function.</p>
<div class="sourceCode" id="cb809"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb809-1"><a href="#cb809-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb809-2"><a href="#cb809-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent.STM</span></span>
<span id="cb809-3"><a href="#cb809-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent.STM.TVar</span></span>
<span id="cb809-4"><a href="#cb809-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb809-5"><a href="#cb809-5" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> <span class="dt">Integer</span></span>
<span id="cb809-6"><a href="#cb809-6" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb809-7"><a href="#cb809-7" aria-hidden="true" tabindex="-1"></a>  account1 <span class="ot">&lt;-</span> atomically <span class="op">$</span> newTVar <span class="dv">5000</span></span>
<span id="cb809-8"><a href="#cb809-8" aria-hidden="true" tabindex="-1"></a>  account2 <span class="ot">&lt;-</span> atomically <span class="op">$</span> newTVar <span class="dv">1000</span></span>
<span id="cb809-9"><a href="#cb809-9" aria-hidden="true" tabindex="-1"></a>  atomically (transfer <span class="dv">500</span> account1 account2)</span>
<span id="cb809-10"><a href="#cb809-10" aria-hidden="true" tabindex="-1"></a>  readTVarIO account1</span>
<span id="cb809-11"><a href="#cb809-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb809-12"><a href="#cb809-12" aria-hidden="true" tabindex="-1"></a><span class="ot">transfer ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">TVar</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">TVar</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</span>
<span id="cb809-13"><a href="#cb809-13" aria-hidden="true" tabindex="-1"></a>transfer n from to <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb809-14"><a href="#cb809-14" aria-hidden="true" tabindex="-1"></a>  modifyTVar from (<span class="op">+</span> (<span class="op">-</span>n))</span>
<span id="cb809-15"><a href="#cb809-15" aria-hidden="true" tabindex="-1"></a>  modifyTVar to (<span class="op">+</span> n)</span></code></pre></div>
<p>There is an additional <code>TMVar</code> which behaves precisely
like the traditional <code>MVar</code> (i.e. it has an empty and full
state) but which is embedded in IO. It is has precisely the same
semantics as MVar but emits values within STM.</p>
<div class="sourceCode" id="cb810"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb810-1"><a href="#cb810-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Control.Concurrent.STM.TMVar</span></span>
<span id="cb810-2"><a href="#cb810-2" aria-hidden="true" tabindex="-1"></a><span class="ot">newTMVar ::</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> (<span class="dt">TMVar</span> a)</span>
<span id="cb810-3"><a href="#cb810-3" aria-hidden="true" tabindex="-1"></a><span class="ot">putTMVar ::</span> <span class="dt">TMVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</span>
<span id="cb810-4"><a href="#cb810-4" aria-hidden="true" tabindex="-1"></a><span class="ot">takeTMVar ::</span> <span class="dt">TMVar</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a</span></code></pre></div>
<h2 id="chans">Chans</h2>
<p>Channels are unbounded queues to which an unbounded number of values
can be written an unbounded number of times. Channels are implemented
using MVars and can be consumed by any number of other threads which
read data off of the Chan. Channels are created, read from and written
to using a simple <code>new</code>, <code>read</code> and
<code>write</code> interface just as we’ve seen with other concurrency
primitives.</p>
<div class="sourceCode" id="cb811"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb811-1"><a href="#cb811-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newChan ::</span> <span class="dt">IO</span> (<span class="dt">Chan</span> a)</span>
<span id="cb811-2"><a href="#cb811-2" aria-hidden="true" tabindex="-1"></a><span class="ot">readChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb811-3"><a href="#cb811-3" aria-hidden="true" tabindex="-1"></a><span class="ot">writeChan ::</span> <span class="dt">Chan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>An example in which a channel is created between a producer and
consumer threads is shown below. This can be used to share data between
threads and create work queue background processing systems.</p>
<div class="sourceCode" id="cb812"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb812-1"><a href="#cb812-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span></span>
<span id="cb812-2"><a href="#cb812-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb812-3"><a href="#cb812-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb812-4"><a href="#cb812-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent.Chan</span></span>
<span id="cb812-5"><a href="#cb812-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb812-6"><a href="#cb812-6" aria-hidden="true" tabindex="-1"></a><span class="ot">producer ::</span> <span class="dt">Chan</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb812-7"><a href="#cb812-7" aria-hidden="true" tabindex="-1"></a>producer chan <span class="ot">=</span> forM_ [<span class="dv">0</span> <span class="op">..</span> <span class="dv">1000</span>] <span class="op">$</span> \i <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb812-8"><a href="#cb812-8" aria-hidden="true" tabindex="-1"></a>  writeChan chan i</span>
<span id="cb812-9"><a href="#cb812-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Writing to channel.&quot;</span></span>
<span id="cb812-10"><a href="#cb812-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb812-11"><a href="#cb812-11" aria-hidden="true" tabindex="-1"></a><span class="ot">consumer ::</span> <span class="dt">Chan</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb812-12"><a href="#cb812-12" aria-hidden="true" tabindex="-1"></a>consumer chan <span class="ot">=</span> forever <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb812-13"><a href="#cb812-13" aria-hidden="true" tabindex="-1"></a>  val <span class="ot">&lt;-</span> readChan chan</span>
<span id="cb812-14"><a href="#cb812-14" aria-hidden="true" tabindex="-1"></a>  thread <span class="ot">&lt;-</span> myThreadId</span>
<span id="cb812-15"><a href="#cb812-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> (<span class="st">&quot;Recieved item in thread: &quot;</span> <span class="op">++</span> <span class="fu">show</span> thread)</span>
<span id="cb812-16"><a href="#cb812-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> val</span>
<span id="cb812-17"><a href="#cb812-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb812-18"><a href="#cb812-18" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> ()</span>
<span id="cb812-19"><a href="#cb812-19" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb812-20"><a href="#cb812-20" aria-hidden="true" tabindex="-1"></a>  chan <span class="ot">&lt;-</span> newChan</span>
<span id="cb812-21"><a href="#cb812-21" aria-hidden="true" tabindex="-1"></a>  forkIO (consumer chan)</span>
<span id="cb812-22"><a href="#cb812-22" aria-hidden="true" tabindex="-1"></a>  forkIO (consumer chan)</span>
<span id="cb812-23"><a href="#cb812-23" aria-hidden="true" tabindex="-1"></a>  forkIO (consumer chan)</span>
<span id="cb812-24"><a href="#cb812-24" aria-hidden="true" tabindex="-1"></a>  forkIO (producer chan)</span>
<span id="cb812-25"><a href="#cb812-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> ()</span>
<span id="cb812-26"><a href="#cb812-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb812-27"><a href="#cb812-27" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb812-28"><a href="#cb812-28" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb812-29"><a href="#cb812-29" aria-hidden="true" tabindex="-1"></a>  hSetBuffering stdout <span class="dt">LineBuffering</span></span>
<span id="cb812-30"><a href="#cb812-30" aria-hidden="true" tabindex="-1"></a>  example</span></code></pre></div>
<p>There is also an STM variant of Chan called <code>TChan</code>.</p>
<div class="sourceCode" id="cb813"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb813-1"><a href="#cb813-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newTChan ::</span> <span class="dt">STM</span> (<span class="dt">TChan</span> a)</span>
<span id="cb813-2"><a href="#cb813-2" aria-hidden="true" tabindex="-1"></a><span class="ot">readTChan ::</span> <span class="dt">TChan</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a</span>
<span id="cb813-3"><a href="#cb813-3" aria-hidden="true" tabindex="-1"></a><span class="ot">writeTChan ::</span> <span class="dt">TChan</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</span></code></pre></div>
<h2 id="semaphores">Semaphores</h2>
<p>Semaphores are a concurrency primitive used to control access to a
common resource used by multiple threads. A semaphore is a variable
containing an integral value that can be incremented or decremented by
concurrent processes. A semaphore will restrict concurrency to a
integral count of consumers called the <em>limit</em>. The
<code>QSem</code> provides an interface for a simple lock semaphore that
can be created in IO and polled on using <code>waitQSem</code>.</p>
<div class="sourceCode" id="cb814"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb814-1"><a href="#cb814-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newQSem ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">QSem</span></span>
<span id="cb814-2"><a href="#cb814-2" aria-hidden="true" tabindex="-1"></a><span class="ot">waitQSem ::</span> <span class="dt">QSem</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb814-3"><a href="#cb814-3" aria-hidden="true" tabindex="-1"></a><span class="ot">signalQSem ::</span> <span class="dt">QSem</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>A simple example of usage:</p>
<div class="sourceCode" id="cb815"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb815-1"><a href="#cb815-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb815-2"><a href="#cb815-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent.QSem</span></span>
<span id="cb815-3"><a href="#cb815-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb815-4"><a href="#cb815-4" aria-hidden="true" tabindex="-1"></a><span class="ot">task ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">QSem</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb815-5"><a href="#cb815-5" aria-hidden="true" tabindex="-1"></a>task <span class="fu">index</span> sem <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb815-6"><a href="#cb815-6" aria-hidden="true" tabindex="-1"></a>  waitQSem sem</span>
<span id="cb815-7"><a href="#cb815-7" aria-hidden="true" tabindex="-1"></a>  forkIO <span class="op">$</span> <span class="fu">putStrLn</span> (<span class="st">&quot;Thread: &quot;</span> <span class="op">++</span> <span class="fu">show</span> <span class="fu">index</span> <span class="op">++</span> <span class="st">&quot;\n&quot;</span>)</span>
<span id="cb815-8"><a href="#cb815-8" aria-hidden="true" tabindex="-1"></a>  signalQSem sem</span>
<span id="cb815-9"><a href="#cb815-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb815-10"><a href="#cb815-10" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> ()</span>
<span id="cb815-11"><a href="#cb815-11" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb815-12"><a href="#cb815-12" aria-hidden="true" tabindex="-1"></a>  sem <span class="ot">&lt;-</span> newQSem <span class="dv">1</span></span>
<span id="cb815-13"><a href="#cb815-13" aria-hidden="true" tabindex="-1"></a>  forkIO (task <span class="dv">1</span> sem)</span>
<span id="cb815-14"><a href="#cb815-14" aria-hidden="true" tabindex="-1"></a>  forkIO (task <span class="dv">2</span> sem)</span>
<span id="cb815-15"><a href="#cb815-15" aria-hidden="true" tabindex="-1"></a>  forkIO (task <span class="dv">3</span> sem)</span>
<span id="cb815-16"><a href="#cb815-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ()</span></code></pre></div>
<p>QSem also have a variant <code>QSemN</code> which allows a resource
to be acquired and released in a fixed quantity other than one. The
<code>waitQSemN</code> function then takes an integral quantity to wait
for.</p>
<div class="sourceCode" id="cb816"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb816-1"><a href="#cb816-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newQSemN ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">QSemN</span></span>
<span id="cb816-2"><a href="#cb816-2" aria-hidden="true" tabindex="-1"></a><span class="ot">waitQSemN ::</span> <span class="dt">QSemN</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>There is also an STM variant of QSem called <code>TSem</code> which
has the same semantics.</p>
<div class="sourceCode" id="cb817"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb817-1"><a href="#cb817-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newTSem ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">STM</span> <span class="dt">TSem</span></span>
<span id="cb817-2"><a href="#cb817-2" aria-hidden="true" tabindex="-1"></a><span class="ot">waitTSem ::</span> <span class="dt">TSem</span> <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</span></code></pre></div>
<h2 id="threadscope">Threadscope</h2>
<p>Passing the flag <code>-l</code> generates the eventlog which can be
rendered with the threadscope library.</p>
<div class="sourceCode" id="cb818"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb818-1"><a href="#cb818-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> ghc <span class="op">-</span><span class="dt">O2</span> <span class="op">-</span>threaded <span class="op">-</span>rtsopts <span class="op">-</span>eventlog Example.hs</span>
<span id="cb818-2"><a href="#cb818-2" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> <span class="op">./</span>program <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span><span class="dt">N4</span> <span class="op">-</span>l</span>
<span id="cb818-3"><a href="#cb818-3" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> threadscope Example.eventlog</span></code></pre></div>
<p><img src="img/threadscope.png" width="300" /></p>
<p>See:</p>
<ul>
<li><a href="http://www.well-typed.com/blog/86/">Performance profiling
with ghc-events-analyze</a></li>
</ul>
<h2 id="strategies">Strategies</h2>
<p>Sparks themselves form the foundation for higher level parallelism
constructs known as <code>strategies</code> which adapt spark creation
to fit the computation or data structure being evaluated. For instance
if we wanted to evaluate both elements of a tuple in parallel we can
create a strategy which uses sparks to evaluate both sides of the
tuple.</p>
<div class="sourceCode" id="cb819"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb819-1"><a href="#cb819-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Strategy</span> a <span class="ot">=</span> a <span class="ot">-&gt;</span> <span class="dt">Eval</span> a</span>
<span id="cb819-2"><a href="#cb819-2" aria-hidden="true" tabindex="-1"></a><span class="ot">using ::</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<div class="sourceCode" id="cb820"
data-include="src/22-concurrency/strategies.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb820-1"><a href="#cb820-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Parallel.Strategies</span></span>
<span id="cb820-2"><a href="#cb820-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb820-3"><a href="#cb820-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parPair&#39; ::</span> <span class="dt">Strategy</span> (a, b)</span>
<span id="cb820-4"><a href="#cb820-4" aria-hidden="true" tabindex="-1"></a>parPair&#39; (a, b) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb820-5"><a href="#cb820-5" aria-hidden="true" tabindex="-1"></a>  a&#39; <span class="ot">&lt;-</span> rpar a</span>
<span id="cb820-6"><a href="#cb820-6" aria-hidden="true" tabindex="-1"></a>  b&#39; <span class="ot">&lt;-</span> rpar b</span>
<span id="cb820-7"><a href="#cb820-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (a&#39;, b&#39;)</span>
<span id="cb820-8"><a href="#cb820-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb820-9"><a href="#cb820-9" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb820-10"><a href="#cb820-10" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb820-11"><a href="#cb820-11" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb820-12"><a href="#cb820-12" aria-hidden="true" tabindex="-1"></a>fib n <span class="ot">=</span> fib (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib (n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb820-13"><a href="#cb820-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb820-14"><a href="#cb820-14" aria-hidden="true" tabindex="-1"></a><span class="ot">serial ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb820-15"><a href="#cb820-15" aria-hidden="true" tabindex="-1"></a>serial   <span class="ot">=</span> (fib <span class="dv">30</span>, fib <span class="dv">31</span>)</span>
<span id="cb820-16"><a href="#cb820-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb820-17"><a href="#cb820-17" aria-hidden="true" tabindex="-1"></a><span class="ot">parallel ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb820-18"><a href="#cb820-18" aria-hidden="true" tabindex="-1"></a>parallel <span class="ot">=</span> runEval <span class="op">.</span> parPair&#39; <span class="op">$</span> (fib <span class="dv">30</span>, fib <span class="dv">31</span>)</span></code></pre></div>
<p>This pattern occurs so frequently the combinator <code>using</code>
can be used to write it equivalently in operator-like form that may be
more visually appealing to some.</p>
<div class="sourceCode" id="cb821"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb821-1"><a href="#cb821-1" aria-hidden="true" tabindex="-1"></a><span class="ot">using ::</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb821-2"><a href="#cb821-2" aria-hidden="true" tabindex="-1"></a>x <span class="ot">`using`</span> s <span class="ot">=</span> runEval (s x)</span>
<span id="cb821-3"><a href="#cb821-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb821-4"><a href="#cb821-4" aria-hidden="true" tabindex="-1"></a>parallel <span class="op">:::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb821-5"><a href="#cb821-5" aria-hidden="true" tabindex="-1"></a>parallel <span class="ot">=</span> (fib <span class="dv">30</span>, fib <span class="dv">31</span>) <span class="ot">`using`</span> parPair</span></code></pre></div>
<p>For a less contrived example consider a parallel <code>parmap</code>
which maps a pure function over a list of a values in parallel.</p>
<div class="sourceCode" id="cb822"
data-include="src/22-concurrency/spark.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb822-1"><a href="#cb822-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Parallel.Strategies</span></span>
<span id="cb822-2"><a href="#cb822-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb822-3"><a href="#cb822-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parMap&#39; ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Eval</span> [b]</span>
<span id="cb822-4"><a href="#cb822-4" aria-hidden="true" tabindex="-1"></a>parMap&#39; f [] <span class="ot">=</span> <span class="fu">return</span> []</span>
<span id="cb822-5"><a href="#cb822-5" aria-hidden="true" tabindex="-1"></a>parMap&#39; f (a<span class="op">:</span>as) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb822-6"><a href="#cb822-6" aria-hidden="true" tabindex="-1"></a>  b  <span class="ot">&lt;-</span> rpar (f a)</span>
<span id="cb822-7"><a href="#cb822-7" aria-hidden="true" tabindex="-1"></a>  bs <span class="ot">&lt;-</span> parMap&#39; f as</span>
<span id="cb822-8"><a href="#cb822-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (b<span class="op">:</span>bs)</span>
<span id="cb822-9"><a href="#cb822-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb822-10"><a href="#cb822-10" aria-hidden="true" tabindex="-1"></a><span class="ot">result ::</span> [<span class="dt">Int</span>]</span>
<span id="cb822-11"><a href="#cb822-11" aria-hidden="true" tabindex="-1"></a>result <span class="ot">=</span> runEval <span class="op">$</span> parMap&#39; (<span class="op">+</span><span class="dv">1</span>) [<span class="dv">1</span><span class="op">..</span><span class="dv">1000</span>]</span></code></pre></div>
<p>The functions above are quite useful, but will break down if
evaluation of the arguments needs to be parallelized beyond simply weak
head normal form. For instance if the arguments to <code>rpar</code> is
a nested constructor we’d like to parallelize the entire section of work
in evaluated the expression to normal form instead of just the outer
layer. As such we’d like to generalize our strategies so the evaluation
strategy for the arguments can be passed as an argument to the
strategy.</p>
<p><code>Control.Parallel.Strategies</code> contains a generalized
version of <code>rpar</code> which embeds additional evaluation logic
inside the <code>rpar</code> computation in Eval monad.</p>
<div class="sourceCode" id="cb823"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb823-1"><a href="#cb823-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rparWith ::</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a</span></code></pre></div>
<p>Using the deepseq library we can now construct a Strategy variant of
rseq that evaluates to full normal form.</p>
<div class="sourceCode" id="cb824"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb824-1"><a href="#cb824-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rdeepseq ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">Strategy</span> a</span>
<span id="cb824-2"><a href="#cb824-2" aria-hidden="true" tabindex="-1"></a>rdeepseq x <span class="ot">=</span> rseq (force x)</span></code></pre></div>
<p>We now can create a “higher order” strategy that takes two strategies
and itself yields a computation which when evaluated uses the passed
strategies in its scheduling.</p>
<div class="sourceCode" id="cb825"
data-include="src/22-concurrency/strategies_param.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb825-1"><a href="#cb825-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.DeepSeq</span></span>
<span id="cb825-2"><a href="#cb825-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Parallel.Strategies</span></span>
<span id="cb825-3"><a href="#cb825-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb825-4"><a href="#cb825-4" aria-hidden="true" tabindex="-1"></a><span class="ot">evalPair ::</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> b <span class="ot">-&gt;</span> <span class="dt">Strategy</span> (a, b)</span>
<span id="cb825-5"><a href="#cb825-5" aria-hidden="true" tabindex="-1"></a>evalPair sa sb (a, b) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb825-6"><a href="#cb825-6" aria-hidden="true" tabindex="-1"></a>  a&#39; <span class="ot">&lt;-</span> sa a</span>
<span id="cb825-7"><a href="#cb825-7" aria-hidden="true" tabindex="-1"></a>  b&#39; <span class="ot">&lt;-</span> sb b</span>
<span id="cb825-8"><a href="#cb825-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (a&#39;, b&#39;)</span>
<span id="cb825-9"><a href="#cb825-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb825-10"><a href="#cb825-10" aria-hidden="true" tabindex="-1"></a><span class="ot">parPair ::</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> b <span class="ot">-&gt;</span> <span class="dt">Strategy</span> (a, b)</span>
<span id="cb825-11"><a href="#cb825-11" aria-hidden="true" tabindex="-1"></a>parPair sa sb <span class="ot">=</span> evalPair (rparWith sa) (rparWith sb)</span>
<span id="cb825-12"><a href="#cb825-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb825-13"><a href="#cb825-13" aria-hidden="true" tabindex="-1"></a><span class="ot">fib ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb825-14"><a href="#cb825-14" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb825-15"><a href="#cb825-15" aria-hidden="true" tabindex="-1"></a>fib <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb825-16"><a href="#cb825-16" aria-hidden="true" tabindex="-1"></a>fib n <span class="ot">=</span> fib (n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib (n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb825-17"><a href="#cb825-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb825-18"><a href="#cb825-18" aria-hidden="true" tabindex="-1"></a><span class="ot">serial ::</span> ([<span class="dt">Int</span>], [<span class="dt">Int</span>])</span>
<span id="cb825-19"><a href="#cb825-19" aria-hidden="true" tabindex="-1"></a>serial <span class="ot">=</span> (a, b)</span>
<span id="cb825-20"><a href="#cb825-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb825-21"><a href="#cb825-21" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">=</span> <span class="fu">fmap</span> fib [<span class="dv">0</span><span class="op">..</span><span class="dv">30</span>]</span>
<span id="cb825-22"><a href="#cb825-22" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">=</span> <span class="fu">fmap</span> fib [<span class="dv">1</span><span class="op">..</span><span class="dv">30</span>]</span>
<span id="cb825-23"><a href="#cb825-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb825-24"><a href="#cb825-24" aria-hidden="true" tabindex="-1"></a><span class="ot">parallel ::</span> ([<span class="dt">Int</span>], [<span class="dt">Int</span>])</span>
<span id="cb825-25"><a href="#cb825-25" aria-hidden="true" tabindex="-1"></a>parallel <span class="ot">=</span> (a, b) <span class="ot">`using`</span> evalPair rdeepseq rdeepseq</span>
<span id="cb825-26"><a href="#cb825-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb825-27"><a href="#cb825-27" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">=</span> <span class="fu">fmap</span> fib [<span class="dv">0</span><span class="op">..</span><span class="dv">30</span>]</span>
<span id="cb825-28"><a href="#cb825-28" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">=</span> <span class="fu">fmap</span> fib [<span class="dv">1</span><span class="op">..</span><span class="dv">30</span>]</span></code></pre></div>
<p>These patterns are implemented in the Strategies library along with
several other general forms and combinators for combining strategies to
fit many different parallel computations.</p>
<div class="sourceCode" id="cb826"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb826-1"><a href="#cb826-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parTraverse ::</span> <span class="dt">Traversable</span> t <span class="ot">=&gt;</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> (t a)</span>
<span id="cb826-2"><a href="#cb826-2" aria-hidden="true" tabindex="-1"></a><span class="ot">dot ::</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a</span>
<span id="cb826-3"><a href="#cb826-3" aria-hidden="true" tabindex="-1"></a><span class="ot">($||) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb826-4"><a href="#cb826-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(.||) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Strategy</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="http://hackage.haskell.org/package/parallel-3.2.0.4/docs/Control-Parallel-Strategies.html">Control.Concurent.Strategies</a></li>
</ul>
<h2 id="stm">STM</h2>
<p><em>Software transactional memory</em> is a technique for demarcating
blocks of atomic transactions that are guaranteed by the runtime to have
several properties:</p>
<ul>
<li>No parallel processes can read from the atomic block until the
transaction commits.</li>
<li>The current process is isolated cannot see any changes made by other
parallel processes.</li>
</ul>
<p>This is similar to the atomicity that databases guarantee. The
<code>stm</code> library provides a lovely compositional interface for
building up higher level primitives that can be composed in atomic
blocks to build safe concurrent logic without worrying about deadlocks
and memory corruption from threaded and mutable reference approaches to
building parallel algorithms.</p>
<div class="sourceCode" id="cb827"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb827-1"><a href="#cb827-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atomically ::</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb827-2"><a href="#cb827-2" aria-hidden="true" tabindex="-1"></a><span class="ot">orElse ::</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a</span>
<span id="cb827-3"><a href="#cb827-3" aria-hidden="true" tabindex="-1"></a><span class="ot">retry ::</span> <span class="dt">STM</span> a</span>
<span id="cb827-4"><a href="#cb827-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb827-5"><a href="#cb827-5" aria-hidden="true" tabindex="-1"></a><span class="ot">newTVar ::</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> (<span class="dt">TVar</span> a)</span>
<span id="cb827-6"><a href="#cb827-6" aria-hidden="true" tabindex="-1"></a><span class="ot">newTVarIO ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">TVar</span> a)</span>
<span id="cb827-7"><a href="#cb827-7" aria-hidden="true" tabindex="-1"></a><span class="ot">writeTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</span>
<span id="cb827-8"><a href="#cb827-8" aria-hidden="true" tabindex="-1"></a><span class="ot">readTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> <span class="dt">STM</span> a</span>
<span id="cb827-9"><a href="#cb827-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb827-10"><a href="#cb827-10" aria-hidden="true" tabindex="-1"></a><span class="ot">modifyTVar ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</span>
<span id="cb827-11"><a href="#cb827-11" aria-hidden="true" tabindex="-1"></a><span class="ot">modifyTVar&#39; ::</span> <span class="dt">TVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</span></code></pre></div>
<p>The strength of Haskell’s purity guarantees that transactions within
STM are pure and can always be rolled back if a commit fails. An example
of usage is shown below.</p>
<div class="sourceCode" id="cb828"
data-include="src/22-concurrency/stm.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb828-1"><a href="#cb828-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb828-2"><a href="#cb828-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb828-3"><a href="#cb828-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent.STM</span></span>
<span id="cb828-4"><a href="#cb828-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb828-5"><a href="#cb828-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Account</span> <span class="ot">=</span> <span class="dt">TVar</span> <span class="dt">Double</span></span>
<span id="cb828-6"><a href="#cb828-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb828-7"><a href="#cb828-7" aria-hidden="true" tabindex="-1"></a><span class="ot">transfer ::</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">STM</span> ()</span>
<span id="cb828-8"><a href="#cb828-8" aria-hidden="true" tabindex="-1"></a>transfer from to amount <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb828-9"><a href="#cb828-9" aria-hidden="true" tabindex="-1"></a>  available <span class="ot">&lt;-</span> readTVar from</span>
<span id="cb828-10"><a href="#cb828-10" aria-hidden="true" tabindex="-1"></a>  when (amount <span class="op">&gt;</span> available) retry</span>
<span id="cb828-11"><a href="#cb828-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb828-12"><a href="#cb828-12" aria-hidden="true" tabindex="-1"></a>  modifyTVar from (<span class="op">+</span> (<span class="op">-</span>amount))</span>
<span id="cb828-13"><a href="#cb828-13" aria-hidden="true" tabindex="-1"></a>  modifyTVar to   (<span class="op">+</span> amount)</span>
<span id="cb828-14"><a href="#cb828-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb828-15"><a href="#cb828-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- Threads are scheduled non-deterministically.</span></span>
<span id="cb828-16"><a href="#cb828-16" aria-hidden="true" tabindex="-1"></a><span class="ot">actions ::</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> <span class="dt">Account</span> <span class="ot">-&gt;</span> [<span class="dt">IO</span> <span class="dt">ThreadId</span>]</span>
<span id="cb828-17"><a href="#cb828-17" aria-hidden="true" tabindex="-1"></a>actions a b <span class="ot">=</span> <span class="fu">map</span> forkIO [</span>
<span id="cb828-18"><a href="#cb828-18" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- transfer to</span></span>
<span id="cb828-19"><a href="#cb828-19" aria-hidden="true" tabindex="-1"></a>       atomically (transfer a b <span class="dv">10</span>)</span>
<span id="cb828-20"><a href="#cb828-20" aria-hidden="true" tabindex="-1"></a>     , atomically (transfer a b (<span class="op">-</span><span class="dv">20</span>))</span>
<span id="cb828-21"><a href="#cb828-21" aria-hidden="true" tabindex="-1"></a>     , atomically (transfer a b <span class="dv">30</span>)</span>
<span id="cb828-22"><a href="#cb828-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb828-23"><a href="#cb828-23" aria-hidden="true" tabindex="-1"></a>     <span class="co">-- transfer back</span></span>
<span id="cb828-24"><a href="#cb828-24" aria-hidden="true" tabindex="-1"></a>     , atomically (transfer a b (<span class="op">-</span><span class="dv">30</span>))</span>
<span id="cb828-25"><a href="#cb828-25" aria-hidden="true" tabindex="-1"></a>     , atomically (transfer a b <span class="dv">20</span>)</span>
<span id="cb828-26"><a href="#cb828-26" aria-hidden="true" tabindex="-1"></a>     , atomically (transfer a b (<span class="op">-</span><span class="dv">10</span>))</span>
<span id="cb828-27"><a href="#cb828-27" aria-hidden="true" tabindex="-1"></a>   ]</span>
<span id="cb828-28"><a href="#cb828-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb828-29"><a href="#cb828-29" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb828-30"><a href="#cb828-30" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb828-31"><a href="#cb828-31" aria-hidden="true" tabindex="-1"></a>  accountA <span class="ot">&lt;-</span> atomically <span class="op">$</span> newTVar <span class="dv">60</span></span>
<span id="cb828-32"><a href="#cb828-32" aria-hidden="true" tabindex="-1"></a>  accountB <span class="ot">&lt;-</span> atomically <span class="op">$</span> newTVar <span class="dv">0</span></span>
<span id="cb828-33"><a href="#cb828-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb828-34"><a href="#cb828-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">sequence_</span> (actions accountA accountB)</span>
<span id="cb828-35"><a href="#cb828-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb828-36"><a href="#cb828-36" aria-hidden="true" tabindex="-1"></a>  balanceA <span class="ot">&lt;-</span> atomically <span class="op">$</span> readTVar accountA</span>
<span id="cb828-37"><a href="#cb828-37" aria-hidden="true" tabindex="-1"></a>  balanceB <span class="ot">&lt;-</span> atomically <span class="op">$</span> readTVar accountB</span>
<span id="cb828-38"><a href="#cb828-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb828-39"><a href="#cb828-39" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> balanceA <span class="op">==</span> <span class="dv">60</span></span>
<span id="cb828-40"><a href="#cb828-40" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> balanceB <span class="op">==</span> <span class="dv">0</span></span></code></pre></div>
<h2 id="monad-par">Monad Par</h2>
<p>Using the Par monad we express our computation as a data flow graph
which is scheduled in order of the connections between forked
computations which exchange resulting computations with
<code>IVar</code>.</p>
<div class="sourceCode" id="cb829"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb829-1"><a href="#cb829-1" aria-hidden="true" tabindex="-1"></a><span class="ot">new ::</span> <span class="dt">Par</span> (<span class="dt">IVar</span> a)</span>
<span id="cb829-2"><a href="#cb829-2" aria-hidden="true" tabindex="-1"></a><span class="ot">put ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">IVar</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Par</span> ()</span>
<span id="cb829-3"><a href="#cb829-3" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">IVar</span> a <span class="ot">-&gt;</span> <span class="dt">Par</span> a</span>
<span id="cb829-4"><a href="#cb829-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fork ::</span> <span class="dt">Par</span> () <span class="ot">-&gt;</span> <span class="dt">Par</span> ()</span>
<span id="cb829-5"><a href="#cb829-5" aria-hidden="true" tabindex="-1"></a><span class="ot">spawn ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">Par</span> a <span class="ot">-&gt;</span> <span class="dt">Par</span> (<span class="dt">IVar</span> a)</span></code></pre></div>
<p><img src="img/par.png" width="250" /></p>
<div class="sourceCode" id="cb830"
data-include="src/22-concurrency/par.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb830-1"><a href="#cb830-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE NoMonadFailDesugaring #-}</span></span>
<span id="cb830-2"><a href="#cb830-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb830-3"><a href="#cb830-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb830-4"><a href="#cb830-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Par</span></span>
<span id="cb830-5"><a href="#cb830-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb830-6"><a href="#cb830-6" aria-hidden="true" tabindex="-1"></a>f ,<span class="ot"> g ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb830-7"><a href="#cb830-7" aria-hidden="true" tabindex="-1"></a>f x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">10</span></span>
<span id="cb830-8"><a href="#cb830-8" aria-hidden="true" tabindex="-1"></a>g x <span class="ot">=</span> x <span class="op">*</span> <span class="dv">10</span></span>
<span id="cb830-9"><a href="#cb830-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb830-10"><a href="#cb830-10" aria-hidden="true" tabindex="-1"></a><span class="co">--   f x      g x</span></span>
<span id="cb830-11"><a href="#cb830-11" aria-hidden="true" tabindex="-1"></a><span class="co">--     \     /</span></span>
<span id="cb830-12"><a href="#cb830-12" aria-hidden="true" tabindex="-1"></a><span class="co">--      a + b</span></span>
<span id="cb830-13"><a href="#cb830-13" aria-hidden="true" tabindex="-1"></a><span class="co">--      /   \</span></span>
<span id="cb830-14"><a href="#cb830-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- f (a+b)  g (a+b)</span></span>
<span id="cb830-15"><a href="#cb830-15" aria-hidden="true" tabindex="-1"></a><span class="co">--      \   /</span></span>
<span id="cb830-16"><a href="#cb830-16" aria-hidden="true" tabindex="-1"></a><span class="co">--      (d,e)</span></span>
<span id="cb830-17"><a href="#cb830-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb830-18"><a href="#cb830-18" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb830-19"><a href="#cb830-19" aria-hidden="true" tabindex="-1"></a>example1 x <span class="ot">=</span> runPar <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb830-20"><a href="#cb830-20" aria-hidden="true" tabindex="-1"></a>  [a, b, c, d, e] <span class="ot">&lt;-</span> replicateM <span class="dv">5</span> new</span>
<span id="cb830-21"><a href="#cb830-21" aria-hidden="true" tabindex="-1"></a>  fork (put a (f x))</span>
<span id="cb830-22"><a href="#cb830-22" aria-hidden="true" tabindex="-1"></a>  fork (put b (g x))</span>
<span id="cb830-23"><a href="#cb830-23" aria-hidden="true" tabindex="-1"></a>  a&#39; <span class="ot">&lt;-</span> get a</span>
<span id="cb830-24"><a href="#cb830-24" aria-hidden="true" tabindex="-1"></a>  b&#39; <span class="ot">&lt;-</span> get b</span>
<span id="cb830-25"><a href="#cb830-25" aria-hidden="true" tabindex="-1"></a>  fork (put c (a&#39; <span class="op">+</span> b&#39;))</span>
<span id="cb830-26"><a href="#cb830-26" aria-hidden="true" tabindex="-1"></a>  c&#39; <span class="ot">&lt;-</span> get c</span>
<span id="cb830-27"><a href="#cb830-27" aria-hidden="true" tabindex="-1"></a>  fork (put d (f c&#39;))</span>
<span id="cb830-28"><a href="#cb830-28" aria-hidden="true" tabindex="-1"></a>  fork (put e (g c&#39;))</span>
<span id="cb830-29"><a href="#cb830-29" aria-hidden="true" tabindex="-1"></a>  d&#39; <span class="ot">&lt;-</span> get d</span>
<span id="cb830-30"><a href="#cb830-30" aria-hidden="true" tabindex="-1"></a>  e&#39; <span class="ot">&lt;-</span> get e</span>
<span id="cb830-31"><a href="#cb830-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (d&#39;, e&#39;)</span>
<span id="cb830-32"><a href="#cb830-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb830-33"><a href="#cb830-33" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> [<span class="dt">Int</span>]</span>
<span id="cb830-34"><a href="#cb830-34" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> runPar <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb830-35"><a href="#cb830-35" aria-hidden="true" tabindex="-1"></a>  xs <span class="ot">&lt;-</span> parMap (<span class="op">+</span> <span class="dv">1</span>) [<span class="dv">1</span> <span class="op">..</span> <span class="dv">25</span>]</span>
<span id="cb830-36"><a href="#cb830-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> xs</span>
<span id="cb830-37"><a href="#cb830-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb830-38"><a href="#cb830-38" aria-hidden="true" tabindex="-1"></a><span class="co">-- foldr (+) 0 (map (^2) [1..xs])</span></span>
<span id="cb830-39"><a href="#cb830-39" aria-hidden="true" tabindex="-1"></a><span class="ot">example3 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb830-40"><a href="#cb830-40" aria-hidden="true" tabindex="-1"></a>example3 n <span class="ot">=</span> runPar <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb830-41"><a href="#cb830-41" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="fu">range</span> <span class="ot">=</span> (<span class="dt">InclusiveRange</span> <span class="dv">1</span> n)</span>
<span id="cb830-42"><a href="#cb830-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mapper x <span class="ot">=</span> <span class="fu">return</span> (x <span class="op">^</span> <span class="dv">2</span>)</span>
<span id="cb830-43"><a href="#cb830-43" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> reducer x y <span class="ot">=</span> <span class="fu">return</span> (x <span class="op">+</span> y)</span>
<span id="cb830-44"><a href="#cb830-44" aria-hidden="true" tabindex="-1"></a>  parMapReduceRangeThresh <span class="dv">10</span> <span class="fu">range</span> mapper reducer <span class="dv">0</span></span></code></pre></div>
<h2 id="async">Async</h2>
<p>Async is a higher level set of functions that work on top of
Control.Concurrent and STM.</p>
<div class="sourceCode" id="cb831"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb831-1"><a href="#cb831-1" aria-hidden="true" tabindex="-1"></a><span class="ot">async ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Async</span> a)</span>
<span id="cb831-2"><a href="#cb831-2" aria-hidden="true" tabindex="-1"></a><span class="ot">wait ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb831-3"><a href="#cb831-3" aria-hidden="true" tabindex="-1"></a><span class="ot">cancel ::</span> <span class="dt">Async</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb831-4"><a href="#cb831-4" aria-hidden="true" tabindex="-1"></a><span class="ot">concurrently ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> (a, b)</span>
<span id="cb831-5"><a href="#cb831-5" aria-hidden="true" tabindex="-1"></a><span class="ot">race ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> a b)</span></code></pre></div>
<div class="sourceCode" id="cb832"
data-include="src/22-concurrency/async.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb832-1"><a href="#cb832-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb832-2"><a href="#cb832-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb832-3"><a href="#cb832-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb832-4"><a href="#cb832-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent.Async</span></span>
<span id="cb832-5"><a href="#cb832-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Time</span></span>
<span id="cb832-6"><a href="#cb832-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb832-7"><a href="#cb832-7" aria-hidden="true" tabindex="-1"></a><span class="ot">timeit ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (a,<span class="dt">Double</span>)</span>
<span id="cb832-8"><a href="#cb832-8" aria-hidden="true" tabindex="-1"></a>timeit io <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb832-9"><a href="#cb832-9" aria-hidden="true" tabindex="-1"></a>  t0 <span class="ot">&lt;-</span> getCurrentTime</span>
<span id="cb832-10"><a href="#cb832-10" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> io</span>
<span id="cb832-11"><a href="#cb832-11" aria-hidden="true" tabindex="-1"></a>  t1 <span class="ot">&lt;-</span> getCurrentTime</span>
<span id="cb832-12"><a href="#cb832-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (a, <span class="fu">realToFrac</span> (t1 <span class="ot">`diffUTCTime`</span> t0))</span>
<span id="cb832-13"><a href="#cb832-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb832-14"><a href="#cb832-14" aria-hidden="true" tabindex="-1"></a><span class="ot">worker ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb832-15"><a href="#cb832-15" aria-hidden="true" tabindex="-1"></a>worker n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb832-16"><a href="#cb832-16" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- simulate some work</span></span>
<span id="cb832-17"><a href="#cb832-17" aria-hidden="true" tabindex="-1"></a>  threadDelay (<span class="dv">10</span><span class="op">^</span><span class="dv">2</span> <span class="op">*</span> n)</span>
<span id="cb832-18"><a href="#cb832-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (n <span class="op">*</span> n)</span>
<span id="cb832-19"><a href="#cb832-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb832-20"><a href="#cb832-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- Spawn 2 threads in parallel, halt on both finished.</span></span>
<span id="cb832-21"><a href="#cb832-21" aria-hidden="true" tabindex="-1"></a><span class="ot">test1 ::</span> <span class="dt">IO</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb832-22"><a href="#cb832-22" aria-hidden="true" tabindex="-1"></a>test1 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb832-23"><a href="#cb832-23" aria-hidden="true" tabindex="-1"></a>  val1 <span class="ot">&lt;-</span> async <span class="op">$</span> worker <span class="dv">1000</span></span>
<span id="cb832-24"><a href="#cb832-24" aria-hidden="true" tabindex="-1"></a>  val2 <span class="ot">&lt;-</span> async <span class="op">$</span> worker <span class="dv">2000</span></span>
<span id="cb832-25"><a href="#cb832-25" aria-hidden="true" tabindex="-1"></a>  (,) <span class="op">&lt;$&gt;</span> wait val1 <span class="op">&lt;*&gt;</span> wait val2</span>
<span id="cb832-26"><a href="#cb832-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb832-27"><a href="#cb832-27" aria-hidden="true" tabindex="-1"></a><span class="co">-- Spawn 2 threads in parallel, halt on first finished.</span></span>
<span id="cb832-28"><a href="#cb832-28" aria-hidden="true" tabindex="-1"></a><span class="ot">test2 ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">Int</span> <span class="dt">Int</span>)</span>
<span id="cb832-29"><a href="#cb832-29" aria-hidden="true" tabindex="-1"></a>test2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb832-30"><a href="#cb832-30" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> val1 <span class="ot">=</span> worker <span class="dv">1000</span></span>
<span id="cb832-31"><a href="#cb832-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> val2 <span class="ot">=</span> worker <span class="dv">2000</span></span>
<span id="cb832-32"><a href="#cb832-32" aria-hidden="true" tabindex="-1"></a>  race val1 val2</span>
<span id="cb832-33"><a href="#cb832-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb832-34"><a href="#cb832-34" aria-hidden="true" tabindex="-1"></a><span class="co">-- Spawn 10000 threads in parallel, halt on all finished.</span></span>
<span id="cb832-35"><a href="#cb832-35" aria-hidden="true" tabindex="-1"></a><span class="ot">test3 ::</span> <span class="dt">IO</span> [<span class="dt">Int</span>]</span>
<span id="cb832-36"><a href="#cb832-36" aria-hidden="true" tabindex="-1"></a>test3 <span class="ot">=</span> mapConcurrently worker [<span class="dv">0</span><span class="op">..</span><span class="dv">10000</span>]</span>
<span id="cb832-37"><a href="#cb832-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb832-38"><a href="#cb832-38" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb832-39"><a href="#cb832-39" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb832-40"><a href="#cb832-40" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">=&lt;&lt;</span> timeit test1</span>
<span id="cb832-41"><a href="#cb832-41" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">=&lt;&lt;</span> timeit test2</span>
<span id="cb832-42"><a href="#cb832-42" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">=&lt;&lt;</span> timeit test3</span></code></pre></div>
<hr/>
<h1 id="parsing">Parsing</h1>
<p>Parser combinators were originally developed in the Haskell
programming language and the last 10 years have seen a massive amount of
refinement and improvements on parser combinator libraries. Today
Haskell has an amazing parser ecosystem.</p>
<h2 id="parsec">Parsec</h2>
<p>For parsing in Haskell it is quite common to use a family of
libraries known as <em>Parser Combinators</em> which let us write code
to generate parsers which construct themselves from an abstract
description of the grammar described with combinators.</p>
<table>
<thead>
<tr class="header">
<th></th>
<th style="text-align: left;">Combinators</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&lt;|&gt;</code></td>
<td style="text-align: left;">The choice operator tries to parse the
first argument before proceeding to the second.</td>
</tr>
<tr class="even">
<td><code>many</code></td>
<td style="text-align: left;">Consumes an arbitrary number of
expressions matching the given pattern and returns them as a list.</td>
</tr>
<tr class="odd">
<td><code>many1</code></td>
<td style="text-align: left;">Like many but requires at least one
match.</td>
</tr>
<tr class="even">
<td><code>optional</code></td>
<td style="text-align: left;">Optionally parses a given pattern
returning its value as a Maybe.</td>
</tr>
<tr class="odd">
<td><code>try</code></td>
<td style="text-align: left;">Backtracking operator will let us parse
ambiguous matching expressions and restart with a different
pattern.</td>
</tr>
</tbody>
</table>
<p><code>&lt;|&gt;</code> can be chained sequentially to generate a
sequence of options.</p>
<p>There are two styles of writing Parsec, one can choose to write with
monads or with applicatives.</p>
<div class="sourceCode" id="cb833"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb833-1"><a href="#cb833-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseM ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb833-2"><a href="#cb833-2" aria-hidden="true" tabindex="-1"></a>parseM <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb833-3"><a href="#cb833-3" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> identifier</span>
<span id="cb833-4"><a href="#cb833-4" aria-hidden="true" tabindex="-1"></a>  char <span class="ch">&#39;+&#39;</span></span>
<span id="cb833-5"><a href="#cb833-5" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> identifier</span>
<span id="cb833-6"><a href="#cb833-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Add</span> a b</span></code></pre></div>
<p>The same code written with applicatives uses the applicative
combinators:</p>
<div class="sourceCode" id="cb834"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb834-1"><a href="#cb834-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Sequential application.</span></span>
<span id="cb834-2"><a href="#cb834-2" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span>
<span id="cb834-3"><a href="#cb834-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb834-4"><a href="#cb834-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Sequence actions, discarding the value of the first argument.</span></span>
<span id="cb834-5"><a href="#cb834-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(*&gt;) ::</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f b</span>
<span id="cb834-6"><a href="#cb834-6" aria-hidden="true" tabindex="-1"></a>(<span class="op">*&gt;</span>) <span class="ot">=</span> liftA2 (<span class="fu">const</span> <span class="fu">id</span>)</span>
<span id="cb834-7"><a href="#cb834-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb834-8"><a href="#cb834-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Sequence actions, discarding the value of the second argument.</span></span>
<span id="cb834-9"><a href="#cb834-9" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;*) ::</span> f a <span class="ot">-&gt;</span> f b <span class="ot">-&gt;</span> f a</span>
<span id="cb834-10"><a href="#cb834-10" aria-hidden="true" tabindex="-1"></a>(<span class="op">&lt;*</span>) <span class="ot">=</span> liftA2 <span class="fu">const</span></span></code></pre></div>
<div class="sourceCode" id="cb835"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb835-1"><a href="#cb835-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseA ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb835-2"><a href="#cb835-2" aria-hidden="true" tabindex="-1"></a>parseA <span class="ot">=</span> <span class="dt">Add</span> <span class="op">&lt;$&gt;</span> identifier <span class="op">&lt;*</span> char <span class="ch">&#39;+&#39;</span> <span class="op">&lt;*&gt;</span> identifier</span></code></pre></div>
<p>Now for instance if we want to parse simple lambda expressions we can
encode the parser logic as compositions of these combinators which yield
the string parser when evaluated with <code>parse</code>.</p>
<div class="sourceCode" id="cb836"
data-include="src/24-parsing/simple_parser.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb836-1"><a href="#cb836-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec</span></span>
<span id="cb836-2"><a href="#cb836-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec.String</span></span>
<span id="cb836-3"><a href="#cb836-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb836-4"><a href="#cb836-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb836-5"><a href="#cb836-5" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Char</span></span>
<span id="cb836-6"><a href="#cb836-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Char</span> <span class="dt">Expr</span></span>
<span id="cb836-7"><a href="#cb836-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb836-8"><a href="#cb836-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb836-9"><a href="#cb836-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb836-10"><a href="#cb836-10" aria-hidden="true" tabindex="-1"></a><span class="ot">lam ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb836-11"><a href="#cb836-11" aria-hidden="true" tabindex="-1"></a>lam <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb836-12"><a href="#cb836-12" aria-hidden="true" tabindex="-1"></a>  char <span class="ch">&#39;\\&#39;</span></span>
<span id="cb836-13"><a href="#cb836-13" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> letter</span>
<span id="cb836-14"><a href="#cb836-14" aria-hidden="true" tabindex="-1"></a>  string <span class="st">&quot;-&gt;&quot;</span></span>
<span id="cb836-15"><a href="#cb836-15" aria-hidden="true" tabindex="-1"></a>  e <span class="ot">&lt;-</span> expr</span>
<span id="cb836-16"><a href="#cb836-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Lam</span> n e</span>
<span id="cb836-17"><a href="#cb836-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb836-18"><a href="#cb836-18" aria-hidden="true" tabindex="-1"></a><span class="ot">app ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb836-19"><a href="#cb836-19" aria-hidden="true" tabindex="-1"></a>app <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb836-20"><a href="#cb836-20" aria-hidden="true" tabindex="-1"></a>  apps <span class="ot">&lt;-</span> many1 term</span>
<span id="cb836-21"><a href="#cb836-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">foldl1</span> <span class="dt">App</span> apps</span>
<span id="cb836-22"><a href="#cb836-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb836-23"><a href="#cb836-23" aria-hidden="true" tabindex="-1"></a><span class="ot">var ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb836-24"><a href="#cb836-24" aria-hidden="true" tabindex="-1"></a>var <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb836-25"><a href="#cb836-25" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> letter</span>
<span id="cb836-26"><a href="#cb836-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Var</span> n</span>
<span id="cb836-27"><a href="#cb836-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb836-28"><a href="#cb836-28" aria-hidden="true" tabindex="-1"></a><span class="ot">parens ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb836-29"><a href="#cb836-29" aria-hidden="true" tabindex="-1"></a>parens p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb836-30"><a href="#cb836-30" aria-hidden="true" tabindex="-1"></a>  char <span class="ch">&#39;(&#39;</span></span>
<span id="cb836-31"><a href="#cb836-31" aria-hidden="true" tabindex="-1"></a>  e <span class="ot">&lt;-</span> p</span>
<span id="cb836-32"><a href="#cb836-32" aria-hidden="true" tabindex="-1"></a>  char <span class="ch">&#39;)&#39;</span></span>
<span id="cb836-33"><a href="#cb836-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> e</span>
<span id="cb836-34"><a href="#cb836-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb836-35"><a href="#cb836-35" aria-hidden="true" tabindex="-1"></a><span class="ot">term ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb836-36"><a href="#cb836-36" aria-hidden="true" tabindex="-1"></a>term <span class="ot">=</span> var <span class="op">&lt;|&gt;</span> parens expr</span>
<span id="cb836-37"><a href="#cb836-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb836-38"><a href="#cb836-38" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb836-39"><a href="#cb836-39" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> lam <span class="op">&lt;|&gt;</span> app</span>
<span id="cb836-40"><a href="#cb836-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb836-41"><a href="#cb836-41" aria-hidden="true" tabindex="-1"></a><span class="ot">decl ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb836-42"><a href="#cb836-42" aria-hidden="true" tabindex="-1"></a>decl <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb836-43"><a href="#cb836-43" aria-hidden="true" tabindex="-1"></a>  e <span class="ot">&lt;-</span> expr</span>
<span id="cb836-44"><a href="#cb836-44" aria-hidden="true" tabindex="-1"></a>  eof</span>
<span id="cb836-45"><a href="#cb836-45" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> e</span>
<span id="cb836-46"><a href="#cb836-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb836-47"><a href="#cb836-47" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">IO</span> ()</span>
<span id="cb836-48"><a href="#cb836-48" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> parseTest decl <span class="st">&quot;\\y-&gt;y(\\x-&gt;x)y&quot;</span></span>
<span id="cb836-49"><a href="#cb836-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb836-50"><a href="#cb836-50" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb836-51"><a href="#cb836-51" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> test <span class="op">&gt;&gt;=</span> <span class="fu">print</span></span></code></pre></div>
<h2 id="custom-lexer">Custom Lexer</h2>
<p>In our previous example a lexing pass was not necessary because each
lexeme mapped to a sequential collection of characters in the stream
type. If we wanted to extend this parser with a non-trivial set of
tokens, then Parsec provides us with a set of functions for defining
lexers and integrating these with the parser combinators. The simplest
example builds on top of the builtin Parsec language definitions which
define a set of most common lexical schemes.</p>
<p>For instance we’ll build on top of the empty language grammar on top
of the haskellDef grammar that uses the Text token instead of
string.</p>
<div class="sourceCode" id="cb837"
data-include="src/24-parsing/lexer_text.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb837-1"><a href="#cb837-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb837-2"><a href="#cb837-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-3"><a href="#cb837-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec</span></span>
<span id="cb837-4"><a href="#cb837-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec.Text</span></span>
<span id="cb837-5"><a href="#cb837-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Parsec.Token</span> <span class="kw">as</span> <span class="dt">Tok</span></span>
<span id="cb837-6"><a href="#cb837-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Parsec.Language</span> <span class="kw">as</span> <span class="dt">Lang</span></span>
<span id="cb837-7"><a href="#cb837-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-8"><a href="#cb837-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Functor.Identity</span> (<span class="dt">Identity</span>)</span>
<span id="cb837-9"><a href="#cb837-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb837-10"><a href="#cb837-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">TIO</span></span>
<span id="cb837-11"><a href="#cb837-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-12"><a href="#cb837-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb837-13"><a href="#cb837-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">T.Text</span></span>
<span id="cb837-14"><a href="#cb837-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb837-15"><a href="#cb837-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">T.Text</span> <span class="dt">Expr</span></span>
<span id="cb837-16"><a href="#cb837-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb837-17"><a href="#cb837-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-18"><a href="#cb837-18" aria-hidden="true" tabindex="-1"></a><span class="ot">lexer ::</span> <span class="dt">Tok.GenTokenParser</span> <span class="dt">T.Text</span> () <span class="dt">Identity</span></span>
<span id="cb837-19"><a href="#cb837-19" aria-hidden="true" tabindex="-1"></a>lexer <span class="ot">=</span> Tok.makeTokenParser style</span>
<span id="cb837-20"><a href="#cb837-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-21"><a href="#cb837-21" aria-hidden="true" tabindex="-1"></a><span class="ot">style ::</span> <span class="dt">Tok.GenLanguageDef</span> <span class="dt">T.Text</span> () <span class="dt">Identity</span></span>
<span id="cb837-22"><a href="#cb837-22" aria-hidden="true" tabindex="-1"></a>style <span class="ot">=</span> Lang.emptyDef</span>
<span id="cb837-23"><a href="#cb837-23" aria-hidden="true" tabindex="-1"></a>  { Tok.commentStart    <span class="ot">=</span> <span class="st">&quot;{-&quot;</span></span>
<span id="cb837-24"><a href="#cb837-24" aria-hidden="true" tabindex="-1"></a>  , Tok.commentEnd      <span class="ot">=</span> <span class="st">&quot;-}&quot;</span></span>
<span id="cb837-25"><a href="#cb837-25" aria-hidden="true" tabindex="-1"></a>  , Tok.commentLine     <span class="ot">=</span> <span class="st">&quot;--&quot;</span></span>
<span id="cb837-26"><a href="#cb837-26" aria-hidden="true" tabindex="-1"></a>  , Tok.nestedComments  <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb837-27"><a href="#cb837-27" aria-hidden="true" tabindex="-1"></a>  , Tok.identStart      <span class="ot">=</span> letter</span>
<span id="cb837-28"><a href="#cb837-28" aria-hidden="true" tabindex="-1"></a>  , Tok.identLetter     <span class="ot">=</span> alphaNum <span class="op">&lt;|&gt;</span> oneOf <span class="st">&quot;_&#39;&quot;</span></span>
<span id="cb837-29"><a href="#cb837-29" aria-hidden="true" tabindex="-1"></a>  , Tok.opStart         <span class="ot">=</span> Tok.opLetter style</span>
<span id="cb837-30"><a href="#cb837-30" aria-hidden="true" tabindex="-1"></a>  , Tok.opLetter        <span class="ot">=</span> oneOf <span class="st">&quot;:!#$%&amp;*+./&lt;=&gt;?@\\^|-~&quot;</span></span>
<span id="cb837-31"><a href="#cb837-31" aria-hidden="true" tabindex="-1"></a>  , Tok.reservedOpNames <span class="ot">=</span> []</span>
<span id="cb837-32"><a href="#cb837-32" aria-hidden="true" tabindex="-1"></a>  , Tok.reservedNames   <span class="ot">=</span> []</span>
<span id="cb837-33"><a href="#cb837-33" aria-hidden="true" tabindex="-1"></a>  , Tok.caseSensitive   <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb837-34"><a href="#cb837-34" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb837-35"><a href="#cb837-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-36"><a href="#cb837-36" aria-hidden="true" tabindex="-1"></a><span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb837-37"><a href="#cb837-37" aria-hidden="true" tabindex="-1"></a>parens <span class="ot">=</span> Tok.parens lexer</span>
<span id="cb837-38"><a href="#cb837-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-39"><a href="#cb837-39" aria-hidden="true" tabindex="-1"></a><span class="ot">reservedOp ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()</span>
<span id="cb837-40"><a href="#cb837-40" aria-hidden="true" tabindex="-1"></a>reservedOp op <span class="ot">=</span> Tok.reservedOp lexer (T.unpack op)</span>
<span id="cb837-41"><a href="#cb837-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-42"><a href="#cb837-42" aria-hidden="true" tabindex="-1"></a><span class="ot">ident ::</span> <span class="dt">Parser</span> <span class="dt">T.Text</span></span>
<span id="cb837-43"><a href="#cb837-43" aria-hidden="true" tabindex="-1"></a>ident <span class="ot">=</span> T.pack <span class="op">&lt;$&gt;</span> Tok.identifier lexer</span>
<span id="cb837-44"><a href="#cb837-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-45"><a href="#cb837-45" aria-hidden="true" tabindex="-1"></a><span class="ot">contents ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb837-46"><a href="#cb837-46" aria-hidden="true" tabindex="-1"></a>contents p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb837-47"><a href="#cb837-47" aria-hidden="true" tabindex="-1"></a>  Tok.whiteSpace lexer</span>
<span id="cb837-48"><a href="#cb837-48" aria-hidden="true" tabindex="-1"></a>  r <span class="ot">&lt;-</span> p</span>
<span id="cb837-49"><a href="#cb837-49" aria-hidden="true" tabindex="-1"></a>  eof</span>
<span id="cb837-50"><a href="#cb837-50" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> r</span>
<span id="cb837-51"><a href="#cb837-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-52"><a href="#cb837-52" aria-hidden="true" tabindex="-1"></a><span class="ot">var ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb837-53"><a href="#cb837-53" aria-hidden="true" tabindex="-1"></a>var <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb837-54"><a href="#cb837-54" aria-hidden="true" tabindex="-1"></a>  var <span class="ot">&lt;-</span> ident</span>
<span id="cb837-55"><a href="#cb837-55" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">Var</span> var )</span>
<span id="cb837-56"><a href="#cb837-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-57"><a href="#cb837-57" aria-hidden="true" tabindex="-1"></a><span class="ot">app ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb837-58"><a href="#cb837-58" aria-hidden="true" tabindex="-1"></a>app <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb837-59"><a href="#cb837-59" aria-hidden="true" tabindex="-1"></a>  e1 <span class="ot">&lt;-</span> expr</span>
<span id="cb837-60"><a href="#cb837-60" aria-hidden="true" tabindex="-1"></a>  e2 <span class="ot">&lt;-</span> expr</span>
<span id="cb837-61"><a href="#cb837-61" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">App</span> e1 e2)</span>
<span id="cb837-62"><a href="#cb837-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-63"><a href="#cb837-63" aria-hidden="true" tabindex="-1"></a><span class="ot">fun ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb837-64"><a href="#cb837-64" aria-hidden="true" tabindex="-1"></a>fun <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb837-65"><a href="#cb837-65" aria-hidden="true" tabindex="-1"></a>  reservedOp <span class="st">&quot;\\&quot;</span></span>
<span id="cb837-66"><a href="#cb837-66" aria-hidden="true" tabindex="-1"></a>  binder <span class="ot">&lt;-</span> ident</span>
<span id="cb837-67"><a href="#cb837-67" aria-hidden="true" tabindex="-1"></a>  reservedOp <span class="st">&quot;.&quot;</span></span>
<span id="cb837-68"><a href="#cb837-68" aria-hidden="true" tabindex="-1"></a>  rhs <span class="ot">&lt;-</span> expr</span>
<span id="cb837-69"><a href="#cb837-69" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">Lam</span> binder rhs)</span>
<span id="cb837-70"><a href="#cb837-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-71"><a href="#cb837-71" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb837-72"><a href="#cb837-72" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb837-73"><a href="#cb837-73" aria-hidden="true" tabindex="-1"></a>  es <span class="ot">&lt;-</span> many1 aexp</span>
<span id="cb837-74"><a href="#cb837-74" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="fu">foldl1</span> <span class="dt">App</span> es)</span>
<span id="cb837-75"><a href="#cb837-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-76"><a href="#cb837-76" aria-hidden="true" tabindex="-1"></a><span class="ot">aexp ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb837-77"><a href="#cb837-77" aria-hidden="true" tabindex="-1"></a>aexp <span class="ot">=</span> fun <span class="op">&lt;|&gt;</span> var <span class="op">&lt;|&gt;</span> (parens expr)</span>
<span id="cb837-78"><a href="#cb837-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-79"><a href="#cb837-79" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> <span class="dt">Expr</span></span>
<span id="cb837-80"><a href="#cb837-80" aria-hidden="true" tabindex="-1"></a>test <span class="ot">=</span> parse (contents expr) <span class="st">&quot;&lt;stdin&gt;&quot;</span></span>
<span id="cb837-81"><a href="#cb837-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-82"><a href="#cb837-82" aria-hidden="true" tabindex="-1"></a><span class="ot">repl ::</span> <span class="dt">IO</span> ()</span>
<span id="cb837-83"><a href="#cb837-83" aria-hidden="true" tabindex="-1"></a>repl <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb837-84"><a href="#cb837-84" aria-hidden="true" tabindex="-1"></a>  str <span class="ot">&lt;-</span> TIO.getLine</span>
<span id="cb837-85"><a href="#cb837-85" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (test str)</span>
<span id="cb837-86"><a href="#cb837-86" aria-hidden="true" tabindex="-1"></a>  repl</span>
<span id="cb837-87"><a href="#cb837-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb837-88"><a href="#cb837-88" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb837-89"><a href="#cb837-89" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> repl</span></code></pre></div>
<p>See: <a
href="https://hackage.haskell.org/package/parsec-3.1.9/docs/Text-Parsec-Language.html">Text.Parsec.Language</a></p>
<h2 id="simple-parsing">Simple Parsing</h2>
<p>Putting our lexer and parser together we can write down a more robust
parser for our little lambda calculus syntax.</p>
<div class="sourceCode" id="cb838"
data-include="src/24-parsing/parser.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb838-1"><a href="#cb838-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Parser</span> (parseExpr) <span class="kw">where</span></span>
<span id="cb838-2"><a href="#cb838-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-3"><a href="#cb838-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec</span></span>
<span id="cb838-4"><a href="#cb838-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec.String</span> (<span class="dt">Parser</span>)</span>
<span id="cb838-5"><a href="#cb838-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec.Language</span> (haskellStyle)</span>
<span id="cb838-6"><a href="#cb838-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-7"><a href="#cb838-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Parsec.Expr</span> <span class="kw">as</span> <span class="dt">Ex</span></span>
<span id="cb838-8"><a href="#cb838-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Parsec.Token</span> <span class="kw">as</span> <span class="dt">Tok</span></span>
<span id="cb838-9"><a href="#cb838-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-10"><a href="#cb838-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Id</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb838-11"><a href="#cb838-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-12"><a href="#cb838-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb838-13"><a href="#cb838-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Lam</span> <span class="dt">Id</span> <span class="dt">Expr</span></span>
<span id="cb838-14"><a href="#cb838-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb838-15"><a href="#cb838-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Var</span> <span class="dt">Id</span></span>
<span id="cb838-16"><a href="#cb838-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Num</span> <span class="dt">Int</span></span>
<span id="cb838-17"><a href="#cb838-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Op</span>  <span class="dt">Binop</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb838-18"><a href="#cb838-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb838-19"><a href="#cb838-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-20"><a href="#cb838-20" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Binop</span> <span class="ot">=</span> <span class="dt">Add</span> <span class="op">|</span> <span class="dt">Sub</span> <span class="op">|</span> <span class="dt">Mul</span> <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb838-21"><a href="#cb838-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-22"><a href="#cb838-22" aria-hidden="true" tabindex="-1"></a><span class="ot">lexer ::</span> <span class="dt">Tok.TokenParser</span> ()</span>
<span id="cb838-23"><a href="#cb838-23" aria-hidden="true" tabindex="-1"></a>lexer <span class="ot">=</span> Tok.makeTokenParser style</span>
<span id="cb838-24"><a href="#cb838-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> ops <span class="ot">=</span> [<span class="st">&quot;-&gt;&quot;</span>,<span class="st">&quot;\\&quot;</span>,<span class="st">&quot;+&quot;</span>,<span class="st">&quot;*&quot;</span>,<span class="st">&quot;-&quot;</span>,<span class="st">&quot;=&quot;</span>]</span>
<span id="cb838-25"><a href="#cb838-25" aria-hidden="true" tabindex="-1"></a>        style <span class="ot">=</span> haskellStyle {Tok.reservedOpNames <span class="ot">=</span> ops }</span>
<span id="cb838-26"><a href="#cb838-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-27"><a href="#cb838-27" aria-hidden="true" tabindex="-1"></a><span class="ot">reservedOp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()</span>
<span id="cb838-28"><a href="#cb838-28" aria-hidden="true" tabindex="-1"></a>reservedOp <span class="ot">=</span> Tok.reservedOp lexer</span>
<span id="cb838-29"><a href="#cb838-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-30"><a href="#cb838-30" aria-hidden="true" tabindex="-1"></a><span class="ot">identifier ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb838-31"><a href="#cb838-31" aria-hidden="true" tabindex="-1"></a>identifier <span class="ot">=</span> Tok.identifier lexer</span>
<span id="cb838-32"><a href="#cb838-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-33"><a href="#cb838-33" aria-hidden="true" tabindex="-1"></a><span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb838-34"><a href="#cb838-34" aria-hidden="true" tabindex="-1"></a>parens <span class="ot">=</span> Tok.parens lexer</span>
<span id="cb838-35"><a href="#cb838-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-36"><a href="#cb838-36" aria-hidden="true" tabindex="-1"></a><span class="ot">contents ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb838-37"><a href="#cb838-37" aria-hidden="true" tabindex="-1"></a>contents p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb838-38"><a href="#cb838-38" aria-hidden="true" tabindex="-1"></a>  Tok.whiteSpace lexer</span>
<span id="cb838-39"><a href="#cb838-39" aria-hidden="true" tabindex="-1"></a>  r <span class="ot">&lt;-</span> p</span>
<span id="cb838-40"><a href="#cb838-40" aria-hidden="true" tabindex="-1"></a>  eof</span>
<span id="cb838-41"><a href="#cb838-41" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> r</span>
<span id="cb838-42"><a href="#cb838-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-43"><a href="#cb838-43" aria-hidden="true" tabindex="-1"></a><span class="ot">natural ::</span> <span class="dt">Parser</span> <span class="dt">Integer</span></span>
<span id="cb838-44"><a href="#cb838-44" aria-hidden="true" tabindex="-1"></a>natural <span class="ot">=</span> Tok.natural lexer</span>
<span id="cb838-45"><a href="#cb838-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-46"><a href="#cb838-46" aria-hidden="true" tabindex="-1"></a><span class="ot">variable ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb838-47"><a href="#cb838-47" aria-hidden="true" tabindex="-1"></a>variable <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb838-48"><a href="#cb838-48" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> identifier</span>
<span id="cb838-49"><a href="#cb838-49" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">Var</span> x)</span>
<span id="cb838-50"><a href="#cb838-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-51"><a href="#cb838-51" aria-hidden="true" tabindex="-1"></a><span class="ot">number ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb838-52"><a href="#cb838-52" aria-hidden="true" tabindex="-1"></a>number <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb838-53"><a href="#cb838-53" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> natural</span>
<span id="cb838-54"><a href="#cb838-54" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">Num</span> (<span class="fu">fromIntegral</span> n))</span>
<span id="cb838-55"><a href="#cb838-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-56"><a href="#cb838-56" aria-hidden="true" tabindex="-1"></a><span class="ot">lambda ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb838-57"><a href="#cb838-57" aria-hidden="true" tabindex="-1"></a>lambda <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb838-58"><a href="#cb838-58" aria-hidden="true" tabindex="-1"></a>  reservedOp <span class="st">&quot;\\&quot;</span></span>
<span id="cb838-59"><a href="#cb838-59" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> identifier</span>
<span id="cb838-60"><a href="#cb838-60" aria-hidden="true" tabindex="-1"></a>  reservedOp <span class="st">&quot;-&gt;&quot;</span></span>
<span id="cb838-61"><a href="#cb838-61" aria-hidden="true" tabindex="-1"></a>  e <span class="ot">&lt;-</span> expr</span>
<span id="cb838-62"><a href="#cb838-62" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">Lam</span> x e)</span>
<span id="cb838-63"><a href="#cb838-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-64"><a href="#cb838-64" aria-hidden="true" tabindex="-1"></a><span class="ot">aexp ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb838-65"><a href="#cb838-65" aria-hidden="true" tabindex="-1"></a>aexp <span class="ot">=</span>  parens expr</span>
<span id="cb838-66"><a href="#cb838-66" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> variable</span>
<span id="cb838-67"><a href="#cb838-67" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> number</span>
<span id="cb838-68"><a href="#cb838-68" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> lambda</span>
<span id="cb838-69"><a href="#cb838-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-70"><a href="#cb838-70" aria-hidden="true" tabindex="-1"></a><span class="ot">term ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb838-71"><a href="#cb838-71" aria-hidden="true" tabindex="-1"></a>term <span class="ot">=</span> Ex.buildExpressionParser table aexp</span>
<span id="cb838-72"><a href="#cb838-72" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> infixOp x f <span class="ot">=</span> <span class="dt">Ex.Infix</span> (reservedOp x <span class="op">&gt;&gt;</span> <span class="fu">return</span> f)</span>
<span id="cb838-73"><a href="#cb838-73" aria-hidden="true" tabindex="-1"></a>        table <span class="ot">=</span> [[infixOp <span class="st">&quot;*&quot;</span> (<span class="dt">Op</span> <span class="dt">Mul</span>) <span class="dt">Ex.AssocLeft</span>],</span>
<span id="cb838-74"><a href="#cb838-74" aria-hidden="true" tabindex="-1"></a>                 [infixOp <span class="st">&quot;+&quot;</span> (<span class="dt">Op</span> <span class="dt">Add</span>) <span class="dt">Ex.AssocLeft</span>]]</span>
<span id="cb838-75"><a href="#cb838-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-76"><a href="#cb838-76" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb838-77"><a href="#cb838-77" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb838-78"><a href="#cb838-78" aria-hidden="true" tabindex="-1"></a>  es <span class="ot">&lt;-</span> many1 term</span>
<span id="cb838-79"><a href="#cb838-79" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="fu">foldl1</span> <span class="dt">App</span> es)</span>
<span id="cb838-80"><a href="#cb838-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-81"><a href="#cb838-81" aria-hidden="true" tabindex="-1"></a><span class="ot">parseExpr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb838-82"><a href="#cb838-82" aria-hidden="true" tabindex="-1"></a>parseExpr input <span class="ot">=</span></span>
<span id="cb838-83"><a href="#cb838-83" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> parse (contents expr) <span class="st">&quot;&lt;stdin&gt;&quot;</span> input <span class="kw">of</span></span>
<span id="cb838-84"><a href="#cb838-84" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="fu">error</span> (<span class="fu">show</span> err)</span>
<span id="cb838-85"><a href="#cb838-85" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> ast <span class="ot">-&gt;</span> ast</span>
<span id="cb838-86"><a href="#cb838-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb838-87"><a href="#cb838-87" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb838-88"><a href="#cb838-88" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> <span class="fu">print</span> <span class="op">.</span> parseExpr <span class="op">&gt;&gt;</span> main</span></code></pre></div>
<p>Trying it out:</p>
<div class="sourceCode" id="cb839"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb839-1"><a href="#cb839-1" aria-hidden="true" tabindex="-1"></a><span class="ex">λ:</span> runhaskell simpleparser.hs</span>
<span id="cb839-2"><a href="#cb839-2" aria-hidden="true" tabindex="-1"></a><span class="ex">1+2</span></span>
<span id="cb839-3"><a href="#cb839-3" aria-hidden="true" tabindex="-1"></a><span class="ex">Op</span> Add <span class="er">(</span><span class="ex">Num</span> 1<span class="kw">)</span> <span class="kw">(</span><span class="ex">Num</span> 2<span class="kw">)</span></span>
<span id="cb839-4"><a href="#cb839-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb839-5"><a href="#cb839-5" aria-hidden="true" tabindex="-1"></a><span class="ex">\i</span> <span class="at">-</span><span class="op">&gt;</span> <span class="dt">\x</span> <span class="at">-</span><span class="op">&gt;</span> x</span>
<span id="cb839-6"><a href="#cb839-6" aria-hidden="true" tabindex="-1"></a><span class="ex">Lam</span> <span class="st">&quot;i&quot;</span> <span class="er">(</span><span class="ex">Lam</span> <span class="st">&quot;x&quot;</span> <span class="er">(</span><span class="ex">Var</span> <span class="st">&quot;x&quot;</span><span class="kw">))</span></span>
<span id="cb839-7"><a href="#cb839-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb839-8"><a href="#cb839-8" aria-hidden="true" tabindex="-1"></a><span class="ex">\s</span> <span class="at">-</span><span class="op">&gt;</span> <span class="dt">\f</span> <span class="at">-</span><span class="op">&gt;</span> <span class="dt">\g</span> <span class="at">-</span><span class="op">&gt;</span> <span class="dt">\x</span> <span class="at">-</span><span class="op">&gt;</span> f x <span class="er">(</span><span class="ex">g</span> x<span class="kw">)</span></span>
<span id="cb839-9"><a href="#cb839-9" aria-hidden="true" tabindex="-1"></a><span class="ex">Lam</span> <span class="st">&quot;s&quot;</span> <span class="er">(</span><span class="ex">Lam</span> <span class="st">&quot;f&quot;</span> <span class="er">(</span><span class="ex">Lam</span> <span class="st">&quot;g&quot;</span> <span class="er">(</span><span class="ex">Lam</span> <span class="st">&quot;x&quot;</span> <span class="er">(</span><span class="ex">App</span> <span class="er">(</span><span class="ex">App</span> <span class="er">(</span><span class="ex">Var</span> <span class="st">&quot;f&quot;</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">Var</span> <span class="st">&quot;x&quot;</span><span class="kw">))</span> <span class="kw">(</span><span class="ex">App</span> <span class="er">(</span><span class="ex">Var</span> <span class="st">&quot;g&quot;</span><span class="kw">)</span> <span class="kw">(</span><span class="ex">Var</span> <span class="st">&quot;x&quot;</span><span class="kw">))))))</span></span></code></pre></div>
<h2 id="megaparsec">Megaparsec</h2>
<p>Megaparsec is a generalisation of parsec which can work with the
several input streams.</p>
<ul>
<li>Text (strict and lazy)</li>
<li>ByteString (strict and lazy)</li>
<li>String = [Char]</li>
</ul>
<p>Megaparsec is an expanded and optimised form of parsec which can be
used to write much larger complex parsers with custom lexers and
Clang-style error message handling.</p>
<p>An example below for the lambda calculus is quite concise:</p>
<div class="sourceCode" id="cb840"
data-include="src/24-parsing/megaparsec.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb840-1"><a href="#cb840-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb840-2"><a href="#cb840-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-3"><a href="#cb840-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Combinators</span></span>
<span id="cb840-4"><a href="#cb840-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb840-5"><a href="#cb840-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec</span></span>
<span id="cb840-6"><a href="#cb840-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Megaparsec.Char</span></span>
<span id="cb840-7"><a href="#cb840-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-8"><a href="#cb840-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Parser</span> <span class="ot">=</span> <span class="dt">Parsec</span> <span class="dt">Expr</span> <span class="dt">Text</span></span>
<span id="cb840-9"><a href="#cb840-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-10"><a href="#cb840-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb840-11"><a href="#cb840-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Char</span></span>
<span id="cb840-12"><a href="#cb840-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Char</span> <span class="dt">Expr</span></span>
<span id="cb840-13"><a href="#cb840-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb840-14"><a href="#cb840-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb840-15"><a href="#cb840-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-16"><a href="#cb840-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ShowErrorComponent</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb840-17"><a href="#cb840-17" aria-hidden="true" tabindex="-1"></a>  showErrorComponent <span class="ot">=</span> <span class="fu">show</span></span>
<span id="cb840-18"><a href="#cb840-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-19"><a href="#cb840-19" aria-hidden="true" tabindex="-1"></a><span class="ot">lam ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb840-20"><a href="#cb840-20" aria-hidden="true" tabindex="-1"></a>lam <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb840-21"><a href="#cb840-21" aria-hidden="true" tabindex="-1"></a>  char <span class="ch">&#39;\\&#39;</span></span>
<span id="cb840-22"><a href="#cb840-22" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> letterChar</span>
<span id="cb840-23"><a href="#cb840-23" aria-hidden="true" tabindex="-1"></a>  string <span class="st">&quot;-&gt;&quot;</span></span>
<span id="cb840-24"><a href="#cb840-24" aria-hidden="true" tabindex="-1"></a>  e <span class="ot">&lt;-</span> expr</span>
<span id="cb840-25"><a href="#cb840-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Lam</span> n e</span>
<span id="cb840-26"><a href="#cb840-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-27"><a href="#cb840-27" aria-hidden="true" tabindex="-1"></a><span class="ot">app ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb840-28"><a href="#cb840-28" aria-hidden="true" tabindex="-1"></a>app <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb840-29"><a href="#cb840-29" aria-hidden="true" tabindex="-1"></a>  apps <span class="ot">&lt;-</span> many term</span>
<span id="cb840-30"><a href="#cb840-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">foldl1</span> <span class="dt">App</span> apps</span>
<span id="cb840-31"><a href="#cb840-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-32"><a href="#cb840-32" aria-hidden="true" tabindex="-1"></a><span class="ot">var ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb840-33"><a href="#cb840-33" aria-hidden="true" tabindex="-1"></a>var <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb840-34"><a href="#cb840-34" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> letterChar</span>
<span id="cb840-35"><a href="#cb840-35" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Var</span> n</span>
<span id="cb840-36"><a href="#cb840-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-37"><a href="#cb840-37" aria-hidden="true" tabindex="-1"></a><span class="ot">parens ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb840-38"><a href="#cb840-38" aria-hidden="true" tabindex="-1"></a>parens p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb840-39"><a href="#cb840-39" aria-hidden="true" tabindex="-1"></a>  char <span class="ch">&#39;(&#39;</span></span>
<span id="cb840-40"><a href="#cb840-40" aria-hidden="true" tabindex="-1"></a>  e <span class="ot">&lt;-</span> p</span>
<span id="cb840-41"><a href="#cb840-41" aria-hidden="true" tabindex="-1"></a>  char <span class="ch">&#39;)&#39;</span></span>
<span id="cb840-42"><a href="#cb840-42" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> e</span>
<span id="cb840-43"><a href="#cb840-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-44"><a href="#cb840-44" aria-hidden="true" tabindex="-1"></a><span class="ot">term ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb840-45"><a href="#cb840-45" aria-hidden="true" tabindex="-1"></a>term <span class="ot">=</span> var <span class="op">&lt;|&gt;</span> parens expr</span>
<span id="cb840-46"><a href="#cb840-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-47"><a href="#cb840-47" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb840-48"><a href="#cb840-48" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> lam <span class="op">&lt;|&gt;</span> app</span>
<span id="cb840-49"><a href="#cb840-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-50"><a href="#cb840-50" aria-hidden="true" tabindex="-1"></a><span class="ot">decl ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb840-51"><a href="#cb840-51" aria-hidden="true" tabindex="-1"></a>decl <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb840-52"><a href="#cb840-52" aria-hidden="true" tabindex="-1"></a>  e <span class="ot">&lt;-</span> expr</span>
<span id="cb840-53"><a href="#cb840-53" aria-hidden="true" tabindex="-1"></a>  eof</span>
<span id="cb840-54"><a href="#cb840-54" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> e</span>
<span id="cb840-55"><a href="#cb840-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-56"><a href="#cb840-56" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">Text</span></span>
<span id="cb840-57"><a href="#cb840-57" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="st">&quot;\\y-&gt;y(\\x-&gt;x)y&quot;</span></span>
<span id="cb840-58"><a href="#cb840-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb840-59"><a href="#cb840-59" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb840-60"><a href="#cb840-60" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">case</span> parse decl <span class="st">&quot;&lt;stdin&gt;&quot;</span> example <span class="kw">of</span></span>
<span id="cb840-61"><a href="#cb840-61" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Left</span> bundle <span class="ot">-&gt;</span> <span class="fu">putStr</span> (errorBundlePretty bundle)</span>
<span id="cb840-62"><a href="#cb840-62" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Right</span> result <span class="ot">-&gt;</span> <span class="fu">print</span> result</span></code></pre></div>
<h2 id="attoparsec">Attoparsec</h2>
<p>Attoparsec is a parser combinator like Parsec but more suited for
bulk parsing of large text and binary files instead of parsing language
syntax to ASTs. When written properly Attoparsec parsers can be <a
href="http://www.serpentine.com/blog/2014/05/31/attoparsec/">efficient</a>.</p>
<p>One notable distinction between Parsec and Attoparsec is that
backtracking operator (<code>try</code>) is not present and reflects on
attoparsec’s different underlying parser model.</p>
<p>For a simple little lambda calculus language we can use attoparsec
much in the same we used parsec:</p>
<div class="sourceCode" id="cb841"
data-include="src/24-parsing/attoparsec_lang.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb841-1"><a href="#cb841-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb841-2"><a href="#cb841-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -fno-warn-unused-do-bind #-}</span></span>
<span id="cb841-3"><a href="#cb841-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-4"><a href="#cb841-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb841-5"><a href="#cb841-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Attoparsec.Text</span></span>
<span id="cb841-6"><a href="#cb841-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb841-7"><a href="#cb841-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.IO</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb841-8"><a href="#cb841-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (foldl1&#39;)</span>
<span id="cb841-9"><a href="#cb841-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-10"><a href="#cb841-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Name</span></span>
<span id="cb841-11"><a href="#cb841-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Gen</span> <span class="dt">Int</span></span>
<span id="cb841-12"><a href="#cb841-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Name</span> <span class="dt">T.Text</span></span>
<span id="cb841-13"><a href="#cb841-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Ord</span>)</span>
<span id="cb841-14"><a href="#cb841-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-15"><a href="#cb841-15" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb841-16"><a href="#cb841-16" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Name</span></span>
<span id="cb841-17"><a href="#cb841-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb841-18"><a href="#cb841-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> [<span class="dt">Name</span>] <span class="dt">Expr</span></span>
<span id="cb841-19"><a href="#cb841-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lit</span> <span class="dt">Int</span></span>
<span id="cb841-20"><a href="#cb841-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Prim</span> <span class="dt">PrimOp</span></span>
<span id="cb841-21"><a href="#cb841-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb841-22"><a href="#cb841-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-23"><a href="#cb841-23" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PrimOp</span></span>
<span id="cb841-24"><a href="#cb841-24" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Add</span></span>
<span id="cb841-25"><a href="#cb841-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Sub</span></span>
<span id="cb841-26"><a href="#cb841-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Mul</span></span>
<span id="cb841-27"><a href="#cb841-27" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Div</span></span>
<span id="cb841-28"><a href="#cb841-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb841-29"><a href="#cb841-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-30"><a href="#cb841-30" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Defn</span> <span class="ot">=</span> <span class="dt">Defn</span> <span class="dt">Name</span> <span class="dt">Expr</span></span>
<span id="cb841-31"><a href="#cb841-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb841-32"><a href="#cb841-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-33"><a href="#cb841-33" aria-hidden="true" tabindex="-1"></a><span class="ot">name ::</span> <span class="dt">Parser</span> <span class="dt">Name</span></span>
<span id="cb841-34"><a href="#cb841-34" aria-hidden="true" tabindex="-1"></a>name <span class="ot">=</span> <span class="dt">Name</span> <span class="op">.</span> T.pack <span class="op">&lt;$&gt;</span> many1 letter</span>
<span id="cb841-35"><a href="#cb841-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-36"><a href="#cb841-36" aria-hidden="true" tabindex="-1"></a><span class="ot">num ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb841-37"><a href="#cb841-37" aria-hidden="true" tabindex="-1"></a>num <span class="ot">=</span> <span class="dt">Lit</span> <span class="op">&lt;$&gt;</span> signed decimal</span>
<span id="cb841-38"><a href="#cb841-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-39"><a href="#cb841-39" aria-hidden="true" tabindex="-1"></a><span class="ot">var ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb841-40"><a href="#cb841-40" aria-hidden="true" tabindex="-1"></a>var <span class="ot">=</span> <span class="dt">Var</span> <span class="op">&lt;$&gt;</span> name</span>
<span id="cb841-41"><a href="#cb841-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-42"><a href="#cb841-42" aria-hidden="true" tabindex="-1"></a><span class="ot">lam ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb841-43"><a href="#cb841-43" aria-hidden="true" tabindex="-1"></a>lam <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb841-44"><a href="#cb841-44" aria-hidden="true" tabindex="-1"></a>  string <span class="st">&quot;\\&quot;</span></span>
<span id="cb841-45"><a href="#cb841-45" aria-hidden="true" tabindex="-1"></a>  vars <span class="ot">&lt;-</span> many1 (skipSpace <span class="op">*&gt;</span> name)</span>
<span id="cb841-46"><a href="#cb841-46" aria-hidden="true" tabindex="-1"></a>  skipSpace <span class="op">*&gt;</span> string <span class="st">&quot;-&gt;&quot;</span></span>
<span id="cb841-47"><a href="#cb841-47" aria-hidden="true" tabindex="-1"></a>  body <span class="ot">&lt;-</span> expr</span>
<span id="cb841-48"><a href="#cb841-48" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">Lam</span> vars body)</span>
<span id="cb841-49"><a href="#cb841-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-50"><a href="#cb841-50" aria-hidden="true" tabindex="-1"></a><span class="ot">eparen ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb841-51"><a href="#cb841-51" aria-hidden="true" tabindex="-1"></a>eparen <span class="ot">=</span> char <span class="ch">&#39;(&#39;</span> <span class="op">*&gt;</span> expr <span class="op">&lt;*</span> skipSpace <span class="op">&lt;*</span> char <span class="ch">&#39;)&#39;</span></span>
<span id="cb841-52"><a href="#cb841-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-53"><a href="#cb841-53" aria-hidden="true" tabindex="-1"></a><span class="ot">prim ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb841-54"><a href="#cb841-54" aria-hidden="true" tabindex="-1"></a>prim <span class="ot">=</span> <span class="dt">Prim</span> <span class="op">&lt;$&gt;</span> (</span>
<span id="cb841-55"><a href="#cb841-55" aria-hidden="true" tabindex="-1"></a>      char <span class="ch">&#39;+&#39;</span> <span class="op">*&gt;</span> <span class="fu">return</span> <span class="dt">Add</span></span>
<span id="cb841-56"><a href="#cb841-56" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;-&#39;</span> <span class="op">*&gt;</span> <span class="fu">return</span> <span class="dt">Sub</span></span>
<span id="cb841-57"><a href="#cb841-57" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;*&#39;</span> <span class="op">*&gt;</span> <span class="fu">return</span> <span class="dt">Mul</span></span>
<span id="cb841-58"><a href="#cb841-58" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;|&gt;</span> char <span class="ch">&#39;/&#39;</span> <span class="op">*&gt;</span> <span class="fu">return</span> <span class="dt">Div</span>)</span>
<span id="cb841-59"><a href="#cb841-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-60"><a href="#cb841-60" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb841-61"><a href="#cb841-61" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> foldl1&#39; <span class="dt">App</span> <span class="op">&lt;$&gt;</span> many1 (skipSpace <span class="op">*&gt;</span> atom)</span>
<span id="cb841-62"><a href="#cb841-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-63"><a href="#cb841-63" aria-hidden="true" tabindex="-1"></a><span class="ot">atom ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb841-64"><a href="#cb841-64" aria-hidden="true" tabindex="-1"></a>atom <span class="ot">=</span> try lam</span>
<span id="cb841-65"><a href="#cb841-65" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> eparen</span>
<span id="cb841-66"><a href="#cb841-66" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> prim</span>
<span id="cb841-67"><a href="#cb841-67" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> var</span>
<span id="cb841-68"><a href="#cb841-68" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;|&gt;</span> num</span>
<span id="cb841-69"><a href="#cb841-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-70"><a href="#cb841-70" aria-hidden="true" tabindex="-1"></a><span class="ot">def ::</span> <span class="dt">Parser</span> <span class="dt">Defn</span></span>
<span id="cb841-71"><a href="#cb841-71" aria-hidden="true" tabindex="-1"></a>def <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb841-72"><a href="#cb841-72" aria-hidden="true" tabindex="-1"></a>  skipSpace</span>
<span id="cb841-73"><a href="#cb841-73" aria-hidden="true" tabindex="-1"></a>  nm <span class="ot">&lt;-</span> name</span>
<span id="cb841-74"><a href="#cb841-74" aria-hidden="true" tabindex="-1"></a>  skipSpace <span class="op">*&gt;</span> char <span class="ch">&#39;=&#39;</span> <span class="op">*&gt;</span> skipSpace</span>
<span id="cb841-75"><a href="#cb841-75" aria-hidden="true" tabindex="-1"></a>  ex <span class="ot">&lt;-</span> expr</span>
<span id="cb841-76"><a href="#cb841-76" aria-hidden="true" tabindex="-1"></a>  skipSpace <span class="op">&lt;*</span> char <span class="ch">&#39;;&#39;</span></span>
<span id="cb841-77"><a href="#cb841-77" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Defn</span> nm ex</span>
<span id="cb841-78"><a href="#cb841-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-79"><a href="#cb841-79" aria-hidden="true" tabindex="-1"></a><span class="ot">file ::</span> <span class="dt">T.Text</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> [<span class="dt">Defn</span>]</span>
<span id="cb841-80"><a href="#cb841-80" aria-hidden="true" tabindex="-1"></a>file <span class="ot">=</span> parseOnly (many def <span class="op">&lt;*</span> skipSpace)</span>
<span id="cb841-81"><a href="#cb841-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-82"><a href="#cb841-82" aria-hidden="true" tabindex="-1"></a><span class="ot">parseFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">T.Text</span> [<span class="dt">Defn</span>])</span>
<span id="cb841-83"><a href="#cb841-83" aria-hidden="true" tabindex="-1"></a>parseFile path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb841-84"><a href="#cb841-84" aria-hidden="true" tabindex="-1"></a>  contents <span class="ot">&lt;-</span> T.readFile path</span>
<span id="cb841-85"><a href="#cb841-85" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> file contents <span class="kw">of</span></span>
<span id="cb841-86"><a href="#cb841-86" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> a <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">Left</span> (T.pack a)</span>
<span id="cb841-87"><a href="#cb841-87" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> b <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">Right</span> b</span>
<span id="cb841-88"><a href="#cb841-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb841-89"><a href="#cb841-89" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">T.Text</span> [<span class="dt">Defn</span>])</span>
<span id="cb841-90"><a href="#cb841-90" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> parseFile <span class="st">&quot;simple.ml&quot;</span></span></code></pre></div>
<p>For an example try the above parser with the following simple lambda
expression.</p>
<div class="sourceCode" id="cb842"
data-include="src/24-parsing/simple.ml"><pre
class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb842-1"><a href="#cb842-1" aria-hidden="true" tabindex="-1"></a>f = g (x - <span class="dv">1</span>);</span>
<span id="cb842-2"><a href="#cb842-2" aria-hidden="true" tabindex="-1"></a>g = f (x + <span class="dv">1</span>);</span>
<span id="cb842-3"><a href="#cb842-3" aria-hidden="true" tabindex="-1"></a>h = \x y -&gt; (f x) + (g y);</span></code></pre></div>
<p>Attoparsec adapts very well to binary and network protocol style
parsing as well, this is extracted from a small implementation of a
distributed consensus network protocol:</p>
<div class="sourceCode" id="cb843"
data-include="src/24-parsing/attoparsec.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb843-1"><a href="#cb843-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb843-2"><a href="#cb843-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb843-3"><a href="#cb843-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb843-4"><a href="#cb843-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Attoparsec.ByteString</span></span>
<span id="cb843-5"><a href="#cb843-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Attoparsec.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">A</span></span>
<span id="cb843-6"><a href="#cb843-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Char8</span></span>
<span id="cb843-7"><a href="#cb843-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb843-8"><a href="#cb843-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Action</span></span>
<span id="cb843-9"><a href="#cb843-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Success</span></span>
<span id="cb843-10"><a href="#cb843-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">KeepAlive</span></span>
<span id="cb843-11"><a href="#cb843-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">NoResource</span></span>
<span id="cb843-12"><a href="#cb843-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Hangup</span></span>
<span id="cb843-13"><a href="#cb843-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">NewLeader</span></span>
<span id="cb843-14"><a href="#cb843-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Election</span></span>
<span id="cb843-15"><a href="#cb843-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb843-16"><a href="#cb843-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb843-17"><a href="#cb843-17" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Sender</span> <span class="ot">=</span> <span class="dt">Sender</span> <span class="dt">ByteString</span></span>
<span id="cb843-18"><a href="#cb843-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb843-19"><a href="#cb843-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb843-20"><a href="#cb843-20" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Payload</span> <span class="ot">=</span> <span class="dt">Payload</span> <span class="dt">ByteString</span></span>
<span id="cb843-21"><a href="#cb843-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb843-22"><a href="#cb843-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb843-23"><a href="#cb843-23" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Message</span></span>
<span id="cb843-24"><a href="#cb843-24" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Message</span></span>
<span id="cb843-25"><a href="#cb843-25" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> action ::</span> <span class="dt">Action</span>,</span>
<span id="cb843-26"><a href="#cb843-26" aria-hidden="true" tabindex="-1"></a><span class="ot">        sender ::</span> <span class="dt">Sender</span>,</span>
<span id="cb843-27"><a href="#cb843-27" aria-hidden="true" tabindex="-1"></a><span class="ot">        payload ::</span> <span class="dt">Payload</span></span>
<span id="cb843-28"><a href="#cb843-28" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb843-29"><a href="#cb843-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb843-30"><a href="#cb843-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb843-31"><a href="#cb843-31" aria-hidden="true" tabindex="-1"></a><span class="ot">proto ::</span> <span class="dt">Parser</span> <span class="dt">Message</span></span>
<span id="cb843-32"><a href="#cb843-32" aria-hidden="true" tabindex="-1"></a>proto <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb843-33"><a href="#cb843-33" aria-hidden="true" tabindex="-1"></a>  act <span class="ot">&lt;-</span> paction</span>
<span id="cb843-34"><a href="#cb843-34" aria-hidden="true" tabindex="-1"></a>  send <span class="ot">&lt;-</span> <span class="dt">Sender</span> <span class="op">&lt;$&gt;</span> A.takeTill (<span class="op">==</span> <span class="ch">&#39;.&#39;</span>)</span>
<span id="cb843-35"><a href="#cb843-35" aria-hidden="true" tabindex="-1"></a>  body <span class="ot">&lt;-</span> <span class="dt">Payload</span> <span class="op">&lt;$&gt;</span> A.takeTill A.isSpace</span>
<span id="cb843-36"><a href="#cb843-36" aria-hidden="true" tabindex="-1"></a>  endOfLine</span>
<span id="cb843-37"><a href="#cb843-37" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Message</span> act send body</span>
<span id="cb843-38"><a href="#cb843-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb843-39"><a href="#cb843-39" aria-hidden="true" tabindex="-1"></a><span class="ot">paction ::</span> <span class="dt">Parser</span> <span class="dt">Action</span></span>
<span id="cb843-40"><a href="#cb843-40" aria-hidden="true" tabindex="-1"></a>paction <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb843-41"><a href="#cb843-41" aria-hidden="true" tabindex="-1"></a>  c <span class="ot">&lt;-</span> anyWord8</span>
<span id="cb843-42"><a href="#cb843-42" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> c <span class="kw">of</span></span>
<span id="cb843-43"><a href="#cb843-43" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Success</span></span>
<span id="cb843-44"><a href="#cb843-44" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">KeepAlive</span></span>
<span id="cb843-45"><a href="#cb843-45" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">NoResource</span></span>
<span id="cb843-46"><a href="#cb843-46" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Hangup</span></span>
<span id="cb843-47"><a href="#cb843-47" aria-hidden="true" tabindex="-1"></a>    <span class="dv">5</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">NewLeader</span></span>
<span id="cb843-48"><a href="#cb843-48" aria-hidden="true" tabindex="-1"></a>    <span class="dv">6</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Election</span></span>
<span id="cb843-49"><a href="#cb843-49" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> mzero</span>
<span id="cb843-50"><a href="#cb843-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb843-51"><a href="#cb843-51" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb843-52"><a href="#cb843-52" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb843-53"><a href="#cb843-53" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> msgtext <span class="ot">=</span> <span class="st">&quot;\x01\x6c\x61\x70\x74\x6f\x70\x2e\x33\x2e\x31\x34\x31\x35\x39\x32\x36\x35\x33\x35\x0A&quot;</span></span>
<span id="cb843-54"><a href="#cb843-54" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> msg <span class="ot">=</span> parseOnly proto msgtext</span>
<span id="cb843-55"><a href="#cb843-55" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> msg</span></code></pre></div>
<h2 id="configurator">Configurator</h2>
<p>Configurator is a library for configuring Haskell daemons and
programs. It uses a simple, but flexible, configuration language,
supporting several of the most commonly needed types of data, along with
interpolation of strings from the configuration or the system
environment.</p>
<div class="sourceCode" id="cb844"
data-include="src/24-parsing/configurator.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb844-1"><a href="#cb844-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb844-2"><a href="#cb844-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb844-3"><a href="#cb844-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span></span>
<span id="cb844-4"><a href="#cb844-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Configurator</span> <span class="kw">as</span> <span class="dt">C</span></span>
<span id="cb844-5"><a href="#cb844-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb844-6"><a href="#cb844-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Config</span> <span class="ot">=</span> <span class="dt">Config</span></span>
<span id="cb844-7"><a href="#cb844-7" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> verbose      ::</span> <span class="dt">Bool</span></span>
<span id="cb844-8"><a href="#cb844-8" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> loggingLevel ::</span> <span class="dt">Int</span></span>
<span id="cb844-9"><a href="#cb844-9" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> logfile      ::</span> <span class="dt">FilePath</span></span>
<span id="cb844-10"><a href="#cb844-10" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> dbHost       ::</span> <span class="dt">Text</span></span>
<span id="cb844-11"><a href="#cb844-11" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> dbUser       ::</span> <span class="dt">Text</span></span>
<span id="cb844-12"><a href="#cb844-12" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> dbDatabase   ::</span> <span class="dt">Text</span></span>
<span id="cb844-13"><a href="#cb844-13" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> dbpassword   ::</span> <span class="dt">Maybe</span> <span class="dt">Text</span></span>
<span id="cb844-14"><a href="#cb844-14" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb844-15"><a href="#cb844-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb844-16"><a href="#cb844-16" aria-hidden="true" tabindex="-1"></a><span class="ot">readConfig ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Config</span></span>
<span id="cb844-17"><a href="#cb844-17" aria-hidden="true" tabindex="-1"></a>readConfig cfgFile <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb844-18"><a href="#cb844-18" aria-hidden="true" tabindex="-1"></a>  cfg          <span class="ot">&lt;-</span> C.load [<span class="dt">C.Required</span> cfgFile]</span>
<span id="cb844-19"><a href="#cb844-19" aria-hidden="true" tabindex="-1"></a>  verbose      <span class="ot">&lt;-</span> C.require cfg <span class="st">&quot;logging.verbose&quot;</span></span>
<span id="cb844-20"><a href="#cb844-20" aria-hidden="true" tabindex="-1"></a>  loggingLevel <span class="ot">&lt;-</span> C.require cfg <span class="st">&quot;logging.loggingLevel&quot;</span></span>
<span id="cb844-21"><a href="#cb844-21" aria-hidden="true" tabindex="-1"></a>  logFile      <span class="ot">&lt;-</span> C.require cfg <span class="st">&quot;logging.logfile&quot;</span></span>
<span id="cb844-22"><a href="#cb844-22" aria-hidden="true" tabindex="-1"></a>  hostname     <span class="ot">&lt;-</span> C.require cfg <span class="st">&quot;database.hostname&quot;</span></span>
<span id="cb844-23"><a href="#cb844-23" aria-hidden="true" tabindex="-1"></a>  username     <span class="ot">&lt;-</span> C.require cfg <span class="st">&quot;database.username&quot;</span></span>
<span id="cb844-24"><a href="#cb844-24" aria-hidden="true" tabindex="-1"></a>  database     <span class="ot">&lt;-</span> C.require cfg <span class="st">&quot;database.database&quot;</span></span>
<span id="cb844-25"><a href="#cb844-25" aria-hidden="true" tabindex="-1"></a>  password     <span class="ot">&lt;-</span> C.lookup cfg <span class="st">&quot;database.password&quot;</span></span>
<span id="cb844-26"><a href="#cb844-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Config</span> verbose loggingLevel logFile hostname username database password</span>
<span id="cb844-27"><a href="#cb844-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb844-28"><a href="#cb844-28" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb844-29"><a href="#cb844-29" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb844-30"><a href="#cb844-30" aria-hidden="true" tabindex="-1"></a>  cfg <span class="ot">&lt;-</span>readConfig <span class="st">&quot;example.config&quot;</span></span>
<span id="cb844-31"><a href="#cb844-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> cfg</span></code></pre></div>
<p>An example configuration file:</p>
<div class="sourceCode" id="cb845"
data-include="src/24-parsing/example.config"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb845-1"><a href="#cb845-1" aria-hidden="true" tabindex="-1"></a>logging </span>
<span id="cb845-2"><a href="#cb845-2" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb845-3"><a href="#cb845-3" aria-hidden="true" tabindex="-1"></a>  verbose      <span class="ot">=</span> true</span>
<span id="cb845-4"><a href="#cb845-4" aria-hidden="true" tabindex="-1"></a>  logfile      <span class="ot">=</span> <span class="st">&quot;/tmp/app.log&quot;</span></span>
<span id="cb845-5"><a href="#cb845-5" aria-hidden="true" tabindex="-1"></a>  loggingLevel <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb845-6"><a href="#cb845-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb845-7"><a href="#cb845-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb845-8"><a href="#cb845-8" aria-hidden="true" tabindex="-1"></a>database</span>
<span id="cb845-9"><a href="#cb845-9" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb845-10"><a href="#cb845-10" aria-hidden="true" tabindex="-1"></a>  hostname <span class="ot">=</span> <span class="st">&quot;us-east-1.rds.amazonaws.com&quot;</span></span>
<span id="cb845-11"><a href="#cb845-11" aria-hidden="true" tabindex="-1"></a>  username <span class="ot">=</span> <span class="st">&quot;app&quot;</span></span>
<span id="cb845-12"><a href="#cb845-12" aria-hidden="true" tabindex="-1"></a>  database <span class="ot">=</span> <span class="st">&quot;booktown&quot;</span></span>
<span id="cb845-13"><a href="#cb845-13" aria-hidden="true" tabindex="-1"></a>  password <span class="ot">=</span> <span class="st">&quot;hunter2&quot;</span></span>
<span id="cb845-14"><a href="#cb845-14" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Configurator also includes an <code>import</code> directive allows
the configuration of a complex application to be split across several
smaller files, or configuration data to be shared across several
applications.</p>
<h2 id="optparse-applicative">Optparse Applicative</h2>
<p>Optparse-applicative is a combinator library for building command
line interfaces that take in various user flags, commands and switches
and maps them into Haskell data structures that can handle the input.
The main interface is through the applicative functor
<code>Parser</code> and various combinators such as
<code>strArgument</code> and <code>flag</code> which populate the option
parsing table with some monadic action which returns a Haskell value.
The resulting sequence of values can be combined applicatively into a
larger Config data structure that holds all the given options. The
<code>--help</code> header is also automatically generated from the
combinators.</p>
<div class="sourceCode" id="cb846"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb846-1"><a href="#cb846-1" aria-hidden="true" tabindex="-1"></a><span class="ex">./optparse</span></span>
<span id="cb846-2"><a href="#cb846-2" aria-hidden="true" tabindex="-1"></a><span class="ex">Usage:</span> optparse.hs <span class="pp">[</span><span class="ss">filename...</span><span class="pp">]</span> <span class="pp">[--</span><span class="ss">quiet</span><span class="pp">]</span> <span class="pp">[--</span><span class="ss">cheetah</span><span class="pp">]</span></span>
<span id="cb846-3"><a href="#cb846-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb846-4"><a href="#cb846-4" aria-hidden="true" tabindex="-1"></a><span class="ex">Available</span> options:</span>
<span id="cb846-5"><a href="#cb846-5" aria-hidden="true" tabindex="-1"></a>  <span class="ex">-h,--help</span>                Show this help text</span>
<span id="cb846-6"><a href="#cb846-6" aria-hidden="true" tabindex="-1"></a>  <span class="ex">filename...</span>              Input files</span>
<span id="cb846-7"><a href="#cb846-7" aria-hidden="true" tabindex="-1"></a>  <span class="ex">--quiet</span>                  Whether to shut up.</span>
<span id="cb846-8"><a href="#cb846-8" aria-hidden="true" tabindex="-1"></a>  <span class="ex">--cheetah</span>                Perform task quickly.</span></code></pre></div>
<div class="sourceCode" id="cb847"
data-include="src/24-parsing/optparse_applicative.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb847-1"><a href="#cb847-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span></span>
<span id="cb847-2"><a href="#cb847-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Monoid</span></span>
<span id="cb847-3"><a href="#cb847-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Options.Applicative</span></span>
<span id="cb847-4"><a href="#cb847-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb847-5"><a href="#cb847-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Opts</span> <span class="ot">=</span> <span class="dt">Opts</span></span>
<span id="cb847-6"><a href="#cb847-6" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> _files ::</span> [<span class="dt">String</span>]</span>
<span id="cb847-7"><a href="#cb847-7" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _quiet ::</span> <span class="dt">Bool</span></span>
<span id="cb847-8"><a href="#cb847-8" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _fast ::</span> <span class="dt">Speed</span></span>
<span id="cb847-9"><a href="#cb847-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb847-10"><a href="#cb847-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb847-11"><a href="#cb847-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Speed</span> <span class="ot">=</span> <span class="dt">Slow</span> <span class="op">|</span> <span class="dt">Fast</span></span>
<span id="cb847-12"><a href="#cb847-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb847-13"><a href="#cb847-13" aria-hidden="true" tabindex="-1"></a><span class="ot">options ::</span> <span class="dt">Parser</span> <span class="dt">Opts</span></span>
<span id="cb847-14"><a href="#cb847-14" aria-hidden="true" tabindex="-1"></a>options <span class="ot">=</span> <span class="dt">Opts</span> <span class="op">&lt;$&gt;</span> filename <span class="op">&lt;*&gt;</span> quiet <span class="op">&lt;*&gt;</span> fast</span>
<span id="cb847-15"><a href="#cb847-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb847-16"><a href="#cb847-16" aria-hidden="true" tabindex="-1"></a><span class="ot">    filename ::</span> <span class="dt">Parser</span> [<span class="dt">String</span>]</span>
<span id="cb847-17"><a href="#cb847-17" aria-hidden="true" tabindex="-1"></a>    filename <span class="ot">=</span> many <span class="op">$</span> argument str <span class="op">$</span></span>
<span id="cb847-18"><a href="#cb847-18" aria-hidden="true" tabindex="-1"></a>         metavar <span class="st">&quot;filename...&quot;</span></span>
<span id="cb847-19"><a href="#cb847-19" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;&gt;</span> help <span class="st">&quot;Input files&quot;</span></span>
<span id="cb847-20"><a href="#cb847-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb847-21"><a href="#cb847-21" aria-hidden="true" tabindex="-1"></a><span class="ot">    fast ::</span> <span class="dt">Parser</span> <span class="dt">Speed</span></span>
<span id="cb847-22"><a href="#cb847-22" aria-hidden="true" tabindex="-1"></a>    fast <span class="ot">=</span> flag <span class="dt">Slow</span> <span class="dt">Fast</span> <span class="op">$</span></span>
<span id="cb847-23"><a href="#cb847-23" aria-hidden="true" tabindex="-1"></a>         long <span class="st">&quot;cheetah&quot;</span></span>
<span id="cb847-24"><a href="#cb847-24" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;&gt;</span> help <span class="st">&quot;Perform task quickly.&quot;</span></span>
<span id="cb847-25"><a href="#cb847-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb847-26"><a href="#cb847-26" aria-hidden="true" tabindex="-1"></a><span class="ot">    quiet ::</span> <span class="dt">Parser</span> <span class="dt">Bool</span></span>
<span id="cb847-27"><a href="#cb847-27" aria-hidden="true" tabindex="-1"></a>    quiet <span class="ot">=</span> switch <span class="op">$</span></span>
<span id="cb847-28"><a href="#cb847-28" aria-hidden="true" tabindex="-1"></a>         long <span class="st">&quot;quiet&quot;</span></span>
<span id="cb847-29"><a href="#cb847-29" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;&gt;</span> help <span class="st">&quot;Whether to shut up.&quot;</span></span>
<span id="cb847-30"><a href="#cb847-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb847-31"><a href="#cb847-31" aria-hidden="true" tabindex="-1"></a><span class="ot">greet ::</span> <span class="dt">Opts</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb847-32"><a href="#cb847-32" aria-hidden="true" tabindex="-1"></a>greet (<span class="dt">Opts</span> files quiet fast) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb847-33"><a href="#cb847-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;reading these files:&quot;</span></span>
<span id="cb847-34"><a href="#cb847-34" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> <span class="fu">print</span> files</span>
<span id="cb847-35"><a href="#cb847-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb847-36"><a href="#cb847-36" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> fast <span class="kw">of</span></span>
<span id="cb847-37"><a href="#cb847-37" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Fast</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;quickly&quot;</span></span>
<span id="cb847-38"><a href="#cb847-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Slow</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;slowly&quot;</span></span>
<span id="cb847-39"><a href="#cb847-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb847-40"><a href="#cb847-40" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> quiet <span class="kw">of</span></span>
<span id="cb847-41"><a href="#cb847-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">True</span>  <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;quietly&quot;</span></span>
<span id="cb847-42"><a href="#cb847-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="st">&quot;loudly&quot;</span></span>
<span id="cb847-43"><a href="#cb847-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb847-44"><a href="#cb847-44" aria-hidden="true" tabindex="-1"></a><span class="ot">opts ::</span> <span class="dt">ParserInfo</span> <span class="dt">Opts</span></span>
<span id="cb847-45"><a href="#cb847-45" aria-hidden="true" tabindex="-1"></a>opts <span class="ot">=</span> info (helper <span class="op">&lt;*&gt;</span> options) fullDesc</span>
<span id="cb847-46"><a href="#cb847-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb847-47"><a href="#cb847-47" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb847-48"><a href="#cb847-48" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> execParser opts <span class="op">&gt;&gt;=</span> greet</span></code></pre></div>
<h4 id="optparse-generic">Optparse Generic</h4>
<p>Many <code>optparse-applicative</code> command line parsers can also
be generated using Generics from descriptions of records. This approach
is not foolproof but works well enough for simple command line
applications with a few options. For more complex interfaces with
subcommands and help information you’ll need to go back to the
<code>optparse-applicative</code> level. For example:</p>
<div class="sourceCode" id="cb848"
data-include="src/24-parsing/optparse_generic.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb848-1"><a href="#cb848-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb848-2"><a href="#cb848-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveAnyClass #-}</span></span>
<span id="cb848-3"><a href="#cb848-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb848-4"><a href="#cb848-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb848-5"><a href="#cb848-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb848-6"><a href="#cb848-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb848-7"><a href="#cb848-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Options.Generic</span></span>
<span id="cb848-8"><a href="#cb848-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb848-9"><a href="#cb848-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Options</span> <span class="ot">=</span> <span class="dt">Options</span></span>
<span id="cb848-10"><a href="#cb848-10" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> verbose ::</span> <span class="dt">Bool</span>     <span class="op">&lt;?&gt;</span> <span class="st">&quot;Enable verbose mode&quot;</span></span>
<span id="cb848-11"><a href="#cb848-11" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> input   ::</span> <span class="dt">FilePath</span> <span class="op">&lt;?&gt;</span> <span class="st">&quot;Input file&quot;</span></span>
<span id="cb848-12"><a href="#cb848-12" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> output  ::</span> <span class="dt">FilePath</span> <span class="op">&lt;?&gt;</span> <span class="st">&quot;Output file&quot;</span></span>
<span id="cb848-13"><a href="#cb848-13" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb848-14"><a href="#cb848-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>, <span class="dt">ParseRecord</span>)</span>
<span id="cb848-15"><a href="#cb848-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb848-16"><a href="#cb848-16" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb848-17"><a href="#cb848-17" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb848-18"><a href="#cb848-18" aria-hidden="true" tabindex="-1"></a>  opts <span class="ot">&lt;-</span> getRecord <span class="st">&quot;My CLI&quot;</span></span>
<span id="cb848-19"><a href="#cb848-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (<span class="ot">opts ::</span> <span class="dt">Options</span>)</span></code></pre></div>
<h2 id="happy-alex">Happy &amp; Alex</h2>
<p>Happy is a parser generator system for Haskell, similar to the tool
`yacc’ for C. It works as a preprocessor with its own syntax that
generates a parse table from two specifications, a lexer file and parser
file. Happy does not have the same underlying parser implementation as
parser combinators and can effectively work with left-recursive grammars
without explicit factorization. It can also easily be modified to track
position information for tokens and handle offside parsing rules for
indentation-sensitive grammars. Happy is used in GHC itself for
Haskell’s grammar.</p>
<ol type="1">
<li>Lexer.x</li>
<li>Parser.y</li>
</ol>
<p>Running the standalone commands will take Alex/Happy source files
from stdin and generate and output Haskell modules. Alex and Happy files
can contain arbitrary Haskell code that can be escaped to the
output.</p>
<div class="sourceCode" id="cb849"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb849-1"><a href="#cb849-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> alex Lexer.x <span class="at">-o</span> Lexer.hs</span>
<span id="cb849-2"><a href="#cb849-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> happy Parser.y <span class="at">-o</span> Parser.hs</span></code></pre></div>
<p>The generated modules are not human readable generally and
unfortunately error messages are given in the Haskell source, not the
Happy source. Anything enclosed in braces is interpreted as literal
Haskell while the code outside the braces is interpeted as parser
grammar.</p>
<div class="sourceCode" id="cb850"><pre
class="sourceCode yacc"><code class="sourceCode yacc"><span id="cb850-1"><a href="#cb850-1" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb850-2"><a href="#cb850-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb850-3"><a href="#cb850-3" aria-hidden="true" tabindex="-1"></a>-- This is Haskell </span>
<span id="cb850-4"><a href="#cb850-4" aria-hidden="true" tabindex="-1"></a>module Parser where</span>
<span id="cb850-5"><a href="#cb850-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb850-6"><a href="#cb850-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb850-7"><a href="#cb850-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb850-8"><a href="#cb850-8" aria-hidden="true" tabindex="-1"></a>-- This is Happy</span>
<span id="cb850-9"><a href="#cb850-9" aria-hidden="true" tabindex="-1"></a><span class="kw">%tokentype</span> { Lexeme Token }</span>
<span id="cb850-10"><a href="#cb850-10" aria-hidden="true" tabindex="-1"></a><span class="kw">%error</span> { parseError }</span>
<span id="cb850-11"><a href="#cb850-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb850-12"><a href="#cb850-12" aria-hidden="true" tabindex="-1"></a><span class="kw">%monad</span> { Parse }</span>
<span id="cb850-13"><a href="#cb850-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb850-14"><a href="#cb850-14" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb850-15"><a href="#cb850-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb850-16"><a href="#cb850-16" aria-hidden="true" tabindex="-1"></a>-- This is Haskell again</span>
<span id="cb850-17"><a href="#cb850-17" aria-hidden="true" tabindex="-1"></a>parseExpr :: String -&gt; Either String [Expr]</span>
<span id="cb850-18"><a href="#cb850-18" aria-hidden="true" tabindex="-1"></a>parseExpr input = </span>
<span id="cb850-19"><a href="#cb850-19" aria-hidden="true" tabindex="-1"></a>  let tokenStream = scanTokens input in</span>
<span id="cb850-20"><a href="#cb850-20" aria-hidden="true" tabindex="-1"></a>  runExcept (expr tokenStream)</span>
<span id="cb850-21"><a href="#cb850-21" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Happy and Alex can be integrated into a cabal file simply by
including the <code>Parser.y</code> and <code>Lexer.x</code> files
inside of the exposed modules and adding them to the build-tools
pragma.</p>
<div class="sourceCode" id="cb851"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb851-1"><a href="#cb851-1" aria-hidden="true" tabindex="-1"></a>exposed-modules: Parser, Lexer</span>
<span id="cb851-2"><a href="#cb851-2" aria-hidden="true" tabindex="-1"></a>build-tools: alex , happy</span></code></pre></div>
<h4 id="lexer">Lexer</h4>
<p>For instance we could define a little toy lexer with a custom set of
tokens.</p>
<div class="sourceCode" id="cb852"
data-include="src/24-parsing/happy/Lexer.x"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb852-1"><a href="#cb852-1" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb852-2"><a href="#cb852-2" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Lexer</span> (</span>
<span id="cb852-3"><a href="#cb852-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Token</span>(<span class="op">..</span>),</span>
<span id="cb852-4"><a href="#cb852-4" aria-hidden="true" tabindex="-1"></a>  scanTokens</span>
<span id="cb852-5"><a href="#cb852-5" aria-hidden="true" tabindex="-1"></a>) <span class="kw">where</span></span>
<span id="cb852-6"><a href="#cb852-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb852-7"><a href="#cb852-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Syntax</span></span>
<span id="cb852-8"><a href="#cb852-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb852-9"><a href="#cb852-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb852-10"><a href="#cb852-10" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>wrapper <span class="st">&quot;basic&quot;</span></span>
<span id="cb852-11"><a href="#cb852-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb852-12"><a href="#cb852-12" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>digit <span class="ot">=</span> <span class="dv">0</span><span class="op">-</span><span class="dv">9</span></span>
<span id="cb852-13"><a href="#cb852-13" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>alpha <span class="ot">=</span> [a<span class="op">-</span>zA<span class="op">-</span><span class="dt">Z</span>]</span>
<span id="cb852-14"><a href="#cb852-14" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>eol   <span class="ot">=</span> [\n]</span>
<span id="cb852-15"><a href="#cb852-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb852-16"><a href="#cb852-16" aria-hidden="true" tabindex="-1"></a>tokens <span class="op">:-</span></span>
<span id="cb852-17"><a href="#cb852-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb852-18"><a href="#cb852-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Whitespace insensitive</span></span>
<span id="cb852-19"><a href="#cb852-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">$</span>eol                          ;</span>
<span id="cb852-20"><a href="#cb852-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">$</span>white<span class="op">+</span>                       ;</span>
<span id="cb852-21"><a href="#cb852-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span>                         { \s <span class="ot">-&gt;</span> <span class="dt">TokenPrint</span> }</span>
<span id="cb852-22"><a href="#cb852-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">$</span>digit<span class="op">+</span>                       { \s <span class="ot">-&gt;</span> <span class="dt">TokenNum</span> (<span class="fu">read</span> s) }</span>
<span id="cb852-23"><a href="#cb852-23" aria-hidden="true" tabindex="-1"></a>  \<span class="ot">=</span>                            { \s <span class="ot">-&gt;</span> <span class="dt">TokenEq</span> }</span>
<span id="cb852-24"><a href="#cb852-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">$</span>alpha [<span class="op">$</span>alpha <span class="op">$</span>digit \_ \&#39;]<span class="op">*</span> { \s <span class="ot">-&gt;</span> <span class="dt">TokenSym</span> s }</span>
<span id="cb852-25"><a href="#cb852-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb852-26"><a href="#cb852-26" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb852-27"><a href="#cb852-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb852-28"><a href="#cb852-28" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Token</span> </span>
<span id="cb852-29"><a href="#cb852-29" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">TokenNum</span> <span class="dt">Int</span></span>
<span id="cb852-30"><a href="#cb852-30" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TokenSym</span> <span class="dt">String</span></span>
<span id="cb852-31"><a href="#cb852-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TokenPrint</span></span>
<span id="cb852-32"><a href="#cb852-32" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TokenEq</span></span>
<span id="cb852-33"><a href="#cb852-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TokenEOF</span></span>
<span id="cb852-34"><a href="#cb852-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Show</span>)</span>
<span id="cb852-35"><a href="#cb852-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb852-36"><a href="#cb852-36" aria-hidden="true" tabindex="-1"></a><span class="ot">scanTokens ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> [<span class="dt">Token</span>]</span>
<span id="cb852-37"><a href="#cb852-37" aria-hidden="true" tabindex="-1"></a>scanTokens <span class="ot">=</span> alexScanTokens</span>
<span id="cb852-38"><a href="#cb852-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb852-39"><a href="#cb852-39" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h4 id="parser">Parser</h4>
<p>The associated parser is list of a production rules and a monad to
run the parser in. Production rules consist of a set of options on the
left and generating Haskell expressions on the right with indexed
metavariables (<code>$1</code>, <code>$2</code>, …) mapping to the
ordered terms on the left (i.e. in the second term <code>term</code> ~
<code>$1</code>, <code>term</code> ~ <code>$2</code>).</p>
<div class="sourceCode" id="cb853"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb853-1"><a href="#cb853-1" aria-hidden="true" tabindex="-1"></a>terms</span>
<span id="cb853-2"><a href="#cb853-2" aria-hidden="true" tabindex="-1"></a>    : term                   { [<span class="wa">$1</span>] }</span>
<span id="cb853-3"><a href="#cb853-3" aria-hidden="true" tabindex="-1"></a>    | term terms             { <span class="wa">$1</span> : <span class="wa">$2</span> }</span></code></pre></div>
<p>An example parser module:</p>
<div class="sourceCode" id="cb854"
data-include="src/24-parsing/happy/Parser.y"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb854-1"><a href="#cb854-1" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb854-2"><a href="#cb854-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb854-3"><a href="#cb854-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb854-4"><a href="#cb854-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Parser</span> (</span>
<span id="cb854-5"><a href="#cb854-5" aria-hidden="true" tabindex="-1"></a>  parseExpr,</span>
<span id="cb854-6"><a href="#cb854-6" aria-hidden="true" tabindex="-1"></a>) <span class="kw">where</span></span>
<span id="cb854-7"><a href="#cb854-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb854-8"><a href="#cb854-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Lexer</span></span>
<span id="cb854-9"><a href="#cb854-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Syntax</span></span>
<span id="cb854-10"><a href="#cb854-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb854-11"><a href="#cb854-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Except</span></span>
<span id="cb854-12"><a href="#cb854-12" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb854-13"><a href="#cb854-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb854-14"><a href="#cb854-14" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>name expr</span>
<span id="cb854-15"><a href="#cb854-15" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>tokentype { <span class="dt">Token</span> }</span>
<span id="cb854-16"><a href="#cb854-16" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>monad { <span class="dt">Except</span> <span class="dt">String</span> } { (<span class="op">&gt;&gt;=</span>) } { <span class="fu">return</span> }</span>
<span id="cb854-17"><a href="#cb854-17" aria-hidden="true" tabindex="-1"></a><span class="op">%</span><span class="fu">error</span> { parseError }</span>
<span id="cb854-18"><a href="#cb854-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb854-19"><a href="#cb854-19" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>token</span>
<span id="cb854-20"><a href="#cb854-20" aria-hidden="true" tabindex="-1"></a>    int   { <span class="dt">TokenNum</span> <span class="op">$$</span> }</span>
<span id="cb854-21"><a href="#cb854-21" aria-hidden="true" tabindex="-1"></a>    var   { <span class="dt">TokenSym</span> <span class="op">$$</span> }</span>
<span id="cb854-22"><a href="#cb854-22" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> { <span class="dt">TokenPrint</span> }</span>
<span id="cb854-23"><a href="#cb854-23" aria-hidden="true" tabindex="-1"></a>    <span class="ch">&#39;=&#39;</span>   { <span class="dt">TokenEq</span> }</span>
<span id="cb854-24"><a href="#cb854-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb854-25"><a href="#cb854-25" aria-hidden="true" tabindex="-1"></a><span class="op">%%</span></span>
<span id="cb854-26"><a href="#cb854-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb854-27"><a href="#cb854-27" aria-hidden="true" tabindex="-1"></a>terms </span>
<span id="cb854-28"><a href="#cb854-28" aria-hidden="true" tabindex="-1"></a>  <span class="op">:</span> term                   { [<span class="op">$</span><span class="dv">1</span>] }</span>
<span id="cb854-29"><a href="#cb854-29" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> term terms             { <span class="op">$</span><span class="dv">1</span> <span class="op">:</span> <span class="op">$</span><span class="dv">2</span> }</span>
<span id="cb854-30"><a href="#cb854-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb854-31"><a href="#cb854-31" aria-hidden="true" tabindex="-1"></a>term </span>
<span id="cb854-32"><a href="#cb854-32" aria-hidden="true" tabindex="-1"></a>  <span class="op">:</span> var                    { <span class="dt">Var</span> <span class="op">$</span><span class="dv">1</span> }</span>
<span id="cb854-33"><a href="#cb854-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> var <span class="ch">&#39;=&#39;</span> int            { <span class="dt">Assign</span> <span class="op">$</span><span class="dv">1</span> <span class="op">$</span><span class="dv">3</span> }</span>
<span id="cb854-34"><a href="#cb854-34" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">print</span> term             { <span class="dt">Print</span> <span class="op">$</span><span class="dv">2</span> }</span>
<span id="cb854-35"><a href="#cb854-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb854-36"><a href="#cb854-36" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb854-37"><a href="#cb854-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb854-38"><a href="#cb854-38" aria-hidden="true" tabindex="-1"></a><span class="ot">parseError ::</span> [<span class="dt">Token</span>] <span class="ot">-&gt;</span> <span class="dt">Except</span> <span class="dt">String</span> a</span>
<span id="cb854-39"><a href="#cb854-39" aria-hidden="true" tabindex="-1"></a>parseError (l<span class="op">:</span>ls) <span class="ot">=</span> throwError (<span class="fu">show</span> l)</span>
<span id="cb854-40"><a href="#cb854-40" aria-hidden="true" tabindex="-1"></a>parseError [] <span class="ot">=</span> throwError <span class="st">&quot;Unexpected end of Input&quot;</span></span>
<span id="cb854-41"><a href="#cb854-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb854-42"><a href="#cb854-42" aria-hidden="true" tabindex="-1"></a><span class="ot">parseExpr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> [<span class="dt">Expr</span>]</span>
<span id="cb854-43"><a href="#cb854-43" aria-hidden="true" tabindex="-1"></a>parseExpr input <span class="ot">=</span> </span>
<span id="cb854-44"><a href="#cb854-44" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> tokenStream <span class="ot">=</span> scanTokens input <span class="kw">in</span></span>
<span id="cb854-45"><a href="#cb854-45" aria-hidden="true" tabindex="-1"></a>  runExcept (expr tokenStream)</span>
<span id="cb854-46"><a href="#cb854-46" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>As a simple input consider the following simple program.</p>
<div class="sourceCode" id="cb855"
data-include="src/24-parsing/happy/input.test"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb855-1"><a href="#cb855-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb855-2"><a href="#cb855-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> x</span>
<span id="cb855-3"><a href="#cb855-3" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> <span class="dv">5</span></span>
<span id="cb855-4"><a href="#cb855-4" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> y</span>
<span id="cb855-5"><a href="#cb855-5" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> <span class="dv">6</span></span>
<span id="cb855-6"><a href="#cb855-6" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> y</span></code></pre></div>
<hr/>
<h1 id="streaming">Streaming</h1>
<h2 id="lazy-io">Lazy IO</h2>
<p>The problem with using the usual monadic approach to processing data
accumulated through IO is that the Prelude tools require us to manifest
large amounts of data in memory all at once before we can even begin
computation.</p>
<div class="sourceCode" id="cb856"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb856-1"><a href="#cb856-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mapM</span><span class="ot"> ::</span> (<span class="dt">Monad</span> m, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> m (t b)</span>
<span id="cb856-2"><a href="#cb856-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sequence</span><span class="ot"> ::</span> (<span class="dt">Monad</span> m, <span class="dt">Traversable</span> t) <span class="ot">=&gt;</span> t (m a) <span class="ot">-&gt;</span> m (t a)</span></code></pre></div>
<p>Reading from the file creates a thunk for the string that forced will
then read the file. The problem is then that this method ties the
ordering of IO effects to evaluation order which is difficult to reason
about in the large.</p>
<p>Consider that normally the monad laws ( in the absence of
<code>seq</code> ) guarantee that these computations should be
identical. But using lazy IO we can construct a degenerate case.</p>
<div class="sourceCode" id="cb857"
data-include="src/25-streaming/lazyio.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb857-1"><a href="#cb857-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span></span>
<span id="cb857-2"><a href="#cb857-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb857-3"><a href="#cb857-3" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb857-4"><a href="#cb857-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb857-5"><a href="#cb857-5" aria-hidden="true" tabindex="-1"></a>  withFile <span class="st">&quot;foo.txt&quot;</span> <span class="dt">ReadMode</span> <span class="op">$</span> \fd <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb857-6"><a href="#cb857-6" aria-hidden="true" tabindex="-1"></a>    contents <span class="ot">&lt;-</span> hGetContents fd</span>
<span id="cb857-7"><a href="#cb857-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> contents</span>
<span id="cb857-8"><a href="#cb857-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- &quot;foo\n&quot;</span></span>
<span id="cb857-9"><a href="#cb857-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb857-10"><a href="#cb857-10" aria-hidden="true" tabindex="-1"></a>  contents <span class="ot">&lt;-</span> withFile <span class="st">&quot;foo.txt&quot;</span> <span class="dt">ReadMode</span> hGetContents</span>
<span id="cb857-11"><a href="#cb857-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> contents</span>
<span id="cb857-12"><a href="#cb857-12" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- &quot;&quot;</span></span></code></pre></div>
<p>So what we need is a system to guarantee deterministic resource
handling with constant memory usage. To that end both the Conduits and
Pipes libraries solved this problem using different ( though largely
equivalent ) approaches.</p>
<h2 id="pipes">Pipes</h2>
<div class="sourceCode" id="cb858"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb858-1"><a href="#cb858-1" aria-hidden="true" tabindex="-1"></a><span class="ot">await ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Pipe</span> a y m a</span>
<span id="cb858-2"><a href="#cb858-2" aria-hidden="true" tabindex="-1"></a><span class="ot">yield ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Pipe</span> x a m ()</span>
<span id="cb858-3"><a href="#cb858-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb858-4"><a href="#cb858-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;-&gt;) ::</span> <span class="dt">Monad</span> m</span>
<span id="cb858-5"><a href="#cb858-5" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=&gt;</span> <span class="dt">Pipe</span> a b m r</span>
<span id="cb858-6"><a href="#cb858-6" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> <span class="dt">Pipe</span> b c m r</span>
<span id="cb858-7"><a href="#cb858-7" aria-hidden="true" tabindex="-1"></a>      <span class="ot">-&gt;</span> <span class="dt">Pipe</span> a c m r</span>
<span id="cb858-8"><a href="#cb858-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb858-9"><a href="#cb858-9" aria-hidden="true" tabindex="-1"></a><span class="ot">runEffect ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Effect</span> m r <span class="ot">-&gt;</span> m r</span>
<span id="cb858-10"><a href="#cb858-10" aria-hidden="true" tabindex="-1"></a><span class="ot">toListM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Producer</span> a m () <span class="ot">-&gt;</span> m [a]</span></code></pre></div>
<p>Pipes is a stream processing library with a strong emphasis on the
static semantics of composition. The simplest usage is to connect “pipe”
functions with a <code>(&gt;-&gt;)</code> composition operator, where
each component can <code>await</code> and <code>yield</code> to push and
pull values along the stream.</p>
<div class="sourceCode" id="cb859"
data-include="src/25-streaming/pipes.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb859-1"><a href="#cb859-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Pipes</span></span>
<span id="cb859-2"><a href="#cb859-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Pipes.Prelude</span> <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb859-3"><a href="#cb859-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb859-4"><a href="#cb859-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Identity</span></span>
<span id="cb859-5"><a href="#cb859-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb859-6"><a href="#cb859-6" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Producer</span> <span class="dt">Int</span> <span class="dt">Identity</span> ()</span>
<span id="cb859-7"><a href="#cb859-7" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> forM_ [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>] yield</span>
<span id="cb859-8"><a href="#cb859-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb859-9"><a href="#cb859-9" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">Pipe</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Identity</span> ()</span>
<span id="cb859-10"><a href="#cb859-10" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span>  forever <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb859-11"><a href="#cb859-11" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> await</span>
<span id="cb859-12"><a href="#cb859-12" aria-hidden="true" tabindex="-1"></a>  yield (x<span class="op">*</span><span class="dv">2</span>)</span>
<span id="cb859-13"><a href="#cb859-13" aria-hidden="true" tabindex="-1"></a>  yield (x<span class="op">*</span><span class="dv">3</span>)</span>
<span id="cb859-14"><a href="#cb859-14" aria-hidden="true" tabindex="-1"></a>  yield (x<span class="op">*</span><span class="dv">4</span>)</span>
<span id="cb859-15"><a href="#cb859-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb859-16"><a href="#cb859-16" aria-hidden="true" tabindex="-1"></a><span class="ot">c ::</span> <span class="dt">Pipe</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Identity</span> ()</span>
<span id="cb859-17"><a href="#cb859-17" aria-hidden="true" tabindex="-1"></a>c <span class="ot">=</span> forever <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb859-18"><a href="#cb859-18" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> await</span>
<span id="cb859-19"><a href="#cb859-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> (x <span class="ot">`mod`</span> <span class="dv">2</span>) <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb859-20"><a href="#cb859-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">then</span> yield x</span>
<span id="cb859-21"><a href="#cb859-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">else</span> <span class="fu">return</span> ()</span>
<span id="cb859-22"><a href="#cb859-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb859-23"><a href="#cb859-23" aria-hidden="true" tabindex="-1"></a><span class="ot">result ::</span> [<span class="dt">Int</span>]</span>
<span id="cb859-24"><a href="#cb859-24" aria-hidden="true" tabindex="-1"></a>result <span class="ot">=</span> P.toList <span class="op">$</span> a <span class="op">&gt;-&gt;</span> b <span class="op">&gt;-&gt;</span> c</span></code></pre></div>
<p>For example we could construct a “FizzBuzz” pipe.</p>
<div class="sourceCode" id="cb860"
data-include="src/25-streaming/pipes_io.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb860-1"><a href="#cb860-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiWayIf #-}</span></span>
<span id="cb860-2"><a href="#cb860-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb860-3"><a href="#cb860-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Pipes</span></span>
<span id="cb860-4"><a href="#cb860-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Pipes.Prelude</span> <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb860-5"><a href="#cb860-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb860-6"><a href="#cb860-6" aria-hidden="true" tabindex="-1"></a><span class="ot">count ::</span> <span class="dt">Producer</span> <span class="dt">Integer</span> <span class="dt">IO</span> ()</span>
<span id="cb860-7"><a href="#cb860-7" aria-hidden="true" tabindex="-1"></a>count <span class="ot">=</span> each [<span class="dv">1</span><span class="op">..</span><span class="dv">100</span>]</span>
<span id="cb860-8"><a href="#cb860-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb860-9"><a href="#cb860-9" aria-hidden="true" tabindex="-1"></a><span class="ot">fizzbuzz ::</span> <span class="dt">Pipe</span> <span class="dt">Integer</span> <span class="dt">String</span> <span class="dt">IO</span> ()</span>
<span id="cb860-10"><a href="#cb860-10" aria-hidden="true" tabindex="-1"></a>fizzbuzz <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb860-11"><a href="#cb860-11" aria-hidden="true" tabindex="-1"></a>  n <span class="ot">&lt;-</span> await</span>
<span id="cb860-12"><a href="#cb860-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> <span class="op">|</span> n <span class="ot">`mod`</span> <span class="dv">15</span> <span class="op">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> yield <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb860-13"><a href="#cb860-13" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span> n <span class="ot">`mod`</span> <span class="dv">5</span>  <span class="op">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> yield <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb860-14"><a href="#cb860-14" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span> n <span class="ot">`mod`</span> <span class="dv">3</span>  <span class="op">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> yield <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb860-15"><a href="#cb860-15" aria-hidden="true" tabindex="-1"></a>     <span class="op">|</span> <span class="fu">otherwise</span>       <span class="ot">-&gt;</span> <span class="fu">return</span> ()</span>
<span id="cb860-16"><a href="#cb860-16" aria-hidden="true" tabindex="-1"></a>  fizzbuzz</span>
<span id="cb860-17"><a href="#cb860-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb860-18"><a href="#cb860-18" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb860-19"><a href="#cb860-19" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> runEffect <span class="op">$</span> count <span class="op">&gt;-&gt;</span> fizzbuzz <span class="op">&gt;-&gt;</span> P.stdoutLn</span></code></pre></div>
<p>To continue with the degenerate case we constructed with Lazy IO,
consider than we can now compose and sequence deterministic actions over
files without having to worry about effect order.</p>
<div class="sourceCode" id="cb861"
data-include="src/25-streaming/pipes_file.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb861-1"><a href="#cb861-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Pipes</span></span>
<span id="cb861-2"><a href="#cb861-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Pipes.Prelude</span> <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb861-3"><a href="#cb861-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span></span>
<span id="cb861-4"><a href="#cb861-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb861-5"><a href="#cb861-5" aria-hidden="true" tabindex="-1"></a><span class="ot">readF ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Producer</span> <span class="dt">String</span> <span class="dt">IO</span> ()</span>
<span id="cb861-6"><a href="#cb861-6" aria-hidden="true" tabindex="-1"></a>readF file <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb861-7"><a href="#cb861-7" aria-hidden="true" tabindex="-1"></a>    lift <span class="op">$</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Opened&quot;</span> <span class="op">++</span> file</span>
<span id="cb861-8"><a href="#cb861-8" aria-hidden="true" tabindex="-1"></a>    h <span class="ot">&lt;-</span> lift <span class="op">$</span> openFile file <span class="dt">ReadMode</span></span>
<span id="cb861-9"><a href="#cb861-9" aria-hidden="true" tabindex="-1"></a>    fromHandle h</span>
<span id="cb861-10"><a href="#cb861-10" aria-hidden="true" tabindex="-1"></a>    lift <span class="op">$</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Closed&quot;</span> <span class="op">++</span> file</span>
<span id="cb861-11"><a href="#cb861-11" aria-hidden="true" tabindex="-1"></a>    lift <span class="op">$</span> hClose h</span>
<span id="cb861-12"><a href="#cb861-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb861-13"><a href="#cb861-13" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb861-14"><a href="#cb861-14" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> runEffect <span class="op">$</span> readF <span class="st">&quot;foo.txt&quot;</span> <span class="op">&gt;-&gt;</span> P.take <span class="dv">3</span> <span class="op">&gt;-&gt;</span> stdoutLn</span></code></pre></div>
<p>This is a simple sampling of the functionality of pipes. The
documentation for pipes is extensive and great deal of care has been
taken make the library extremely thorough. <code>pipes</code> is a
shining example of an accessible yet category theoretic driven
design.</p>
<p>See: <a
href="http://hackage.haskell.org/package/pipes-4.1.0/docs/Pipes-Tutorial.html">Pipes
Tutorial</a></p>
<h2 id="zeromq">ZeroMQ</h2>
<div class="sourceCode" id="cb862"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb862-1"><a href="#cb862-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bracket ::</span> <span class="dt">MonadSafe</span> m <span class="ot">=&gt;</span> <span class="dt">Base</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Base</span> m b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> m c</span></code></pre></div>
<p>As a motivating example, ZeroMQ is a network messaging library that
abstracts over traditional Unix sockets to a variety of network
topologies. Most notably it isn’t designed to guarantee any sort of
transactional guarantees for delivery or recovery in case of errors so
it’s necessary to design a layer on top of it to provide the desired
behavior at the application layer.</p>
<p>In Haskell we’d like to guarantee that if we’re polling on a socket
we get messages delivered in a timely fashion or consider the resource
in an error state and recover from it. Using <code>pipes-safe</code> we
can manage the life cycle of lazy IO resources and can safely handle
failures, resource termination and finalization gracefully. In other
languages this kind of logic would be smeared across several places, or
put in some global context and prone to introduce errors and subtle race
conditions. Using pipes we instead get a nice tight abstraction designed
exactly to fit this kind of use case.</p>
<p>For instance now we can bracket the ZeroMQ socket creation and
finalization within the <code>SafeT</code> monad transformer which
guarantees that after successful message delivery we execute the pipes
function as expected, or on failure we halt the execution and finalize
the socket.</p>
<div class="sourceCode" id="cb863"
data-include="src/25-streaming/pipes_safe.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb863-1"><a href="#cb863-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Pipes</span></span>
<span id="cb863-2"><a href="#cb863-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Pipes.Safe</span></span>
<span id="cb863-3"><a href="#cb863-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Pipes.Prelude</span> <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb863-4"><a href="#cb863-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb863-5"><a href="#cb863-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Timeout</span> (timeout)</span>
<span id="cb863-6"><a href="#cb863-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Char8</span></span>
<span id="cb863-7"><a href="#cb863-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.ZMQ</span> <span class="kw">as</span> <span class="dt">ZMQ</span></span>
<span id="cb863-8"><a href="#cb863-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb863-9"><a href="#cb863-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Opts</span> <span class="ot">=</span> <span class="dt">Opts</span></span>
<span id="cb863-10"><a href="#cb863-10" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> _addr    ::</span> <span class="dt">String</span>  <span class="co">-- ^ ZMQ socket address</span></span>
<span id="cb863-11"><a href="#cb863-11" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> _timeout ::</span> <span class="dt">Int</span>     <span class="co">-- ^ Time in milliseconds for socket timeout</span></span>
<span id="cb863-12"><a href="#cb863-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb863-13"><a href="#cb863-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb863-14"><a href="#cb863-14" aria-hidden="true" tabindex="-1"></a><span class="ot">recvTimeout ::</span> <span class="dt">Opts</span> <span class="ot">-&gt;</span> <span class="dt">ZMQ.Socket</span> a <span class="ot">-&gt;</span> <span class="dt">Producer</span> <span class="dt">ByteString</span> (<span class="dt">SafeT</span> <span class="dt">IO</span>) ()</span>
<span id="cb863-15"><a href="#cb863-15" aria-hidden="true" tabindex="-1"></a>recvTimeout opts sock <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb863-16"><a href="#cb863-16" aria-hidden="true" tabindex="-1"></a>  body <span class="ot">&lt;-</span> liftIO <span class="op">$</span> timeout (_timeout opts) (ZMQ.receive sock [])</span>
<span id="cb863-17"><a href="#cb863-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> body <span class="kw">of</span></span>
<span id="cb863-18"><a href="#cb863-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> msg <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb863-19"><a href="#cb863-19" aria-hidden="true" tabindex="-1"></a>      liftIO <span class="op">$</span> ZMQ.send sock msg []</span>
<span id="cb863-20"><a href="#cb863-20" aria-hidden="true" tabindex="-1"></a>      yield msg</span>
<span id="cb863-21"><a href="#cb863-21" aria-hidden="true" tabindex="-1"></a>      recvTimeout opts sock</span>
<span id="cb863-22"><a href="#cb863-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span>  <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="fu">print</span> <span class="st">&quot;socket timed out&quot;</span></span>
<span id="cb863-23"><a href="#cb863-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb863-24"><a href="#cb863-24" aria-hidden="true" tabindex="-1"></a><span class="ot">collect ::</span> <span class="dt">ZMQ.Context</span></span>
<span id="cb863-25"><a href="#cb863-25" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">Opts</span></span>
<span id="cb863-26"><a href="#cb863-26" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> <span class="dt">Producer</span> <span class="dt">ByteString</span> (<span class="dt">SafeT</span> <span class="dt">IO</span>) ()</span>
<span id="cb863-27"><a href="#cb863-27" aria-hidden="true" tabindex="-1"></a>collect ctx opts <span class="ot">=</span> bracket zinit zclose (recvTimeout opts)</span>
<span id="cb863-28"><a href="#cb863-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb863-29"><a href="#cb863-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- Initialize the socket</span></span>
<span id="cb863-30"><a href="#cb863-30" aria-hidden="true" tabindex="-1"></a>    zinit <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb863-31"><a href="#cb863-31" aria-hidden="true" tabindex="-1"></a>      liftIO <span class="op">$</span> <span class="fu">print</span> <span class="st">&quot;waiting for messages&quot;</span></span>
<span id="cb863-32"><a href="#cb863-32" aria-hidden="true" tabindex="-1"></a>      sock <span class="ot">&lt;-</span> ZMQ.socket ctx <span class="dt">ZMQ.Rep</span></span>
<span id="cb863-33"><a href="#cb863-33" aria-hidden="true" tabindex="-1"></a>      ZMQ.bind sock (_addr opts)</span>
<span id="cb863-34"><a href="#cb863-34" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> sock</span>
<span id="cb863-35"><a href="#cb863-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb863-36"><a href="#cb863-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- On timeout or completion guarantee the socket get closed.</span></span>
<span id="cb863-37"><a href="#cb863-37" aria-hidden="true" tabindex="-1"></a>    zclose sock <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb863-38"><a href="#cb863-38" aria-hidden="true" tabindex="-1"></a>      liftIO <span class="op">$</span> <span class="fu">print</span> <span class="st">&quot;finalizing&quot;</span></span>
<span id="cb863-39"><a href="#cb863-39" aria-hidden="true" tabindex="-1"></a>      ZMQ.close sock</span>
<span id="cb863-40"><a href="#cb863-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb863-41"><a href="#cb863-41" aria-hidden="true" tabindex="-1"></a><span class="ot">runZmq ::</span> <span class="dt">ZMQ.Context</span> <span class="ot">-&gt;</span> <span class="dt">Opts</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb863-42"><a href="#cb863-42" aria-hidden="true" tabindex="-1"></a>runZmq ctx opts <span class="ot">=</span> runSafeT <span class="op">$</span> runEffect <span class="op">$</span></span>
<span id="cb863-43"><a href="#cb863-43" aria-hidden="true" tabindex="-1"></a>  collect ctx opts <span class="op">&gt;-&gt;</span> P.take <span class="dv">10</span> <span class="op">&gt;-&gt;</span> P.print</span>
<span id="cb863-44"><a href="#cb863-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb863-45"><a href="#cb863-45" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb863-46"><a href="#cb863-46" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb863-47"><a href="#cb863-47" aria-hidden="true" tabindex="-1"></a>  ctx <span class="ot">&lt;-</span> ZMQ.init <span class="dv">1</span></span>
<span id="cb863-48"><a href="#cb863-48" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> opts <span class="ot">=</span> <span class="dt">Opts</span> {_addr <span class="ot">=</span> <span class="st">&quot;tcp://127.0.0.1:8000&quot;</span>, _timeout <span class="ot">=</span> <span class="dv">1000000</span> }</span>
<span id="cb863-49"><a href="#cb863-49" aria-hidden="true" tabindex="-1"></a>  runZmq ctx opts</span>
<span id="cb863-50"><a href="#cb863-50" aria-hidden="true" tabindex="-1"></a>  ZMQ.term ctx</span></code></pre></div>
<h2 id="conduits">Conduits</h2>
<div class="sourceCode" id="cb864"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb864-1"><a href="#cb864-1" aria-hidden="true" tabindex="-1"></a><span class="ot">await ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> i o m (<span class="dt">Maybe</span> i)</span>
<span id="cb864-2"><a href="#cb864-2" aria-hidden="true" tabindex="-1"></a><span class="ot">yield ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> o <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> i o m ()</span>
<span id="cb864-3"><a href="#cb864-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb864-4"><a href="#cb864-4" aria-hidden="true" tabindex="-1"></a><span class="ot">runConduit ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">ConduitT</span> () <span class="dt">Void</span> m r <span class="ot">-&gt;</span> m r</span>
<span id="cb864-5"><a href="#cb864-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(.|) ::</span> <span class="dt">Monad</span> m</span>
<span id="cb864-6"><a href="#cb864-6" aria-hidden="true" tabindex="-1"></a>     <span class="ot">=&gt;</span> <span class="dt">ConduitM</span> a b m ()</span>
<span id="cb864-7"><a href="#cb864-7" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> b c m r</span>
<span id="cb864-8"><a href="#cb864-8" aria-hidden="true" tabindex="-1"></a>     <span class="ot">-&gt;</span> <span class="dt">ConduitM</span> a c m r</span></code></pre></div>
<p>Conduits are conceptually similar though philosophically different
approach to the same problem of constant space deterministic resource
handling for IO resources.</p>
<p>The first initial difference is that await function now returns a
<code>Maybe</code> which allows different handling of termination.</p>
<p>Since 1.2.8 the separate connecting and fusing operators are
deprecated in favor of a single fusing operator <code>(.|)</code>.</p>
<div class="sourceCode" id="cb865"
data-include="src/25-streaming/conduit.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb865-1"><a href="#cb865-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiWayIf #-}</span></span>
<span id="cb865-2"><a href="#cb865-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb865-3"><a href="#cb865-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span></span>
<span id="cb865-4"><a href="#cb865-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Conduit</span></span>
<span id="cb865-5"><a href="#cb865-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Conduit.List</span> <span class="kw">as</span> <span class="dt">CL</span></span>
<span id="cb865-6"><a href="#cb865-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb865-7"><a href="#cb865-7" aria-hidden="true" tabindex="-1"></a><span class="ot">source ::</span> <span class="dt">ConduitT</span> () <span class="dt">Int</span> <span class="dt">IO</span> ()</span>
<span id="cb865-8"><a href="#cb865-8" aria-hidden="true" tabindex="-1"></a>source <span class="ot">=</span> CL.sourceList [<span class="dv">1</span> <span class="op">..</span> <span class="dv">100</span>]</span>
<span id="cb865-9"><a href="#cb865-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb865-10"><a href="#cb865-10" aria-hidden="true" tabindex="-1"></a><span class="ot">conduit ::</span> <span class="dt">ConduitT</span> <span class="dt">Int</span> <span class="dt">String</span> <span class="dt">IO</span> ()</span>
<span id="cb865-11"><a href="#cb865-11" aria-hidden="true" tabindex="-1"></a>conduit <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb865-12"><a href="#cb865-12" aria-hidden="true" tabindex="-1"></a>  val <span class="ot">&lt;-</span> await</span>
<span id="cb865-13"><a href="#cb865-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> val <span class="kw">of</span></span>
<span id="cb865-14"><a href="#cb865-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()</span>
<span id="cb865-15"><a href="#cb865-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> n <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb865-16"><a href="#cb865-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span>  <span class="op">|</span> n <span class="ot">`mod`</span> <span class="dv">15</span> <span class="op">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> yield <span class="st">&quot;FizzBuzz&quot;</span></span>
<span id="cb865-17"><a href="#cb865-17" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> n <span class="ot">`mod`</span> <span class="dv">5</span> <span class="op">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> yield <span class="st">&quot;Fizz&quot;</span></span>
<span id="cb865-18"><a href="#cb865-18" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> n <span class="ot">`mod`</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span> <span class="ot">-&gt;</span> yield <span class="st">&quot;Buzz&quot;</span></span>
<span id="cb865-19"><a href="#cb865-19" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()</span>
<span id="cb865-20"><a href="#cb865-20" aria-hidden="true" tabindex="-1"></a>      conduit</span>
<span id="cb865-21"><a href="#cb865-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb865-22"><a href="#cb865-22" aria-hidden="true" tabindex="-1"></a><span class="ot">sink ::</span> <span class="dt">ConduitT</span> <span class="dt">String</span> o <span class="dt">IO</span> ()</span>
<span id="cb865-23"><a href="#cb865-23" aria-hidden="true" tabindex="-1"></a>sink <span class="ot">=</span> CL.mapM_ <span class="fu">putStrLn</span></span>
<span id="cb865-24"><a href="#cb865-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb865-25"><a href="#cb865-25" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb865-26"><a href="#cb865-26" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> runConduit <span class="op">$</span> source <span class="op">.|</span> conduit <span class="op">.|</span> sink</span></code></pre></div>
</hr>
<h1 id="cryptography">Cryptography</h1>
<p>Recently Haskell has seen quite a bit of development of cryptography
libraries as it serves as an excellent language for working with and
manipulating algebraic structures found in cryptographic primitives. In
addition to most of the basic hashing, elliptic curve and cipher suites
libraries, Haskell has a excellent standard cryptography library called
<code>cryptonite</code> which provides the standard kitchen sink of most
modern primitives. These include hash functions, elliptic curve
cryptography, digital signature algorithms, ciphers, one time passwords,
entropy generation and safe memory handling.</p>
<h2 id="sha-hashing">SHA Hashing</h2>
<p>A cryptographic hash function is a special class of hash function
that has certain properties which make it suitable for use in
cryptography. It is a mathematical algorithm that maps data of arbitrary
size to a bit string of a fixed size (a hash function) which is designed
to also be a one-way function, that is, a function which is infeasible
to invert.</p>
<p>SHA-256 is a cryptographic hash function from the SHA-2 family and is
standardized by NIST. It produces a 256-bit message digest.</p>
<div class="sourceCode" id="cb866"
data-include="src/32-cryptography/SHA.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb866-1"><a href="#cb866-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb866-2"><a href="#cb866-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb866-3"><a href="#cb866-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.Hash</span> (<span class="dt">SHA256</span>, <span class="dt">Digest</span>, hash)</span>
<span id="cb866-4"><a href="#cb866-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteArray</span> (convert)</span>
<span id="cb866-5"><a href="#cb866-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Char8</span> (<span class="dt">ByteString</span>)</span>
<span id="cb866-6"><a href="#cb866-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb866-7"><a href="#cb866-7" aria-hidden="true" tabindex="-1"></a><span class="ot">v1 ::</span> <span class="dt">ByteString</span></span>
<span id="cb866-8"><a href="#cb866-8" aria-hidden="true" tabindex="-1"></a>v1 <span class="ot">=</span> <span class="st">&quot;The quick brown fox jumps over the lazy dog&quot;</span></span>
<span id="cb866-9"><a href="#cb866-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb866-10"><a href="#cb866-10" aria-hidden="true" tabindex="-1"></a><span class="ot">h1 ::</span> <span class="dt">Digest</span> <span class="dt">SHA256</span></span>
<span id="cb866-11"><a href="#cb866-11" aria-hidden="true" tabindex="-1"></a>h1 <span class="ot">=</span> hash v1</span>
<span id="cb866-12"><a href="#cb866-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb866-13"><a href="#cb866-13" aria-hidden="true" tabindex="-1"></a><span class="ot">s1 ::</span> <span class="dt">ByteString</span></span>
<span id="cb866-14"><a href="#cb866-14" aria-hidden="true" tabindex="-1"></a>s1  <span class="ot">=</span> convert h1</span>
<span id="cb866-15"><a href="#cb866-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb866-16"><a href="#cb866-16" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb866-17"><a href="#cb866-17" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb866-18"><a href="#cb866-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> v1</span>
<span id="cb866-19"><a href="#cb866-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> h1</span>
<span id="cb866-20"><a href="#cb866-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> s1</span></code></pre></div>
<div class="sourceCode" id="cb867"
data-include="src/32-cryptography/Keccak.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb867-1"><a href="#cb867-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb867-2"><a href="#cb867-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb867-3"><a href="#cb867-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.Hash</span> (<span class="dt">Keccak_256</span>, <span class="dt">Digest</span>, hash)</span>
<span id="cb867-4"><a href="#cb867-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteArray</span> (convert)</span>
<span id="cb867-5"><a href="#cb867-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Char8</span> (<span class="dt">ByteString</span>)</span>
<span id="cb867-6"><a href="#cb867-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb867-7"><a href="#cb867-7" aria-hidden="true" tabindex="-1"></a><span class="ot">v1 ::</span> <span class="dt">ByteString</span></span>
<span id="cb867-8"><a href="#cb867-8" aria-hidden="true" tabindex="-1"></a>v1 <span class="ot">=</span> <span class="st">&quot;The quick brown fox jumps over the lazy dog&quot;</span></span>
<span id="cb867-9"><a href="#cb867-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb867-10"><a href="#cb867-10" aria-hidden="true" tabindex="-1"></a><span class="ot">h1 ::</span> <span class="dt">Digest</span> <span class="dt">Keccak_256</span></span>
<span id="cb867-11"><a href="#cb867-11" aria-hidden="true" tabindex="-1"></a>h1 <span class="ot">=</span> hash v1</span>
<span id="cb867-12"><a href="#cb867-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb867-13"><a href="#cb867-13" aria-hidden="true" tabindex="-1"></a><span class="ot">s1 ::</span> <span class="dt">ByteString</span></span>
<span id="cb867-14"><a href="#cb867-14" aria-hidden="true" tabindex="-1"></a>s1  <span class="ot">=</span> convert h1</span>
<span id="cb867-15"><a href="#cb867-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb867-16"><a href="#cb867-16" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb867-17"><a href="#cb867-17" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb867-18"><a href="#cb867-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> v1</span>
<span id="cb867-19"><a href="#cb867-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> h1</span>
<span id="cb867-20"><a href="#cb867-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> s1</span></code></pre></div>
<h2 id="password-hashing">Password Hashing</h2>
<p>Modern applications should use one of either the Blake2 or Argon2
hashing algorithms for storing passwords in a database as part of an
authentication workflow.</p>
<p>To use Argon2:</p>
<div class="sourceCode" id="cb868"
data-include="src/32-cryptography/Argon.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb868-1"><a href="#cb868-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb868-2"><a href="#cb868-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb868-3"><a href="#cb868-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Argon</span> <span class="kw">where</span></span>
<span id="cb868-4"><a href="#cb868-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb868-5"><a href="#cb868-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.Error</span></span>
<span id="cb868-6"><a href="#cb868-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.KDF.Argon2</span></span>
<span id="cb868-7"><a href="#cb868-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.Random</span> (getRandomBytes)</span>
<span id="cb868-8"><a href="#cb868-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString</span></span>
<span id="cb868-9"><a href="#cb868-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb868-10"><a href="#cb868-10" aria-hidden="true" tabindex="-1"></a><span class="ot">passHash ::</span> <span class="dt">IO</span> ()</span>
<span id="cb868-11"><a href="#cb868-11" aria-hidden="true" tabindex="-1"></a>passHash <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb868-12"><a href="#cb868-12" aria-hidden="true" tabindex="-1"></a>  salt <span class="ot">&lt;-</span> getRandomBytes <span class="dv">16</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">ByteString</span></span>
<span id="cb868-13"><a href="#cb868-13" aria-hidden="true" tabindex="-1"></a>  out <span class="ot">&lt;-</span> throwCryptoErrorIO (hash defaultOptions (<span class="st">&quot;hunter2&quot;</span><span class="ot"> ::</span> <span class="dt">ByteString</span>) salt <span class="dv">256</span>)</span>
<span id="cb868-14"><a href="#cb868-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (<span class="ot">out ::</span> <span class="dt">ByteString</span>)</span></code></pre></div>
<p>To use Blake2:</p>
<div class="sourceCode" id="cb869"
data-include="src/32-cryptography/Blake2.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb869-1"><a href="#cb869-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb869-2"><a href="#cb869-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb869-3"><a href="#cb869-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Blake2</span> <span class="kw">where</span></span>
<span id="cb869-4"><a href="#cb869-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb869-5"><a href="#cb869-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.Hash</span></span>
<span id="cb869-6"><a href="#cb869-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString</span></span>
<span id="cb869-7"><a href="#cb869-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb869-8"><a href="#cb869-8" aria-hidden="true" tabindex="-1"></a><span class="ot">passHash ::</span> <span class="dt">Digest</span> <span class="dt">Blake2b_256</span></span>
<span id="cb869-9"><a href="#cb869-9" aria-hidden="true" tabindex="-1"></a>passHash <span class="ot">=</span> hash (<span class="st">&quot;hunter2&quot;</span><span class="ot"> ::</span> <span class="dt">ByteString</span>)</span></code></pre></div>
<h2 id="curve25519-diffie-hellman">Curve25519 Diffie-Hellman</h2>
<p>Curve25519 is a widely used Diffie-Hellman function suitable for a
wide variety of applications. Private and public keys using Curve25519
are 32 bytes each. Elliptic curve Diffie-Hellman is a protocol in which
two parties can exchange their public keys in the clear and generate a
shared secret which can be used to share information across a secure
channel.</p>
<p>A private key is a large integral value which is multiplied by the
base point on the curve to generate the public key. Going to backwards
from a public key requires one to solve the elliptic curve discrete
logarithm which is believed to be computationally infeasible.</p>
<div class="sourceCode" id="cb870"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb870-1"><a href="#cb870-1" aria-hidden="true" tabindex="-1"></a><span class="ot">generateSecretKey ::</span> <span class="dt">MonadRandom</span> m <span class="ot">=&gt;</span> m <span class="dt">SecretKey</span></span>
<span id="cb870-2"><a href="#cb870-2" aria-hidden="true" tabindex="-1"></a><span class="ot">toPublic ::</span> <span class="dt">SecretKey</span> <span class="ot">-&gt;</span> <span class="dt">PublicKey</span></span></code></pre></div>
<p>Diffie-Hellman key exchange be performed by executing the function
<code>dh</code> over the private and public keys for Alice and Bob.</p>
<div class="sourceCode" id="cb871"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb871-1"><a href="#cb871-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dh ::</span> <span class="dt">PublicKey</span> <span class="ot">-&gt;</span> <span class="dt">SecretKey</span> <span class="ot">-&gt;</span> <span class="dt">DhSecret</span></span></code></pre></div>
<p>An example is shown below:</p>
<div class="sourceCode" id="cb872"
data-include="src/32-cryptography/Curve25519.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb872-1"><a href="#cb872-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.Error</span></span>
<span id="cb872-2"><a href="#cb872-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Crypto.PubKey.Curve25519</span> <span class="kw">as</span> <span class="dt">Curve25519</span></span>
<span id="cb872-3"><a href="#cb872-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb872-4"><a href="#cb872-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Diffie-Hellman Key Exchange for Curve25519</span></span>
<span id="cb872-5"><a href="#cb872-5" aria-hidden="true" tabindex="-1"></a><span class="ot">dh ::</span> <span class="dt">IO</span> ()</span>
<span id="cb872-6"><a href="#cb872-6" aria-hidden="true" tabindex="-1"></a>dh <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb872-7"><a href="#cb872-7" aria-hidden="true" tabindex="-1"></a>  alicePriv <span class="ot">&lt;-</span> Curve25519.generateSecretKey</span>
<span id="cb872-8"><a href="#cb872-8" aria-hidden="true" tabindex="-1"></a>  bobPriv <span class="ot">&lt;-</span> Curve25519.generateSecretKey</span>
<span id="cb872-9"><a href="#cb872-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> secret1 <span class="ot">=</span> Curve25519.dh (Curve25519.toPublic alicePriv) bobPriv</span>
<span id="cb872-10"><a href="#cb872-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> secret2 <span class="ot">=</span> Curve25519.dh (Curve25519.toPublic bobPriv) alicePriv</span>
<span id="cb872-11"><a href="#cb872-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (secret1 <span class="op">==</span> secret2)</span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://cr.yp.to/ecdh.html">curve25519</a></li>
</ul>
<h2 id="ed25519-eddsa">Ed25519 EdDSA</h2>
<p>EdDSA is a digital signature scheme based on Schnorr signature using
the twisted Edwards curve Ed25519 and SHA-512 (SHA-2). It generates
succinct (64 byte) signatures and has fast verification times.</p>
<div class="sourceCode" id="cb873"
data-include="src/32-cryptography/Ed25519.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb873-1"><a href="#cb873-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb873-2"><a href="#cb873-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb873-3"><a href="#cb873-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Ed25519</span> <span class="kw">where</span></span>
<span id="cb873-4"><a href="#cb873-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb873-5"><a href="#cb873-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.PubKey.Ed25519</span> <span class="kw">as</span> <span class="dt">Ed25519</span></span>
<span id="cb873-6"><a href="#cb873-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString</span></span>
<span id="cb873-7"><a href="#cb873-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb873-8"><a href="#cb873-8" aria-hidden="true" tabindex="-1"></a><span class="ot">msg ::</span> <span class="dt">ByteString</span></span>
<span id="cb873-9"><a href="#cb873-9" aria-hidden="true" tabindex="-1"></a>msg <span class="ot">=</span> <span class="st">&quot;My example message&quot;</span></span>
<span id="cb873-10"><a href="#cb873-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb873-11"><a href="#cb873-11" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> ()</span>
<span id="cb873-12"><a href="#cb873-12" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb873-13"><a href="#cb873-13" aria-hidden="true" tabindex="-1"></a>  privKey <span class="ot">&lt;-</span> Ed25519.generateSecretKey</span>
<span id="cb873-14"><a href="#cb873-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pubKey <span class="ot">=</span> Ed25519.toPublic privKey</span>
<span id="cb873-15"><a href="#cb873-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> sig <span class="ot">=</span> sign privKey pubKey msg</span>
<span id="cb873-16"><a href="#cb873-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> sig</span>
<span id="cb873-17"><a href="#cb873-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (Ed25519.verify pubKey msg sig)</span></code></pre></div>
<p>See Also:</p>
<ul>
<li><a href="https://ed25519.cr.yp.to/">ed25519</a></li>
</ul>
<h2 id="secure-memory-handling">Secure Memory Handling</h2>
<p>When using Haskell for cryptography work and even inside web
services, some care must be taken to ensure that the primitives you are
using don’t accidentally expose secrets or user data accidentally. This
can occur in many ways through the mishandling of keys, timing attacks
against interactive protocols, and the insecure wiping of memory.</p>
<p>When using Haskell integers be aware that arithmetic operations are
<strong>not constant time</strong> and are simply backed by GMP
integers. This may or may not be appropriate for your code if you expect
arithmetic operations to be branch-free or have constant time addition
or multiplication. If you need constant arithmetic you will likely have
to drop down to C or Assembly and link the resulting code into your
Haskell logic. Many Haskell cryptography libraries do just this.</p>
<p>With regards to timing attacks, take note of which functions are
marked as vulnerable to timing attacks as most of these are marked in
public API documentation.</p>
<p>When comparing hashes and unencrypted data for equality also make
sure to use an equality test which is constant time. The default derived
instance for <code>Eq</code> does <em>not</em> have this property. The
<code>securemem</code> library provides a <code>SecureMem</code>
datatype which can hold an arbitrary sized ByteString and can only be
compared against other <code>SecureMem</code> ByteStrings by a constant
time algorithm.</p>
<div class="sourceCode" id="cb874"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb874-1"><a href="#cb874-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- import Data.SecureMem</span></span>
<span id="cb874-2"><a href="#cb874-2" aria-hidden="true" tabindex="-1"></a><span class="ot">allocateSecureMem ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">SecureMem</span></span>
<span id="cb874-3"><a href="#cb874-3" aria-hidden="true" tabindex="-1"></a><span class="ot">finalizeSecureMem ::</span> <span class="dt">SecureMem</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb874-4"><a href="#cb874-4" aria-hidden="true" tabindex="-1"></a><span class="ot">toSecureMem ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">SecureMem</span></span></code></pre></div>
<p>This data structure will also automatically scrub its bytes with a
runtime integrated finalizer on the pointer to the underlying memory.
This ensures that as soon as the value is garbage collected, its
underlying memory is wiped to zero values and does not linger on the
process’s memory.</p>
<h2 id="aes-encryption">AES Encryption</h2>
<p>AES (Advanced Encryption Standard) is a symmetric block cipher
standardized by NIST. The cipher block size is fixed at 16 bytes and it
is encrypted using a key of 128, 192 or 256 bits. AES is common cipher
standard for symmetric encryption and used heavily in internet
protocols.</p>
<p>An example of encrypting and decrypting data using the
<code>cryptonite</code> library is shown below:</p>
<div class="sourceCode" id="cb875"
data-include="src/32-cryptography/AES.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb875-1"><a href="#cb875-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb875-2"><a href="#cb875-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb875-3"><a href="#cb875-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">AES</span> <span class="kw">where</span></span>
<span id="cb875-4"><a href="#cb875-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb875-5"><a href="#cb875-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.Cipher.AES</span></span>
<span id="cb875-6"><a href="#cb875-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.Cipher.Types</span></span>
<span id="cb875-7"><a href="#cb875-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.Error</span></span>
<span id="cb875-8"><a href="#cb875-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Crypto.Random.Types</span></span>
<span id="cb875-9"><a href="#cb875-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString</span></span>
<span id="cb875-10"><a href="#cb875-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb875-11"><a href="#cb875-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">AesKey</span> <span class="ot">=</span> <span class="dt">ByteString</span></span>
<span id="cb875-12"><a href="#cb875-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb875-13"><a href="#cb875-13" aria-hidden="true" tabindex="-1"></a><span class="ot">genKey ::</span> <span class="dt">IO</span> <span class="dt">AesKey</span></span>
<span id="cb875-14"><a href="#cb875-14" aria-hidden="true" tabindex="-1"></a>genKey <span class="ot">=</span> getRandomBytes <span class="dv">32</span> <span class="co">-- AES256 key size</span></span>
<span id="cb875-15"><a href="#cb875-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb875-16"><a href="#cb875-16" aria-hidden="true" tabindex="-1"></a><span class="ot">aesEncrypt ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">AesKey</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">CryptoError</span> <span class="dt">ByteString</span></span>
<span id="cb875-17"><a href="#cb875-17" aria-hidden="true" tabindex="-1"></a>aesEncrypt input sk <span class="ot">=</span></span>
<span id="cb875-18"><a href="#cb875-18" aria-hidden="true" tabindex="-1"></a>  ctrCombine</span>
<span id="cb875-19"><a href="#cb875-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;$&gt;</span> <span class="fu">init</span></span>
<span id="cb875-20"><a href="#cb875-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> nullIV</span>
<span id="cb875-21"><a href="#cb875-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> input</span>
<span id="cb875-22"><a href="#cb875-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb875-23"><a href="#cb875-23" aria-hidden="true" tabindex="-1"></a><span class="ot">    init ::</span> <span class="dt">Either</span> <span class="dt">CryptoError</span> <span class="dt">AES256</span></span>
<span id="cb875-24"><a href="#cb875-24" aria-hidden="true" tabindex="-1"></a>    <span class="fu">init</span> <span class="ot">=</span> eitherCryptoError <span class="op">$</span> cipherInit sk</span>
<span id="cb875-25"><a href="#cb875-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb875-26"><a href="#cb875-26" aria-hidden="true" tabindex="-1"></a><span class="ot">aesDecrypt ::</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">AesKey</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">CryptoError</span> <span class="dt">ByteString</span></span>
<span id="cb875-27"><a href="#cb875-27" aria-hidden="true" tabindex="-1"></a>aesDecrypt <span class="ot">=</span> aesEncrypt</span>
<span id="cb875-28"><a href="#cb875-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb875-29"><a href="#cb875-29" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb875-30"><a href="#cb875-30" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb875-31"><a href="#cb875-31" aria-hidden="true" tabindex="-1"></a>  key <span class="ot">&lt;-</span> genKey</span>
<span id="cb875-32"><a href="#cb875-32" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> message <span class="ot">=</span> <span class="st">&quot;The quick brown fox jumped over the lazy dog.&quot;</span></span>
<span id="cb875-33"><a href="#cb875-33" aria-hidden="true" tabindex="-1"></a>      mcipherText <span class="ot">=</span> aesEncrypt message key</span>
<span id="cb875-34"><a href="#cb875-34" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> mcipherText <span class="kw">of</span></span>
<span id="cb875-35"><a href="#cb875-35" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> cipherText <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb875-36"><a href="#cb875-36" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span> cipherText</span>
<span id="cb875-37"><a href="#cb875-37" aria-hidden="true" tabindex="-1"></a>      <span class="fu">print</span> (aesDecrypt cipherText key)</span>
<span id="cb875-38"><a href="#cb875-38" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="fu">print</span> err</span></code></pre></div>
<h2 id="galois-fields">Galois Fields</h2>
<p>Many modern cryptographic protocols require the use of finite field
arithmetic. Finite fields are algebraic structures that have algebraic
field structure (addition, multiplication, division) and closure</p>
<div class="sourceCode" id="cb876"
data-include="src/32-cryptography/Galois.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb876-1"><a href="#cb876-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb876-2"><a href="#cb876-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb876-3"><a href="#cb876-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb876-4"><a href="#cb876-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb876-5"><a href="#cb876-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedLists #-}</span></span>
<span id="cb876-6"><a href="#cb876-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb876-7"><a href="#cb876-7" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Galois</span> <span class="kw">where</span></span>
<span id="cb876-8"><a href="#cb876-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb876-9"><a href="#cb876-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Field.Galois</span></span>
<span id="cb876-10"><a href="#cb876-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((/))</span>
<span id="cb876-11"><a href="#cb876-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb876-12"><a href="#cb876-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- Prime field</span></span>
<span id="cb876-13"><a href="#cb876-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Fq</span> <span class="ot">=</span> <span class="dt">Prime</span> <span class="dv">2147483647</span></span>
<span id="cb876-14"><a href="#cb876-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb876-15"><a href="#cb876-15" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleFq ::</span> <span class="dt">IO</span> ()</span>
<span id="cb876-16"><a href="#cb876-16" aria-hidden="true" tabindex="-1"></a>exampleFq <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb876-17"><a href="#cb876-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> ((<span class="dv">1</span> <span class="op">+</span> <span class="bn">0x7FFFFFFF16</span>)<span class="ot"> ::</span> <span class="dt">Fq</span>)</span>
<span id="cb876-18"><a href="#cb876-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> ((<span class="dv">10000</span> <span class="op">*</span> <span class="dv">10000</span>)<span class="ot"> ::</span> <span class="dt">Fq</span>)</span>
<span id="cb876-19"><a href="#cb876-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> ((<span class="dv">1</span> <span class="op">/</span> <span class="dv">524287</span>)<span class="ot"> ::</span> <span class="dt">Fq</span>)</span>
<span id="cb876-20"><a href="#cb876-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb876-21"><a href="#cb876-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- Polynomial term</span></span>
<span id="cb876-22"><a href="#cb876-22" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">P2</span></span>
<span id="cb876-23"><a href="#cb876-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb876-24"><a href="#cb876-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- Extension field</span></span>
<span id="cb876-25"><a href="#cb876-25" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Fq2</span> <span class="ot">=</span> <span class="dt">Extension</span> <span class="dt">P2</span> <span class="dt">Fq</span></span>
<span id="cb876-26"><a href="#cb876-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb876-27"><a href="#cb876-27" aria-hidden="true" tabindex="-1"></a><span class="co">-- Irreducublie monic polynomial extension</span></span>
<span id="cb876-28"><a href="#cb876-28" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IrreducibleMonic</span> <span class="dt">P2</span> <span class="dt">Fq</span> <span class="kw">where</span></span>
<span id="cb876-29"><a href="#cb876-29" aria-hidden="true" tabindex="-1"></a>  poly _ <span class="ot">=</span> <span class="dt">X2</span> <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb876-30"><a href="#cb876-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb876-31"><a href="#cb876-31" aria-hidden="true" tabindex="-1"></a><span class="co">-- Polynomial 2*x^2 + 1 over Fq2</span></span>
<span id="cb876-32"><a href="#cb876-32" aria-hidden="true" tabindex="-1"></a><span class="ot">p1 ::</span> <span class="dt">Fq2</span></span>
<span id="cb876-33"><a href="#cb876-33" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">=</span> [<span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb876-34"><a href="#cb876-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb876-35"><a href="#cb876-35" aria-hidden="true" tabindex="-1"></a><span class="ot">p2 ::</span> <span class="dt">Fq2</span></span>
<span id="cb876-36"><a href="#cb876-36" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">=</span> (p1 <span class="op">+</span> p1) <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb876-37"><a href="#cb876-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb876-38"><a href="#cb876-38" aria-hidden="true" tabindex="-1"></a><span class="ot">p3 ::</span> <span class="dt">Bool</span></span>
<span id="cb876-39"><a href="#cb876-39" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">=</span> p2 <span class="op">/</span> p1 <span class="op">==</span> <span class="dv">4</span></span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="https://hackage.haskell.org/package/galois-field">galois-field</a></li>
</ul>
<h2 id="elliptic-curves">Elliptic Curves</h2>
<p>Elliptic curves are a type of algebraic structure that are used
heavily in cryptography. Most generally elliptic curves are families of
curves to second order plane curves in two variables defined over finite
fields. These elliptic curves admit a group construction over the curve
points which has multiplication and addition. For finite fields with
large order computing inversions is quite computationally difficult and
gives rise to a trapdoor function which is easy to compute in one
direction but difficult in reverse.</p>
<p>There are many types of plane curves with different coefficients that
can be defined. The widely studied groups are one of the four classes.
These are defined in the <code>elliptic-curve</code> library as lifted
datatypes which are used at the type-level to distinguish curve
operations.</p>
<ul>
<li>Binary</li>
<li>Edwards</li>
<li>Montgomery</li>
<li>Weierstrass</li>
</ul>
<p>On top of these curves there is an additional degree of freedom in
the choice of coordinate system used. There are many ways to interpret
the Cartesian plane in terms of coordinates and some of these coordinate
systems admit more efficient operations for multiplication and addition
of points.</p>
<ul>
<li>Affine</li>
<li>Jacobian</li>
<li>Projective</li>
</ul>
<p>For example the common Ed25519 curve can be defined as the following
group structure defined as a series of type-level constructions:</p>
<div class="sourceCode" id="cb877"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb877-1"><a href="#cb877-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Fr</span> <span class="ot">=</span> <span class="dt">Prime</span> </span>
<span id="cb877-2"><a href="#cb877-2" aria-hidden="true" tabindex="-1"></a>  <span class="dv">7237005577332262213973186563042994240857116359379907606001950938285454250989</span></span>
<span id="cb877-3"><a href="#cb877-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Fq</span> <span class="ot">=</span> <span class="dt">Prime</span> </span>
<span id="cb877-4"><a href="#cb877-4" aria-hidden="true" tabindex="-1"></a>  <span class="dv">57896044618658097711785492504343953926634992332820282019728792003956564819949</span></span>
<span id="cb877-5"><a href="#cb877-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">PA</span> <span class="ot">=</span> <span class="dt">Point</span> <span class="dt">Edwards</span> <span class="dt">Affine</span> <span class="dt">Ed25519</span> <span class="dt">Fq</span> <span class="dt">Fr</span></span>
<span id="cb877-6"><a href="#cb877-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">PP</span> <span class="ot">=</span> <span class="dt">Point</span> <span class="dt">Edwards</span> <span class="dt">Projective</span> <span class="dt">Ed25519</span> <span class="dt">Fq</span> <span class="dt">Fr</span></span></code></pre></div>
<p>Operations on this can be executed by several type classes
functions.</p>
<div class="sourceCode" id="cb878"
data-include="src/32-cryptography/ECC.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb878-1"><a href="#cb878-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Example</span> <span class="kw">where</span></span>
<span id="cb878-2"><a href="#cb878-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb878-3"><a href="#cb878-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Curve.Edwards.Ed25519</span> <span class="kw">as</span> <span class="dt">Ed25519</span></span>
<span id="cb878-4"><a href="#cb878-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Protolude</span></span>
<span id="cb878-5"><a href="#cb878-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb878-6"><a href="#cb878-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- generate random affine point</span></span>
<span id="cb878-7"><a href="#cb878-7" aria-hidden="true" tabindex="-1"></a><span class="ot">p1 ::</span> <span class="dt">Ed25519.PA</span></span>
<span id="cb878-8"><a href="#cb878-8" aria-hidden="true" tabindex="-1"></a>p1 <span class="ot">=</span> Ed25519.gen</span>
<span id="cb878-9"><a href="#cb878-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb878-10"><a href="#cb878-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- generate affine point by multiply by field coefficient</span></span>
<span id="cb878-11"><a href="#cb878-11" aria-hidden="true" tabindex="-1"></a><span class="ot">p2 ::</span> <span class="dt">Ed25519.PA</span></span>
<span id="cb878-12"><a href="#cb878-12" aria-hidden="true" tabindex="-1"></a>p2 <span class="ot">=</span> Ed25519.mul p1 (<span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Ed25519.Fr</span>)</span>
<span id="cb878-13"><a href="#cb878-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb878-14"><a href="#cb878-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- point addition</span></span>
<span id="cb878-15"><a href="#cb878-15" aria-hidden="true" tabindex="-1"></a><span class="ot">p3 ::</span> <span class="dt">Ed25519.PA</span></span>
<span id="cb878-16"><a href="#cb878-16" aria-hidden="true" tabindex="-1"></a>p3 <span class="ot">=</span> Ed25519.add p1 p2</span>
<span id="cb878-17"><a href="#cb878-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb878-18"><a href="#cb878-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- point identity</span></span>
<span id="cb878-19"><a href="#cb878-19" aria-hidden="true" tabindex="-1"></a><span class="ot">p4 ::</span> <span class="dt">Ed25519.PA</span></span>
<span id="cb878-20"><a href="#cb878-20" aria-hidden="true" tabindex="-1"></a>p4 <span class="ot">=</span> Ed25519.id</span>
<span id="cb878-21"><a href="#cb878-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb878-22"><a href="#cb878-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- point doubling</span></span>
<span id="cb878-23"><a href="#cb878-23" aria-hidden="true" tabindex="-1"></a><span class="ot">p5 ::</span> <span class="dt">Ed25519.PA</span></span>
<span id="cb878-24"><a href="#cb878-24" aria-hidden="true" tabindex="-1"></a>p5 <span class="ot">=</span> Ed25519.dbl p1</span>
<span id="cb878-25"><a href="#cb878-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb878-26"><a href="#cb878-26" aria-hidden="true" tabindex="-1"></a><span class="co">-- point inversion</span></span>
<span id="cb878-27"><a href="#cb878-27" aria-hidden="true" tabindex="-1"></a><span class="ot">p6 ::</span> <span class="dt">Ed25519.PA</span></span>
<span id="cb878-28"><a href="#cb878-28" aria-hidden="true" tabindex="-1"></a>p6 <span class="ot">=</span> Ed25519.inv p1</span>
<span id="cb878-29"><a href="#cb878-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb878-30"><a href="#cb878-30" aria-hidden="true" tabindex="-1"></a><span class="co">-- Frobenius endomorphism</span></span>
<span id="cb878-31"><a href="#cb878-31" aria-hidden="true" tabindex="-1"></a><span class="ot">p7 ::</span> <span class="dt">Ed25519.PA</span></span>
<span id="cb878-32"><a href="#cb878-32" aria-hidden="true" tabindex="-1"></a>p7 <span class="ot">=</span> Ed25519.frob p1</span>
<span id="cb878-33"><a href="#cb878-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb878-34"><a href="#cb878-34" aria-hidden="true" tabindex="-1"></a><span class="co">-- base point</span></span>
<span id="cb878-35"><a href="#cb878-35" aria-hidden="true" tabindex="-1"></a><span class="ot">p8 ::</span> <span class="dt">Ed25519.PA</span></span>
<span id="cb878-36"><a href="#cb878-36" aria-hidden="true" tabindex="-1"></a>p8 <span class="ot">=</span> Ed25519.gA</span>
<span id="cb878-37"><a href="#cb878-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb878-38"><a href="#cb878-38" aria-hidden="true" tabindex="-1"></a><span class="co">-- convert affine coordinates to projective coordinates</span></span>
<span id="cb878-39"><a href="#cb878-39" aria-hidden="true" tabindex="-1"></a><span class="ot">p9 ::</span> <span class="dt">Ed25519.PP</span></span>
<span id="cb878-40"><a href="#cb878-40" aria-hidden="true" tabindex="-1"></a>p9 <span class="ot">=</span> Ed25519.fromA p8</span>
<span id="cb878-41"><a href="#cb878-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb878-42"><a href="#cb878-42" aria-hidden="true" tabindex="-1"></a><span class="co">-- get y coordinate (point from Fq) from coordinate</span></span>
<span id="cb878-43"><a href="#cb878-43" aria-hidden="true" tabindex="-1"></a><span class="ot">p10 ::</span> <span class="dt">Maybe</span> <span class="dt">Ed25519.Fq</span></span>
<span id="cb878-44"><a href="#cb878-44" aria-hidden="true" tabindex="-1"></a>p10 <span class="ot">=</span> Ed25519.yX p1 (<span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Fq</span>)</span></code></pre></div>
<p>See: <a
href="https://hackage.haskell.org/package/elliptic-curve">elliptic-curve</a></p>
<h2 id="pairing-cryptography">Pairing Cryptography</h2>
<p>Cryptographic pairings are a novel technique that allows us to
construct bilinear mappings of the form:</p>
<p><span
class="math display"><em>e</em> : 𝔾<sub>1</sub> × 𝔾<sub>2</sub> → 𝔾<sub><em>T</em></sub></span></p>
<p>These are bilinear over group addition and multiplication.</p>
<p><span
class="math display"><em>e</em>(<em>g</em><sub>1</sub> + <em>g</em><sub>2</sub>, <em>h</em>) = <em>e</em>(<em>g</em><sub>1</sub>, <em>h</em>)<em>e</em>(<em>g</em><sub>2</sub>, <em>h</em>)</span></p>
<p><span
class="math display"><em>e</em>(<em>g</em>, <em>h</em><sub>1</sub> + <em>h</em><sub>2</sub>) = <em>e</em>(<em>g</em>, <em>h</em><sub>1</sub>)<em>e</em>(<em>g</em>, <em>h</em><sub>2</sub>)</span></p>
<p>There are many types of pairings that can be computed. The
<code>pairing</code> library implements the Ate pairing over several
elliptic curve groups including the Barreto-Naehrig family and the
BLS12-381 curve. These types of pairings are used quite frequently in
modern cryptographic protocols such as the construction of zkSNARKs.</p>
<div class="sourceCode" id="cb879"
data-include="src/32-cryptography/Pairing.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb879-1"><a href="#cb879-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedLists #-}</span></span>
<span id="cb879-2"><a href="#cb879-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb879-3"><a href="#cb879-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb879-4"><a href="#cb879-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb879-5"><a href="#cb879-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Curve.Weierstrass</span> (<span class="dt">Point</span> (<span class="dt">A</span>), mul&#39;)</span>
<span id="cb879-6"><a href="#cb879-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Group</span> (pow)</span>
<span id="cb879-7"><a href="#cb879-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Pairing.BN254</span> (<span class="dt">BN254</span>, <span class="dt">G1</span>, <span class="dt">G2</span>, pairing)</span>
<span id="cb879-8"><a href="#cb879-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb879-9"><a href="#cb879-9" aria-hidden="true" tabindex="-1"></a><span class="ot">p ::</span> <span class="dt">G1</span> <span class="dt">BN254</span></span>
<span id="cb879-10"><a href="#cb879-10" aria-hidden="true" tabindex="-1"></a>p <span class="ot">=</span></span>
<span id="cb879-11"><a href="#cb879-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">A</span></span>
<span id="cb879-12"><a href="#cb879-12" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1368015179489954701390400359078579693043519447331113978918064868415326638035</span></span>
<span id="cb879-13"><a href="#cb879-13" aria-hidden="true" tabindex="-1"></a>    <span class="dv">9918110051302171585080402603319702774565515993150576347155970296011118125764</span></span>
<span id="cb879-14"><a href="#cb879-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb879-15"><a href="#cb879-15" aria-hidden="true" tabindex="-1"></a><span class="ot">q ::</span> <span class="dt">G2</span> <span class="dt">BN254</span></span>
<span id="cb879-16"><a href="#cb879-16" aria-hidden="true" tabindex="-1"></a>q <span class="ot">=</span></span>
<span id="cb879-17"><a href="#cb879-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">A</span></span>
<span id="cb879-18"><a href="#cb879-18" aria-hidden="true" tabindex="-1"></a>    [ <span class="dv">2725019753478801796453339367788033689375851816420509565303521482350756874229</span>,</span>
<span id="cb879-19"><a href="#cb879-19" aria-hidden="true" tabindex="-1"></a>      <span class="dv">7273165102799931111715871471550377909735733521218303035754523677688038059653</span></span>
<span id="cb879-20"><a href="#cb879-20" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb879-21"><a href="#cb879-21" aria-hidden="true" tabindex="-1"></a>    [ <span class="dv">2512659008974376214222774206987427162027254181373325676825515531566330959255</span>,</span>
<span id="cb879-22"><a href="#cb879-22" aria-hidden="true" tabindex="-1"></a>      <span class="dv">957874124722006818841961785324909313781880061366718538693995380805373202866</span></span>
<span id="cb879-23"><a href="#cb879-23" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb879-24"><a href="#cb879-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb879-25"><a href="#cb879-25" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb879-26"><a href="#cb879-26" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb879-27"><a href="#cb879-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;e(P, Q):&quot;</span></span>
<span id="cb879-28"><a href="#cb879-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (pairing p q)</span>
<span id="cb879-29"><a href="#cb879-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;e(P, Q) is bilinear:&quot;</span></span>
<span id="cb879-30"><a href="#cb879-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> pairing (mul&#39; p a) (mul&#39; q b) <span class="op">==</span> pow (pairing p q) (a <span class="op">*</span> b)</span>
<span id="cb879-31"><a href="#cb879-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb879-32"><a href="#cb879-32" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">=</span> <span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span></span>
<span id="cb879-33"><a href="#cb879-33" aria-hidden="true" tabindex="-1"></a>    b <span class="ot">=</span> <span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Int</span></span></code></pre></div>
<p>See</p>
<ul>
<li><a href="https://github.com/adjoint-io/pairing">Pairing</a></li>
<li><a
href="https://tools.ietf.org/html/draft-kato-optimal-ate-pairings-00">Optimal
Ate Pairing</a></li>
</ul>
<h2 id="zksnarks">zkSNARKs</h2>
<p>zkSNARKS (zero knowledge succinct non-interactive arguments of
knowledge) are a modern cryptographic construction that enable two
parties called the <em>Prover</em> and <em>Verifier</em> to convince the
verifier that a general computational statement is true without
revealing anything else.</p>
<p>Haskell has a variety of libraries for building zkSNARK protocols
including libraries to build circuit representations of embedded domain
specific languages and produce succinct pairing based zero knowledge
proofs.</p>
<ul>
<li><a href="https://github.com/adjoint-io/zkp">zkp</a> - Implementation
of the Groth16 protocol based on bilinear pairings.</li>
<li><a
href="https://hackage.haskell.org/package/bulletproofs">bulletproofs</a>
- Implementation of the Bulletproofs protocol.</li>
<li><a
href="https://github.com/adjoint-io/arithmetic-circuits">arithmetic-circuits</a>
Generic data structures for construction arithmetic circuits and Rank-1
constraint systems (R1CS) in Haskell.</li>
</ul>
<h1 id="dates-and-times">Dates and Times</h1>
<h2 id="time">time</h2>
<p>Haskell’s datetime library is unambiguously called <em>time</em> it
exposes six core data structure which hold temporal quantities of
various precisions.</p>
<ul>
<li><strong>Day</strong> - Datetime triple of day, month, year in the
Gregorian calendar system</li>
<li><strong>TimeOfDay</strong> - A clock time measure in hours, minutes
and seconds</li>
<li><strong>UTCTime</strong> - A unix time measured in seconds since the
Unix epoch.</li>
<li><strong>TimeZone</strong> - A ISO8601 timezone</li>
<li><strong>LocalTime</strong> - A Day and TimeOfDay combined into a
aggregate type.</li>
<li><strong>ZonedTime</strong> - A LocalTime combined with
TimeZone.</li>
</ul>
<p>There are several delta types that correspond to changes in time
measured in various units of days or seconds.</p>
<ul>
<li><strong>NominalDiffTime</strong> - Time delta measured in
picoseconds.</li>
<li><strong>CalendarDiffDays</strong> - Calendar delta measured in
months and days offset.</li>
<li><strong>CalendarDiffTime</strong> - Time difference measured in
months and picoseconds.</li>
</ul>
<div class="sourceCode" id="cb880"
data-include="src/34-time/Time.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb880-1"><a href="#cb880-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Time</span> <span class="kw">where</span></span>
<span id="cb880-2"><a href="#cb880-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb880-3"><a href="#cb880-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb880-4"><a href="#cb880-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Time</span></span>
<span id="cb880-5"><a href="#cb880-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb880-6"><a href="#cb880-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- Example date:</span></span>
<span id="cb880-7"><a href="#cb880-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- April 5, 2063</span></span>
<span id="cb880-8"><a href="#cb880-8" aria-hidden="true" tabindex="-1"></a><span class="ot">day ::</span> <span class="dt">Day</span></span>
<span id="cb880-9"><a href="#cb880-9" aria-hidden="true" tabindex="-1"></a>day <span class="ot">=</span> fromJust <span class="op">$</span> fromGregorianValid year month day</span>
<span id="cb880-10"><a href="#cb880-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb880-11"><a href="#cb880-11" aria-hidden="true" tabindex="-1"></a>    year <span class="ot">=</span> <span class="dv">2063</span></span>
<span id="cb880-12"><a href="#cb880-12" aria-hidden="true" tabindex="-1"></a>    month <span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb880-13"><a href="#cb880-13" aria-hidden="true" tabindex="-1"></a>    day <span class="ot">=</span> <span class="dv">5</span></span>
<span id="cb880-14"><a href="#cb880-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb880-15"><a href="#cb880-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- Adding day deltas to dates</span></span>
<span id="cb880-16"><a href="#cb880-16" aria-hidden="true" tabindex="-1"></a><span class="ot">delta ::</span> <span class="dt">Day</span></span>
<span id="cb880-17"><a href="#cb880-17" aria-hidden="true" tabindex="-1"></a>delta <span class="ot">=</span> <span class="dv">3</span> <span class="ot">`addDays`</span> day</span>
<span id="cb880-18"><a href="#cb880-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb880-19"><a href="#cb880-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- Adding month deltas to dates</span></span>
<span id="cb880-20"><a href="#cb880-20" aria-hidden="true" tabindex="-1"></a><span class="ot">deltaMo ::</span> <span class="dt">Day</span></span>
<span id="cb880-21"><a href="#cb880-21" aria-hidden="true" tabindex="-1"></a>deltaMo <span class="ot">=</span> <span class="dv">8</span> <span class="ot">`addGregorianMonthsClip`</span> day</span>
<span id="cb880-22"><a href="#cb880-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb880-23"><a href="#cb880-23" aria-hidden="true" tabindex="-1"></a><span class="co">-- Number of days between two dates</span></span>
<span id="cb880-24"><a href="#cb880-24" aria-hidden="true" tabindex="-1"></a><span class="ot">diff ::</span> <span class="dt">Integer</span></span>
<span id="cb880-25"><a href="#cb880-25" aria-hidden="true" tabindex="-1"></a>diff <span class="ot">=</span> delta <span class="ot">`diffDays`</span> day</span>
<span id="cb880-26"><a href="#cb880-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb880-27"><a href="#cb880-27" aria-hidden="true" tabindex="-1"></a><span class="co">-- Example time</span></span>
<span id="cb880-28"><a href="#cb880-28" aria-hidden="true" tabindex="-1"></a><span class="ot">time ::</span> <span class="dt">IO</span> <span class="dt">UTCTime</span></span>
<span id="cb880-29"><a href="#cb880-29" aria-hidden="true" tabindex="-1"></a>time <span class="ot">=</span> getCurrentTime</span>
<span id="cb880-30"><a href="#cb880-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb880-31"><a href="#cb880-31" aria-hidden="true" tabindex="-1"></a><span class="co">-- Add NominalDiffTime (i.e. picoseconds) to the time</span></span>
<span id="cb880-32"><a href="#cb880-32" aria-hidden="true" tabindex="-1"></a><span class="co">-- Add 5 minutes.</span></span>
<span id="cb880-33"><a href="#cb880-33" aria-hidden="true" tabindex="-1"></a><span class="co">-- Num instance converts from integral seconds to picoseconds</span></span>
<span id="cb880-34"><a href="#cb880-34" aria-hidden="true" tabindex="-1"></a><span class="ot">tdelta ::</span> <span class="dt">IO</span> <span class="dt">UTCTime</span></span>
<span id="cb880-35"><a href="#cb880-35" aria-hidden="true" tabindex="-1"></a>tdelta <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb880-36"><a href="#cb880-36" aria-hidden="true" tabindex="-1"></a>  time <span class="ot">&lt;-</span> getCurrentTime</span>
<span id="cb880-37"><a href="#cb880-37" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (<span class="dv">300</span> <span class="ot">`addUTCTime`</span> time)</span>
<span id="cb880-38"><a href="#cb880-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb880-39"><a href="#cb880-39" aria-hidden="true" tabindex="-1"></a><span class="co">-- Get the current time zone</span></span>
<span id="cb880-40"><a href="#cb880-40" aria-hidden="true" tabindex="-1"></a><span class="ot">zone ::</span> <span class="dt">IO</span> <span class="dt">TimeZone</span></span>
<span id="cb880-41"><a href="#cb880-41" aria-hidden="true" tabindex="-1"></a>zone <span class="ot">=</span> getCurrentTimeZone</span>
<span id="cb880-42"><a href="#cb880-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb880-43"><a href="#cb880-43" aria-hidden="true" tabindex="-1"></a><span class="co">-- Get current time with timezone attached</span></span>
<span id="cb880-44"><a href="#cb880-44" aria-hidden="true" tabindex="-1"></a><span class="ot">zonetime ::</span> <span class="dt">IO</span> <span class="dt">ZonedTime</span></span>
<span id="cb880-45"><a href="#cb880-45" aria-hidden="true" tabindex="-1"></a>zonetime <span class="ot">=</span> getZonedTime</span>
<span id="cb880-46"><a href="#cb880-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb880-47"><a href="#cb880-47" aria-hidden="true" tabindex="-1"></a><span class="ot">timer ::</span> <span class="dt">IO</span> <span class="dt">NominalDiffTime</span></span>
<span id="cb880-48"><a href="#cb880-48" aria-hidden="true" tabindex="-1"></a>timer <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb880-49"><a href="#cb880-49" aria-hidden="true" tabindex="-1"></a>  start <span class="ot">&lt;-</span> getCurrentTime</span>
<span id="cb880-50"><a href="#cb880-50" aria-hidden="true" tabindex="-1"></a>  end <span class="ot">&lt;-</span> getCurrentTime</span>
<span id="cb880-51"><a href="#cb880-51" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (diffUTCTime end start)</span></code></pre></div>
<h2 id="iso8601">ISO8601</h2>
<p>The ISO standard for rendering and parsing datetimes can work with
the default temporal datatypes. These work bidirectionally for both
parsing and pretty printing. Simple use case is shown below:</p>
<div class="sourceCode" id="cb881"
data-include="src/34-time/Strings.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb881-1"><a href="#cb881-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Time</span> <span class="kw">where</span></span>
<span id="cb881-2"><a href="#cb881-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb881-3"><a href="#cb881-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb881-4"><a href="#cb881-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Time</span></span>
<span id="cb881-5"><a href="#cb881-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Time.Format.ISO8601</span></span>
<span id="cb881-6"><a href="#cb881-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb881-7"><a href="#cb881-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- April 5, 2063</span></span>
<span id="cb881-8"><a href="#cb881-8" aria-hidden="true" tabindex="-1"></a><span class="ot">day ::</span> <span class="dt">Day</span></span>
<span id="cb881-9"><a href="#cb881-9" aria-hidden="true" tabindex="-1"></a>day <span class="ot">=</span> fromJust (fromGregorianValid year month day)</span>
<span id="cb881-10"><a href="#cb881-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb881-11"><a href="#cb881-11" aria-hidden="true" tabindex="-1"></a>    year <span class="ot">=</span> <span class="dv">2063</span></span>
<span id="cb881-12"><a href="#cb881-12" aria-hidden="true" tabindex="-1"></a>    month <span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb881-13"><a href="#cb881-13" aria-hidden="true" tabindex="-1"></a>    day <span class="ot">=</span> <span class="dv">5</span></span>
<span id="cb881-14"><a href="#cb881-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb881-15"><a href="#cb881-15" aria-hidden="true" tabindex="-1"></a><span class="ot">printing ::</span> <span class="dt">IO</span> ()</span>
<span id="cb881-16"><a href="#cb881-16" aria-hidden="true" tabindex="-1"></a>printing <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb881-17"><a href="#cb881-17" aria-hidden="true" tabindex="-1"></a>  t <span class="ot">&lt;-</span> getCurrentTime</span>
<span id="cb881-18"><a href="#cb881-18" aria-hidden="true" tabindex="-1"></a>  zt <span class="ot">&lt;-</span> getZonedTime</span>
<span id="cb881-19"><a href="#cb881-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (iso8601Show day)</span>
<span id="cb881-20"><a href="#cb881-20" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (iso8601Show t)</span>
<span id="cb881-21"><a href="#cb881-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (iso8601Show zt)</span>
<span id="cb881-22"><a href="#cb881-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb881-23"><a href="#cb881-23" aria-hidden="true" tabindex="-1"></a><span class="ot">parsing ::</span> <span class="dt">IO</span> ()</span>
<span id="cb881-24"><a href="#cb881-24" aria-hidden="true" tabindex="-1"></a>parsing <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb881-25"><a href="#cb881-25" aria-hidden="true" tabindex="-1"></a>  d <span class="ot">&lt;-</span> iso8601ParseM <span class="st">&quot;2063-04-05&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">Day</span></span>
<span id="cb881-26"><a href="#cb881-26" aria-hidden="true" tabindex="-1"></a>  t <span class="ot">&lt;-</span> iso8601ParseM <span class="st">&quot;2020-01-29T15:03:43.013033515Z&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">UTCTime</span></span>
<span id="cb881-27"><a href="#cb881-27" aria-hidden="true" tabindex="-1"></a>  zt <span class="ot">&lt;-</span> iso8601ParseM <span class="st">&quot;2020-01-29T15:03:43.013040029+00:00&quot;</span><span class="ot"> ::</span> <span class="dt">IO</span> <span class="dt">ZonedTime</span></span>
<span id="cb881-28"><a href="#cb881-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> d</span>
<span id="cb881-29"><a href="#cb881-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> t</span>
<span id="cb881-30"><a href="#cb881-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> zt</span></code></pre></div>
<h1 id="data-formats">Data Formats</h1>
<h2 id="json">JSON</h2>
<p>Aeson is a library for efficient parsing and generating JSON. It is
the canonical JSON library for handling JSON.</p>
<div class="sourceCode" id="cb882"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb882-1"><a href="#cb882-1" aria-hidden="true" tabindex="-1"></a><span class="ot">decode ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb882-2"><a href="#cb882-2" aria-hidden="true" tabindex="-1"></a><span class="ot">encode ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span></span>
<span id="cb882-3"><a href="#cb882-3" aria-hidden="true" tabindex="-1"></a><span class="ot">eitherDecode ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> a</span>
<span id="cb882-4"><a href="#cb882-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb882-5"><a href="#cb882-5" aria-hidden="true" tabindex="-1"></a><span class="ot">fromJSON ::</span> <span class="dt">FromJSON</span> a <span class="ot">=&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Result</span> a</span>
<span id="cb882-6"><a href="#cb882-6" aria-hidden="true" tabindex="-1"></a><span class="ot">toJSON ::</span> <span class="dt">ToJSON</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Value</span></span></code></pre></div>
<p>A point of some subtlety to beginners is that the return types for
Aeson functions are <strong>polymorphic in their return types</strong>
meaning that the resulting type of decode is specified only in the
context of your programs use of the decode function. So if you use
decode in a point your program and bind it to a value <code>x</code> and
then use <code>x</code> as if it were an integer throughout the rest of
your program, Aeson will select the typeclass instance which parses the
given input string into a Haskell integer.</p>
<ul>
<li><a href="https://hackage.haskell.org/package/aeson"><strong>Aeson
Library</strong></a></li>
</ul>
<h4 id="value">Value</h4>
<p>Aeson uses several high performance data structures (Vector, Text,
HashMap) by default instead of the naive versions so typically using
Aeson will require that we import them and use
<code>OverloadedStrings</code> when indexing into objects.</p>
<p>The underlying Aeson structure is called <code>Value</code> and
encodes a recursive tree structure that models the semantics of untyped
JSON objects by mapping them onto a large sum type which embodies all
possible JSON values.</p>
<div class="sourceCode" id="cb883"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb883-1"><a href="#cb883-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Object</span> <span class="ot">=</span> <span class="dt">HashMap</span> <span class="dt">Text</span> <span class="dt">Value</span></span>
<span id="cb883-2"><a href="#cb883-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb883-3"><a href="#cb883-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Array</span> <span class="ot">=</span> <span class="dt">Vector</span> <span class="dt">Value</span></span>
<span id="cb883-4"><a href="#cb883-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb883-5"><a href="#cb883-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- | A JSON value represented as a Haskell value.</span></span>
<span id="cb883-6"><a href="#cb883-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Value</span></span>
<span id="cb883-7"><a href="#cb883-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Object</span> <span class="op">!</span><span class="dt">Object</span></span>
<span id="cb883-8"><a href="#cb883-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Array</span> <span class="op">!</span><span class="dt">Array</span></span>
<span id="cb883-9"><a href="#cb883-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">String</span> <span class="op">!</span><span class="dt">Text</span></span>
<span id="cb883-10"><a href="#cb883-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Number</span> <span class="op">!</span><span class="dt">Scientific</span></span>
<span id="cb883-11"><a href="#cb883-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Bool</span> <span class="op">!</span><span class="dt">Bool</span></span>
<span id="cb883-12"><a href="#cb883-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Null</span></span></code></pre></div>
<p>For instance the Value expansion of the following JSON blob:</p>
<div class="sourceCode" id="cb884"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb884-1"><a href="#cb884-1" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb884-2"><a href="#cb884-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;a&quot;</span><span class="op">:</span> [<span class="dv">1</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span>]<span class="op">,</span></span>
<span id="cb884-3"><a href="#cb884-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;b&quot;</span><span class="op">:</span> <span class="dv">1</span></span>
<span id="cb884-4"><a href="#cb884-4" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>Is represented in Aeson as the <code>Value</code>:</p>
<div class="sourceCode" id="cb885"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb885-1"><a href="#cb885-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Object</span></span>
<span id="cb885-2"><a href="#cb885-2" aria-hidden="true" tabindex="-1"></a>   (fromList</span>
<span id="cb885-3"><a href="#cb885-3" aria-hidden="true" tabindex="-1"></a>      [ ( <span class="st">&quot;a&quot;</span></span>
<span id="cb885-4"><a href="#cb885-4" aria-hidden="true" tabindex="-1"></a>        , <span class="dt">Array</span> (fromList [ <span class="dt">Number</span> <span class="fl">1.0</span> , <span class="dt">Number</span> <span class="fl">2.0</span> , <span class="dt">Number</span> <span class="fl">3.0</span> ])</span>
<span id="cb885-5"><a href="#cb885-5" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb885-6"><a href="#cb885-6" aria-hidden="true" tabindex="-1"></a>      , ( <span class="st">&quot;b&quot;</span> , <span class="dt">Number</span> <span class="fl">1.0</span> )</span>
<span id="cb885-7"><a href="#cb885-7" aria-hidden="true" tabindex="-1"></a>      ])</span></code></pre></div>
<p>Let’s consider some larger examples, we’ll work with this contrived
example JSON:</p>
<div class="sourceCode" id="cb886"
data-include="src/26-data-formats/example.json"><pre
class="sourceCode json"><code class="sourceCode json"><span id="cb886-1"><a href="#cb886-1" aria-hidden="true" tabindex="-1"></a><span class="fu">{</span></span>
<span id="cb886-2"><a href="#cb886-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;id&quot;</span><span class="fu">:</span> <span class="dv">1</span><span class="fu">,</span></span>
<span id="cb886-3"><a href="#cb886-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;name&quot;</span><span class="fu">:</span> <span class="st">&quot;A green door&quot;</span><span class="fu">,</span></span>
<span id="cb886-4"><a href="#cb886-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;price&quot;</span><span class="fu">:</span> <span class="fl">12.50</span><span class="fu">,</span></span>
<span id="cb886-5"><a href="#cb886-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;tags&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="st">&quot;home&quot;</span><span class="ot">,</span> <span class="st">&quot;green&quot;</span><span class="ot">]</span><span class="fu">,</span></span>
<span id="cb886-6"><a href="#cb886-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">&quot;refs&quot;</span><span class="fu">:</span> <span class="fu">{</span></span>
<span id="cb886-7"><a href="#cb886-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;a&quot;</span><span class="fu">:</span> <span class="st">&quot;red&quot;</span><span class="fu">,</span></span>
<span id="cb886-8"><a href="#cb886-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;b&quot;</span><span class="fu">:</span> <span class="st">&quot;blue&quot;</span></span>
<span id="cb886-9"><a href="#cb886-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span></span>
<span id="cb886-10"><a href="#cb886-10" aria-hidden="true" tabindex="-1"></a><span class="fu">}</span></span></code></pre></div>
<h4 id="unstructured-or-dynamic-json">Unstructured or Dynamic JSON</h4>
<p>In dynamic scripting languages it’s common to parse amorphous blobs
of JSON without any a priori structure and then handle validation
problems by throwing exceptions while traversing it. We can do the same
using Aeson and the Maybe monad.</p>
<div class="sourceCode" id="cb887"
data-include="src/26-data-formats/aeson_unstructured.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb887-1"><a href="#cb887-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb887-2"><a href="#cb887-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb887-3"><a href="#cb887-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span></span>
<span id="cb887-4"><a href="#cb887-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson</span></span>
<span id="cb887-5"><a href="#cb887-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector</span></span>
<span id="cb887-6"><a href="#cb887-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.HashMap.Strict</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb887-7"><a href="#cb887-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span></span>
<span id="cb887-8"><a href="#cb887-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb887-9"><a href="#cb887-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Pull a key out of an JSON object.</span></span>
<span id="cb887-10"><a href="#cb887-10" aria-hidden="true" tabindex="-1"></a><span class="ot">(^?) ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb887-11"><a href="#cb887-11" aria-hidden="true" tabindex="-1"></a>(<span class="op">^?</span>) (<span class="dt">Object</span> obj) k <span class="ot">=</span> M.lookup k obj</span>
<span id="cb887-12"><a href="#cb887-12" aria-hidden="true" tabindex="-1"></a>(<span class="op">^?</span>) _ _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb887-13"><a href="#cb887-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb887-14"><a href="#cb887-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- Pull the ith value out of a JSON list.</span></span>
<span id="cb887-15"><a href="#cb887-15" aria-hidden="true" tabindex="-1"></a><span class="ot">ix ::</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Value</span></span>
<span id="cb887-16"><a href="#cb887-16" aria-hidden="true" tabindex="-1"></a>ix (<span class="dt">Array</span> arr) i <span class="ot">=</span> arr <span class="op">!?</span> i</span>
<span id="cb887-17"><a href="#cb887-17" aria-hidden="true" tabindex="-1"></a>ix _ _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb887-18"><a href="#cb887-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb887-19"><a href="#cb887-19" aria-hidden="true" tabindex="-1"></a>readJSON str <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb887-20"><a href="#cb887-20" aria-hidden="true" tabindex="-1"></a>  obj <span class="ot">&lt;-</span> decode str</span>
<span id="cb887-21"><a href="#cb887-21" aria-hidden="true" tabindex="-1"></a>  price <span class="ot">&lt;-</span> obj <span class="op">^?</span> <span class="st">&quot;price&quot;</span></span>
<span id="cb887-22"><a href="#cb887-22" aria-hidden="true" tabindex="-1"></a>  refs  <span class="ot">&lt;-</span> obj <span class="op">^?</span> <span class="st">&quot;refs&quot;</span></span>
<span id="cb887-23"><a href="#cb887-23" aria-hidden="true" tabindex="-1"></a>  tags  <span class="ot">&lt;-</span> obj <span class="op">^?</span> <span class="st">&quot;tags&quot;</span></span>
<span id="cb887-24"><a href="#cb887-24" aria-hidden="true" tabindex="-1"></a>  aref  <span class="ot">&lt;-</span> refs <span class="op">^?</span> <span class="st">&quot;a&quot;</span></span>
<span id="cb887-25"><a href="#cb887-25" aria-hidden="true" tabindex="-1"></a>  tag1  <span class="ot">&lt;-</span> tags <span class="ot">`ix`</span> <span class="dv">0</span></span>
<span id="cb887-26"><a href="#cb887-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (price, aref, tag1)</span>
<span id="cb887-27"><a href="#cb887-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb887-28"><a href="#cb887-28" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb887-29"><a href="#cb887-29" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb887-30"><a href="#cb887-30" aria-hidden="true" tabindex="-1"></a>  contents <span class="ot">&lt;-</span> BL.readFile <span class="st">&quot;example.json&quot;</span></span>
<span id="cb887-31"><a href="#cb887-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> readJSON contents</span></code></pre></div>
<h4 id="structured-json">Structured JSON</h4>
<p>This isn’t ideal since we’ve just smeared all the validation logic
across our traversal logic instead of separating concerns and handling
validation in separate logic. We’d like to describe the structure
before-hand and the invalid case separately. Using Generic also allows
Haskell to automatically write the serializer and deserializer between
our datatype and the JSON string based on the names of record field
names.</p>
<div class="sourceCode" id="cb888"
data-include="src/26-data-formats/aeson_structured.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb888-1"><a href="#cb888-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb888-2"><a href="#cb888-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb888-3"><a href="#cb888-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span></span>
<span id="cb888-4"><a href="#cb888-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson</span></span>
<span id="cb888-5"><a href="#cb888-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb888-6"><a href="#cb888-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span></span>
<span id="cb888-7"><a href="#cb888-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb888-8"><a href="#cb888-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb888-9"><a href="#cb888-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb888-10"><a href="#cb888-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Refs</span> <span class="ot">=</span> <span class="dt">Refs</span></span>
<span id="cb888-11"><a href="#cb888-11" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> a ::</span> <span class="dt">Text</span></span>
<span id="cb888-12"><a href="#cb888-12" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> b ::</span> <span class="dt">Text</span></span>
<span id="cb888-13"><a href="#cb888-13" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Generic</span>)</span>
<span id="cb888-14"><a href="#cb888-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb888-15"><a href="#cb888-15" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Data</span> <span class="ot">=</span> <span class="dt">Data</span></span>
<span id="cb888-16"><a href="#cb888-16" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> id    ::</span> <span class="dt">Int</span></span>
<span id="cb888-17"><a href="#cb888-17" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> name  ::</span> <span class="dt">Text</span></span>
<span id="cb888-18"><a href="#cb888-18" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> price ::</span> <span class="dt">Float</span></span>
<span id="cb888-19"><a href="#cb888-19" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tags  ::</span> [<span class="dt">Text</span>]</span>
<span id="cb888-20"><a href="#cb888-20" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> refs  ::</span> <span class="dt">Refs</span></span>
<span id="cb888-21"><a href="#cb888-21" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Generic</span>)</span>
<span id="cb888-22"><a href="#cb888-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb888-23"><a href="#cb888-23" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Data</span></span>
<span id="cb888-24"><a href="#cb888-24" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Refs</span></span>
<span id="cb888-25"><a href="#cb888-25" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Data</span></span>
<span id="cb888-26"><a href="#cb888-26" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Refs</span></span>
<span id="cb888-27"><a href="#cb888-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb888-28"><a href="#cb888-28" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb888-29"><a href="#cb888-29" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb888-30"><a href="#cb888-30" aria-hidden="true" tabindex="-1"></a>  contents <span class="ot">&lt;-</span> BL.readFile <span class="st">&quot;example.json&quot;</span></span>
<span id="cb888-31"><a href="#cb888-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="dt">Just</span> dat <span class="ot">=</span> decode contents</span>
<span id="cb888-32"><a href="#cb888-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> name dat</span>
<span id="cb888-33"><a href="#cb888-33" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> a (refs dat)</span></code></pre></div>
<p>Now we get our validated JSON wrapped up into a nicely typed Haskell
ADT.</p>
<div class="sourceCode" id="cb889"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb889-1"><a href="#cb889-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Data</span></span>
<span id="cb889-2"><a href="#cb889-2" aria-hidden="true" tabindex="-1"></a>  { <span class="fu">id</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb889-3"><a href="#cb889-3" aria-hidden="true" tabindex="-1"></a>  , name <span class="ot">=</span> <span class="st">&quot;A green door&quot;</span></span>
<span id="cb889-4"><a href="#cb889-4" aria-hidden="true" tabindex="-1"></a>  , price <span class="ot">=</span> <span class="dv">12</span></span>
<span id="cb889-5"><a href="#cb889-5" aria-hidden="true" tabindex="-1"></a>  , tags <span class="ot">=</span> [ <span class="st">&quot;home&quot;</span> , <span class="st">&quot;green&quot;</span> ]</span>
<span id="cb889-6"><a href="#cb889-6" aria-hidden="true" tabindex="-1"></a>  , refs <span class="ot">=</span> <span class="dt">Refs</span> { a <span class="ot">=</span> <span class="st">&quot;red&quot;</span> , b <span class="ot">=</span> <span class="st">&quot;blue&quot;</span> }</span>
<span id="cb889-7"><a href="#cb889-7" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The functions <code>fromJSON</code> and <code>toJSON</code> can be
used to convert between this sum type and regular Haskell types
with.</p>
<div class="sourceCode" id="cb890"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb890-1"><a href="#cb890-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Result</span> a <span class="ot">=</span> <span class="dt">Error</span> <span class="dt">String</span> <span class="op">|</span> <span class="dt">Success</span> a</span></code></pre></div>
<div class="sourceCode" id="cb891"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb891-1"><a href="#cb891-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> fromJSON (<span class="dt">Bool</span> <span class="dt">True</span>)<span class="ot"> ::</span> <span class="dt">Result</span> <span class="dt">Bool</span></span>
<span id="cb891-2"><a href="#cb891-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Success</span> <span class="dt">True</span></span>
<span id="cb891-3"><a href="#cb891-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb891-4"><a href="#cb891-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> fromJSON (<span class="dt">Bool</span> <span class="dt">True</span>)<span class="ot"> ::</span> <span class="dt">Result</span> <span class="dt">Double</span></span>
<span id="cb891-5"><a href="#cb891-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Error</span> <span class="st">&quot;when expecting a Double, encountered Boolean instead&quot;</span></span></code></pre></div>
<p>As of 7.10.2 we can use the new -XDeriveAnyClass to automatically
derive instances of FromJSON and ToJSON without the need for standalone
instance declarations. These are implemented entirely in terms of the
default methods which use Generics under the hood.</p>
<div class="sourceCode" id="cb892"
data-include="src/26-data-formats/aeson_derive.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb892-1"><a href="#cb892-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveAnyClass #-}</span></span>
<span id="cb892-2"><a href="#cb892-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb892-3"><a href="#cb892-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb892-4"><a href="#cb892-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson</span></span>
<span id="cb892-5"><a href="#cb892-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">BL</span></span>
<span id="cb892-6"><a href="#cb892-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span></span>
<span id="cb892-7"><a href="#cb892-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb892-8"><a href="#cb892-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb892-9"><a href="#cb892-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Refs</span></span>
<span id="cb892-10"><a href="#cb892-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Refs</span></span>
<span id="cb892-11"><a href="#cb892-11" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> a ::</span> <span class="dt">Text</span>,</span>
<span id="cb892-12"><a href="#cb892-12" aria-hidden="true" tabindex="-1"></a><span class="ot">        b ::</span> <span class="dt">Text</span></span>
<span id="cb892-13"><a href="#cb892-13" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb892-14"><a href="#cb892-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">FromJSON</span>, <span class="dt">ToJSON</span>)</span>
<span id="cb892-15"><a href="#cb892-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb892-16"><a href="#cb892-16" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Data</span></span>
<span id="cb892-17"><a href="#cb892-17" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Data</span></span>
<span id="cb892-18"><a href="#cb892-18" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> id ::</span> <span class="dt">Int</span>,</span>
<span id="cb892-19"><a href="#cb892-19" aria-hidden="true" tabindex="-1"></a><span class="ot">        name ::</span> <span class="dt">Text</span>,</span>
<span id="cb892-20"><a href="#cb892-20" aria-hidden="true" tabindex="-1"></a><span class="ot">        price ::</span> <span class="dt">Int</span>,</span>
<span id="cb892-21"><a href="#cb892-21" aria-hidden="true" tabindex="-1"></a><span class="ot">        tags ::</span> [<span class="dt">Text</span>],</span>
<span id="cb892-22"><a href="#cb892-22" aria-hidden="true" tabindex="-1"></a><span class="ot">        refs ::</span> <span class="dt">Refs</span></span>
<span id="cb892-23"><a href="#cb892-23" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb892-24"><a href="#cb892-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">FromJSON</span>, <span class="dt">ToJSON</span>)</span>
<span id="cb892-25"><a href="#cb892-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb892-26"><a href="#cb892-26" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb892-27"><a href="#cb892-27" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb892-28"><a href="#cb892-28" aria-hidden="true" tabindex="-1"></a>  contents <span class="ot">&lt;-</span> BL.readFile <span class="st">&quot;example.json&quot;</span></span>
<span id="cb892-29"><a href="#cb892-29" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> <span class="dt">Just</span> dat <span class="ot">=</span> decode contents</span>
<span id="cb892-30"><a href="#cb892-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> name dat</span>
<span id="cb892-31"><a href="#cb892-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> a (refs dat)</span>
<span id="cb892-32"><a href="#cb892-32" aria-hidden="true" tabindex="-1"></a>  BL.putStrLn <span class="op">$</span> encode dat</span></code></pre></div>
<h4 id="hand-written-instances">Hand Written Instances</h4>
<p>While it’s useful to use generics to derive instances, sometimes you
actually want more fine grained control over serialization and de
serialization. So we fall back on writing ToJSON and FromJSON instances
manually. Using FromJSON we can project into hashmap using the
<code>(.:)</code> operator to extract keys. If the key fails to exist
the parser will abort with a key failure message. The ToJSON instances
can never fail and simply require us to pattern match on our custom
datatype and generate an appropriate value.</p>
<p>The law that the FromJSON and ToJSON classes should maintain is that
<code>encode . decode</code> and <code>decode . encode</code> should map
to the same object. Although in practice there many times when we break
this rule and especially if the serialize or de serialize is one
way.</p>
<div class="sourceCode" id="cb893"
data-include="src/26-data-formats/aeson_custom.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb893-1"><a href="#cb893-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb893-2"><a href="#cb893-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb893-3"><a href="#cb893-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-4"><a href="#cb893-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span></span>
<span id="cb893-5"><a href="#cb893-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson</span></span>
<span id="cb893-6"><a href="#cb893-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span></span>
<span id="cb893-7"><a href="#cb893-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson.Types</span></span>
<span id="cb893-8"><a href="#cb893-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb893-9"><a href="#cb893-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span></span>
<span id="cb893-10"><a href="#cb893-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-11"><a href="#cb893-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Crew</span> <span class="ot">=</span> <span class="dt">Crew</span></span>
<span id="cb893-12"><a href="#cb893-12" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> name  ::</span> <span class="dt">Text</span></span>
<span id="cb893-13"><a href="#cb893-13" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> rank  ::</span> <span class="dt">Rank</span></span>
<span id="cb893-14"><a href="#cb893-14" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb893-15"><a href="#cb893-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-16"><a href="#cb893-16" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Rank</span></span>
<span id="cb893-17"><a href="#cb893-17" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Captain</span></span>
<span id="cb893-18"><a href="#cb893-18" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Ensign</span></span>
<span id="cb893-19"><a href="#cb893-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lieutenant</span></span>
<span id="cb893-20"><a href="#cb893-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb893-21"><a href="#cb893-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-22"><a href="#cb893-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- Custom JSON Deserializer</span></span>
<span id="cb893-23"><a href="#cb893-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-24"><a href="#cb893-24" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Crew</span> <span class="kw">where</span></span>
<span id="cb893-25"><a href="#cb893-25" aria-hidden="true" tabindex="-1"></a>  parseJSON (<span class="dt">Object</span> o) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb893-26"><a href="#cb893-26" aria-hidden="true" tabindex="-1"></a>    _name <span class="ot">&lt;-</span> o <span class="op">.:</span> <span class="st">&quot;name&quot;</span></span>
<span id="cb893-27"><a href="#cb893-27" aria-hidden="true" tabindex="-1"></a>    _rank <span class="ot">&lt;-</span> o <span class="op">.:</span> <span class="st">&quot;rank&quot;</span></span>
<span id="cb893-28"><a href="#cb893-28" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> (<span class="dt">Crew</span> _name _rank)</span>
<span id="cb893-29"><a href="#cb893-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-30"><a href="#cb893-30" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromJSON</span> <span class="dt">Rank</span> <span class="kw">where</span></span>
<span id="cb893-31"><a href="#cb893-31" aria-hidden="true" tabindex="-1"></a>  parseJSON (<span class="dt">String</span> s) <span class="ot">=</span> <span class="kw">case</span> s <span class="kw">of</span></span>
<span id="cb893-32"><a href="#cb893-32" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Captain&quot;</span>    <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="dt">Captain</span></span>
<span id="cb893-33"><a href="#cb893-33" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Ensign&quot;</span>     <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="dt">Ensign</span></span>
<span id="cb893-34"><a href="#cb893-34" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Lieutenant&quot;</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="dt">Lieutenant</span></span>
<span id="cb893-35"><a href="#cb893-35" aria-hidden="true" tabindex="-1"></a>    _            <span class="ot">-&gt;</span> typeMismatch <span class="st">&quot;Could not parse Rank&quot;</span> (<span class="dt">String</span> s)</span>
<span id="cb893-36"><a href="#cb893-36" aria-hidden="true" tabindex="-1"></a>  parseJSON x <span class="ot">=</span> typeMismatch <span class="st">&quot;Expected String&quot;</span> x</span>
<span id="cb893-37"><a href="#cb893-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-38"><a href="#cb893-38" aria-hidden="true" tabindex="-1"></a><span class="co">-- Custom JSON Serializer</span></span>
<span id="cb893-39"><a href="#cb893-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-40"><a href="#cb893-40" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Crew</span> <span class="kw">where</span></span>
<span id="cb893-41"><a href="#cb893-41" aria-hidden="true" tabindex="-1"></a>  toJSON (<span class="dt">Crew</span> name rank) <span class="ot">=</span> object [</span>
<span id="cb893-42"><a href="#cb893-42" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;name&quot;</span> <span class="op">.=</span> name</span>
<span id="cb893-43"><a href="#cb893-43" aria-hidden="true" tabindex="-1"></a>    , <span class="st">&quot;rank&quot;</span> <span class="op">.=</span> rank</span>
<span id="cb893-44"><a href="#cb893-44" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb893-45"><a href="#cb893-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-46"><a href="#cb893-46" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToJSON</span> <span class="dt">Rank</span> <span class="kw">where</span></span>
<span id="cb893-47"><a href="#cb893-47" aria-hidden="true" tabindex="-1"></a>  toJSON <span class="dt">Captain</span>    <span class="ot">=</span> <span class="dt">String</span> <span class="st">&quot;Captain&quot;</span></span>
<span id="cb893-48"><a href="#cb893-48" aria-hidden="true" tabindex="-1"></a>  toJSON <span class="dt">Ensign</span>     <span class="ot">=</span> <span class="dt">String</span> <span class="st">&quot;Ensign&quot;</span></span>
<span id="cb893-49"><a href="#cb893-49" aria-hidden="true" tabindex="-1"></a>  toJSON <span class="dt">Lieutenant</span> <span class="ot">=</span> <span class="dt">String</span> <span class="st">&quot;Lieutenant&quot;</span></span>
<span id="cb893-50"><a href="#cb893-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-51"><a href="#cb893-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-52"><a href="#cb893-52" aria-hidden="true" tabindex="-1"></a><span class="ot">roundTrips ::</span> <span class="dt">Crew</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb893-53"><a href="#cb893-53" aria-hidden="true" tabindex="-1"></a>roundTrips <span class="ot">=</span> isJust <span class="op">.</span> go</span>
<span id="cb893-54"><a href="#cb893-54" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb893-55"><a href="#cb893-55" aria-hidden="true" tabindex="-1"></a><span class="ot">    go ::</span> <span class="dt">Crew</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Crew</span></span>
<span id="cb893-56"><a href="#cb893-56" aria-hidden="true" tabindex="-1"></a>    go <span class="ot">=</span> decode <span class="op">.</span> encode</span>
<span id="cb893-57"><a href="#cb893-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-58"><a href="#cb893-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-59"><a href="#cb893-59" aria-hidden="true" tabindex="-1"></a><span class="ot">picard ::</span> <span class="dt">Crew</span></span>
<span id="cb893-60"><a href="#cb893-60" aria-hidden="true" tabindex="-1"></a>picard <span class="ot">=</span> <span class="dt">Crew</span> { name <span class="ot">=</span> <span class="st">&quot;Jean-Luc Picard&quot;</span>, rank <span class="ot">=</span> <span class="dt">Captain</span> }</span>
<span id="cb893-61"><a href="#cb893-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb893-62"><a href="#cb893-62" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb893-63"><a href="#cb893-63" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb893-64"><a href="#cb893-64" aria-hidden="true" tabindex="-1"></a>  contents <span class="ot">&lt;-</span> BL.readFile <span class="st">&quot;crew.json&quot;</span></span>
<span id="cb893-65"><a href="#cb893-65" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (<span class="ot">res ::</span> <span class="dt">Maybe</span> <span class="dt">Crew</span>) <span class="ot">=</span> decode contents</span>
<span id="cb893-66"><a href="#cb893-66" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> res</span>
<span id="cb893-67"><a href="#cb893-67" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> roundTrips picard</span></code></pre></div>
<p>See: <a href="http://hackage.haskell.org/package/aeson">Aeson
Documentation</a></p>
<h2 id="yaml">Yaml</h2>
<p>Yaml is a textual serialization format similar to JSON. It uses an
indentation sensitive structure to encode nested maps of keys and
values. The Yaml interface for Haskell is a precise copy of
<code>Data.Aeson</code></p>
<ul>
<li><a href="https://hackage.haskell.org/package/yaml"><strong>Yaml
Library</strong></a></li>
</ul>
<p><strong>YAML Input:</strong></p>
<div class="sourceCode" id="cb894"
data-include="src/26-data-formats/example.yaml"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb894-1"><a href="#cb894-1" aria-hidden="true" tabindex="-1"></a>invoice<span class="op">:</span> <span class="dv">34843</span></span>
<span id="cb894-2"><a href="#cb894-2" aria-hidden="true" tabindex="-1"></a>date   <span class="op">:</span> <span class="dv">2001</span><span class="op">-</span><span class="dv">01</span><span class="op">-</span><span class="dv">23</span></span>
<span id="cb894-3"><a href="#cb894-3" aria-hidden="true" tabindex="-1"></a>bill<span class="op">:</span> </span>
<span id="cb894-4"><a href="#cb894-4" aria-hidden="true" tabindex="-1"></a>    given  <span class="op">:</span> <span class="dt">Chris</span></span>
<span id="cb894-5"><a href="#cb894-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">family</span> <span class="op">:</span> <span class="dt">Dumars</span></span>
<span id="cb894-6"><a href="#cb894-6" aria-hidden="true" tabindex="-1"></a>    address<span class="op">:</span></span>
<span id="cb894-7"><a href="#cb894-7" aria-hidden="true" tabindex="-1"></a>        <span class="fu">lines</span><span class="op">:</span> <span class="op">|</span></span>
<span id="cb894-8"><a href="#cb894-8" aria-hidden="true" tabindex="-1"></a>            <span class="dv">458</span> <span class="dt">Walkman</span> <span class="dt">Dr</span><span class="op">.</span></span>
<span id="cb894-9"><a href="#cb894-9" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Suite</span> <span class="op">#</span><span class="dv">292</span></span>
<span id="cb894-10"><a href="#cb894-10" aria-hidden="true" tabindex="-1"></a>        city    <span class="op">:</span> <span class="dt">Royal</span> <span class="dt">Oak</span></span>
<span id="cb894-11"><a href="#cb894-11" aria-hidden="true" tabindex="-1"></a>        state   <span class="op">:</span> <span class="dt">MI</span></span>
<span id="cb894-12"><a href="#cb894-12" aria-hidden="true" tabindex="-1"></a>        postal  <span class="op">:</span> <span class="dv">48046</span></span></code></pre></div>
<p><strong>YAML Output:</strong></p>
<div class="sourceCode" id="cb895"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb895-1"><a href="#cb895-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Object</span></span>
<span id="cb895-2"><a href="#cb895-2" aria-hidden="true" tabindex="-1"></a>  (fromList</span>
<span id="cb895-3"><a href="#cb895-3" aria-hidden="true" tabindex="-1"></a>     [ ( <span class="st">&quot;invoice&quot;</span> , <span class="dt">Number</span> <span class="fl">34843.0</span> )</span>
<span id="cb895-4"><a href="#cb895-4" aria-hidden="true" tabindex="-1"></a>     , ( <span class="st">&quot;date&quot;</span> , <span class="dt">String</span> <span class="st">&quot;2001-01-23&quot;</span> )</span>
<span id="cb895-5"><a href="#cb895-5" aria-hidden="true" tabindex="-1"></a>     , ( <span class="st">&quot;bill-to&quot;</span></span>
<span id="cb895-6"><a href="#cb895-6" aria-hidden="true" tabindex="-1"></a>       , <span class="dt">Object</span></span>
<span id="cb895-7"><a href="#cb895-7" aria-hidden="true" tabindex="-1"></a>           (fromList</span>
<span id="cb895-8"><a href="#cb895-8" aria-hidden="true" tabindex="-1"></a>              [ ( <span class="st">&quot;address&quot;</span></span>
<span id="cb895-9"><a href="#cb895-9" aria-hidden="true" tabindex="-1"></a>                , <span class="dt">Object</span></span>
<span id="cb895-10"><a href="#cb895-10" aria-hidden="true" tabindex="-1"></a>                    (fromList</span>
<span id="cb895-11"><a href="#cb895-11" aria-hidden="true" tabindex="-1"></a>                       [ ( <span class="st">&quot;state&quot;</span> , <span class="dt">String</span> <span class="st">&quot;MI&quot;</span> )</span>
<span id="cb895-12"><a href="#cb895-12" aria-hidden="true" tabindex="-1"></a>                       , ( <span class="st">&quot;lines&quot;</span> , <span class="dt">String</span> <span class="st">&quot;458 Walkman Dr.\nSuite #292\n&quot;</span> )</span>
<span id="cb895-13"><a href="#cb895-13" aria-hidden="true" tabindex="-1"></a>                       , ( <span class="st">&quot;city&quot;</span> , <span class="dt">String</span> <span class="st">&quot;Royal Oak&quot;</span> )</span>
<span id="cb895-14"><a href="#cb895-14" aria-hidden="true" tabindex="-1"></a>                       , ( <span class="st">&quot;postal&quot;</span> , <span class="dt">Number</span> <span class="fl">48046.0</span> )</span>
<span id="cb895-15"><a href="#cb895-15" aria-hidden="true" tabindex="-1"></a>                       ])</span>
<span id="cb895-16"><a href="#cb895-16" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb895-17"><a href="#cb895-17" aria-hidden="true" tabindex="-1"></a>              , ( <span class="st">&quot;family&quot;</span> , <span class="dt">String</span> <span class="st">&quot;Dumars&quot;</span> )</span>
<span id="cb895-18"><a href="#cb895-18" aria-hidden="true" tabindex="-1"></a>              , ( <span class="st">&quot;given&quot;</span> , <span class="dt">String</span> <span class="st">&quot;Chris&quot;</span> )</span>
<span id="cb895-19"><a href="#cb895-19" aria-hidden="true" tabindex="-1"></a>              ])</span>
<span id="cb895-20"><a href="#cb895-20" aria-hidden="true" tabindex="-1"></a>       )</span>
<span id="cb895-21"><a href="#cb895-21" aria-hidden="true" tabindex="-1"></a>     ])</span></code></pre></div>
<p>To parse this file we use the following datatypes and functions:</p>
<div class="sourceCode" id="cb896"
data-include="src/26-data-formats/yaml.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb896-1"><a href="#cb896-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveAnyClass #-}</span></span>
<span id="cb896-2"><a href="#cb896-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb896-3"><a href="#cb896-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb896-4"><a href="#cb896-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb896-5"><a href="#cb896-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString</span> <span class="kw">as</span> <span class="dt">BL</span></span>
<span id="cb896-6"><a href="#cb896-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span> (<span class="dt">Text</span>)</span>
<span id="cb896-7"><a href="#cb896-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Yaml</span></span>
<span id="cb896-8"><a href="#cb896-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb896-9"><a href="#cb896-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb896-10"><a href="#cb896-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Invoice</span></span>
<span id="cb896-11"><a href="#cb896-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Invoice</span></span>
<span id="cb896-12"><a href="#cb896-12" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> invoice ::</span> <span class="dt">Int</span>,</span>
<span id="cb896-13"><a href="#cb896-13" aria-hidden="true" tabindex="-1"></a><span class="ot">        date ::</span> <span class="dt">Text</span>,</span>
<span id="cb896-14"><a href="#cb896-14" aria-hidden="true" tabindex="-1"></a><span class="ot">        bill ::</span> <span class="dt">Billing</span></span>
<span id="cb896-15"><a href="#cb896-15" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb896-16"><a href="#cb896-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">FromJSON</span>)</span>
<span id="cb896-17"><a href="#cb896-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb896-18"><a href="#cb896-18" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Billing</span></span>
<span id="cb896-19"><a href="#cb896-19" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Billing</span></span>
<span id="cb896-20"><a href="#cb896-20" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> address ::</span> <span class="dt">Address</span>,</span>
<span id="cb896-21"><a href="#cb896-21" aria-hidden="true" tabindex="-1"></a><span class="ot">        family ::</span> <span class="dt">Text</span>,</span>
<span id="cb896-22"><a href="#cb896-22" aria-hidden="true" tabindex="-1"></a><span class="ot">        given ::</span> <span class="dt">Text</span></span>
<span id="cb896-23"><a href="#cb896-23" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb896-24"><a href="#cb896-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">FromJSON</span>)</span>
<span id="cb896-25"><a href="#cb896-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb896-26"><a href="#cb896-26" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Address</span></span>
<span id="cb896-27"><a href="#cb896-27" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Address</span></span>
<span id="cb896-28"><a href="#cb896-28" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> lines ::</span> <span class="dt">Text</span>,</span>
<span id="cb896-29"><a href="#cb896-29" aria-hidden="true" tabindex="-1"></a><span class="ot">        city ::</span> <span class="dt">Text</span>,</span>
<span id="cb896-30"><a href="#cb896-30" aria-hidden="true" tabindex="-1"></a><span class="ot">        state ::</span> <span class="dt">Text</span>,</span>
<span id="cb896-31"><a href="#cb896-31" aria-hidden="true" tabindex="-1"></a><span class="ot">        postal ::</span> <span class="dt">Int</span></span>
<span id="cb896-32"><a href="#cb896-32" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb896-33"><a href="#cb896-33" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">FromJSON</span>)</span>
<span id="cb896-34"><a href="#cb896-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb896-35"><a href="#cb896-35" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb896-36"><a href="#cb896-36" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb896-37"><a href="#cb896-37" aria-hidden="true" tabindex="-1"></a>  contents <span class="ot">&lt;-</span> BL.readFile <span class="st">&quot;example.yaml&quot;</span></span>
<span id="cb896-38"><a href="#cb896-38" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (<span class="ot">res ::</span> <span class="dt">Either</span> <span class="dt">ParseException</span> <span class="dt">Invoice</span>) <span class="ot">=</span> decodeEither&#39; contents</span>
<span id="cb896-39"><a href="#cb896-39" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> res <span class="kw">of</span></span>
<span id="cb896-40"><a href="#cb896-40" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="fu">print</span> err</span>
<span id="cb896-41"><a href="#cb896-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> val <span class="ot">-&gt;</span> <span class="fu">print</span> val</span></code></pre></div>
<p>Which generates:</p>
<div class="sourceCode" id="cb897"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb897-1"><a href="#cb897-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Invoice</span></span>
<span id="cb897-2"><a href="#cb897-2" aria-hidden="true" tabindex="-1"></a>  { invoice <span class="ot">=</span> <span class="dv">34843</span></span>
<span id="cb897-3"><a href="#cb897-3" aria-hidden="true" tabindex="-1"></a>  , date <span class="ot">=</span> <span class="st">&quot;2001-01-23&quot;</span></span>
<span id="cb897-4"><a href="#cb897-4" aria-hidden="true" tabindex="-1"></a>  , bill <span class="ot">=</span></span>
<span id="cb897-5"><a href="#cb897-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Billing</span></span>
<span id="cb897-6"><a href="#cb897-6" aria-hidden="true" tabindex="-1"></a>        { address <span class="ot">=</span></span>
<span id="cb897-7"><a href="#cb897-7" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Address</span></span>
<span id="cb897-8"><a href="#cb897-8" aria-hidden="true" tabindex="-1"></a>              { <span class="fu">lines</span> <span class="ot">=</span> <span class="st">&quot;458 Walkman Dr.\nSuite #292\n&quot;</span></span>
<span id="cb897-9"><a href="#cb897-9" aria-hidden="true" tabindex="-1"></a>              , city <span class="ot">=</span> <span class="st">&quot;Royal Oak&quot;</span></span>
<span id="cb897-10"><a href="#cb897-10" aria-hidden="true" tabindex="-1"></a>              , state <span class="ot">=</span> <span class="st">&quot;MI&quot;</span></span>
<span id="cb897-11"><a href="#cb897-11" aria-hidden="true" tabindex="-1"></a>              , postal <span class="ot">=</span> <span class="dv">48046</span></span>
<span id="cb897-12"><a href="#cb897-12" aria-hidden="true" tabindex="-1"></a>              }</span>
<span id="cb897-13"><a href="#cb897-13" aria-hidden="true" tabindex="-1"></a>        , <span class="kw">family</span> <span class="ot">=</span> <span class="st">&quot;Dumars&quot;</span></span>
<span id="cb897-14"><a href="#cb897-14" aria-hidden="true" tabindex="-1"></a>        , given <span class="ot">=</span> <span class="st">&quot;Chris&quot;</span></span>
<span id="cb897-15"><a href="#cb897-15" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb897-16"><a href="#cb897-16" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<h2 id="csv">CSV</h2>
<p>Cassava is an efficient CSV parser library. We’ll work with this tiny
snippet from the iris dataset:</p>
<ul>
<li><a
href="https://hackage.haskell.org/package/cassava"><strong>Cassava
Library</strong></a></li>
</ul>
<div class="sourceCode" id="cb898"
data-include="src/26-data-formats/iris.csv"><pre
class="sourceCode perl"><code class="sourceCode perl"><span id="cb898-1"><a href="#cb898-1" aria-hidden="true" tabindex="-1"></a>sepal_length,sepal_width,petal_length,petal_width,plant_class</span>
<span id="cb898-2"><a href="#cb898-2" aria-hidden="true" tabindex="-1"></a><span class="fl">5.1</span>,<span class="fl">3.5</span>,<span class="fl">1.4</span>,<span class="fl">0.2</span>,Iris-setosa</span>
<span id="cb898-3"><a href="#cb898-3" aria-hidden="true" tabindex="-1"></a><span class="fl">5.0</span>,<span class="fl">2.0</span>,<span class="fl">3.5</span>,<span class="fl">1.0</span>,Iris-versicolor</span>
<span id="cb898-4"><a href="#cb898-4" aria-hidden="true" tabindex="-1"></a><span class="fl">6.3</span>,<span class="fl">3.3</span>,<span class="fl">6.0</span>,<span class="fl">2.5</span>,Iris-virginica</span></code></pre></div>
<h4 id="unstructured-csv">Unstructured CSV</h4>
<p>Just like with Aeson if we really want to work with unstructured data
the library accommodates this.</p>
<div class="sourceCode" id="cb899"
data-include="src/26-data-formats/cassava_unstructured.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb899-1"><a href="#cb899-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Csv</span></span>
<span id="cb899-2"><a href="#cb899-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb899-3"><a href="#cb899-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span></span>
<span id="cb899-4"><a href="#cb899-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb899-5"><a href="#cb899-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb899-6"><a href="#cb899-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span></span>
<span id="cb899-7"><a href="#cb899-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb899-8"><a href="#cb899-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ErrorMsg</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb899-9"><a href="#cb899-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CsvData</span> <span class="ot">=</span> <span class="dt">V.Vector</span> (<span class="dt">V.Vector</span> <span class="dt">BL.ByteString</span>)</span>
<span id="cb899-10"><a href="#cb899-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb899-11"><a href="#cb899-11" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">ErrorMsg</span> <span class="dt">CsvData</span>)</span>
<span id="cb899-12"><a href="#cb899-12" aria-hidden="true" tabindex="-1"></a>example fname <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb899-13"><a href="#cb899-13" aria-hidden="true" tabindex="-1"></a>  contents <span class="ot">&lt;-</span> BL.readFile fname</span>
<span id="cb899-14"><a href="#cb899-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> decode <span class="dt">NoHeader</span> contents</span></code></pre></div>
<p>We see we get the nested set of stringy vectors:</p>
<div class="sourceCode" id="cb900"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb900-1"><a href="#cb900-1" aria-hidden="true" tabindex="-1"></a>[ [ <span class="st">&quot;sepal_length&quot;</span></span>
<span id="cb900-2"><a href="#cb900-2" aria-hidden="true" tabindex="-1"></a>  , <span class="st">&quot;sepal_width&quot;</span></span>
<span id="cb900-3"><a href="#cb900-3" aria-hidden="true" tabindex="-1"></a>  , <span class="st">&quot;petal_length&quot;</span></span>
<span id="cb900-4"><a href="#cb900-4" aria-hidden="true" tabindex="-1"></a>  , <span class="st">&quot;petal_width&quot;</span></span>
<span id="cb900-5"><a href="#cb900-5" aria-hidden="true" tabindex="-1"></a>  , <span class="st">&quot;plant_class&quot;</span></span>
<span id="cb900-6"><a href="#cb900-6" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb900-7"><a href="#cb900-7" aria-hidden="true" tabindex="-1"></a>, [ <span class="st">&quot;5.1&quot;</span> , <span class="st">&quot;3.5&quot;</span> , <span class="st">&quot;1.4&quot;</span> , <span class="st">&quot;0.2&quot;</span> , <span class="st">&quot;Iris-setosa&quot;</span> ]</span>
<span id="cb900-8"><a href="#cb900-8" aria-hidden="true" tabindex="-1"></a>, [ <span class="st">&quot;5.0&quot;</span> , <span class="st">&quot;2.0&quot;</span> , <span class="st">&quot;3.5&quot;</span> , <span class="st">&quot;1.0&quot;</span> , <span class="st">&quot;Iris-versicolor&quot;</span> ]</span>
<span id="cb900-9"><a href="#cb900-9" aria-hidden="true" tabindex="-1"></a>, [ <span class="st">&quot;6.3&quot;</span> , <span class="st">&quot;3.3&quot;</span> , <span class="st">&quot;6.0&quot;</span> , <span class="st">&quot;2.5&quot;</span> , <span class="st">&quot;Iris-virginica&quot;</span> ]</span>
<span id="cb900-10"><a href="#cb900-10" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<h4 id="structured-csv">Structured CSV</h4>
<p>Just like with Aeson we can use Generic to automatically write the
deserializer between our CSV data and our custom datatype.</p>
<div class="sourceCode" id="cb901"
data-include="src/26-data-formats/cassava_structured.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb901-1"><a href="#cb901-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb901-2"><a href="#cb901-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb901-3"><a href="#cb901-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb901-4"><a href="#cb901-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Csv</span></span>
<span id="cb901-5"><a href="#cb901-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb901-6"><a href="#cb901-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">V</span></span>
<span id="cb901-7"><a href="#cb901-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">BL</span></span>
<span id="cb901-8"><a href="#cb901-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb901-9"><a href="#cb901-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Plant</span> <span class="ot">=</span> <span class="dt">Plant</span></span>
<span id="cb901-10"><a href="#cb901-10" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> sepal_length ::</span> <span class="dt">Double</span></span>
<span id="cb901-11"><a href="#cb901-11" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> sepal_width  ::</span> <span class="dt">Double</span></span>
<span id="cb901-12"><a href="#cb901-12" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> petal_length ::</span> <span class="dt">Double</span></span>
<span id="cb901-13"><a href="#cb901-13" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> petal_width  ::</span> <span class="dt">Double</span></span>
<span id="cb901-14"><a href="#cb901-14" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> plant_class ::</span> <span class="dt">String</span></span>
<span id="cb901-15"><a href="#cb901-15" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">Show</span>)</span>
<span id="cb901-16"><a href="#cb901-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb901-17"><a href="#cb901-17" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromNamedRecord</span> <span class="dt">Plant</span></span>
<span id="cb901-18"><a href="#cb901-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToNamedRecord</span> <span class="dt">Plant</span></span>
<span id="cb901-19"><a href="#cb901-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb901-20"><a href="#cb901-20" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ErrorMsg</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb901-21"><a href="#cb901-21" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CsvData</span> <span class="ot">=</span> (<span class="dt">Header</span>, <span class="dt">V.Vector</span> <span class="dt">Plant</span>)</span>
<span id="cb901-22"><a href="#cb901-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb901-23"><a href="#cb901-23" aria-hidden="true" tabindex="-1"></a><span class="ot">parseCSV ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">ErrorMsg</span> <span class="dt">CsvData</span>)</span>
<span id="cb901-24"><a href="#cb901-24" aria-hidden="true" tabindex="-1"></a>parseCSV fname <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb901-25"><a href="#cb901-25" aria-hidden="true" tabindex="-1"></a>  contents <span class="ot">&lt;-</span> BL.readFile fname</span>
<span id="cb901-26"><a href="#cb901-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> decodeByName contents</span>
<span id="cb901-27"><a href="#cb901-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb901-28"><a href="#cb901-28" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> parseCSV <span class="st">&quot;iris.csv&quot;</span> <span class="op">&gt;&gt;=</span> <span class="fu">print</span></span></code></pre></div>
<p>And again we get a nice typed ADT as a result.</p>
<div class="sourceCode" id="cb902"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb902-1"><a href="#cb902-1" aria-hidden="true" tabindex="-1"></a>[ <span class="dt">Plant</span></span>
<span id="cb902-2"><a href="#cb902-2" aria-hidden="true" tabindex="-1"></a>    { sepal_length <span class="ot">=</span> <span class="fl">5.1</span></span>
<span id="cb902-3"><a href="#cb902-3" aria-hidden="true" tabindex="-1"></a>    , sepal_width <span class="ot">=</span> <span class="fl">3.5</span></span>
<span id="cb902-4"><a href="#cb902-4" aria-hidden="true" tabindex="-1"></a>    , petal_length <span class="ot">=</span> <span class="fl">1.4</span></span>
<span id="cb902-5"><a href="#cb902-5" aria-hidden="true" tabindex="-1"></a>    , petal_width <span class="ot">=</span> <span class="fl">0.2</span></span>
<span id="cb902-6"><a href="#cb902-6" aria-hidden="true" tabindex="-1"></a>    , plant_class <span class="ot">=</span> <span class="st">&quot;Iris-setosa&quot;</span></span>
<span id="cb902-7"><a href="#cb902-7" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb902-8"><a href="#cb902-8" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Plant</span></span>
<span id="cb902-9"><a href="#cb902-9" aria-hidden="true" tabindex="-1"></a>    { sepal_length <span class="ot">=</span> <span class="fl">5.0</span></span>
<span id="cb902-10"><a href="#cb902-10" aria-hidden="true" tabindex="-1"></a>    , sepal_width <span class="ot">=</span> <span class="fl">2.0</span></span>
<span id="cb902-11"><a href="#cb902-11" aria-hidden="true" tabindex="-1"></a>    , petal_length <span class="ot">=</span> <span class="fl">3.5</span></span>
<span id="cb902-12"><a href="#cb902-12" aria-hidden="true" tabindex="-1"></a>    , petal_width <span class="ot">=</span> <span class="fl">1.0</span></span>
<span id="cb902-13"><a href="#cb902-13" aria-hidden="true" tabindex="-1"></a>    , plant_class <span class="ot">=</span> <span class="st">&quot;Iris-versicolor&quot;</span></span>
<span id="cb902-14"><a href="#cb902-14" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb902-15"><a href="#cb902-15" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Plant</span></span>
<span id="cb902-16"><a href="#cb902-16" aria-hidden="true" tabindex="-1"></a>    { sepal_length <span class="ot">=</span> <span class="fl">6.3</span></span>
<span id="cb902-17"><a href="#cb902-17" aria-hidden="true" tabindex="-1"></a>    , sepal_width <span class="ot">=</span> <span class="fl">3.3</span></span>
<span id="cb902-18"><a href="#cb902-18" aria-hidden="true" tabindex="-1"></a>    , petal_length <span class="ot">=</span> <span class="fl">6.0</span></span>
<span id="cb902-19"><a href="#cb902-19" aria-hidden="true" tabindex="-1"></a>    , petal_width <span class="ot">=</span> <span class="fl">2.5</span></span>
<span id="cb902-20"><a href="#cb902-20" aria-hidden="true" tabindex="-1"></a>    , plant_class <span class="ot">=</span> <span class="st">&quot;Iris-virginica&quot;</span></span>
<span id="cb902-21"><a href="#cb902-21" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb902-22"><a href="#cb902-22" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
</hr>
<h1 id="network-web-programming">Network &amp; Web Programming</h1>
<p>There is a common meme that it is impossible to build web CRUD
applications in Haskell. This absolutely false and the ecosystem
provides a wide variety of tools and frameworks for building modern web
services. That said, although Haskell has web frameworks the userbase of
these libraries is several orders of magnitude less than common tools
like PHP and Wordpress and as such are not close to the level of polish,
documentation, or userbase. Put simply you won’t be able to drunkenly
muddle your way through building a Haskell web application by copying
and pasting code from Stackoverflow.</p>
<p>Building web applications in Haskell is always a balance between the
power and flexibility of the type-driven way of building software versus
the network effects of ecosystems based on dynamically typed languages
with lower barriers to entry.</p>
<p>Web packages can mostly be broken down into several categories:</p>
<ul>
<li><strong>Web servers</strong> - Services that handle the TCP level of
content delivery and protocol servicing.</li>
<li><strong>Request libraries</strong> - Libraries for issuing HTTP
requests to other servers.</li>
<li><strong>Templating Libraries</strong> - Libraries to generate HTML
from interpolating strings.</li>
<li><strong>HTML Generation</strong> - Libraries to generate HTML from
Haskell datatypes.</li>
<li><strong>Form Handling &amp; Validation</strong> - Libraries for
handling form input and serialisation and validating data against a
given schema and constraint sets.</li>
<li><strong>Web Frameworks</strong> - Frameworks for constructing
RESTful services and handling the lifecycle of HTTP requests within a
business logic framework.</li>
<li><strong>Database Mapping</strong> - ORM and database libraries to
work with database models and serialise data to web services. See <a
href="#databases">Databases</a>.</li>
</ul>
<h2 id="frameworks">Frameworks</h2>
<p>There are three large Haskell web frameworks:</p>
<p><strong>IHP</strong></p>
<p>IHP, by digitallyInduced, is a new batteries-included web framework
optimized for longterm productivity and programmer happiness. The
framework manages installation of ide, db, and haskell for you, as
result of trying to be as beginner friendly as possible with all
batteries included, while while having a bunch of novel features. The
framework has its own documentation.</p>
<p><strong>Servant</strong></p>
<p>Servant is the newest of the standard Haskell web frameworks. It
emerged after GHC 8.0 and incorporates many modern language extensions.
It is based around the key idea of having a type-safe routing system in
which many aspects of the request/response cycle of the server are
expressed at the type-level. This allows many common errors found in web
applications to be prevented. Servant also has very advanced
documentation generation capability and can automatically generate API
endpoint documentation from the type signatures of an application.
Servant has a reputation for being a bit more challenging to learn but
is quite powerful and has an wide user-base in the industrial Haskell
community.</p>
<p>See: <a href="#servant">Servant</a></p>
<p><strong>Scotty</strong></p>
<p>Scotty is a minimal web framework that builds on top of the Warp web
server. It is based on a simple routing model and that makes standing up
simple REST API services quite simple. Its design is modeled after the
Flask and Sinatra models found in Python and Ruby.</p>
<p>See: <a href="#scotty">Scotty</a></p>
<p><strong>Yesod</strong></p>
<p>Yesod is a large featureful ecosystem built on lots of
metaprogramming using Template Haskell. There is excellent documentation
and a book on building real world applications. This style of
metaprogramming appeals to some types of programmers who can work with
the code generation style.</p>
<p><strong>Snap</strong></p>
<p>Snap is a small Haskell web framework which was developed heavily in
the early 2000s. It is based on a very well-tested core and has a
modular framework in which “snaplets” can extend the base server. Much
of the Haskell.org infrastructure of packages and development runs on
top of Snap web applications.</p>
<h2 id="http-requests">HTTP Requests</h2>
<p>Haskell has a variety of HTTP request and processing libraries. The
simplest and most flexible is the <a
href="https://hackage.haskell.org/package/HTTP">HTTP library</a>.</p>
<div class="sourceCode" id="cb903"
data-include="src/27-web/http.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb903-1"><a href="#cb903-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb903-2"><a href="#cb903-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb903-3"><a href="#cb903-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb903-4"><a href="#cb903-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent.Async</span></span>
<span id="cb903-5"><a href="#cb903-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.HTTP.Client</span></span>
<span id="cb903-6"><a href="#cb903-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.HTTP.Types</span></span>
<span id="cb903-7"><a href="#cb903-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb903-8"><a href="#cb903-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">URL</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb903-9"><a href="#cb903-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb903-10"><a href="#cb903-10" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">Manager</span> <span class="ot">-&gt;</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb903-11"><a href="#cb903-11" aria-hidden="true" tabindex="-1"></a>get m url <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb903-12"><a href="#cb903-12" aria-hidden="true" tabindex="-1"></a>  req <span class="ot">&lt;-</span> parseUrlThrow url</span>
<span id="cb903-13"><a href="#cb903-13" aria-hidden="true" tabindex="-1"></a>  statusCode <span class="op">.</span> responseStatus <span class="op">&lt;$&gt;</span> httpNoBody req m</span>
<span id="cb903-14"><a href="#cb903-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb903-15"><a href="#cb903-15" aria-hidden="true" tabindex="-1"></a><span class="ot">single ::</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb903-16"><a href="#cb903-16" aria-hidden="true" tabindex="-1"></a>single <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb903-17"><a href="#cb903-17" aria-hidden="true" tabindex="-1"></a>  manager <span class="ot">&lt;-</span> newManager defaultManagerSettings</span>
<span id="cb903-18"><a href="#cb903-18" aria-hidden="true" tabindex="-1"></a>  get manager <span class="st">&quot;http://haskell.org&quot;</span></span>
<span id="cb903-19"><a href="#cb903-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb903-20"><a href="#cb903-20" aria-hidden="true" tabindex="-1"></a><span class="ot">parallel ::</span> <span class="dt">IO</span> [<span class="dt">Int</span>]</span>
<span id="cb903-21"><a href="#cb903-21" aria-hidden="true" tabindex="-1"></a>parallel <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb903-22"><a href="#cb903-22" aria-hidden="true" tabindex="-1"></a>  manager <span class="ot">&lt;-</span> newManager defaultManagerSettings</span>
<span id="cb903-23"><a href="#cb903-23" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Fetch w3.org 10 times concurrently</span></span>
<span id="cb903-24"><a href="#cb903-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> urls <span class="ot">=</span> <span class="fu">replicate</span> <span class="dv">10</span> <span class="st">&quot;http://www.w3.org&quot;</span></span>
<span id="cb903-25"><a href="#cb903-25" aria-hidden="true" tabindex="-1"></a>  mapConcurrently (get manager) urls</span>
<span id="cb903-26"><a href="#cb903-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb903-27"><a href="#cb903-27" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb903-28"><a href="#cb903-28" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb903-29"><a href="#cb903-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">=&lt;&lt;</span> single</span>
<span id="cb903-30"><a href="#cb903-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">=&lt;&lt;</span> parallel</span></code></pre></div>
<h2 id="req">Req</h2>
<p>Req is a modern HTTP request library that provides a simple monad for
executing batches of HTTP requests to servers. It integrates closely
with the Aeson library for JSON handling and exposes a type safe API to
prevent the mixing of invalid requests and payload types.</p>
<p>The two toplevel functions of note are <code>req</code> and
<code>runReq</code> which run inside of a <code>Req</code> monad which
holds the socket state.</p>
<div class="sourceCode" id="cb904"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb904-1"><a href="#cb904-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runReq ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">HttpConfig</span> <span class="ot">-&gt;</span> <span class="dt">Req</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb904-2"><a href="#cb904-2" aria-hidden="true" tabindex="-1"></a>req</span>
<span id="cb904-3"><a href="#cb904-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> ( <span class="dt">MonadHttp</span>    m</span>
<span id="cb904-4"><a href="#cb904-4" aria-hidden="true" tabindex="-1"></a>     , <span class="dt">HttpMethod</span>   method</span>
<span id="cb904-5"><a href="#cb904-5" aria-hidden="true" tabindex="-1"></a>     , <span class="dt">HttpBody</span>     body</span>
<span id="cb904-6"><a href="#cb904-6" aria-hidden="true" tabindex="-1"></a>     , <span class="dt">HttpResponse</span> response</span>
<span id="cb904-7"><a href="#cb904-7" aria-hidden="true" tabindex="-1"></a>     , <span class="dt">HttpBodyAllowed</span> (<span class="dt">AllowsBody</span> method) (<span class="dt">ProvidesBody</span> body) )</span>
<span id="cb904-8"><a href="#cb904-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> method            <span class="co">-- ^ HTTP method</span></span>
<span id="cb904-9"><a href="#cb904-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Url</span> scheme        <span class="co">-- ^ &#39;Url&#39;—location of resource</span></span>
<span id="cb904-10"><a href="#cb904-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> body              <span class="co">-- ^ Body of the request</span></span>
<span id="cb904-11"><a href="#cb904-11" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Proxy</span> response    <span class="co">-- ^ A hint how to interpret response</span></span>
<span id="cb904-12"><a href="#cb904-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Option</span> scheme     <span class="co">-- ^ Collection of optional parameters</span></span>
<span id="cb904-13"><a href="#cb904-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> m response        <span class="co">-- ^ Response</span></span></code></pre></div>
<p>A end to end example can include serialising and de serialising
requests to and from JSON from RESTful services.</p>
<div class="sourceCode" id="cb905" data-include="src/27-web/req.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb905-1"><a href="#cb905-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveAnyClass #-}</span></span>
<span id="cb905-2"><a href="#cb905-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb905-3"><a href="#cb905-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb905-4"><a href="#cb905-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb905-5"><a href="#cb905-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span></span>
<span id="cb905-6"><a href="#cb905-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Aeson</span></span>
<span id="cb905-7"><a href="#cb905-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb905-8"><a href="#cb905-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.HTTP.Req</span></span>
<span id="cb905-9"><a href="#cb905-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb905-10"><a href="#cb905-10" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Point</span> <span class="ot">=</span> <span class="dt">Point</span> {<span class="ot">x ::</span> <span class="dt">Int</span>,<span class="ot"> y ::</span> <span class="dt">Int</span>}</span>
<span id="cb905-11"><a href="#cb905-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">ToJSON</span>, <span class="dt">FromJSON</span>)</span>
<span id="cb905-12"><a href="#cb905-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb905-13"><a href="#cb905-13" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> ()</span>
<span id="cb905-14"><a href="#cb905-14" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> runReq defaultHttpConfig <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb905-15"><a href="#cb905-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- GET request http response</span></span>
<span id="cb905-16"><a href="#cb905-16" aria-hidden="true" tabindex="-1"></a>  r <span class="ot">&lt;-</span> req <span class="dt">GET</span> (https <span class="st">&quot;w3.org&quot;</span>) <span class="dt">NoReqBody</span> bsResponse <span class="fu">mempty</span></span>
<span id="cb905-17"><a href="#cb905-17" aria-hidden="true" tabindex="-1"></a>  liftIO <span class="op">$</span> <span class="fu">print</span> (responseBody r)</span>
<span id="cb905-18"><a href="#cb905-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- GET request json response</span></span>
<span id="cb905-19"><a href="#cb905-19" aria-hidden="true" tabindex="-1"></a>  r <span class="ot">&lt;-</span> req <span class="dt">GET</span> (https <span class="st">&quot;api.github.com&quot;</span> <span class="op">/:</span> <span class="st">&quot;users&quot;</span> <span class="op">/:</span> <span class="st">&quot;sdiehl&quot;</span>) <span class="dt">NoReqBody</span> jsonResponse <span class="fu">mempty</span></span>
<span id="cb905-20"><a href="#cb905-20" aria-hidden="true" tabindex="-1"></a>  liftIO <span class="op">$</span> <span class="fu">print</span> (responseBody<span class="ot"> r ::</span> <span class="dt">Value</span>)</span>
<span id="cb905-21"><a href="#cb905-21" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- POST request json payload</span></span>
<span id="cb905-22"><a href="#cb905-22" aria-hidden="true" tabindex="-1"></a>  r <span class="ot">&lt;-</span> req <span class="dt">POST</span> (https <span class="st">&quot;example.com&quot;</span>) (<span class="dt">ReqBodyJson</span> (<span class="dt">Point</span> <span class="dv">1</span> <span class="dv">2</span>)) jsonResponse <span class="fu">mempty</span></span>
<span id="cb905-23"><a href="#cb905-23" aria-hidden="true" tabindex="-1"></a>  liftIO <span class="op">$</span> <span class="fu">print</span> (responseBody<span class="ot"> r ::</span> <span class="dt">Value</span>)</span></code></pre></div>
<h2 id="blaze">Blaze</h2>
<p>Blaze is an HTML combinator library that provides that capacity to
build composable bits of HTML programmatically. It doesn’t string
templating libraries like <a href="#hastache">Hastache</a> but instead
provides an API for building up HTML documents from logic where the
format out of the output is generated procedurally.</p>
<p>For sequencing HTML elements the elements can either be sequenced in
a monad or with monoid operations.</p>
<div class="sourceCode" id="cb906"
data-include="src/27-web/blaze.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb906-1"><a href="#cb906-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb906-2"><a href="#cb906-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb906-3"><a href="#cb906-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Html</span> <span class="kw">where</span></span>
<span id="cb906-4"><a href="#cb906-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb906-5"><a href="#cb906-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Html5</span></span>
<span id="cb906-6"><a href="#cb906-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Html.Renderer.Text</span></span>
<span id="cb906-7"><a href="#cb906-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb906-8"><a href="#cb906-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb906-9"><a href="#cb906-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb906-10"><a href="#cb906-10" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">Html</span></span>
<span id="cb906-11"><a href="#cb906-11" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb906-12"><a href="#cb906-12" aria-hidden="true" tabindex="-1"></a>  h1 <span class="st">&quot;First header&quot;</span></span>
<span id="cb906-13"><a href="#cb906-13" aria-hidden="true" tabindex="-1"></a>  p <span class="op">$</span> ul <span class="op">$</span> <span class="fu">mconcat</span> [li <span class="st">&quot;First&quot;</span>, li <span class="st">&quot;Second&quot;</span>]</span>
<span id="cb906-14"><a href="#cb906-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb906-15"><a href="#cb906-15" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb906-16"><a href="#cb906-16" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb906-17"><a href="#cb906-17" aria-hidden="true" tabindex="-1"></a>  T.putStrLn <span class="op">$</span> renderHtml example</span></code></pre></div>
<p>For custom datatypes we can implement the <code>ToMarkup</code>class
to convert between Haskell data structures and HTML representation.</p>
<div class="sourceCode" id="cb907"
data-include="src/27-web/blaze_instance.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb907-1"><a href="#cb907-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecordWildCards #-}</span></span>
<span id="cb907-2"><a href="#cb907-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb907-3"><a href="#cb907-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb907-4"><a href="#cb907-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Html</span> <span class="kw">where</span></span>
<span id="cb907-5"><a href="#cb907-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb907-6"><a href="#cb907-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Html5</span></span>
<span id="cb907-7"><a href="#cb907-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Html.Renderer.Text</span></span>
<span id="cb907-8"><a href="#cb907-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb907-9"><a href="#cb907-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb907-10"><a href="#cb907-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb907-11"><a href="#cb907-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb907-12"><a href="#cb907-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Employee</span> <span class="ot">=</span> <span class="dt">Employee</span></span>
<span id="cb907-13"><a href="#cb907-13" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> name ::</span> <span class="dt">T.Text</span></span>
<span id="cb907-14"><a href="#cb907-14" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> age ::</span> <span class="dt">Int</span></span>
<span id="cb907-15"><a href="#cb907-15" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb907-16"><a href="#cb907-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb907-17"><a href="#cb907-17" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">ToMarkup</span> <span class="dt">Employee</span> <span class="kw">where</span></span>
<span id="cb907-18"><a href="#cb907-18" aria-hidden="true" tabindex="-1"></a>  toMarkup <span class="dt">Employee</span> {<span class="op">..</span>} <span class="ot">=</span> ul <span class="op">$</span> <span class="fu">mconcat</span></span>
<span id="cb907-19"><a href="#cb907-19" aria-hidden="true" tabindex="-1"></a>    [ li (toHtml name)</span>
<span id="cb907-20"><a href="#cb907-20" aria-hidden="true" tabindex="-1"></a>    , li (toHtml age)</span>
<span id="cb907-21"><a href="#cb907-21" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb907-22"><a href="#cb907-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb907-23"><a href="#cb907-23" aria-hidden="true" tabindex="-1"></a><span class="ot">fred ::</span> <span class="dt">Employee</span></span>
<span id="cb907-24"><a href="#cb907-24" aria-hidden="true" tabindex="-1"></a>fred <span class="ot">=</span> <span class="dt">Employee</span> { name <span class="ot">=</span> <span class="st">&quot;Fred&quot;</span>, age <span class="ot">=</span> <span class="dv">35</span> }</span>
<span id="cb907-25"><a href="#cb907-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb907-26"><a href="#cb907-26" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb907-27"><a href="#cb907-27" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb907-28"><a href="#cb907-28" aria-hidden="true" tabindex="-1"></a>  T.putStrLn <span class="op">$</span> renderHtml (toHtml fred)</span></code></pre></div>
<h2 id="lucid">Lucid</h2>
<p>Lucid is another HTML generation library. It takes a different
namespacing approach than Blaze and doesn’t use names which clash with
the default Prelude exports. So elements like <code>div</code>,
<code>id</code>, and <code>head</code> are replaced with underscore
suffixed functions. <code>div_</code>, <code>id_</code> and
<code>head_</code>.</p>
<p>The base interface is defined through a <code>ToHTML</code> typeclass
which renders an element into a text builder interface wrapped in
<code>HtmlT</code> transformer.</p>
<div class="sourceCode" id="cb908"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb908-1"><a href="#cb908-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">ToHtml</span> a <span class="kw">where</span></span>
<span id="cb908-2"><a href="#cb908-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  toHtml ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">HtmlT</span> m ()</span>
<span id="cb908-3"><a href="#cb908-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  toHtmlRaw ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">HtmlT</span> m ()</span>
<span id="cb908-4"><a href="#cb908-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb908-5"><a href="#cb908-5" aria-hidden="true" tabindex="-1"></a><span class="ot">execHtmlT ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">HtmlT</span> m a <span class="ot">-&gt;</span> m <span class="dt">Builder</span></span>
<span id="cb908-6"><a href="#cb908-6" aria-hidden="true" tabindex="-1"></a><span class="ot">renderText ::</span> <span class="dt">Html</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb908-7"><a href="#cb908-7" aria-hidden="true" tabindex="-1"></a><span class="ot">renderBS ::</span> <span class="dt">Html</span> a <span class="ot">-&gt;</span> <span class="dt">ByteString</span></span></code></pre></div>
<p>New elements and attributes can be created by the smart constructors
for <code>Attribute</code> and <code>Element</code> types.</p>
<div class="sourceCode" id="cb909"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb909-1"><a href="#cb909-1" aria-hidden="true" tabindex="-1"></a>makeAttribute</span>
<span id="cb909-2"><a href="#cb909-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">Text</span> <span class="co">-- ^ Attribute name.</span></span>
<span id="cb909-3"><a href="#cb909-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Text</span> <span class="co">-- ^ Attribute value.</span></span>
<span id="cb909-4"><a href="#cb909-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">Attribute</span></span>
<span id="cb909-5"><a href="#cb909-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb909-6"><a href="#cb909-6" aria-hidden="true" tabindex="-1"></a>makeElement</span>
<span id="cb909-7"><a href="#cb909-7" aria-hidden="true" tabindex="-1"></a><span class="ot">  ::</span> <span class="dt">Functor</span> m</span>
<span id="cb909-8"><a href="#cb909-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> <span class="dt">Text</span>       <span class="co">-- ^ Name.</span></span>
<span id="cb909-9"><a href="#cb909-9" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">HtmlT</span> m a  <span class="co">-- ^ Children HTML.</span></span>
<span id="cb909-10"><a href="#cb909-10" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">HtmlT</span> m a <span class="co">-- ^ A parent element.</span></span></code></pre></div>
<p>A simple example of usage is shown below:</p>
<div class="sourceCode" id="cb910"
data-include="src/27-web/lucid.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb910-1"><a href="#cb910-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BlockArguments #-}</span></span>
<span id="cb910-2"><a href="#cb910-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb910-3"><a href="#cb910-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb910-4"><a href="#cb910-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb910-5"><a href="#cb910-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb910-6"><a href="#cb910-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Lucid</span></span>
<span id="cb910-7"><a href="#cb910-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Lucid.Base</span></span>
<span id="cb910-8"><a href="#cb910-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Lucid.Html5</span></span>
<span id="cb910-9"><a href="#cb910-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb910-10"><a href="#cb910-10" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">Html</span> ()</span>
<span id="cb910-11"><a href="#cb910-11" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> table_ (tr_ (td_ (p_ <span class="st">&quot;My table.&quot;</span>)))</span>
<span id="cb910-12"><a href="#cb910-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb910-13"><a href="#cb910-13" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">Html</span> ()</span>
<span id="cb910-14"><a href="#cb910-14" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> html_ <span class="kw">do</span></span>
<span id="cb910-15"><a href="#cb910-15" aria-hidden="true" tabindex="-1"></a>  head_ <span class="kw">do</span></span>
<span id="cb910-16"><a href="#cb910-16" aria-hidden="true" tabindex="-1"></a>    title_ <span class="st">&quot;HTML from Haskell&quot;</span></span>
<span id="cb910-17"><a href="#cb910-17" aria-hidden="true" tabindex="-1"></a>    link_ [rel_ <span class="st">&quot;stylesheet&quot;</span>, type_ <span class="st">&quot;text/css&quot;</span>, href_ <span class="st">&quot;bootstrap.css&quot;</span>]</span>
<span id="cb910-18"><a href="#cb910-18" aria-hidden="true" tabindex="-1"></a>  body_ <span class="kw">do</span></span>
<span id="cb910-19"><a href="#cb910-19" aria-hidden="true" tabindex="-1"></a>    p_ <span class="st">&quot;Generating HTMl form Haskell datatypes:&quot;</span></span>
<span id="cb910-20"><a href="#cb910-20" aria-hidden="true" tabindex="-1"></a>    ul_ <span class="op">$</span> <span class="fu">mapM_</span> (li_ <span class="op">.</span> toHtml <span class="op">.</span> <span class="fu">show</span>) [<span class="dv">1</span> <span class="op">..</span> <span class="dv">100</span>]</span>
<span id="cb910-21"><a href="#cb910-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb910-22"><a href="#cb910-22" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb910-23"><a href="#cb910-23" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb910-24"><a href="#cb910-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (renderText example1)</span>
<span id="cb910-25"><a href="#cb910-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (renderBS example2)</span></code></pre></div>
<h2 id="hastache">Hastache</h2>
<p>Hastache is string templating based on the “Mustache” style of
encoding metavariables with double braces <code>{{ x }}</code>. Hastache
supports automatically converting many Haskell types into strings and
uses the efficient Text functions for formatting.</p>
<p>The variables loaded into the template are specified in either a
function mapping variable names to printable MuType values. For instance
using a function.</p>
<div class="sourceCode" id="cb911"
data-include="src/27-web/hastache.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb911-1"><a href="#cb911-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb911-2"><a href="#cb911-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb911-3"><a href="#cb911-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Hastache</span></span>
<span id="cb911-4"><a href="#cb911-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Hastache.Context</span></span>
<span id="cb911-5"><a href="#cb911-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb911-6"><a href="#cb911-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb911-7"><a href="#cb911-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">TL</span></span>
<span id="cb911-8"><a href="#cb911-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">TL</span></span>
<span id="cb911-9"><a href="#cb911-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb911-10"><a href="#cb911-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Data</span></span>
<span id="cb911-11"><a href="#cb911-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb911-12"><a href="#cb911-12" aria-hidden="true" tabindex="-1"></a><span class="ot">template ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">MuContext</span> <span class="dt">IO</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TL.Text</span></span>
<span id="cb911-13"><a href="#cb911-13" aria-hidden="true" tabindex="-1"></a>template <span class="ot">=</span> hastacheFile defaultConfig</span>
<span id="cb911-14"><a href="#cb911-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb911-15"><a href="#cb911-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- Function strContext</span></span>
<span id="cb911-16"><a href="#cb911-16" aria-hidden="true" tabindex="-1"></a><span class="ot">context ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">MuType</span> <span class="dt">IO</span></span>
<span id="cb911-17"><a href="#cb911-17" aria-hidden="true" tabindex="-1"></a>context <span class="st">&quot;body&quot;</span>  <span class="ot">=</span> <span class="dt">MuVariable</span> (<span class="st">&quot;Hello World&quot;</span><span class="ot"> ::</span> <span class="dt">TL.Text</span>)</span>
<span id="cb911-18"><a href="#cb911-18" aria-hidden="true" tabindex="-1"></a>context <span class="st">&quot;title&quot;</span> <span class="ot">=</span> <span class="dt">MuVariable</span> (<span class="st">&quot;Haskell is lovely&quot;</span><span class="ot"> ::</span> <span class="dt">TL.Text</span>)</span>
<span id="cb911-19"><a href="#cb911-19" aria-hidden="true" tabindex="-1"></a>context _       <span class="ot">=</span> <span class="dt">MuVariable</span> ()</span>
<span id="cb911-20"><a href="#cb911-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb911-21"><a href="#cb911-21" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb911-22"><a href="#cb911-22" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb911-23"><a href="#cb911-23" aria-hidden="true" tabindex="-1"></a>  output <span class="ot">&lt;-</span> template <span class="st">&quot;templates/home.html&quot;</span> (mkStrContext context)</span>
<span id="cb911-24"><a href="#cb911-24" aria-hidden="true" tabindex="-1"></a>  TL.putStrLn output</span></code></pre></div>
<p>Or using Data-Typeable record and <code>mkGenericContext</code>, the
Haskell field names are converted into variable names.</p>
<div class="sourceCode" id="cb912"
data-include="src/27-web/hastache_generic.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb912-1"><a href="#cb912-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb912-2"><a href="#cb912-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb912-3"><a href="#cb912-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb912-4"><a href="#cb912-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Hastache</span></span>
<span id="cb912-5"><a href="#cb912-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Hastache.Context</span></span>
<span id="cb912-6"><a href="#cb912-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb912-7"><a href="#cb912-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">TL</span></span>
<span id="cb912-8"><a href="#cb912-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">TL</span></span>
<span id="cb912-9"><a href="#cb912-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb912-10"><a href="#cb912-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Data</span></span>
<span id="cb912-11"><a href="#cb912-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb912-12"><a href="#cb912-12" aria-hidden="true" tabindex="-1"></a><span class="ot">template ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">MuContext</span> <span class="dt">IO</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">TL.Text</span></span>
<span id="cb912-13"><a href="#cb912-13" aria-hidden="true" tabindex="-1"></a>template <span class="ot">=</span> hastacheFile defaultConfig</span>
<span id="cb912-14"><a href="#cb912-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb912-15"><a href="#cb912-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- Record context</span></span>
<span id="cb912-16"><a href="#cb912-16" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TemplateCtx</span> <span class="ot">=</span> <span class="dt">TemplateCtx</span></span>
<span id="cb912-17"><a href="#cb912-17" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> body ::</span> <span class="dt">TL.Text</span></span>
<span id="cb912-18"><a href="#cb912-18" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> title ::</span> <span class="dt">TL.Text</span></span>
<span id="cb912-19"><a href="#cb912-19" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Data</span>, <span class="dt">Typeable</span>)</span>
<span id="cb912-20"><a href="#cb912-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb912-21"><a href="#cb912-21" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb912-22"><a href="#cb912-22" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb912-23"><a href="#cb912-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ctx <span class="ot">=</span> <span class="dt">TemplateCtx</span> { body <span class="ot">=</span> <span class="st">&quot;Hello&quot;</span>, title <span class="ot">=</span> <span class="st">&quot;Haskell&quot;</span> }</span>
<span id="cb912-24"><a href="#cb912-24" aria-hidden="true" tabindex="-1"></a>  output <span class="ot">&lt;-</span> template <span class="st">&quot;templates/home.html&quot;</span> (mkGenericContext ctx)</span>
<span id="cb912-25"><a href="#cb912-25" aria-hidden="true" tabindex="-1"></a>  TL.putStrLn output</span></code></pre></div>
<p>The MuType and MuContext types can be parameterized by any monad or
transformer that implements <code>MonadIO</code>, not just IO.</p>
</hr>
<h2 id="warp">Warp</h2>
<p>Warp is a efficient massively concurrent web server, it is the
backend server behind several of popular Haskell web frameworks. The
internals have been finely tuned to utilize Haskell’s concurrent runtime
and is capable of handling a great deal of concurrent requests. For
example we can construct a simple web service which simply returns a 200
status code with a ByteString which is flushed to the socket.</p>
<div class="sourceCode" id="cb913"
data-include="src/27-web/warp.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb913-1"><a href="#cb913-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb913-2"><a href="#cb913-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb913-3"><a href="#cb913-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.HTTP.Types</span></span>
<span id="cb913-4"><a href="#cb913-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Wai</span></span>
<span id="cb913-5"><a href="#cb913-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Network.Wai.Handler.Warp</span> (run)</span>
<span id="cb913-6"><a href="#cb913-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb913-7"><a href="#cb913-7" aria-hidden="true" tabindex="-1"></a><span class="ot">app ::</span> <span class="dt">Application</span></span>
<span id="cb913-8"><a href="#cb913-8" aria-hidden="true" tabindex="-1"></a>app req respond <span class="ot">=</span> respond <span class="op">$</span> responseLBS status200 [] <span class="st">&quot;Make it so.&quot;</span></span>
<span id="cb913-9"><a href="#cb913-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb913-10"><a href="#cb913-10" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb913-11"><a href="#cb913-11" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> run <span class="dv">8000</span> app</span></code></pre></div>
<p>See: <a href="http://aosabook.org/en/posa/warp.html">Warp</a></p>
<h2 id="scotty">Scotty</h2>
<p>Continuing with our trek through web libraries, Scotty is a web
microframework similar in principle to Flask in Python or Sinatra in
Ruby.</p>
<div class="sourceCode" id="cb914"
data-include="src/27-web/scotty.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb914-1"><a href="#cb914-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb914-2"><a href="#cb914-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb914-3"><a href="#cb914-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Web.Scotty</span></span>
<span id="cb914-4"><a href="#cb914-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb914-5"><a href="#cb914-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Blaze.Html5</span> <span class="kw">as</span> <span class="dt">H</span></span>
<span id="cb914-6"><a href="#cb914-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Html5</span> (toHtml, <span class="dt">Html</span>)</span>
<span id="cb914-7"><a href="#cb914-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Blaze.Html.Renderer.Text</span> (renderHtml)</span>
<span id="cb914-8"><a href="#cb914-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb914-9"><a href="#cb914-9" aria-hidden="true" tabindex="-1"></a><span class="ot">greet ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Html</span></span>
<span id="cb914-10"><a href="#cb914-10" aria-hidden="true" tabindex="-1"></a>greet user <span class="ot">=</span> H.html <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb914-11"><a href="#cb914-11" aria-hidden="true" tabindex="-1"></a>  H.head <span class="op">$</span></span>
<span id="cb914-12"><a href="#cb914-12" aria-hidden="true" tabindex="-1"></a>    H.title <span class="st">&quot;Welcome!&quot;</span></span>
<span id="cb914-13"><a href="#cb914-13" aria-hidden="true" tabindex="-1"></a>  H.body <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb914-14"><a href="#cb914-14" aria-hidden="true" tabindex="-1"></a>    H.h1 <span class="st">&quot;Greetings!&quot;</span></span>
<span id="cb914-15"><a href="#cb914-15" aria-hidden="true" tabindex="-1"></a>    H.p (<span class="st">&quot;Hello &quot;</span> <span class="op">&gt;&gt;</span> toHtml user <span class="op">&gt;&gt;</span> <span class="st">&quot;!&quot;</span>)</span>
<span id="cb914-16"><a href="#cb914-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb914-17"><a href="#cb914-17" aria-hidden="true" tabindex="-1"></a>app <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb914-18"><a href="#cb914-18" aria-hidden="true" tabindex="-1"></a>  get <span class="st">&quot;/&quot;</span> <span class="op">$</span></span>
<span id="cb914-19"><a href="#cb914-19" aria-hidden="true" tabindex="-1"></a>    text <span class="st">&quot;Home Page&quot;</span></span>
<span id="cb914-20"><a href="#cb914-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb914-21"><a href="#cb914-21" aria-hidden="true" tabindex="-1"></a>  get <span class="st">&quot;/greet/:name&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb914-22"><a href="#cb914-22" aria-hidden="true" tabindex="-1"></a>    name <span class="ot">&lt;-</span> param <span class="st">&quot;name&quot;</span></span>
<span id="cb914-23"><a href="#cb914-23" aria-hidden="true" tabindex="-1"></a>    html <span class="op">$</span> renderHtml (greet name)</span>
<span id="cb914-24"><a href="#cb914-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb914-25"><a href="#cb914-25" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb914-26"><a href="#cb914-26" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> scotty <span class="dv">8000</span> app</span></code></pre></div>
<p>Of importance to note is the Blaze library used here overloads
do-notation but is not itself a proper monad so the various laws and
invariants that normally apply for monads may break down or fail with
error terms.</p>
<p>A collection of useful related resources can be found on the Scotty
wiki: <a href="https://github.com/scotty-web/scotty/wiki">Scotty
Tutorials &amp; Examples</a></p>
<h2 id="servant">Servant</h2>
<p>Servant is a modern Haskell web framework heavily based on type-level
programming patterns. Servant’s novel invention is a type-safe way of
specifying URL routes. This consists of two type-level infix combinators
<code>:&gt;</code> and <code>:&lt;|&gt;</code> combinators which combine
URL fragments into routes that are run by the web server. The two
datatypes are defined as followings:</p>
<div class="sourceCode" id="cb915"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb915-1"><a href="#cb915-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> (<span class="ot">path ::</span> k) <span class="op">:&gt;</span> (<span class="ot">a ::</span> <span class="op">*</span>) </span>
<span id="cb915-2"><a href="#cb915-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> a <span class="op">:&lt;|&gt;</span> b </span></code></pre></div>
<p>For example the URL endpoint for a GET route that returns JSON.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Endpoint</th>
<th style="text-align: left;">Servant route</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>GET /api/hello</code></td>
<td
style="text-align: left;"><code>"api" :&gt; "hello" :&gt; Get ‘[JSON] String</code></td>
</tr>
</tbody>
</table>
<p>The HTTP methods are lifted to the type level as <a
href="#promotion">DataKinds</a> from the following definition.</p>
<div class="sourceCode" id="cb916"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb916-1"><a href="#cb916-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">StdMethod</span> <span class="ot">=</span> <span class="dt">GET</span> <span class="op">|</span> <span class="dt">POST</span> <span class="op">|</span> <span class="dt">HEAD</span> <span class="op">|</span> <span class="dt">PUT</span> <span class="op">|</span> <span class="dt">DELETE</span> <span class="op">|</span> <span class="dt">TRACE</span> <span class="op">|</span> <span class="dt">CONNECT</span> <span class="op">|</span> <span class="dt">OPTIONS</span> <span class="op">|</span> <span class="dt">PATCH</span></span></code></pre></div>
<p>And the common type synonyms are given for successful requests:</p>
<div class="sourceCode" id="cb917"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb917-1"><a href="#cb917-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Post</span> <span class="ot">=</span> <span class="dt">Verb</span> <span class="dt">POST</span> <span class="dv">200</span></span>
<span id="cb917-2"><a href="#cb917-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Get</span>  <span class="ot">=</span> <span class="dt">Verb</span> <span class="dt">GET</span> <span class="dv">200</span></span></code></pre></div>
<p>For requests that receive a payload from the client a
<code>ReqBody</code> is attached to the route which contains the content
type of the requested payload. This takes a type-level list of options
and the Haskell value type to serialize into.</p>
<div class="sourceCode" id="cb918"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb918-1"><a href="#cb918-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ReqBody&#39;</span> (<span class="ot">mods ::</span> [<span class="op">*</span>]) (<span class="ot">contentTypes ::</span> [<span class="op">*</span>]) (<span class="ot">a ::</span> <span class="op">*</span>)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Endpoint</th>
<th style="text-align: left;">Servant route</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>POST /api/hello</code></td>
<td
style="text-align: left;"><code>"api" :&gt; "hello" :&gt; ReqBody '[JSON] MyData :&gt; Post '[JSON] MyData</code></td>
</tr>
</tbody>
</table>
<p>The application itself is expressed simply as a function which takes
a <code>Request</code> containing the headers and payload and handles it
by evaluating to a <code>Response</code> inside of the IO. The
underlying server used in <code>servant-server</code> is Warp.</p>
<div class="sourceCode" id="cb919"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb919-1"><a href="#cb919-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Application</span> </span>
<span id="cb919-2"><a href="#cb919-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Request</span> </span>
<span id="cb919-3"><a href="#cb919-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (<span class="dt">Response</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ResponseReceived</span>)</span>
<span id="cb919-4"><a href="#cb919-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ResponseReceived</span></span></code></pre></div>
<p>Middleware is then simply a higher order function which takes an
<code>Application</code> to another <code>Application</code>.</p>
<div class="sourceCode" id="cb920"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb920-1"><a href="#cb920-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Middleware</span> <span class="ot">=</span> <span class="dt">Application</span> <span class="ot">-&gt;</span> <span class="dt">Application</span></span></code></pre></div>
<p>Handlers are specified defined in <code>servant-server</code> and are
IO computations with failures handed by <code>ServerError</code>. The
toplevel functions <code>run</code> and <code>serve</code> can be used
to instantiate the application inside of a server.</p>
<div class="sourceCode" id="cb921"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb921-1"><a href="#cb921-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Handler</span> a <span class="ot">=</span> <span class="dt">Handler</span> {<span class="ot"> runHandler&#39; ::</span> <span class="dt">ExceptT</span> <span class="dt">ServerError</span> <span class="dt">IO</span> a }</span>
<span id="cb921-2"><a href="#cb921-2" aria-hidden="true" tabindex="-1"></a><span class="ot">serve ::</span> <span class="dt">HasServer</span> api &#39;[] <span class="ot">=&gt;</span> <span class="dt">Proxy</span> api <span class="ot">-&gt;</span> <span class="dt">Server</span> api <span class="ot">-&gt;</span> <span class="dt">Application</span></span>
<span id="cb921-3"><a href="#cb921-3" aria-hidden="true" tabindex="-1"></a><span class="ot">run ::</span> <span class="dt">Port</span> <span class="ot">-&gt;</span> <span class="dt">Application</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>For error handling the <code>throwError</code> function can be used
attached to an error response code.</p>
<div class="sourceCode" id="cb922"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb922-1"><a href="#cb922-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fail404 ::</span> <span class="dt">Handler</span> ()</span>
<span id="cb922-2"><a href="#cb922-2" aria-hidden="true" tabindex="-1"></a>fail404 <span class="ot">=</span> throwError <span class="op">$</span> err404 { errBody <span class="ot">=</span> <span class="st">&quot;Not found&quot;</span> }</span></code></pre></div>
<p><strong>Minimal Example</strong></p>
<p>The simplest end to end example is simply a router which has a single
endpoint mapping to a server handler which returns the String “Hello
World” as a <code>application/json</code> content type.</p>
<div class="sourceCode" id="cb923"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb923-1"><a href="#cb923-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">AppAPI</span> <span class="ot">=</span> <span class="st">&quot;api&quot;</span> <span class="op">:&gt;</span> <span class="st">&quot;hello&quot;</span> <span class="op">:&gt;</span> <span class="dt">Get</span> ‘[<span class="dt">JSON</span>] <span class="dt">String</span></span>
<span id="cb923-2"><a href="#cb923-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb923-3"><a href="#cb923-3" aria-hidden="true" tabindex="-1"></a><span class="ot">appAPI ::</span> <span class="dt">Proxy</span> <span class="dt">AppAPI</span></span>
<span id="cb923-4"><a href="#cb923-4" aria-hidden="true" tabindex="-1"></a>appAPI <span class="ot">=</span> <span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">AppAPI</span></span>
<span id="cb923-5"><a href="#cb923-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb923-6"><a href="#cb923-6" aria-hidden="true" tabindex="-1"></a><span class="ot">helloHandler ::</span> <span class="dt">Handler</span> <span class="dt">String</span></span>
<span id="cb923-7"><a href="#cb923-7" aria-hidden="true" tabindex="-1"></a>helloHandler <span class="ot">=</span> <span class="fu">return</span> <span class="st">&quot;Hello World!&quot;</span></span>
<span id="cb923-8"><a href="#cb923-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb923-9"><a href="#cb923-9" aria-hidden="true" tabindex="-1"></a><span class="ot">apiHandler ::</span> <span class="dt">Server</span> <span class="dt">AppAPI</span></span>
<span id="cb923-10"><a href="#cb923-10" aria-hidden="true" tabindex="-1"></a>apiHandler <span class="ot">=</span> helloHandler</span>
<span id="cb923-11"><a href="#cb923-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb923-12"><a href="#cb923-12" aria-hidden="true" tabindex="-1"></a><span class="ot">runServer ::</span> <span class="dt">IO</span> ()</span>
<span id="cb923-13"><a href="#cb923-13" aria-hidden="true" tabindex="-1"></a>runServer <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb923-14"><a href="#cb923-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> port <span class="ot">=</span> <span class="dv">8000</span></span>
<span id="cb923-15"><a href="#cb923-15" aria-hidden="true" tabindex="-1"></a>  run port (serve appAPI apiHandler)</span></code></pre></div>
<p><strong>Full Example</strong></p>
<p>As a second case, we consider a larger application which builds a
user interface which will enable the interface to send and receive data
from the client to the REST API.</p>
<p>First we define a custom <code>User</code> datatype and using generic
deriving we can derive the serializer from URI form data
automatically.</p>
<div class="sourceCode" id="cb924"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb924-1"><a href="#cb924-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">User</span> <span class="ot">=</span> <span class="dt">User</span> {<span class="ot">name ::</span> <span class="dt">Text</span>,<span class="ot"> userId ::</span> <span class="dt">Int</span>}</span>
<span id="cb924-2"><a href="#cb924-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> stock (<span class="dt">Generic</span>, <span class="dt">Show</span>)</span>
<span id="cb924-3"><a href="#cb924-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> anyclass (<span class="dt">FromForm</span>, <span class="dt">FromHttpApiData</span>)</span></code></pre></div>
<p>The URL routes are specified in an API type which maps the REST verbs
to response handlers.</p>
<div class="sourceCode" id="cb925"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb925-1"><a href="#cb925-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">API</span> <span class="ot">=</span></span>
<span id="cb925-2"><a href="#cb925-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Get</span> &#39;[<span class="dt">HTML</span>] <span class="dt">Markup</span></span>
<span id="cb925-3"><a href="#cb925-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">:&lt;|&gt;</span> ( <span class="st">&quot;user&quot;</span> <span class="op">:&gt;</span> <span class="dt">ReqBody</span> &#39;[<span class="dt">FormUrlEncoded</span>] <span class="dt">User</span> <span class="op">:&gt;</span> <span class="dt">Post</span> &#39;[<span class="dt">HTML</span>] <span class="dt">Markup</span> )</span></code></pre></div>
<p>The handler is an inhabitant of the <code>API</code>type and defines
the value level handlers corresponding to the routes at the type-level
<code>:&lt;|&gt;</code> terms.</p>
<div class="sourceCode" id="cb926"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb926-1"><a href="#cb926-1" aria-hidden="true" tabindex="-1"></a><span class="ot">server ::</span> <span class="dt">Handler</span> <span class="dt">Markup</span> <span class="op">:&lt;|&gt;</span> (<span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Markup</span>)</span>
<span id="cb926-2"><a href="#cb926-2" aria-hidden="true" tabindex="-1"></a>server <span class="ot">=</span> <span class="fu">index</span> <span class="op">:&lt;|&gt;</span> createUser</span></code></pre></div>
<p>The page rendering itself is mostly blaze boilerplate that generates
the markup programmatically using combinators. One could just as easily
plug in any of the templating languages (Mustache, …) instead here.</p>
<div class="sourceCode" id="cb927"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb927-1"><a href="#cb927-1" aria-hidden="true" tabindex="-1"></a><span class="fu">index</span><span class="ot"> ::</span> <span class="dt">Handler</span> <span class="dt">Markup</span></span>
<span id="cb927-2"><a href="#cb927-2" aria-hidden="true" tabindex="-1"></a><span class="fu">index</span> <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb927-3"><a href="#cb927-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> (page userForm)</span>
<span id="cb927-4"><a href="#cb927-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb927-5"><a href="#cb927-5" aria-hidden="true" tabindex="-1"></a><span class="ot">userForm ::</span> <span class="dt">Html.Html</span></span>
<span id="cb927-6"><a href="#cb927-6" aria-hidden="true" tabindex="-1"></a>userForm <span class="ot">=</span></span>
<span id="cb927-7"><a href="#cb927-7" aria-hidden="true" tabindex="-1"></a>  Html.div <span class="op">!</span> Attr.class_ <span class="st">&quot;row&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb927-8"><a href="#cb927-8" aria-hidden="true" tabindex="-1"></a>    form <span class="st">&quot;/user&quot;</span> <span class="st">&quot;post&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb927-9"><a href="#cb927-9" aria-hidden="true" tabindex="-1"></a>      field <span class="st">&quot;name&quot;</span></span>
<span id="cb927-10"><a href="#cb927-10" aria-hidden="true" tabindex="-1"></a>      field <span class="st">&quot;userId&quot;</span></span>
<span id="cb927-11"><a href="#cb927-11" aria-hidden="true" tabindex="-1"></a>      submit <span class="st">&quot;Create user&quot;</span></span></code></pre></div>
<p>The page will include the html and header containing the source
files. In this case we’ll simply load the Bootstrap library from a
CDN.</p>
<div class="sourceCode" id="cb928"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb928-1"><a href="#cb928-1" aria-hidden="true" tabindex="-1"></a><span class="ot">page ::</span> <span class="dt">Markup</span> <span class="ot">-&gt;</span> <span class="dt">Markup</span></span>
<span id="cb928-2"><a href="#cb928-2" aria-hidden="true" tabindex="-1"></a>page body <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb928-3"><a href="#cb928-3" aria-hidden="true" tabindex="-1"></a>  Html.html <span class="kw">do</span></span>
<span id="cb928-4"><a href="#cb928-4" aria-hidden="true" tabindex="-1"></a>    Html.head <span class="kw">do</span></span>
<span id="cb928-5"><a href="#cb928-5" aria-hidden="true" tabindex="-1"></a>      Html.title <span class="st">&quot;Example App&quot;</span></span>
<span id="cb928-6"><a href="#cb928-6" aria-hidden="true" tabindex="-1"></a>      Html.link</span>
<span id="cb928-7"><a href="#cb928-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">!</span> Attr.rel <span class="st">&quot;stylesheet&quot;</span></span>
<span id="cb928-8"><a href="#cb928-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">!</span> Attr.href <span class="st">&quot;https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css&quot;</span></span>
<span id="cb928-9"><a href="#cb928-9" aria-hidden="true" tabindex="-1"></a>    Html.body <span class="kw">do</span></span>
<span id="cb928-10"><a href="#cb928-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">...</span> other body markup <span class="op">...</span></span></code></pre></div>
<p>And then the handler for POST for the single endpoint will simply
deserialize the User datatype form the POST data and render it into a
page with the fields extracted.</p>
<div class="sourceCode" id="cb929"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb929-1"><a href="#cb929-1" aria-hidden="true" tabindex="-1"></a><span class="ot">createUser ::</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">Handler</span> <span class="dt">Markup</span></span>
<span id="cb929-2"><a href="#cb929-2" aria-hidden="true" tabindex="-1"></a>createUser user<span class="op">@</span><span class="dt">User</span> {<span class="op">..</span>} <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb929-3"><a href="#cb929-3" aria-hidden="true" tabindex="-1"></a>  liftIO (<span class="fu">print</span> user)</span>
<span id="cb929-4"><a href="#cb929-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> <span class="op">$</span> page <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb929-5"><a href="#cb929-5" aria-hidden="true" tabindex="-1"></a>    Html.p (<span class="st">&quot;Id: &quot;</span> <span class="op">&lt;&gt;</span> toHtml userId)</span>
<span id="cb929-6"><a href="#cb929-6" aria-hidden="true" tabindex="-1"></a>    Html.p (<span class="st">&quot;Username: &quot;</span> <span class="op">&lt;&gt;</span> toHtml name)</span></code></pre></div>
<p>Putting it all together we can invoke run on a given port and serve
the application. Point your browser at <code>localhost:8000</code> to
see it run.</p>
<div class="sourceCode" id="cb930"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb930-1"><a href="#cb930-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb930-2"><a href="#cb930-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb930-3"><a href="#cb930-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Running Server&quot;</span></span>
<span id="cb930-4"><a href="#cb930-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> application <span class="ot">=</span> Server.serve <span class="op">@</span><span class="dt">API</span> <span class="dt">Proxy</span> server</span>
<span id="cb930-5"><a href="#cb930-5" aria-hidden="true" tabindex="-1"></a>  Warp.run <span class="dv">8000</span> application</span></code></pre></div>
<p>From here you could all manner of additional logic, like adding in
the <a href="#selda">Selda</a> object relational mapper, adding in
<code>servant-auth</code> for authentication or using
<code>swagger2</code> for building Open API specifications.</p>
<hr/>
<h1 id="databases">Databases</h1>
<p>Haskell has bindings for most major databases and persistence
engines. Generally the libraries will consist of two different layers.
The raw bindings which wrap the C library or wire protocol will usually
be called <code>-simple</code>. So for example
<code>postgresql-simple</code> is the Haskell library for interfacing
with the C library <code>libpq-dev</code>. Higher level libraries will
depend on this library for the bindings and provide higher level
interfaces for building queries, managing transactions, and connection
pooling.</p>
<h2 id="postgres">Postgres</h2>
<p>Postgres is an object-relational database management system with a
rich extension of the SQL standard. Consider the following tables
specified in DDL.</p>
<div class="sourceCode" id="cb931"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb931-1"><a href="#cb931-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> <span class="ot">&quot;books&quot;</span> (</span>
<span id="cb931-2"><a href="#cb931-2" aria-hidden="true" tabindex="-1"></a>        <span class="ot">&quot;id&quot;</span> <span class="dt">integer</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb931-3"><a href="#cb931-3" aria-hidden="true" tabindex="-1"></a>        <span class="ot">&quot;title&quot;</span> text <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb931-4"><a href="#cb931-4" aria-hidden="true" tabindex="-1"></a>        <span class="ot">&quot;author_id&quot;</span> <span class="dt">integer</span>,</span>
<span id="cb931-5"><a href="#cb931-5" aria-hidden="true" tabindex="-1"></a>        <span class="ot">&quot;subject_id&quot;</span> <span class="dt">integer</span>,</span>
<span id="cb931-6"><a href="#cb931-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">Constraint</span> <span class="ot">&quot;books_id_pkey&quot;</span> <span class="kw">Primary</span> <span class="kw">Key</span> (<span class="ot">&quot;id&quot;</span>)</span>
<span id="cb931-7"><a href="#cb931-7" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb931-8"><a href="#cb931-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb931-9"><a href="#cb931-9" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> <span class="kw">TABLE</span> <span class="ot">&quot;authors&quot;</span> (</span>
<span id="cb931-10"><a href="#cb931-10" aria-hidden="true" tabindex="-1"></a>        <span class="ot">&quot;id&quot;</span> <span class="dt">integer</span> <span class="kw">NOT</span> <span class="kw">NULL</span>,</span>
<span id="cb931-11"><a href="#cb931-11" aria-hidden="true" tabindex="-1"></a>        <span class="ot">&quot;last_name&quot;</span> text,</span>
<span id="cb931-12"><a href="#cb931-12" aria-hidden="true" tabindex="-1"></a>        <span class="ot">&quot;first_name&quot;</span> text,</span>
<span id="cb931-13"><a href="#cb931-13" aria-hidden="true" tabindex="-1"></a>        <span class="kw">Constraint</span> <span class="ot">&quot;authors_pkey&quot;</span> <span class="kw">Primary</span> <span class="kw">Key</span> (<span class="ot">&quot;id&quot;</span>)</span>
<span id="cb931-14"><a href="#cb931-14" aria-hidden="true" tabindex="-1"></a>);</span></code></pre></div>
<p>The postgresql-simple bindings provide a thin wrapper to various
libpq commands to interact with a Postgres server. These functions all
take a <code>Connection</code> object to the database instance and allow
various bytestring queries to be sent and result sets mapped into
Haskell datatypes. There are four primary functions for these
interactions:</p>
<div class="sourceCode" id="cb932"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb932-1"><a href="#cb932-1" aria-hidden="true" tabindex="-1"></a><span class="ot">query_ ::</span> <span class="dt">FromRow</span> r <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [r]</span>
<span id="cb932-2"><a href="#cb932-2" aria-hidden="true" tabindex="-1"></a><span class="ot">query ::</span> (<span class="dt">ToRow</span> q, <span class="dt">FromRow</span> r) <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> q <span class="ot">-&gt;</span> <span class="dt">IO</span> [r]</span>
<span id="cb932-3"><a href="#cb932-3" aria-hidden="true" tabindex="-1"></a><span class="ot">execute ::</span> <span class="dt">ToRow</span> q <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> q <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int64</span></span>
<span id="cb932-4"><a href="#cb932-4" aria-hidden="true" tabindex="-1"></a><span class="ot">execute_ ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int64</span></span></code></pre></div>
<p>The result of the <code>query</code> function is a list of elements
which implement the FromRow typeclass. This can be many things including
a single element (Only), a list of tuples where each element implements
<code>FromField</code> or a custom datatype that itself implements
<code>FromRow</code>. Under the hood the database bindings inspects the
Postgres <code>oid</code> objects and then attempts to convert them into
the Haskell datatype of the field being scrutinised. This can fail at
runtime if the types in the database don’t align with the expected types
in the logic executing the SQL query.</p>
<h4 id="tuples-1">Tuples</h4>
<div class="sourceCode" id="cb933"
data-include="src/28-databases/postgres.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb933-1"><a href="#cb933-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb933-2"><a href="#cb933-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb933-3"><a href="#cb933-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb933-4"><a href="#cb933-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb933-5"><a href="#cb933-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Database.PostgreSQL.Simple</span> <span class="kw">as</span> <span class="dt">SQL</span></span>
<span id="cb933-6"><a href="#cb933-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb933-7"><a href="#cb933-7" aria-hidden="true" tabindex="-1"></a><span class="ot">creds ::</span> <span class="dt">SQL.ConnectInfo</span></span>
<span id="cb933-8"><a href="#cb933-8" aria-hidden="true" tabindex="-1"></a>creds <span class="ot">=</span></span>
<span id="cb933-9"><a href="#cb933-9" aria-hidden="true" tabindex="-1"></a>  SQL.defaultConnectInfo</span>
<span id="cb933-10"><a href="#cb933-10" aria-hidden="true" tabindex="-1"></a>    { SQL.connectUser <span class="ot">=</span> <span class="st">&quot;example&quot;</span>,</span>
<span id="cb933-11"><a href="#cb933-11" aria-hidden="true" tabindex="-1"></a>      SQL.connectPassword <span class="ot">=</span> <span class="st">&quot;example&quot;</span>,</span>
<span id="cb933-12"><a href="#cb933-12" aria-hidden="true" tabindex="-1"></a>      SQL.connectDatabase <span class="ot">=</span> <span class="st">&quot;booktown&quot;</span></span>
<span id="cb933-13"><a href="#cb933-13" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb933-14"><a href="#cb933-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb933-15"><a href="#cb933-15" aria-hidden="true" tabindex="-1"></a><span class="ot">selectBooks ::</span> <span class="dt">SQL.Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [(<span class="dt">Int</span>, <span class="dt">T.Text</span>, <span class="dt">Int</span>)]</span>
<span id="cb933-16"><a href="#cb933-16" aria-hidden="true" tabindex="-1"></a>selectBooks conn <span class="ot">=</span> SQL.query_ conn <span class="st">&quot;select id, title, author_id from books&quot;</span></span>
<span id="cb933-17"><a href="#cb933-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb933-18"><a href="#cb933-18" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb933-19"><a href="#cb933-19" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb933-20"><a href="#cb933-20" aria-hidden="true" tabindex="-1"></a>  conn <span class="ot">&lt;-</span> SQL.connect creds</span>
<span id="cb933-21"><a href="#cb933-21" aria-hidden="true" tabindex="-1"></a>  books <span class="ot">&lt;-</span> selectBooks conn</span>
<span id="cb933-22"><a href="#cb933-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> books</span></code></pre></div>
<p>This yields the result set:</p>
<div class="sourceCode" id="cb934"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb934-1"><a href="#cb934-1" aria-hidden="true" tabindex="-1"></a>[ ( <span class="dv">7808</span> , <span class="st">&quot;The Shining&quot;</span> , <span class="dv">4156</span> )</span>
<span id="cb934-2"><a href="#cb934-2" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">4513</span> , <span class="st">&quot;Dune&quot;</span> , <span class="dv">1866</span> )</span>
<span id="cb934-3"><a href="#cb934-3" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">4267</span> , <span class="st">&quot;2001: A Space Odyssey&quot;</span> , <span class="dv">2001</span> )</span>
<span id="cb934-4"><a href="#cb934-4" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">1608</span> , <span class="st">&quot;The Cat in the Hat&quot;</span> , <span class="dv">1809</span> )</span>
<span id="cb934-5"><a href="#cb934-5" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">1590</span> , <span class="st">&quot;Bartholomew and the Oobleck&quot;</span> , <span class="dv">1809</span> )</span>
<span id="cb934-6"><a href="#cb934-6" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">25908</span> , <span class="st">&quot;Franklin in the Dark&quot;</span> , <span class="dv">15990</span> )</span>
<span id="cb934-7"><a href="#cb934-7" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">1501</span> , <span class="st">&quot;Goodnight Moon&quot;</span> , <span class="dv">2031</span> )</span>
<span id="cb934-8"><a href="#cb934-8" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">190</span> , <span class="st">&quot;Little Women&quot;</span> , <span class="dv">16</span> )</span>
<span id="cb934-9"><a href="#cb934-9" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">1234</span> , <span class="st">&quot;The Velveteen Rabbit&quot;</span> , <span class="dv">25041</span> )</span>
<span id="cb934-10"><a href="#cb934-10" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">2038</span> , <span class="st">&quot;Dynamic Anatomy&quot;</span> , <span class="dv">1644</span> )</span>
<span id="cb934-11"><a href="#cb934-11" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">156</span> , <span class="st">&quot;The Tell-Tale Heart&quot;</span> , <span class="dv">115</span> )</span>
<span id="cb934-12"><a href="#cb934-12" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">41473</span> , <span class="st">&quot;Programming Python&quot;</span> , <span class="dv">7805</span> )</span>
<span id="cb934-13"><a href="#cb934-13" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">41477</span> , <span class="st">&quot;Learning Python&quot;</span> , <span class="dv">7805</span> )</span>
<span id="cb934-14"><a href="#cb934-14" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">41478</span> , <span class="st">&quot;Perl Cookbook&quot;</span> , <span class="dv">7806</span> )</span>
<span id="cb934-15"><a href="#cb934-15" aria-hidden="true" tabindex="-1"></a>, ( <span class="dv">41472</span> , <span class="st">&quot;Practical PostgreSQL&quot;</span> , <span class="dv">1212</span> )</span>
<span id="cb934-16"><a href="#cb934-16" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<h4 id="custom-types">Custom Types</h4>
<div class="sourceCode" id="cb935"
data-include="src/28-databases/postgres_custom.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb935-1"><a href="#cb935-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb935-2"><a href="#cb935-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb935-3"><a href="#cb935-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb935-4"><a href="#cb935-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb935-5"><a href="#cb935-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Database.PostgreSQL.Simple</span> <span class="kw">as</span> <span class="dt">SQL</span></span>
<span id="cb935-6"><a href="#cb935-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Database.PostgreSQL.Simple.FromRow</span> (<span class="dt">FromRow</span>(..), field)</span>
<span id="cb935-7"><a href="#cb935-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb935-8"><a href="#cb935-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Book</span> <span class="ot">=</span> <span class="dt">Book</span></span>
<span id="cb935-9"><a href="#cb935-9" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> id_ ::</span> <span class="dt">Int</span></span>
<span id="cb935-10"><a href="#cb935-10" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> title ::</span> <span class="dt">T.Text</span></span>
<span id="cb935-11"><a href="#cb935-11" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> author_id ::</span> <span class="dt">Int</span></span>
<span id="cb935-12"><a href="#cb935-12" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb935-13"><a href="#cb935-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb935-14"><a href="#cb935-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromRow</span> <span class="dt">Book</span> <span class="kw">where</span></span>
<span id="cb935-15"><a href="#cb935-15" aria-hidden="true" tabindex="-1"></a>  fromRow <span class="ot">=</span> <span class="dt">Book</span> <span class="op">&lt;$&gt;</span> field <span class="op">&lt;*&gt;</span> field <span class="op">&lt;*&gt;</span> field</span>
<span id="cb935-16"><a href="#cb935-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb935-17"><a href="#cb935-17" aria-hidden="true" tabindex="-1"></a><span class="ot">creds ::</span> <span class="dt">SQL.ConnectInfo</span></span>
<span id="cb935-18"><a href="#cb935-18" aria-hidden="true" tabindex="-1"></a>creds <span class="ot">=</span> SQL.defaultConnectInfo</span>
<span id="cb935-19"><a href="#cb935-19" aria-hidden="true" tabindex="-1"></a>  { SQL.connectUser <span class="ot">=</span> <span class="st">&quot;example&quot;</span></span>
<span id="cb935-20"><a href="#cb935-20" aria-hidden="true" tabindex="-1"></a>  , SQL.connectPassword <span class="ot">=</span> <span class="st">&quot;example&quot;</span></span>
<span id="cb935-21"><a href="#cb935-21" aria-hidden="true" tabindex="-1"></a>  , SQL.connectDatabase <span class="ot">=</span> <span class="st">&quot;booktown&quot;</span></span>
<span id="cb935-22"><a href="#cb935-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb935-23"><a href="#cb935-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb935-24"><a href="#cb935-24" aria-hidden="true" tabindex="-1"></a><span class="ot">selectBooks ::</span> <span class="dt">SQL.Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Book</span>]</span>
<span id="cb935-25"><a href="#cb935-25" aria-hidden="true" tabindex="-1"></a>selectBooks conn <span class="ot">=</span> SQL.query_ conn <span class="st">&quot;select id, title, author_id from books limit 4&quot;</span></span>
<span id="cb935-26"><a href="#cb935-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb935-27"><a href="#cb935-27" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb935-28"><a href="#cb935-28" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb935-29"><a href="#cb935-29" aria-hidden="true" tabindex="-1"></a>  conn <span class="ot">&lt;-</span> SQL.connect creds</span>
<span id="cb935-30"><a href="#cb935-30" aria-hidden="true" tabindex="-1"></a>  books <span class="ot">&lt;-</span> selectBooks conn</span>
<span id="cb935-31"><a href="#cb935-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> books</span></code></pre></div>
<p>This yields the result set:</p>
<div class="sourceCode" id="cb936"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb936-1"><a href="#cb936-1" aria-hidden="true" tabindex="-1"></a>[ <span class="dt">Book</span> { id_ <span class="ot">=</span> <span class="dv">7808</span> , title <span class="ot">=</span> <span class="st">&quot;The Shining&quot;</span> , author_id <span class="ot">=</span> <span class="dv">4156</span> }</span>
<span id="cb936-2"><a href="#cb936-2" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Book</span> { id_ <span class="ot">=</span> <span class="dv">4513</span> , title <span class="ot">=</span> <span class="st">&quot;Dune&quot;</span> , author_id <span class="ot">=</span> <span class="dv">1866</span> }</span>
<span id="cb936-3"><a href="#cb936-3" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Book</span> { id_ <span class="ot">=</span> <span class="dv">4267</span> , title <span class="ot">=</span> <span class="st">&quot;2001: A Space Odyssey&quot;</span> , author_id <span class="ot">=</span> <span class="dv">2001</span> }</span>
<span id="cb936-4"><a href="#cb936-4" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Book</span> { id_ <span class="ot">=</span> <span class="dv">1608</span> , title <span class="ot">=</span> <span class="st">&quot;The Cat in the Hat&quot;</span> , author_id <span class="ot">=</span> <span class="dv">1809</span> }</span>
<span id="cb936-5"><a href="#cb936-5" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<h4 id="quasiquoter">Quasiquoter</h4>
<p>As SQL expressions grow in complexity they often span multiple lines
and sometimes it’s useful to just drop down to a quasiquoter to embed
the whole query. The quoter here is pure, and just generates the
<code>Query</code> object behind as a ByteString.</p>
<div class="sourceCode" id="cb937"
data-include="src/28-databases/postgres_qq.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb937-1"><a href="#cb937-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb937-2"><a href="#cb937-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb937-3"><a href="#cb937-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb937-4"><a href="#cb937-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb937-5"><a href="#cb937-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb937-6"><a href="#cb937-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb937-7"><a href="#cb937-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Database.PostgreSQL.Simple</span> <span class="kw">as</span> <span class="dt">SQL</span></span>
<span id="cb937-8"><a href="#cb937-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Database.PostgreSQL.Simple.SqlQQ</span> (sql)</span>
<span id="cb937-9"><a href="#cb937-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Database.PostgreSQL.Simple.FromRow</span> (<span class="dt">FromRow</span>(..), field)</span>
<span id="cb937-10"><a href="#cb937-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb937-11"><a href="#cb937-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Book</span> <span class="ot">=</span> <span class="dt">Book</span></span>
<span id="cb937-12"><a href="#cb937-12" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> id_ ::</span> <span class="dt">Int</span></span>
<span id="cb937-13"><a href="#cb937-13" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> title ::</span> <span class="dt">T.Text</span></span>
<span id="cb937-14"><a href="#cb937-14" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> first_name ::</span> <span class="dt">T.Text</span></span>
<span id="cb937-15"><a href="#cb937-15" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> last_name ::</span> <span class="dt">T.Text</span></span>
<span id="cb937-16"><a href="#cb937-16" aria-hidden="true" tabindex="-1"></a>  } <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb937-17"><a href="#cb937-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb937-18"><a href="#cb937-18" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">FromRow</span> <span class="dt">Book</span> <span class="kw">where</span></span>
<span id="cb937-19"><a href="#cb937-19" aria-hidden="true" tabindex="-1"></a>  fromRow <span class="ot">=</span> <span class="dt">Book</span> <span class="op">&lt;$&gt;</span> field <span class="op">&lt;*&gt;</span> field <span class="op">&lt;*&gt;</span> field <span class="op">&lt;*&gt;</span> field</span>
<span id="cb937-20"><a href="#cb937-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb937-21"><a href="#cb937-21" aria-hidden="true" tabindex="-1"></a><span class="ot">creds ::</span> <span class="dt">SQL.ConnectInfo</span></span>
<span id="cb937-22"><a href="#cb937-22" aria-hidden="true" tabindex="-1"></a>creds <span class="ot">=</span> SQL.defaultConnectInfo</span>
<span id="cb937-23"><a href="#cb937-23" aria-hidden="true" tabindex="-1"></a>  { SQL.connectUser <span class="ot">=</span> <span class="st">&quot;example&quot;</span></span>
<span id="cb937-24"><a href="#cb937-24" aria-hidden="true" tabindex="-1"></a>  , SQL.connectPassword <span class="ot">=</span> <span class="st">&quot;example&quot;</span></span>
<span id="cb937-25"><a href="#cb937-25" aria-hidden="true" tabindex="-1"></a>  , SQL.connectDatabase <span class="ot">=</span> <span class="st">&quot;booktown&quot;</span></span>
<span id="cb937-26"><a href="#cb937-26" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb937-27"><a href="#cb937-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb937-28"><a href="#cb937-28" aria-hidden="true" tabindex="-1"></a><span class="ot">selectBooks ::</span> <span class="dt">SQL.Query</span></span>
<span id="cb937-29"><a href="#cb937-29" aria-hidden="true" tabindex="-1"></a>selectBooks <span class="ot">=</span> [sql|</span>
<span id="cb937-30"><a href="#cb937-30" aria-hidden="true" tabindex="-1"></a>select</span>
<span id="cb937-31"><a href="#cb937-31" aria-hidden="true" tabindex="-1"></a>  books.id,</span>
<span id="cb937-32"><a href="#cb937-32" aria-hidden="true" tabindex="-1"></a>  books.title,</span>
<span id="cb937-33"><a href="#cb937-33" aria-hidden="true" tabindex="-1"></a>  authors.first_name,</span>
<span id="cb937-34"><a href="#cb937-34" aria-hidden="true" tabindex="-1"></a>  authors.last_name</span>
<span id="cb937-35"><a href="#cb937-35" aria-hidden="true" tabindex="-1"></a>from books</span>
<span id="cb937-36"><a href="#cb937-36" aria-hidden="true" tabindex="-1"></a>join authors on</span>
<span id="cb937-37"><a href="#cb937-37" aria-hidden="true" tabindex="-1"></a>  authors.id = books.author_id</span>
<span id="cb937-38"><a href="#cb937-38" aria-hidden="true" tabindex="-1"></a>limit 5</span>
<span id="cb937-39"><a href="#cb937-39" aria-hidden="true" tabindex="-1"></a>|]</span>
<span id="cb937-40"><a href="#cb937-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb937-41"><a href="#cb937-41" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb937-42"><a href="#cb937-42" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb937-43"><a href="#cb937-43" aria-hidden="true" tabindex="-1"></a>  conn <span class="ot">&lt;-</span> SQL.connect creds</span>
<span id="cb937-44"><a href="#cb937-44" aria-hidden="true" tabindex="-1"></a>  (<span class="ot">books ::</span> [<span class="dt">Book</span>]) <span class="ot">&lt;-</span> SQL.query_ conn selectBooks</span>
<span id="cb937-45"><a href="#cb937-45" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> books</span></code></pre></div>
<p>This yields the result set:</p>
<div class="sourceCode" id="cb938"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb938-1"><a href="#cb938-1" aria-hidden="true" tabindex="-1"></a>[ <span class="dt">Book</span></span>
<span id="cb938-2"><a href="#cb938-2" aria-hidden="true" tabindex="-1"></a>    { id_ <span class="ot">=</span> <span class="dv">41472</span></span>
<span id="cb938-3"><a href="#cb938-3" aria-hidden="true" tabindex="-1"></a>    , title <span class="ot">=</span> <span class="st">&quot;Practical PostgreSQL&quot;</span></span>
<span id="cb938-4"><a href="#cb938-4" aria-hidden="true" tabindex="-1"></a>    , first_name <span class="ot">=</span> <span class="st">&quot;John&quot;</span></span>
<span id="cb938-5"><a href="#cb938-5" aria-hidden="true" tabindex="-1"></a>    , last_name <span class="ot">=</span> <span class="st">&quot;Worsley&quot;</span></span>
<span id="cb938-6"><a href="#cb938-6" aria-hidden="true" tabindex="-1"></a>   }</span>
<span id="cb938-7"><a href="#cb938-7" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Book</span></span>
<span id="cb938-8"><a href="#cb938-8" aria-hidden="true" tabindex="-1"></a>    { id_ <span class="ot">=</span> <span class="dv">25908</span></span>
<span id="cb938-9"><a href="#cb938-9" aria-hidden="true" tabindex="-1"></a>    , title <span class="ot">=</span> <span class="st">&quot;Franklin in the Dark&quot;</span></span>
<span id="cb938-10"><a href="#cb938-10" aria-hidden="true" tabindex="-1"></a>    , first_name <span class="ot">=</span> <span class="st">&quot;Paulette&quot;</span></span>
<span id="cb938-11"><a href="#cb938-11" aria-hidden="true" tabindex="-1"></a>    , last_name <span class="ot">=</span> <span class="st">&quot;Bourgeois&quot;</span></span>
<span id="cb938-12"><a href="#cb938-12" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb938-13"><a href="#cb938-13" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Book</span></span>
<span id="cb938-14"><a href="#cb938-14" aria-hidden="true" tabindex="-1"></a>    { id_ <span class="ot">=</span> <span class="dv">1234</span></span>
<span id="cb938-15"><a href="#cb938-15" aria-hidden="true" tabindex="-1"></a>    , title <span class="ot">=</span> <span class="st">&quot;The Velveteen Rabbit&quot;</span></span>
<span id="cb938-16"><a href="#cb938-16" aria-hidden="true" tabindex="-1"></a>    , first_name <span class="ot">=</span> <span class="st">&quot;Margery Williams&quot;</span></span>
<span id="cb938-17"><a href="#cb938-17" aria-hidden="true" tabindex="-1"></a>    , last_name <span class="ot">=</span> <span class="st">&quot;Bianco&quot;</span></span>
<span id="cb938-18"><a href="#cb938-18" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb938-19"><a href="#cb938-19" aria-hidden="true" tabindex="-1"></a>, <span class="dt">Book</span></span>
<span id="cb938-20"><a href="#cb938-20" aria-hidden="true" tabindex="-1"></a>    { id_ <span class="ot">=</span> <span class="dv">190</span></span>
<span id="cb938-21"><a href="#cb938-21" aria-hidden="true" tabindex="-1"></a>    , title <span class="ot">=</span> <span class="st">&quot;Little Women&quot;</span></span>
<span id="cb938-22"><a href="#cb938-22" aria-hidden="true" tabindex="-1"></a>    , first_name <span class="ot">=</span> <span class="st">&quot;Louisa May&quot;</span></span>
<span id="cb938-23"><a href="#cb938-23" aria-hidden="true" tabindex="-1"></a>    , last_name <span class="ot">=</span> <span class="st">&quot;Alcott&quot;</span></span>
<span id="cb938-24"><a href="#cb938-24" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb938-25"><a href="#cb938-25" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
<h2 id="sqlite">Sqlite</h2>
<p>The <code>sqlite-simple</code> library provides a binding to the
<code>libsqlite3</code> which can interact with and query SQLite
databases. It provides precisely the same interface as the Postgres
library of similar namesakes.</p>
<div class="sourceCode" id="cb939"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb939-1"><a href="#cb939-1" aria-hidden="true" tabindex="-1"></a><span class="ot">query_ ::</span> <span class="dt">FromRow</span> r <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [r]</span>
<span id="cb939-2"><a href="#cb939-2" aria-hidden="true" tabindex="-1"></a><span class="ot">query ::</span> (<span class="dt">ToRow</span> q, <span class="dt">FromRow</span> r) <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> q <span class="ot">-&gt;</span> <span class="dt">IO</span> [r]</span>
<span id="cb939-3"><a href="#cb939-3" aria-hidden="true" tabindex="-1"></a><span class="ot">execute ::</span> <span class="dt">ToRow</span> q <span class="ot">=&gt;</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> q <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int64</span></span>
<span id="cb939-4"><a href="#cb939-4" aria-hidden="true" tabindex="-1"></a><span class="ot">execute_ ::</span> <span class="dt">Connection</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int64</span></span></code></pre></div>
<p>All datatypes can be serialised to and from result sets by defining
<code>FromRow</code> and <code>ToRow</code> datatypes which map your
custom datatypes to a RowParser which convets result sets, or a
serialisers which maps custom to one of the following primitive sqlite
types.</p>
<ul>
<li><code>SQLInteger</code></li>
<li><code>SQLFloat</code></li>
<li><code>SQLText</code></li>
<li><code>SQLBlob</code></li>
<li><code>SQLNull</code></li>
</ul>
<div class="sourceCode" id="cb940"
data-include="src/28-databases/sqlite.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb940-1"><a href="#cb940-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb940-2"><a href="#cb940-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb940-3"><a href="#cb940-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb940-4"><a href="#cb940-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb940-5"><a href="#cb940-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Database.SQLite.Simple</span> <span class="kw">as</span> <span class="dt">SQL</span></span>
<span id="cb940-6"><a href="#cb940-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb940-7"><a href="#cb940-7" aria-hidden="true" tabindex="-1"></a><span class="ot">selectBooks ::</span> <span class="dt">SQL.Connection</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [(<span class="dt">Int</span>, <span class="dt">T.Text</span>, <span class="dt">Int</span>)]</span>
<span id="cb940-8"><a href="#cb940-8" aria-hidden="true" tabindex="-1"></a>selectBooks conn <span class="ot">=</span> SQL.query_ conn <span class="st">&quot;select id, title, author_id from books&quot;</span></span>
<span id="cb940-9"><a href="#cb940-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb940-10"><a href="#cb940-10" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb940-11"><a href="#cb940-11" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb940-12"><a href="#cb940-12" aria-hidden="true" tabindex="-1"></a>  conn <span class="ot">&lt;-</span> open <span class="st">&quot;books.db&quot;</span></span>
<span id="cb940-13"><a href="#cb940-13" aria-hidden="true" tabindex="-1"></a>  books <span class="ot">&lt;-</span> selectBooks conn</span>
<span id="cb940-14"><a href="#cb940-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> ()</span></code></pre></div>
<p>For examples of serialising to datatype see the previous <a
href="#postgres">Postgres</a> section as it has an identical
interface.</p>
<h2 id="redis">Redis</h2>
<p>Redis is an in-memory key-value store with support for a variety of
datastructures. The Haskell exposure is exposed in a <code>Redis</code>
monad which sequences a set of <a href="http://redis.io/commands">redis
commands</a> taking ByteString arguments and then executes them against
a connection object.</p>
<div class="sourceCode" id="cb941"
data-include="src/28-databases/hedis.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb941-1"><a href="#cb941-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb941-2"><a href="#cb941-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb941-3"><a href="#cb941-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Database.Redis</span></span>
<span id="cb941-4"><a href="#cb941-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Char8</span></span>
<span id="cb941-5"><a href="#cb941-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb941-6"><a href="#cb941-6" aria-hidden="true" tabindex="-1"></a><span class="ot">session ::</span> <span class="dt">Redis</span> (<span class="dt">Either</span> <span class="dt">Reply</span> (<span class="dt">Maybe</span> <span class="dt">ByteString</span>))</span>
<span id="cb941-7"><a href="#cb941-7" aria-hidden="true" tabindex="-1"></a>session <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb941-8"><a href="#cb941-8" aria-hidden="true" tabindex="-1"></a>  set <span class="st">&quot;hello&quot;</span> <span class="st">&quot;haskell&quot;</span></span>
<span id="cb941-9"><a href="#cb941-9" aria-hidden="true" tabindex="-1"></a>  get <span class="st">&quot;hello&quot;</span></span>
<span id="cb941-10"><a href="#cb941-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb941-11"><a href="#cb941-11" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb941-12"><a href="#cb941-12" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb941-13"><a href="#cb941-13" aria-hidden="true" tabindex="-1"></a>  conn <span class="ot">&lt;-</span> connect defaultConnectInfo</span>
<span id="cb941-14"><a href="#cb941-14" aria-hidden="true" tabindex="-1"></a>  res <span class="ot">&lt;-</span> runRedis conn session</span>
<span id="cb941-15"><a href="#cb941-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> res</span></code></pre></div>
<p>Redis is quite often used as a lightweight pubsub server, and the
bindings integrate with the Haskell concurrency primitives so that
listeners can be sparked and shared across threads off without blocking
the main thread.</p>
<div class="sourceCode" id="cb942"
data-include="src/28-databases/hedis_pubsub.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb942-1"><a href="#cb942-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb942-2"><a href="#cb942-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb942-3"><a href="#cb942-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Database.Redis</span></span>
<span id="cb942-4"><a href="#cb942-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb942-5"><a href="#cb942-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb942-6"><a href="#cb942-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span></span>
<span id="cb942-7"><a href="#cb942-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Char8</span></span>
<span id="cb942-8"><a href="#cb942-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb942-9"><a href="#cb942-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb942-10"><a href="#cb942-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb942-11"><a href="#cb942-11" aria-hidden="true" tabindex="-1"></a><span class="ot">subscriber ::</span> <span class="dt">Redis</span> ()</span>
<span id="cb942-12"><a href="#cb942-12" aria-hidden="true" tabindex="-1"></a>subscriber <span class="ot">=</span></span>
<span id="cb942-13"><a href="#cb942-13" aria-hidden="true" tabindex="-1"></a> pubSub (subscribe [<span class="st">&quot;news&quot;</span>]) <span class="op">$</span> \msg <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb942-14"><a href="#cb942-14" aria-hidden="true" tabindex="-1"></a>   <span class="fu">print</span> msg</span>
<span id="cb942-15"><a href="#cb942-15" aria-hidden="true" tabindex="-1"></a>   <span class="fu">return</span> <span class="fu">mempty</span></span>
<span id="cb942-16"><a href="#cb942-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb942-17"><a href="#cb942-17" aria-hidden="true" tabindex="-1"></a><span class="ot">publisher ::</span> <span class="dt">Redis</span> ()</span>
<span id="cb942-18"><a href="#cb942-18" aria-hidden="true" tabindex="-1"></a>publisher <span class="ot">=</span> forM_ [<span class="dv">1</span><span class="op">..</span><span class="dv">100</span>] <span class="op">$</span> \n <span class="ot">-&gt;</span> publish <span class="st">&quot;news&quot;</span> (<span class="fu">pack</span> (<span class="fu">show</span> n))</span>
<span id="cb942-19"><a href="#cb942-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb942-20"><a href="#cb942-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- connects to localhost:6379</span></span>
<span id="cb942-21"><a href="#cb942-21" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb942-22"><a href="#cb942-22" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb942-23"><a href="#cb942-23" aria-hidden="true" tabindex="-1"></a>  conn1 <span class="ot">&lt;-</span> connect defaultConnectInfo</span>
<span id="cb942-24"><a href="#cb942-24" aria-hidden="true" tabindex="-1"></a>  conn2 <span class="ot">&lt;-</span> connect defaultConnectInfo</span>
<span id="cb942-25"><a href="#cb942-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb942-26"><a href="#cb942-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Fork off a publisher</span></span>
<span id="cb942-27"><a href="#cb942-27" aria-hidden="true" tabindex="-1"></a>  forkIO <span class="op">$</span> runRedis conn1 publisher</span>
<span id="cb942-28"><a href="#cb942-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb942-29"><a href="#cb942-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Subscribe for messages</span></span>
<span id="cb942-30"><a href="#cb942-30" aria-hidden="true" tabindex="-1"></a>  runRedis conn2 subscriber</span></code></pre></div>
<h2 id="acid-state">Acid State</h2>
<p>Acid-state allows us to build a “database” for around our existing
Haskell datatypes that guarantees atomic transactions. For example, we
can build a simple key-value store wrapped around the Map type.</p>
<div class="sourceCode" id="cb943"
data-include="src/28-databases/acid.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb943-1"><a href="#cb943-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb943-2"><a href="#cb943-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb943-3"><a href="#cb943-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb943-4"><a href="#cb943-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-5"><a href="#cb943-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Acid</span></span>
<span id="cb943-6"><a href="#cb943-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Typeable</span></span>
<span id="cb943-7"><a href="#cb943-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.SafeCopy</span></span>
<span id="cb943-8"><a href="#cb943-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Reader</span> (ask)</span>
<span id="cb943-9"><a href="#cb943-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-10"><a href="#cb943-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb943-11"><a href="#cb943-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Monad.State</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb943-12"><a href="#cb943-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-13"><a href="#cb943-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Key</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb943-14"><a href="#cb943-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Value</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb943-15"><a href="#cb943-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-16"><a href="#cb943-16" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Database</span> <span class="ot">=</span> <span class="dt">Database</span> <span class="op">!</span>(<span class="dt">Map.Map</span> <span class="dt">Key</span> <span class="dt">Value</span>)</span>
<span id="cb943-17"><a href="#cb943-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Ord</span>, <span class="dt">Eq</span>, <span class="dt">Typeable</span>)</span>
<span id="cb943-18"><a href="#cb943-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-19"><a href="#cb943-19" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(deriveSafeCopy <span class="dv">0</span> &#39;base &#39;<span class="dt">&#39;Database</span>)</span>
<span id="cb943-20"><a href="#cb943-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-21"><a href="#cb943-21" aria-hidden="true" tabindex="-1"></a><span class="ot">insertKey ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">Update</span> <span class="dt">Database</span> ()</span>
<span id="cb943-22"><a href="#cb943-22" aria-hidden="true" tabindex="-1"></a>insertKey key value</span>
<span id="cb943-23"><a href="#cb943-23" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> S.get</span>
<span id="cb943-24"><a href="#cb943-24" aria-hidden="true" tabindex="-1"></a>         S.put (<span class="dt">Database</span> (Map.insert key value m))</span>
<span id="cb943-25"><a href="#cb943-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-26"><a href="#cb943-26" aria-hidden="true" tabindex="-1"></a><span class="ot">lookupKey ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="dt">Database</span> (<span class="dt">Maybe</span> <span class="dt">Value</span>)</span>
<span id="cb943-27"><a href="#cb943-27" aria-hidden="true" tabindex="-1"></a>lookupKey key</span>
<span id="cb943-28"><a href="#cb943-28" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> ask</span>
<span id="cb943-29"><a href="#cb943-29" aria-hidden="true" tabindex="-1"></a>         <span class="fu">return</span> (Map.lookup key m)</span>
<span id="cb943-30"><a href="#cb943-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-31"><a href="#cb943-31" aria-hidden="true" tabindex="-1"></a><span class="ot">deleteKey ::</span> <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Update</span> <span class="dt">Database</span> ()</span>
<span id="cb943-32"><a href="#cb943-32" aria-hidden="true" tabindex="-1"></a>deleteKey key</span>
<span id="cb943-33"><a href="#cb943-33" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> S.get</span>
<span id="cb943-34"><a href="#cb943-34" aria-hidden="true" tabindex="-1"></a>         S.put (<span class="dt">Database</span> (Map.delete key m))</span>
<span id="cb943-35"><a href="#cb943-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-36"><a href="#cb943-36" aria-hidden="true" tabindex="-1"></a><span class="ot">allKeys ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> <span class="dt">Database</span> [(<span class="dt">Key</span>, <span class="dt">Value</span>)]</span>
<span id="cb943-37"><a href="#cb943-37" aria-hidden="true" tabindex="-1"></a>allKeys limit</span>
<span id="cb943-38"><a href="#cb943-38" aria-hidden="true" tabindex="-1"></a>    <span class="ot">=</span> <span class="kw">do</span> <span class="dt">Database</span> m <span class="ot">&lt;-</span> ask</span>
<span id="cb943-39"><a href="#cb943-39" aria-hidden="true" tabindex="-1"></a>         <span class="fu">return</span> <span class="op">$</span> <span class="fu">take</span> limit (Map.toList m)</span>
<span id="cb943-40"><a href="#cb943-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-41"><a href="#cb943-41" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(makeAcidic &#39;<span class="dt">&#39;Database</span> [&#39;insertKey, &#39;lookupKey, &#39;allKeys, &#39;deleteKey])</span>
<span id="cb943-42"><a href="#cb943-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-43"><a href="#cb943-43" aria-hidden="true" tabindex="-1"></a><span class="ot">fixtures ::</span> <span class="dt">Map.Map</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb943-44"><a href="#cb943-44" aria-hidden="true" tabindex="-1"></a>fixtures <span class="ot">=</span> Map.empty</span>
<span id="cb943-45"><a href="#cb943-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb943-46"><a href="#cb943-46" aria-hidden="true" tabindex="-1"></a><span class="ot">test ::</span>  <span class="dt">Key</span> <span class="ot">-&gt;</span> <span class="dt">Value</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb943-47"><a href="#cb943-47" aria-hidden="true" tabindex="-1"></a>test key val <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb943-48"><a href="#cb943-48" aria-hidden="true" tabindex="-1"></a>    database <span class="ot">&lt;-</span> openLocalStateFrom <span class="st">&quot;db/&quot;</span> (<span class="dt">Database</span> fixtures)</span>
<span id="cb943-49"><a href="#cb943-49" aria-hidden="true" tabindex="-1"></a>    result <span class="ot">&lt;-</span> update database (<span class="dt">InsertKey</span> key val)</span>
<span id="cb943-50"><a href="#cb943-50" aria-hidden="true" tabindex="-1"></a>    result <span class="ot">&lt;-</span> query database (<span class="dt">AllKeys</span> <span class="dv">10</span>)</span>
<span id="cb943-51"><a href="#cb943-51" aria-hidden="true" tabindex="-1"></a>    <span class="fu">print</span> result</span></code></pre></div>
<h2 id="selda">Selda</h2>
<p>Selda is a object relation mapper and database abstraction which
provides a higher level interface for creating database schemas for
multiple database backends, as well as a type-safe query interface which
makes use of advanced type system features to ensure integrity of
queries.</p>
<p>Selda is very unique in that it uses the
<code>OverloadedLabels</code> extension to query refer to database
fields that map directly to fields of records. By deriving
<code>Generic</code> and instantiating <code>SqlRow</code> via
<code>DeriveAnyClass</code> we can create databases schemas
automatically with generic deriving.</p>
<div class="sourceCode" id="cb944"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb944-1"><a href="#cb944-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Employee</span> <span class="ot">=</span> <span class="dt">Employee</span></span>
<span id="cb944-2"><a href="#cb944-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> id        ::</span> <span class="dt">ID</span> <span class="dt">Employee</span></span>
<span id="cb944-3"><a href="#cb944-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> name      ::</span> <span class="dt">Text</span></span>
<span id="cb944-4"><a href="#cb944-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> title     ::</span> <span class="dt">Text</span></span>
<span id="cb944-5"><a href="#cb944-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> companyId ::</span> <span class="dt">ID</span> <span class="dt">Company</span></span>
<span id="cb944-6"><a href="#cb944-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb944-7"><a href="#cb944-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">SqlRow</span>)</span>
<span id="cb944-8"><a href="#cb944-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb944-9"><a href="#cb944-9" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Company</span> <span class="ot">=</span> <span class="dt">Company</span></span>
<span id="cb944-10"><a href="#cb944-10" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> id ::</span> <span class="dt">ID</span> <span class="dt">Company</span></span>
<span id="cb944-11"><a href="#cb944-11" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> name ::</span> <span class="dt">Text</span></span>
<span id="cb944-12"><a href="#cb944-12" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb944-13"><a href="#cb944-13" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Generic</span>, <span class="dt">SqlRow</span>)</span>
<span id="cb944-14"><a href="#cb944-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb944-15"><a href="#cb944-15" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SqlRow</span> <span class="dt">Employee</span></span>
<span id="cb944-16"><a href="#cb944-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">SqlRow</span> <span class="dt">Company</span></span></code></pre></div>
<p>The tables themselves can be named, annotated with metadata about
constraints and foreign keys and assigned to a Haskell value.</p>
<div class="sourceCode" id="cb945"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb945-1"><a href="#cb945-1" aria-hidden="true" tabindex="-1"></a><span class="ot">employees ::</span> <span class="dt">Table</span> <span class="dt">Employee</span></span>
<span id="cb945-2"><a href="#cb945-2" aria-hidden="true" tabindex="-1"></a>employees <span class="ot">=</span> table <span class="st">&quot;employees&quot;</span> [<span class="op">#</span>id <span class="op">:-</span> autoPrimary, <span class="op">#</span>companyId <span class="op">:-</span> foreignKey companies <span class="op">#</span>id]</span>
<span id="cb945-3"><a href="#cb945-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb945-4"><a href="#cb945-4" aria-hidden="true" tabindex="-1"></a><span class="ot">companies ::</span> <span class="dt">Table</span> <span class="dt">Company</span></span>
<span id="cb945-5"><a href="#cb945-5" aria-hidden="true" tabindex="-1"></a>companies <span class="ot">=</span> table <span class="st">&quot;companies&quot;</span> [<span class="op">#</span>id <span class="op">:-</span> autoPrimary]</span></code></pre></div>
<p>This table can then be generated and populated.</p>
<div class="sourceCode" id="cb946"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb946-1"><a href="#cb946-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb946-2"><a href="#cb946-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> withSQLite <span class="st">&quot;company.sqlite&quot;</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb946-3"><a href="#cb946-3" aria-hidden="true" tabindex="-1"></a>  createTable employees</span>
<span id="cb946-4"><a href="#cb946-4" aria-hidden="true" tabindex="-1"></a>  createTable companies</span>
<span id="cb946-5"><a href="#cb946-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Populate companies</span></span>
<span id="cb946-6"><a href="#cb946-6" aria-hidden="true" tabindex="-1"></a>  insert_</span>
<span id="cb946-7"><a href="#cb946-7" aria-hidden="true" tabindex="-1"></a>    companies</span>
<span id="cb946-8"><a href="#cb946-8" aria-hidden="true" tabindex="-1"></a>    [<span class="dt">Company</span> (toId <span class="dv">0</span>) <span class="st">&quot;Dunder Mifflin Inc.&quot;</span>]</span>
<span id="cb946-9"><a href="#cb946-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Populate employees</span></span>
<span id="cb946-10"><a href="#cb946-10" aria-hidden="true" tabindex="-1"></a>  insert_</span>
<span id="cb946-11"><a href="#cb946-11" aria-hidden="true" tabindex="-1"></a>    employees</span>
<span id="cb946-12"><a href="#cb946-12" aria-hidden="true" tabindex="-1"></a>    [ <span class="dt">Employee</span> (toId <span class="dv">0</span>) <span class="st">&quot;Michael Scott&quot;</span> <span class="st">&quot;Director&quot;</span> (toId <span class="dv">0</span>),</span>
<span id="cb946-13"><a href="#cb946-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Employee</span> (toId <span class="dv">1</span>) <span class="st">&quot;Dwight Schrute&quot;</span> <span class="st">&quot;Regional Manager&quot;</span> (toId <span class="dv">0</span>)</span>
<span id="cb946-14"><a href="#cb946-14" aria-hidden="true" tabindex="-1"></a>    ]</span></code></pre></div>
<p>This will generate the following Sqlite DDL to instantiate the tables
directly from the types of the Haskell data strutures.</p>
<div class="sourceCode" id="cb947"><pre
class="sourceCode sql"><code class="sourceCode sql"><span id="cb947-1"><a href="#cb947-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> TABLEIF <span class="kw">NOT</span> <span class="kw">EXISTS</span> <span class="ot">&quot;companies&quot;</span> </span>
<span id="cb947-2"><a href="#cb947-2" aria-hidden="true" tabindex="-1"></a>( </span>
<span id="cb947-3"><a href="#cb947-3" aria-hidden="true" tabindex="-1"></a>   <span class="ot">&quot;id&quot;</span> <span class="dt">integer</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span> autoincrement <span class="kw">NOT</span> <span class="kw">NULL</span>, </span>
<span id="cb947-4"><a href="#cb947-4" aria-hidden="true" tabindex="-1"></a>   <span class="ot">&quot;name&quot;</span> text <span class="kw">NOT</span> <span class="kw">NULL</span> </span>
<span id="cb947-5"><a href="#cb947-5" aria-hidden="true" tabindex="-1"></a>);</span>
<span id="cb947-6"><a href="#cb947-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb947-7"><a href="#cb947-7" aria-hidden="true" tabindex="-1"></a><span class="kw">CREATE</span> TABLEIF <span class="kw">NOT</span> <span class="kw">EXISTS</span> <span class="ot">&quot;employees&quot;</span> </span>
<span id="cb947-8"><a href="#cb947-8" aria-hidden="true" tabindex="-1"></a>( </span>
<span id="cb947-9"><a href="#cb947-9" aria-hidden="true" tabindex="-1"></a>   <span class="ot">&quot;id&quot;</span> <span class="dt">integer</span> <span class="kw">PRIMARY</span> <span class="kw">KEY</span> autoincrement <span class="kw">NOT</span> <span class="kw">NULL</span>, </span>
<span id="cb947-10"><a href="#cb947-10" aria-hidden="true" tabindex="-1"></a>   <span class="ot">&quot;name&quot;</span> text <span class="kw">NOT</span> <span class="kw">NULL</span>, </span>
<span id="cb947-11"><a href="#cb947-11" aria-hidden="true" tabindex="-1"></a>   <span class="ot">&quot;title&quot;</span> text <span class="kw">NOT</span> <span class="kw">NULL</span>, </span>
<span id="cb947-12"><a href="#cb947-12" aria-hidden="true" tabindex="-1"></a>   <span class="ot">&quot;companyId&quot;</span> <span class="dt">integer</span> <span class="kw">NOT</span> <span class="kw">NULL</span>, </span>
<span id="cb947-13"><a href="#cb947-13" aria-hidden="true" tabindex="-1"></a>   <span class="kw">CONSTRAINT</span> <span class="ot">&quot;fk0_companyId&quot;</span> <span class="kw">FOREIGN</span> <span class="kw">KEY</span> (<span class="ot">&quot;companyId&quot;</span>) <span class="kw">REFERENCES</span> <span class="ot">&quot;companies&quot;</span>(<span class="ot">&quot;id&quot;</span> ) </span>
<span id="cb947-14"><a href="#cb947-14" aria-hidden="true" tabindex="-1"></a>);</span></code></pre></div>
<p>Selda also provides an embedded query language for specifying
type-safe queries by allowing you to add the overloaded labels to work
with these values directly as SQL selectors.</p>
<div class="sourceCode" id="cb948"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb948-1"><a href="#cb948-1" aria-hidden="true" tabindex="-1"></a><span class="ot">select ::</span> <span class="dt">Relational</span> a <span class="ot">=&gt;</span> <span class="dt">Table</span> a <span class="ot">-&gt;</span> <span class="dt">Query</span> s (<span class="dt">Row</span> s a)</span>
<span id="cb948-2"><a href="#cb948-2" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> (<span class="dt">MonadSelda</span> m, <span class="dt">Relational</span> a) <span class="ot">=&gt;</span> <span class="dt">Table</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m <span class="dt">Int</span></span>
<span id="cb948-3"><a href="#cb948-3" aria-hidden="true" tabindex="-1"></a><span class="ot">query ::</span> (<span class="dt">MonadSelda</span> m, <span class="dt">Result</span> a) <span class="ot">=&gt;</span> <span class="dt">Query</span> (<span class="dt">Backend</span> m) a <span class="ot">-&gt;</span> m [<span class="dt">Res</span> a]</span>
<span id="cb948-4"><a href="#cb948-4" aria-hidden="true" tabindex="-1"></a><span class="ot">from ::</span> (<span class="dt">Typeable</span> t, <span class="dt">SqlType</span> a) <span class="ot">=&gt;</span> <span class="dt">Selector</span> t a <span class="ot">-&gt;</span> <span class="dt">Query</span> s (<span class="dt">Row</span> s t) <span class="ot">-&gt;</span> <span class="dt">Query</span> s (<span class="dt">Col</span> s a)</span>
<span id="cb948-5"><a href="#cb948-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb948-6"><a href="#cb948-6" aria-hidden="true" tabindex="-1"></a><span class="ot">restrict ::</span> <span class="dt">Same</span> s t <span class="ot">=&gt;</span> <span class="dt">Col</span> s <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> t ()</span>
<span id="cb948-7"><a href="#cb948-7" aria-hidden="true" tabindex="-1"></a><span class="ot">order ::</span> (<span class="dt">Same</span> s t, <span class="dt">SqlType</span> a) <span class="ot">=&gt;</span> <span class="dt">Col</span> s a <span class="ot">-&gt;</span> <span class="dt">Order</span> <span class="ot">-&gt;</span> <span class="dt">Query</span> t ()</span></code></pre></div>
<p>An example <code>SELECT</code> SQL query:</p>
<div class="sourceCode" id="cb949"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb949-1"><a href="#cb949-1" aria-hidden="true" tabindex="-1"></a><span class="ot">exampleSelect ::</span> <span class="dt">IO</span> ([<span class="dt">Employee</span>], [<span class="dt">Company</span>])</span>
<span id="cb949-2"><a href="#cb949-2" aria-hidden="true" tabindex="-1"></a>exampleSelect <span class="ot">=</span> withSQLite <span class="st">&quot;company.sqlite&quot;</span> <span class="op">$</span></span>
<span id="cb949-3"><a href="#cb949-3" aria-hidden="true" tabindex="-1"></a>  query <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb949-4"><a href="#cb949-4" aria-hidden="true" tabindex="-1"></a>      employee <span class="ot">&lt;-</span> select employees</span>
<span id="cb949-5"><a href="#cb949-5" aria-hidden="true" tabindex="-1"></a>      restrict (employee <span class="op">!</span> <span class="op">#</span>id <span class="op">.&gt;=</span> <span class="dv">1</span>)</span></code></pre></div>
<hr/>
<h1 id="ghc-1">GHC</h1>
<h2 id="compiler-design">Compiler Design</h2>
<p>The flow of code through GHC is a process of translation between
several intermediate languages and optimizations and transformations
thereof. A common pattern for many of these AST types is they are
parametrized over a binder type and at various stages the binders will
be transformed, for example the Renamer pass effectively translates the
<code>HsSyn</code> datatype from a AST parametrized over literal strings
as the user enters into a <code>HsSyn</code> parameterized over
qualified names that includes modules and package names into a higher
level Name type.</p>
<h5 id="ghc-compiler-passes">GHC Compiler Passes</h5>
<ul>
<li><strong>Parser/Frontend</strong>: An enormous AST translated from
human syntax that makes explicit all possible expressible syntax (
declarations, do-notation, where clauses, syntax extensions, template
haskell, … ). This is unfiltered Haskell and it is
<em>enormous</em>.</li>
<li><strong>Renamer</strong> takes syntax from the frontend and
transforms all names to be qualified (<code>base:Prelude.map</code>
instead of <code>map</code>) and any shadowed names in lambda binders
transformed into unique names.</li>
<li><strong>Typechecker</strong> is a large pass that serves two
purposes, first is the core type bidirectional inference engine where
most of the work happens and the translation between the frontend
<code>Core</code> syntax.</li>
<li><strong>Desugarer</strong> translates several higher level syntactic
constructors
<ul>
<li><code>where</code> statements are turned into (possibly recursive)
nested <code>let</code> statements.</li>
<li>Nested pattern matches are expanded out into splitting trees of case
statements.</li>
<li>do-notation is expanded into explicit bind statements.</li>
<li>Lots of others.</li>
</ul></li>
<li><strong>Simplifier</strong> transforms many Core constructs into
forms that are more adaptable to compilation. For example let statements
will be floated or raised, pattern matches will simplified, inner loops
will be pulled out and transformed into more optimal forms.
Non-intuitively the resulting may actually be much more complex (for
humans) after going through the simplifier!</li>
<li><strong>Stg</strong> pass translates the resulting Core into STG
(Spineless Tagless G-Machine) which effectively makes all laziness
explicit and encodes the thunks and update frames that will be handled
during evaluation.</li>
<li><strong>Codegen/Cmm</strong> pass will then translate STG into Cmm a
simple imperative language that manifests the low-level implementation
details of runtime types. The runtime closure types and stack frames are
made explicit and low-level information about the data and code (arity,
updatability, free variables, pointer layout) made manifest in the info
tables present on most constructs.</li>
<li><strong>Native Code</strong> The final pass will than translate the
resulting code into either LLVM or Assembly via either through GHC’s
home built native code generator (NCG) or the LLVM backend.</li>
</ul>
<p>Information for each pass can be dumped out via a rather large
collection of flags. The GHC internals are very accessible although some
passes are somewhat easier to understand than others. Most of the time
<code>-ddump-simpl</code> and <code>-ddump-stg</code> are sufficient to
get an understanding of how the code will compile, unless of course
you’re dealing with very specialized optimizations or hacking on GHC
itself.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Flag</th>
<th style="text-align: left;">Action</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>-ddump-parsed</code></td>
<td style="text-align: left;">Frontend AST.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-ddump-rn</code></td>
<td style="text-align: left;">Output of the rename pass.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-ddump-tc</code></td>
<td style="text-align: left;">Output of the typechecker.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-ddump-splices</code></td>
<td style="text-align: left;">Output of TemplateHaskell splices.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-ddump-types</code></td>
<td style="text-align: left;">Typed AST representation.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-ddump-deriv</code></td>
<td style="text-align: left;">Output of deriving instances.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-ddump-ds</code></td>
<td style="text-align: left;">Output of the desugar pass.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-ddump-spec</code></td>
<td style="text-align: left;">Output of specialisation pass.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-ddump-rules</code></td>
<td style="text-align: left;">Output of applying rewrite rules.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-ddump-vect</code></td>
<td style="text-align: left;">Output results of vectorize pass.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-ddump-simpl</code></td>
<td style="text-align: left;">Output of the SimplCore pass.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-ddump-inlinings</code></td>
<td style="text-align: left;">Output of the inliner.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-ddump-cse</code></td>
<td style="text-align: left;">Output of the common subexpression
elimination pass.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-ddump-prep</code></td>
<td style="text-align: left;">The CorePrep pass.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-ddump-stg</code></td>
<td style="text-align: left;">The resulting STG.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-ddump-cmm</code></td>
<td style="text-align: left;">The resulting Cmm.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-ddump-opt-cmm</code></td>
<td style="text-align: left;">The resulting Cmm optimization pass.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-ddump-asm</code></td>
<td style="text-align: left;">The final assembly generated.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-ddump-llvm</code></td>
<td style="text-align: left;">The final LLVM IR generated.</td>
</tr>
</tbody>
</table>
<h2 id="ghc-api">GHC API</h2>
<p>GHC can be used as a library to manipulate and transform Haskell
source code into executable code. It consists of many functions, the
primary drivers in the pipeline are outlined below.</p>
<div class="sourceCode" id="cb950"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb950-1"><a href="#cb950-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Parse a module.</span></span>
<span id="cb950-2"><a href="#cb950-2" aria-hidden="true" tabindex="-1"></a><span class="ot">parseModule ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> <span class="dt">ModSummary</span> <span class="ot">-&gt;</span> m <span class="dt">ParsedModule</span></span>
<span id="cb950-3"><a href="#cb950-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb950-4"><a href="#cb950-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Typecheck and rename a parsed module.</span></span>
<span id="cb950-5"><a href="#cb950-5" aria-hidden="true" tabindex="-1"></a><span class="ot">typecheckModule ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> <span class="dt">ParsedModule</span> <span class="ot">-&gt;</span> m <span class="dt">TypecheckedModule</span></span>
<span id="cb950-6"><a href="#cb950-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb950-7"><a href="#cb950-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Desugar a typechecked module.</span></span>
<span id="cb950-8"><a href="#cb950-8" aria-hidden="true" tabindex="-1"></a><span class="ot">desugarModule ::</span> <span class="dt">GhcMonad</span> m <span class="ot">=&gt;</span> <span class="dt">TypecheckedModule</span> <span class="ot">-&gt;</span> m <span class="dt">DesugaredModule</span></span>
<span id="cb950-9"><a href="#cb950-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb950-10"><a href="#cb950-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- Generated ModIface and Generated Code</span></span>
<span id="cb950-11"><a href="#cb950-11" aria-hidden="true" tabindex="-1"></a><span class="ot">loadModule ::</span> (<span class="dt">TypecheckedMod</span> <span class="fu">mod</span>, <span class="dt">GhcMonad</span> m) <span class="ot">=&gt;</span> <span class="fu">mod</span> <span class="ot">-&gt;</span> m <span class="fu">mod</span></span></code></pre></div>
<p>The output of these functions consists of four main data
structures:</p>
<ul>
<li>ParsedModule</li>
<li>TypecheckedModule</li>
<li>DesugaredModule</li>
<li>CoreModule</li>
</ul>
<p>GHC itself can be used as a library just as any other library. The
example below compiles a simple source module “B” that contains no
code.</p>
<div class="sourceCode" id="cb951"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb951-1"><a href="#cb951-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC</span></span>
<span id="cb951-2"><a href="#cb951-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Paths</span> (libdir)</span>
<span id="cb951-3"><a href="#cb951-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">DynFlags</span></span>
<span id="cb951-4"><a href="#cb951-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb951-5"><a href="#cb951-5" aria-hidden="true" tabindex="-1"></a><span class="ot">targetFile ::</span> <span class="dt">FilePath</span></span>
<span id="cb951-6"><a href="#cb951-6" aria-hidden="true" tabindex="-1"></a>targetFile <span class="ot">=</span> <span class="st">&quot;B.hs&quot;</span></span>
<span id="cb951-7"><a href="#cb951-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb951-8"><a href="#cb951-8" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">IO</span> ()</span>
<span id="cb951-9"><a href="#cb951-9" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span></span>
<span id="cb951-10"><a href="#cb951-10" aria-hidden="true" tabindex="-1"></a>  defaultErrorHandler defaultFatalMessager defaultFlushOut <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb951-11"><a href="#cb951-11" aria-hidden="true" tabindex="-1"></a>    runGhc (<span class="dt">Just</span> libdir) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb951-12"><a href="#cb951-12" aria-hidden="true" tabindex="-1"></a>      dflags <span class="ot">&lt;-</span> getSessionDynFlags</span>
<span id="cb951-13"><a href="#cb951-13" aria-hidden="true" tabindex="-1"></a>      setSessionDynFlags dflags</span>
<span id="cb951-14"><a href="#cb951-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb951-15"><a href="#cb951-15" aria-hidden="true" tabindex="-1"></a>      target <span class="ot">&lt;-</span> guessTarget targetFile <span class="dt">Nothing</span></span>
<span id="cb951-16"><a href="#cb951-16" aria-hidden="true" tabindex="-1"></a>      setTargets [target]</span>
<span id="cb951-17"><a href="#cb951-17" aria-hidden="true" tabindex="-1"></a>      load <span class="dt">LoadAllTargets</span></span>
<span id="cb951-18"><a href="#cb951-18" aria-hidden="true" tabindex="-1"></a>      modSum <span class="ot">&lt;-</span> getModSummary <span class="op">$</span> mkModuleName <span class="st">&quot;B&quot;</span></span>
<span id="cb951-19"><a href="#cb951-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb951-20"><a href="#cb951-20" aria-hidden="true" tabindex="-1"></a>      p <span class="ot">&lt;-</span> parseModule modSum      <span class="co">-- ModuleSummary</span></span>
<span id="cb951-21"><a href="#cb951-21" aria-hidden="true" tabindex="-1"></a>      t <span class="ot">&lt;-</span> typecheckModule p       <span class="co">-- TypecheckedSource</span></span>
<span id="cb951-22"><a href="#cb951-22" aria-hidden="true" tabindex="-1"></a>      d <span class="ot">&lt;-</span> desugarModule t         <span class="co">-- DesugaredModule</span></span>
<span id="cb951-23"><a href="#cb951-23" aria-hidden="true" tabindex="-1"></a>      l <span class="ot">&lt;-</span> loadModule d</span>
<span id="cb951-24"><a href="#cb951-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> c <span class="ot">=</span> coreModule d         <span class="co">-- CoreModule</span></span>
<span id="cb951-25"><a href="#cb951-25" aria-hidden="true" tabindex="-1"></a>      g <span class="ot">&lt;-</span> getModuleGraph</span>
<span id="cb951-26"><a href="#cb951-26" aria-hidden="true" tabindex="-1"></a>      <span class="fu">mapM</span> showModule g</span>
<span id="cb951-27"><a href="#cb951-27" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> c</span>
<span id="cb951-28"><a href="#cb951-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb951-29"><a href="#cb951-29" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb951-30"><a href="#cb951-30" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb951-31"><a href="#cb951-31" aria-hidden="true" tabindex="-1"></a>   res <span class="ot">&lt;-</span> example</span>
<span id="cb951-32"><a href="#cb951-32" aria-hidden="true" tabindex="-1"></a>   <span class="fu">putStrLn</span> <span class="op">$</span> showSDoc ( ppr res )</span></code></pre></div>
<h2 id="dynflags">DynFlags</h2>
<p>The internal compiler state of GHC is largely driven from a set of
many configuration flags known as DynFlags. These flags are largely
divided into four categories:</p>
<ul>
<li>Dump Flags</li>
<li>Warning Flags</li>
<li>Extension Flags</li>
<li>General Flags</li>
</ul>
<p>These are flags are set via the following modifier functions:</p>
<div class="sourceCode" id="cb952"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb952-1"><a href="#cb952-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dopt_set ::</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">DumpFlag</span> <span class="ot">-&gt;</span> <span class="dt">DynFlags</span></span>
<span id="cb952-2"><a href="#cb952-2" aria-hidden="true" tabindex="-1"></a><span class="ot">wopt_set ::</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">WarningFlag</span> <span class="ot">-&gt;</span> <span class="dt">DynFlags</span></span>
<span id="cb952-3"><a href="#cb952-3" aria-hidden="true" tabindex="-1"></a><span class="ot">xopt_set ::</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">Extension</span> <span class="ot">-&gt;</span> <span class="dt">DynFlags</span></span>
<span id="cb952-4"><a href="#cb952-4" aria-hidden="true" tabindex="-1"></a><span class="ot">gopt_set ::</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">GeneralFlag</span> <span class="ot">-&gt;</span> <span class="dt">DynFlags</span></span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="https://hackage.haskell.org/package/ghc-8.6.5/docs/DynFlags.html">DynFlags</a></li>
</ul>
<h2 id="package-databases">Package Databases</h2>
<p>A package is a library of Haskell modules known to the compiler.
Compilation of a Haskell module through Cabal uses a directory structure
known as a package database. This directory is named
<code>package.conf.d</code>, and contains a file for each package used
for compiling a module and is combined with a binary cache of package’s
cabal data in <code>package.cache</code>.</p>
<p>When Cabal operates it stores the active package database in the
environment variable: <code>GHC_PACKAGE_PATH</code></p>
<p>To see which packages are currently available, use the ghc-pkg list
command:</p>
<div class="sourceCode" id="cb953"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb953-1"><a href="#cb953-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc-pkg list</span>
<span id="cb953-2"><a href="#cb953-2" aria-hidden="true" tabindex="-1"></a><span class="ex">/home/sdiehl/.ghcup/ghc/8.6.5/lib/ghc-8.6.5/package.conf.d</span></span>
<span id="cb953-3"><a href="#cb953-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">Cabal-2.4.0.1</span></span>
<span id="cb953-4"><a href="#cb953-4" aria-hidden="true" tabindex="-1"></a>    <span class="ex">array-0.5.3.0</span></span>
<span id="cb953-5"><a href="#cb953-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">base-4.12.0.0</span></span>
<span id="cb953-6"><a href="#cb953-6" aria-hidden="true" tabindex="-1"></a>    <span class="ex">binary-0.8.6.0</span></span>
<span id="cb953-7"><a href="#cb953-7" aria-hidden="true" tabindex="-1"></a>    <span class="ex">bytestring-0.10.8.2</span></span>
<span id="cb953-8"><a href="#cb953-8" aria-hidden="true" tabindex="-1"></a>    <span class="ex">containers-0.6.0.1</span></span>
<span id="cb953-9"><a href="#cb953-9" aria-hidden="true" tabindex="-1"></a>    <span class="ex">deepseq-1.4.4.0</span></span>
<span id="cb953-10"><a href="#cb953-10" aria-hidden="true" tabindex="-1"></a>    <span class="ex">directory-1.3.3.0</span></span>
<span id="cb953-11"><a href="#cb953-11" aria-hidden="true" tabindex="-1"></a>    <span class="ex">filepath-1.4.2.1</span></span>
<span id="cb953-12"><a href="#cb953-12" aria-hidden="true" tabindex="-1"></a>    <span class="ex">ghc-8.6.5</span></span>
<span id="cb953-13"><a href="#cb953-13" aria-hidden="true" tabindex="-1"></a>    <span class="ex">ghc-boot-8.6.5</span></span>
<span id="cb953-14"><a href="#cb953-14" aria-hidden="true" tabindex="-1"></a>    <span class="ex">ghc-boot-th-8.6.5</span></span>
<span id="cb953-15"><a href="#cb953-15" aria-hidden="true" tabindex="-1"></a>    <span class="ex">ghc-compact-0.1.0.0</span></span>
<span id="cb953-16"><a href="#cb953-16" aria-hidden="true" tabindex="-1"></a>    <span class="ex">ghc-heap-8.6.5</span></span>
<span id="cb953-17"><a href="#cb953-17" aria-hidden="true" tabindex="-1"></a>    <span class="ex">ghc-prim-0.5.3</span></span>
<span id="cb953-18"><a href="#cb953-18" aria-hidden="true" tabindex="-1"></a>    <span class="ex">ghci-8.6.5</span></span>
<span id="cb953-19"><a href="#cb953-19" aria-hidden="true" tabindex="-1"></a>    <span class="ex">haskeline-0.7.4.3</span></span>
<span id="cb953-20"><a href="#cb953-20" aria-hidden="true" tabindex="-1"></a>    <span class="ex">hpc-0.6.0.3</span></span>
<span id="cb953-21"><a href="#cb953-21" aria-hidden="true" tabindex="-1"></a>    <span class="ex">integer-gmp-1.0.2.0</span></span>
<span id="cb953-22"><a href="#cb953-22" aria-hidden="true" tabindex="-1"></a>    <span class="ex">libiserv-8.6.3</span></span>
<span id="cb953-23"><a href="#cb953-23" aria-hidden="true" tabindex="-1"></a>    <span class="ex">mtl-2.2.2</span></span>
<span id="cb953-24"><a href="#cb953-24" aria-hidden="true" tabindex="-1"></a>    <span class="ex">parsec-3.1.13.0</span></span>
<span id="cb953-25"><a href="#cb953-25" aria-hidden="true" tabindex="-1"></a>    <span class="ex">pretty-1.1.3.6</span></span>
<span id="cb953-26"><a href="#cb953-26" aria-hidden="true" tabindex="-1"></a>    <span class="ex">process-1.6.5.0</span></span>
<span id="cb953-27"><a href="#cb953-27" aria-hidden="true" tabindex="-1"></a>    <span class="ex">rts-1.0</span></span>
<span id="cb953-28"><a href="#cb953-28" aria-hidden="true" tabindex="-1"></a>    <span class="ex">stm-2.5.0.0</span></span>
<span id="cb953-29"><a href="#cb953-29" aria-hidden="true" tabindex="-1"></a>    <span class="ex">template-haskell-2.14.0.0</span></span>
<span id="cb953-30"><a href="#cb953-30" aria-hidden="true" tabindex="-1"></a>    <span class="ex">terminfo-0.4.1.2</span></span>
<span id="cb953-31"><a href="#cb953-31" aria-hidden="true" tabindex="-1"></a>    <span class="ex">text-1.2.3.1</span></span>
<span id="cb953-32"><a href="#cb953-32" aria-hidden="true" tabindex="-1"></a>    <span class="ex">time-1.8.0.2</span></span>
<span id="cb953-33"><a href="#cb953-33" aria-hidden="true" tabindex="-1"></a>    <span class="ex">transformers-0.5.6.2</span></span>
<span id="cb953-34"><a href="#cb953-34" aria-hidden="true" tabindex="-1"></a>    <span class="ex">unix-2.7.2.2</span></span>
<span id="cb953-35"><a href="#cb953-35" aria-hidden="true" tabindex="-1"></a>    <span class="ex">xhtml-3000.2.2.1</span></span></code></pre></div>
<p>The package database can be queried for specific metadata of the
cabal files associated with each package. For example to query the
version of base library currently used for compilation we can query from
the <code>ghc-pkg</code> command:</p>
<div class="sourceCode" id="cb954"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb954-1"><a href="#cb954-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc-pkg field base version</span>
<span id="cb954-2"><a href="#cb954-2" aria-hidden="true" tabindex="-1"></a><span class="ex">version:</span> 4.12.0.0</span>
<span id="cb954-3"><a href="#cb954-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb954-4"><a href="#cb954-4" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc-pkg field rts license</span>
<span id="cb954-5"><a href="#cb954-5" aria-hidden="true" tabindex="-1"></a><span class="ex">license:</span> BSD-3-Clause</span>
<span id="cb954-6"><a href="#cb954-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb954-7"><a href="#cb954-7" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc-pkg field haskeline exposed-modules</span>
<span id="cb954-8"><a href="#cb954-8" aria-hidden="true" tabindex="-1"></a><span class="ex">exposed-modules:</span></span>
<span id="cb954-9"><a href="#cb954-9" aria-hidden="true" tabindex="-1"></a>    <span class="ex">System.Console.Haskeline</span> System.Console.Haskeline.Completion</span>
<span id="cb954-10"><a href="#cb954-10" aria-hidden="true" tabindex="-1"></a>    <span class="ex">System.Console.Haskeline.History</span> System.Console.Haskeline.IO</span>
<span id="cb954-11"><a href="#cb954-11" aria-hidden="true" tabindex="-1"></a>    <span class="ex">System.Console.Haskeline.MonadException</span></span></code></pre></div>
<h2 id="hie-bios">HIE Bios</h2>
<p>A session is fully specified by a set GHC dynflags that are needed to
compile a module. Typically when the compiler is invoked by Cabal these
are all generated during compilation time. These flags contain the
entire transitive dependency graph of the module, the language
extensions and the file system locations of all paths. Given the
bifucation of many of these tools setting up the GHC environment from
inside of libraries has been non-trivial in the past. HIE-bios is a new
library which can read package metadata from Cabal and Stack files and
dynamically set up the appropriate session for a project.</p>
<p>Hie-bios will read a Cradle file (<code>hie.yaml</code>) file in the
root of the workspace which describes how to setup the environment. For
example for using Stack this file would contain:</p>
<div class="sourceCode" id="cb955"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb955-1"><a href="#cb955-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cradle</span><span class="kw">:</span><span class="at"> </span><span class="kw">{</span><span class="fu">stack</span><span class="kw">:</span><span class="at"> </span><span class="kw">{</span><span class="fu">component</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;myproject:lib&quot;</span><span class="at"> </span><span class="kw">}}</span></span></code></pre></div>
<p>While using Cabal the file would contain:</p>
<div class="sourceCode" id="cb956"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb956-1"><a href="#cb956-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cradle</span><span class="kw">:</span><span class="at"> </span><span class="kw">{</span><span class="fu">cabal</span><span class="kw">:</span><span class="at"> </span><span class="kw">{</span><span class="fu">component</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;myproject:lib&quot;</span><span class="at"> </span><span class="kw">}}</span></span></code></pre></div>
<p>This is particularly useful for projects that require access to the
internal compiler artifacts or do static analysis on top of Haskell
code. An example of setting a compiler session from a cradle is shown
below:</p>
<div class="sourceCode" id="cb957" data-include="src/29-ghc/hie.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb957-1"><a href="#cb957-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span></span>
<span id="cb957-2"><a href="#cb957-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">DynFlags</span></span>
<span id="cb957-3"><a href="#cb957-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC</span></span>
<span id="cb957-4"><a href="#cb957-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.LanguageExtensions.Type</span></span>
<span id="cb957-5"><a href="#cb957-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Paths</span></span>
<span id="cb957-6"><a href="#cb957-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GhcMonad</span></span>
<span id="cb957-7"><a href="#cb957-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">HIE.Bios</span></span>
<span id="cb957-8"><a href="#cb957-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">InteractiveEval</span></span>
<span id="cb957-9"><a href="#cb957-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Outputable</span></span>
<span id="cb957-10"><a href="#cb957-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb957-11"><a href="#cb957-11" aria-hidden="true" tabindex="-1"></a><span class="ot">example ::</span> <span class="dt">Ghc</span> ()</span>
<span id="cb957-12"><a href="#cb957-12" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb957-13"><a href="#cb957-13" aria-hidden="true" tabindex="-1"></a>  cradle <span class="ot">&lt;-</span> liftIO (loadImplicitCradle <span class="st">&quot;.&quot;</span>)</span>
<span id="cb957-14"><a href="#cb957-14" aria-hidden="true" tabindex="-1"></a>  comp <span class="ot">&lt;-</span> liftIO <span class="op">$</span> getCompilerOptions <span class="st">&quot;.&quot;</span> cradle</span>
<span id="cb957-15"><a href="#cb957-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> comp <span class="kw">of</span></span>
<span id="cb957-16"><a href="#cb957-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">CradleSuccess</span> r <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb957-17"><a href="#cb957-17" aria-hidden="true" tabindex="-1"></a>      liftIO (<span class="fu">print</span> <span class="st">&quot;Success&quot;</span>)</span>
<span id="cb957-18"><a href="#cb957-18" aria-hidden="true" tabindex="-1"></a>      session <span class="ot">&lt;-</span> initSession r</span>
<span id="cb957-19"><a href="#cb957-19" aria-hidden="true" tabindex="-1"></a>      dflags <span class="ot">&lt;-</span> getSessionDynFlags</span>
<span id="cb957-20"><a href="#cb957-20" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> dflags&#39; <span class="ot">=</span> <span class="fu">foldl</span> xopt_set dflags [<span class="dt">ImplicitPrelude</span>]</span>
<span id="cb957-21"><a href="#cb957-21" aria-hidden="true" tabindex="-1"></a>      setSessionDynFlags</span>
<span id="cb957-22"><a href="#cb957-22" aria-hidden="true" tabindex="-1"></a>        dflags&#39;</span>
<span id="cb957-23"><a href="#cb957-23" aria-hidden="true" tabindex="-1"></a>          { hscTarget <span class="ot">=</span> <span class="dt">HscInterpreted</span>,</span>
<span id="cb957-24"><a href="#cb957-24" aria-hidden="true" tabindex="-1"></a>            ghcLink <span class="ot">=</span> <span class="dt">LinkInMemory</span>,</span>
<span id="cb957-25"><a href="#cb957-25" aria-hidden="true" tabindex="-1"></a>            ghcMode <span class="ot">=</span> <span class="dt">CompManager</span></span>
<span id="cb957-26"><a href="#cb957-26" aria-hidden="true" tabindex="-1"></a>          }</span>
<span id="cb957-27"><a href="#cb957-27" aria-hidden="true" tabindex="-1"></a>      liftIO (<span class="fu">putStrLn</span> (showSDoc dflags (ppr session)))</span>
<span id="cb957-28"><a href="#cb957-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">CradleFail</span> err <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="fu">print</span> err</span>
<span id="cb957-29"><a href="#cb957-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">CradleNone</span> <span class="ot">-&gt;</span> liftIO <span class="op">$</span> <span class="fu">print</span> <span class="st">&quot;No cradle&quot;</span></span>
<span id="cb957-30"><a href="#cb957-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pure</span> ()</span>
<span id="cb957-31"><a href="#cb957-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb957-32"><a href="#cb957-32" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb957-33"><a href="#cb957-33" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> runGhc (<span class="dt">Just</span> GHC.Paths.libdir) example</span></code></pre></div>
<h2 id="abstract-syntax-tree">Abstract Syntax Tree</h2>
<p>GHC uses several syntax trees during its compilation. These are
defined in the following modules:</p>
<ul>
<li><code>HsExpr</code> - Syntax tree for the frontend of GHC
compiler.</li>
<li><code>StgSyn</code> - Syntax tree of STG intermediate
representation</li>
<li><code>Cmm</code> - Syntax tree for the CMM intermediate
representation</li>
</ul>
<p>GHC’s frontend source tree are grouped into datatypes for the
following language constructs and use the naming convention:</p>
<ul>
<li><code>Binds</code> - Declarations of functions. For example the body
of a class declaration or class instance.</li>
<li><code>Decl</code> - Declarations of datatypes, types, newtypes,
etc.</li>
<li><code>Expr</code> - Expressions. For example, let statements,
lambdas, if-blocks, do-blocks, etc.</li>
<li><code>Lit</code> - Literals. For example, integers, characters,
strings, etc.</li>
<li><code>Module</code> - Modules including import declarations, exports
and pragmas.</li>
<li><code>Name</code> - Names that occur in other constructs. Such as
modules names, constructors and variables.</li>
<li><code>Pat</code> - Patterns that occur in case statements and
binders.</li>
<li><code>Type</code> - Type syntax that occurs in toplevel signatures
and explicit annotations.</li>
</ul>
<p>Generally all AST in the frontend of the compiler is annotated with
position information that is kept around to give better error reporting
about the provenance of the specific problematic set of the syntax tree.
This is done through a datatype <code>GenLocated</code> with attaches
the position information <code>l</code> to element <code>e</code>.</p>
<div class="sourceCode" id="cb958"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb958-1"><a href="#cb958-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">GenLocated</span> l e <span class="ot">=</span> <span class="dt">L</span> l e</span>
<span id="cb958-2"><a href="#cb958-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Data</span>, <span class="dt">Functor</span>, <span class="dt">Foldable</span>, <span class="dt">Traversable</span>)</span>
<span id="cb958-3"><a href="#cb958-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb958-4"><a href="#cb958-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Located</span> <span class="ot">=</span> <span class="dt">GenLocated</span> <span class="dt">SrcSpan</span></span></code></pre></div>
<p>For example, the type of located source expressions is defined by the
type:</p>
<div class="sourceCode" id="cb959"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb959-1"><a href="#cb959-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LHsExpr</span> p <span class="ot">=</span> <span class="dt">Located</span> (<span class="dt">HsExpr</span> p)</span>
<span id="cb959-2"><a href="#cb959-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">HsExpr</span> p</span>
<span id="cb959-3"><a href="#cb959-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">HsVar</span> (<span class="dt">XVar</span> p) (<span class="dt">Located</span> (<span class="dt">IdP</span> p))    </span>
<span id="cb959-4"><a href="#cb959-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">HsLam</span> (<span class="dt">XLam</span> p) (<span class="dt">MatchGroup</span> p (<span class="dt">LHsExpr</span> p))   </span>
<span id="cb959-5"><a href="#cb959-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">HsApp</span> (<span class="dt">XApp</span> p) (<span class="dt">LHsExpr</span> p) (<span class="dt">LHsExpr</span> p)      </span>
<span id="cb959-6"><a href="#cb959-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">...</span></span></code></pre></div>
<p>The <code>HsSyn</code> AST is reused across multiple compiler
passes.</p>
<div class="sourceCode" id="cb960"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb960-1"><a href="#cb960-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">GhcPass</span> (<span class="ot">c ::</span> <span class="dt">Pass</span>)</span>
<span id="cb960-2"><a href="#cb960-2" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Pass</span> <span class="ot">=</span> <span class="dt">Parsed</span> <span class="op">|</span> <span class="dt">Renamed</span> <span class="op">|</span> <span class="dt">Typechecked</span></span>
<span id="cb960-3"><a href="#cb960-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb960-4"><a href="#cb960-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">GhcPs</span> <span class="ot">=</span> <span class="dt">GhcPass</span> <span class="dt">&#39;Parsed</span></span>
<span id="cb960-5"><a href="#cb960-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">GhcRn</span> <span class="ot">=</span> <span class="dt">GhcPass</span> <span class="dt">&#39;Renamed</span></span>
<span id="cb960-6"><a href="#cb960-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">GhcTc</span> <span class="ot">=</span> <span class="dt">GhcPass</span> <span class="dt">&#39;Typechecked</span></span></code></pre></div>
<div class="sourceCode" id="cb961"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb961-1"><a href="#cb961-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">IdP</span> p</span>
<span id="cb961-2"><a href="#cb961-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">IdP</span> <span class="dt">GhcPs</span> <span class="ot">=</span> <span class="dt">RdrName</span></span>
<span id="cb961-3"><a href="#cb961-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">IdP</span> <span class="dt">GhcRn</span> <span class="ot">=</span> <span class="dt">Name</span></span>
<span id="cb961-4"><a href="#cb961-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">IdP</span> <span class="dt">GhcTc</span> <span class="ot">=</span> <span class="dt">Id</span></span>
<span id="cb961-5"><a href="#cb961-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb961-6"><a href="#cb961-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LIdP</span> p <span class="ot">=</span> <span class="dt">Located</span> (<span class="dt">IdP</span> p)</span></code></pre></div>
<p>Individual elements of the syntax are defined by type families which
a single parameter for the pass.</p>
<div class="sourceCode" id="cb962"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb962-1"><a href="#cb962-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XVar</span> x</span>
<span id="cb962-2"><a href="#cb962-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XLam</span> x</span>
<span id="cb962-3"><a href="#cb962-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">XApp</span> x</span></code></pre></div>
<p>The type of <code>HsExpr</code> used in the <em>parser pass</em> can
then be defined simply as <code>LHsExpr GhcPs</code> and from the
<em>typechecker pass</em> <code>LHsExpr GhcTc</code>.</p>
<p><strong>Names</strong></p>
<p>GHC has an interesting zoo of names it uses internally for
identifiers in the syntax tree. There are more than the following but
these are the primary ones you will see most often:</p>
<ul>
<li><code>RdrName</code> - Names that come directly from the parser
without metadata.</li>
<li><code>OccName</code> - Names with metadata about the namespace the
variable is in.</li>
<li><code>Name</code> - A unique name introduced during the renamer pass
with metadata about its provenance.</li>
<li><code>Var</code> - A typed variable name with metadata about its use
sites.</li>
<li><code>Id</code> - A term-level identifier. Type Synonym for
Var.</li>
<li><code>TyVar</code> - A type-level identifier. Type Synonym for
Var.</li>
<li><code>TcTyVar</code> - A type variable used in the typechecker. Type
Synonym for Var.</li>
</ul>
<p>See: <a
href="https://ghc.haskell.org/trac/ghc/wiki/ImplementingTreesThatGrow">Trees
That Grow</a></p>
<h2 id="parser-1">Parser</h2>
<p>The GHC parser is itself written in Happy. It defines its Parser
monad as the following definition which emits a sequences of
<code>Located</code> tokens with the lexemes position information. The
parser is embedded inside the <code>P</code> monad.</p>
<div class="sourceCode" id="cb963"><pre
class="sourceCode yacc"><code class="sourceCode yacc"><span id="cb963-1"><a href="#cb963-1" aria-hidden="true" tabindex="-1"></a><span class="kw">%monad</span> { P } { &gt;&gt;= } { return }</span>
<span id="cb963-2"><a href="#cb963-2" aria-hidden="true" tabindex="-1"></a><span class="kw">%lexer</span> { (lexer True) } { L _ ITeof }</span>
<span id="cb963-3"><a href="#cb963-3" aria-hidden="true" tabindex="-1"></a><span class="kw">%tokentype</span> { (Located Token) }</span></code></pre></div>
<p>Since there are many flavours of Haskell syntax enabled by language
syntax extensions, the monad parser itself is passed a specific set of
<code>DynFlags</code> which specify the language specific Haskell syntax
to parse. An example parser invocation would look like:</p>
<div class="sourceCode" id="cb964"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb964-1"><a href="#cb964-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runParser ::</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">P</span> a <span class="ot">-&gt;</span> <span class="dt">ParseResult</span> a</span>
<span id="cb964-2"><a href="#cb964-2" aria-hidden="true" tabindex="-1"></a>runParser flags str parser <span class="ot">=</span> unP parser parseState</span>
<span id="cb964-3"><a href="#cb964-3" aria-hidden="true" tabindex="-1"></a><span class="kw">where</span></span>
<span id="cb964-4"><a href="#cb964-4" aria-hidden="true" tabindex="-1"></a>  filename   <span class="ot">=</span> <span class="st">&quot;&lt;interactive&gt;&quot;</span></span>
<span id="cb964-5"><a href="#cb964-5" aria-hidden="true" tabindex="-1"></a>  location   <span class="ot">=</span> mkRealSrcLoc (mkFastString filename) <span class="dv">1</span> <span class="dv">1</span></span>
<span id="cb964-6"><a href="#cb964-6" aria-hidden="true" tabindex="-1"></a>  buffer     <span class="ot">=</span> stringToStringBuffer str</span>
<span id="cb964-7"><a href="#cb964-7" aria-hidden="true" tabindex="-1"></a>  parseState <span class="ot">=</span> mkPState flags buffer location</span></code></pre></div>
<p>The <code>parser</code> argument above can be one of the following
Happy entry point functions which parse different fragments of the
Haskell grammar.</p>
<ul>
<li><code>parseModule</code></li>
<li><code>parseSignature</code></li>
<li><code>parseStatement</code></li>
<li><code>parseDeclaration</code></li>
<li><code>parseExpression</code></li>
<li><code>parseTypeSignature</code></li>
<li><code>parseStmt</code></li>
<li><code>parseIdentifier</code></li>
<li><code>parseType</code></li>
</ul>
<p>See:</p>
<ul>
<li><a
href="https://github.com/ghc/ghc/blob/master/compiler/parser/Lexer.x">GHC
Lexer.x</a></li>
<li><a
href="https://github.com/ghc/ghc/blob/master/compiler/parser/Parser.y">GHC
Parser.y</a></li>
<li><a
href="https://hackage.haskell.org/package/ghc-lib-parser">ghc-lib-parser</a></li>
</ul>
<h2 id="outputable">Outputable</h2>
<p>GHC internally use a pretty printer class for rendering its core
structures out to text. This is based on the Wadler-Leijen style and
uses a <code>Outputable</code> class as its interface:</p>
<div class="sourceCode" id="cb965"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb965-1"><a href="#cb965-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Outputable</span> a <span class="kw">where</span></span>
<span id="cb965-2"><a href="#cb965-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  ppr ::</span> a <span class="ot">-&gt;</span> <span class="dt">SDoc</span></span>
<span id="cb965-3"><a href="#cb965-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  pprPrec ::</span> <span class="dt">Rational</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">SDoc</span></span></code></pre></div>
<p>The primary renderer for SDoc types is <code>showSDoc</code> which
takes as argument a set of DynFlags which determine how the structure
are printed.</p>
<div class="sourceCode" id="cb966"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb966-1"><a href="#cb966-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showSDoc ::</span> <span class="dt">DynFlags</span> <span class="ot">-&gt;</span> <span class="dt">SDoc</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span></code></pre></div>
<p>We can also cheat and use a unsafe show which uses a dummy set of
DynFlags.</p>
<div class="sourceCode" id="cb967"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb967-1"><a href="#cb967-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Show a GHC.Outputable structure</span></span>
<span id="cb967-2"><a href="#cb967-2" aria-hidden="true" tabindex="-1"></a><span class="ot">showGhc ::</span> (<span class="dt">GHC.Outputable</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb967-3"><a href="#cb967-3" aria-hidden="true" tabindex="-1"></a>showGhc <span class="ot">=</span> GHC.showPpr GHC.unsafeGlobalDynFlags</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="https://hackage.haskell.org/package/ghc-8.6.5/docs/Outputable.html">Outputable</a></li>
</ul>
<h2 id="datatypes-1">Datatypes</h2>
<p>GHC has many datatypes but several of them are central data
structures that are the core datatypes that are manipulated during
compilation. These are divided into seven core categories.</p>
<p><strong>Monads</strong></p>
<p>The GHC monads which encapsulate the compiler driver pipeline and
statefully hold the interactions between the user and the internal
compiler phases.</p>
<ul>
<li><code>GHC</code> - The toplevel GHC monad that contains the compiler
driver.</li>
<li><code>P</code> - The parser monad.</li>
<li><code>Hsc</code> - The compiler module for a single module.</li>
<li><code>TcRn</code> - The monad holding state for typechecker and
renamer passes.</li>
<li><code>DsM</code> - The monad holding state for desugaring pass.</li>
<li><code>SimplM</code> - The monad holding state of simplification
pass.</li>
<li><code>MonadUnique</code> - A monad for generating unique
identifiers</li>
</ul>
<p><strong>Names</strong></p>
<ul>
<li><code>ModuleName</code> - A qualified module name.</li>
<li><code>Name</code> - A unique name generated after renaming pass with
provenance information of the symbol.</li>
<li><code>Var</code> - A typed <code>Name</code>.</li>
<li><code>Type</code> - The representation of a type in the GHC type
system.</li>
<li><code>RdrName</code> - A name generated from the parser without
scoping or type information.</li>
<li><code>Token</code> - Alex lexer tokens</li>
<li><code>SrcLoc</code> - The position information of a lexeme within
the source code.</li>
<li><code>SrcSpan</code> - The span information of a lexeme within the
source code.</li>
<li><code>Located</code> - Source code location newtype wrapper for AST
containing position and span information.</li>
</ul>
<p><strong>Session</strong></p>
<ul>
<li><code>DynFlags</code> - A mutable state holding all compiler flags
and options for compiling a project.</li>
<li><code>HscEnv</code> - An immutable monad state holding the flags and
session for compiling a single module.</li>
<li><code>Settings</code> - Immutable datatype holding holding system
settings, architecture and paths for compilation.</li>
<li><code>Target</code> - A compilation target.</li>
<li><code>TargetId</code> - Name of a compilation target, either module
or file.</li>
<li><code>HscTarget</code> - Target code output. Either LLVM, ASM or
interpreted.</li>
<li><code>GhcMode</code> - Operation mode of GHC, either multi-module
compilation or single shot.</li>
<li><code>ModSummary</code> - An element in a project’s module graph
containing file information and graph location.</li>
<li><code>InteractiveContext</code> - Context for GHCI interactive shell
when using interpreter target.</li>
<li><code>TypeEnv</code> - A symbol table mapping from Names to
TyThings.</li>
<li><code>GlobalRdrEnv</code> - A symbol table mapping
<code>RdrName</code> to <code>GlobalRdrElt</code>.</li>
<li><code>GlobalRdrElt</code> - A symbol emitted by the parser with
provenance about where it was defined and brought into scope.</li>
<li><code>TcGblEnv</code> - A symbol table generated after a module is
completed typechecking.</li>
<li><code>FixityEnv</code> - A symbol table mapping infix operators to
fixity delcarations.</li>
<li><code>Module</code> - A module name and identifier.</li>
<li><code>ModGuts</code> - The total state of all passes accumulated by
compiling a module. After compilation <code>ModIFace</code> and
<code>ModDetails</code> are kept.</li>
<li><code>ModuleInfo</code> - Container for information about a
Module.</li>
<li><code>ModDetails</code> - Data structure summarises all metadata
about a compiled module.</li>
<li><code>AvailInfo</code> - Symbol table of what objects are in
scope.</li>
<li><code>Class</code> - Data structure holding all metadata about a
typeclass definition.</li>
<li><code>ClsInt</code> - Data structure holding all metadata about a
typeclass instance.</li>
<li><code>FamInst</code>- Data structure holding all metadata about a
type/data family instance declaration.</li>
<li><code>TyCon</code> - Data structure holding all metadata about a
type constructor.</li>
<li><code>DataCon</code> - Data structure holding all metadata about a
data constructor.</li>
<li><code>InstEnv</code> - A InstEnv hodlings a mapping of known
instances for that family.</li>
<li><code>TyThing</code> - A global name with a type attached.
Classified by namespace.</li>
<li><code>DataConRep</code> - Data constructor representation generated
from parser.</li>
<li><code>GhcException</code> - Exceptions thrown by GHC inside of Hsc
monad for aberrant compiler behavior. Panics or internal errors.</li>
</ul>
<p><strong>HsSyn</strong></p>
<ul>
<li><code>HsModule</code> - Haskell source module containing all
toplevel definitions, pragmas and imports.</li>
<li><code>HsBind</code> - Universal type for any Haskell binding mapping
names to scope.</li>
<li><code>HsDecl</code> - Toplevel declaration in a module.</li>
<li><code>HsGroup</code> - A classifier type of toplevel
decalarations.</li>
<li><code>HsExpr</code> - An expression used in a declaration.</li>
<li><code>HsLit</code> - An literal expression (number, character, char,
etc) used in a declaration.</li>
<li><code>Pat</code> - A pattern match occuring in a function
declaration of left of a pattern binding.</li>
<li><code>HsType</code> - Haskell source representation of a type-level
expression.</li>
<li><code>Literal</code> - Haskell source representation of a literal
mapping to either a literal numeric type or a machine type.</li>
</ul>
<p><strong>CoreSyn</strong></p>
<p>The core syntax is a very small set of constructors for the Core
intermediate language. Most of the datatypes are contained in the
<code>Expr</code> datatype. All core expressions consists of toplevel
<code>Bind</code> of expressions objects.</p>
<ul>
<li><code>Expr</code> - Core expression.</li>
<li><code>Bind</code> - Core binder, either recursive or
non-recursive.</li>
<li><code>Arg</code> - Expression that occur in function arguments.</li>
<li><code>Alt</code> - A pattern match case split alternative.</li>
<li><code>AltCon</code> - A case alterantive constructor.</li>
</ul>
<p><strong>StgSyn</strong></p>
<p>Spineless tagless G-machine or STG is the intermediate representation
GHC uses before generating native code. It is an even simpler language
than Core and models a virtual machine which maps to the native
compilation target.</p>
<ul>
<li><code>StgTopBinding</code> - A toplevel module STG binding.</li>
<li><code>StgBinding</code> - An STG binding, either recursive or
non-recursive.</li>
<li><code>StgExpr</code> - A STG expression over Id names.
<ul>
<li><code>StgApp</code> - Application of a function to a fixed set of
arguments.</li>
<li><code>StgLit</code> - An expression literal.</li>
<li><code>StgConApp</code> - An application of a data constructor to a
fixed set of values.</li>
<li><code>StgOpApp</code>- An application of a primop to a fixed set of
arguments.</li>
<li><code>StgLam</code> - An STG lambda binding.</li>
<li><code>StgCase</code> - An STG case expansion.</li>
<li><code>StgLet</code> - An STG let binding.</li>
</ul></li>
</ul>
<h2 id="core">Core</h2>
<p>Core is the explicitly typed System-F family syntax through which all
Haskell constructs can be expressed.</p>
<div class="sourceCode" id="cb968"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb968-1"><a href="#cb968-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bind</span> b</span>
<span id="cb968-2"><a href="#cb968-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">NonRec</span> b (<span class="dt">Expr</span> b)</span>
<span id="cb968-3"><a href="#cb968-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Rec</span> [(b, <span class="dt">Expr</span> b)]</span>
<span id="cb968-4"><a href="#cb968-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb968-5"><a href="#cb968-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span> b</span>
<span id="cb968-6"><a href="#cb968-6" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">Id</span></span>
<span id="cb968-7"><a href="#cb968-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lit</span> <span class="dt">Literal</span>  </span>
<span id="cb968-8"><a href="#cb968-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> (<span class="dt">Expr</span> b) (<span class="dt">Arg</span> b)</span>
<span id="cb968-9"><a href="#cb968-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> b (<span class="dt">Expr</span> b)</span>
<span id="cb968-10"><a href="#cb968-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Let</span> (<span class="dt">Bind</span> b) (<span class="dt">Expr</span> b)</span>
<span id="cb968-11"><a href="#cb968-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Case</span> (<span class="dt">Expr</span> b) b <span class="dt">Type</span> [<span class="dt">Alt</span> b]</span>
<span id="cb968-12"><a href="#cb968-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Cast</span> (<span class="dt">Expr</span> b) <span class="dt">Coercion</span></span>
<span id="cb968-13"><a href="#cb968-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Tick</span> (<span class="dt">Tickish</span> <span class="dt">Id</span>) (<span class="dt">Expr</span> b)</span>
<span id="cb968-14"><a href="#cb968-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb968-15"><a href="#cb968-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Coercion</span> <span class="dt">Coercion</span></span></code></pre></div>
<p>To inspect the core from GHCi we can invoke it using the following
flags and the following shell alias. We have explicitly disabled the
printing of certain metadata and longform names to make the
representation easier to read.</p>
<div class="sourceCode" id="cb969"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb969-1"><a href="#cb969-1" aria-hidden="true" tabindex="-1"></a><span class="bu">alias</span> ghci-core=<span class="st">&quot;ghci -ddump-simpl -dsuppress-idinfo </span><span class="dt">\</span></span>
<span id="cb969-2"><a href="#cb969-2" aria-hidden="true" tabindex="-1"></a><span class="st">-dsuppress-coercions -dsuppress-type-applications </span><span class="dt">\</span></span>
<span id="cb969-3"><a href="#cb969-3" aria-hidden="true" tabindex="-1"></a><span class="st">-dsuppress-uniques -dsuppress-module-prefixes&quot;</span></span></code></pre></div>
<p>At the interactive prompt we can then explore the core representation
interactively:</p>
<div class="sourceCode" id="cb970"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb970-1"><a href="#cb970-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghci-core</span>
<span id="cb970-2"><a href="#cb970-2" aria-hidden="true" tabindex="-1"></a><span class="ex">λ:</span> let f x = x + 2 <span class="kw">;</span> <span class="ex">f</span> :: Int <span class="at">-</span><span class="op">&gt;</span> Int</span>
<span id="cb970-3"><a href="#cb970-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb970-4"><a href="#cb970-4" aria-hidden="true" tabindex="-1"></a><span class="ex">====================</span> Simplified expression ====================</span>
<span id="cb970-5"><a href="#cb970-5" aria-hidden="true" tabindex="-1"></a><span class="ex">returnIO</span></span>
<span id="cb970-6"><a href="#cb970-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">(</span><span class="bu">:</span> <span class="er">(</span><span class="kw">(</span><span class="ex">\ </span><span class="er">(</span><span class="ex">x</span> :: Int<span class="kw">)</span> <span class="ex">-</span><span class="op">&gt;</span> + <span class="va">$fNumInt</span> x <span class="er">(</span><span class="ex">I#</span> 2<span class="kw">))</span> <span class="kw">`</span><span class="ex">cast</span><span class="kw">`</span> ...<span class="kw">)</span> <span class="kw">(</span><span class="ex">[]</span><span class="kw">))</span></span>
<span id="cb970-7"><a href="#cb970-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb970-8"><a href="#cb970-8" aria-hidden="true" tabindex="-1"></a><span class="ex">λ:</span> let f x = <span class="er">(</span><span class="ex">x,</span> x<span class="kw">)</span></span>
<span id="cb970-9"><a href="#cb970-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb970-10"><a href="#cb970-10" aria-hidden="true" tabindex="-1"></a><span class="ex">====================</span> Simplified expression ====================</span>
<span id="cb970-11"><a href="#cb970-11" aria-hidden="true" tabindex="-1"></a><span class="ex">returnIO</span> <span class="er">(</span><span class="bu">:</span> <span class="er">(</span><span class="kw">(</span><span class="ex">\ </span><span class="er">(</span><span class="ex">@</span> t<span class="kw">)</span> <span class="kw">(</span><span class="ex">x</span> :: t<span class="kw">)</span> <span class="ex">-</span><span class="op">&gt;</span> <span class="er">(</span><span class="ex">x,</span> x<span class="kw">))</span> <span class="kw">`</span><span class="ex">cast</span><span class="kw">`</span> ...<span class="kw">)</span> <span class="kw">(</span><span class="ex">[]</span><span class="kw">))</span></span></code></pre></div>
<p><a href="http://hackage.haskell.org/package/ghc-core">ghc-core</a> is
also very useful for looking at GHC’s compilation artifacts.</p>
<div class="sourceCode" id="cb971"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb971-1"><a href="#cb971-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc-core <span class="at">--no-cast</span> <span class="at">--no-asm</span></span></code></pre></div>
<p>Alternatively the major stages of the compiler ( parse tree, core,
stg, cmm, asm ) can be manually outputted and inspected by passing
several flags to the compiler:</p>
<div class="sourceCode" id="cb972"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb972-1"><a href="#cb972-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc <span class="at">-ddump-to-file</span> <span class="at">-ddump-parsed</span> <span class="at">-ddump-simpl</span> <span class="at">-ddump-stg</span> <span class="at">-ddump-cmm</span> <span class="at">-ddump-asm</span></span></code></pre></div>
<p><strong>Reading Core</strong></p>
<p>Core from GHC is roughly human readable, but it’s helpful to look at
simple human written examples to get the hang of what’s going on.</p>
<div class="sourceCode" id="cb973"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb973-1"><a href="#cb973-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb973-2"><a href="#cb973-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<div class="sourceCode" id="cb974"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb974-1"><a href="#cb974-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span><span class="ot"> ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb974-2"><a href="#cb974-2" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> <span class="ot">=</span> \ (<span class="op">@</span> a) (<span class="ot">x ::</span> a) <span class="ot">-&gt;</span> x</span>
<span id="cb974-3"><a href="#cb974-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb974-4"><a href="#cb974-4" aria-hidden="true" tabindex="-1"></a><span class="ot">idInt ::</span> <span class="dt">GHC.Types.Int</span> <span class="ot">-&gt;</span> <span class="dt">GHC.Types.Int</span></span>
<span id="cb974-5"><a href="#cb974-5" aria-hidden="true" tabindex="-1"></a>idInt <span class="ot">=</span> <span class="fu">id</span> <span class="op">@</span> <span class="dt">GHC.Types.Int</span></span></code></pre></div>
<div class="sourceCode" id="cb975"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb975-1"><a href="#cb975-1" aria-hidden="true" tabindex="-1"></a><span class="ot">compose ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb975-2"><a href="#cb975-2" aria-hidden="true" tabindex="-1"></a>compose f g x <span class="ot">=</span> f (g x)</span></code></pre></div>
<div class="sourceCode" id="cb976"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb976-1"><a href="#cb976-1" aria-hidden="true" tabindex="-1"></a><span class="ot">compose ::</span> <span class="kw">forall</span> b c a<span class="op">.</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> c</span>
<span id="cb976-2"><a href="#cb976-2" aria-hidden="true" tabindex="-1"></a>compose <span class="ot">=</span> \ (<span class="op">@</span> b) (<span class="op">@</span> c) (<span class="op">@</span> a) (<span class="ot">f1 ::</span> b <span class="ot">-&gt;</span> c) (<span class="ot">g ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">x1 ::</span> a) <span class="ot">-&gt;</span> f1 (g x1)</span></code></pre></div>
<div class="sourceCode" id="cb977"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb977-1"><a href="#cb977-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb977-2"><a href="#cb977-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f []     <span class="ot">=</span> []</span>
<span id="cb977-3"><a href="#cb977-3" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (x<span class="op">:</span>xs) <span class="ot">=</span> f x <span class="op">:</span> <span class="fu">map</span> f xs</span></code></pre></div>
<div class="sourceCode" id="cb978"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb978-1"><a href="#cb978-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span><span class="ot"> ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb978-2"><a href="#cb978-2" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> <span class="ot">=</span></span>
<span id="cb978-3"><a href="#cb978-3" aria-hidden="true" tabindex="-1"></a>  \ (<span class="op">@</span> a) (<span class="op">@</span> b) (<span class="ot">f ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">xs ::</span> [a]) <span class="ot">-&gt;</span></span>
<span id="cb978-4"><a href="#cb978-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> xs <span class="kw">of</span> _ {</span>
<span id="cb978-5"><a href="#cb978-5" aria-hidden="true" tabindex="-1"></a>      []     <span class="ot">-&gt;</span> [] <span class="op">@</span> b;</span>
<span id="cb978-6"><a href="#cb978-6" aria-hidden="true" tabindex="-1"></a>      <span class="op">:</span> y ys <span class="ot">-&gt;</span> <span class="op">:</span> <span class="op">@</span> b (f y) (<span class="fu">map</span> <span class="op">@</span> a <span class="op">@</span> b f ys)</span>
<span id="cb978-7"><a href="#cb978-7" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Machine generated names are created for a lot of transformation of
Core. Generally they consist of a prefix and unique identifier. The
prefix is often pass specific ( e.g <code>ds</code> for desugar
generated names) and sometimes specific names are generated for specific
automatically generated code. A list of the common prefixes and their
meaning is show below.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Prefix</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>$f...</code></td>
<td style="text-align: left;">Dict-fun identifiers (from inst
decls)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>$dmop</code></td>
<td style="text-align: left;">Default method for ‘op’</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>$wf</code></td>
<td style="text-align: left;">Worker for function ‘f’</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>$sf</code></td>
<td style="text-align: left;">Specialised version of f</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>$gdm</code></td>
<td style="text-align: left;">Generated class method</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>$d</code></td>
<td style="text-align: left;">Dictionary names</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>$s</code></td>
<td style="text-align: left;">Specialized function name</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>$f</code></td>
<td style="text-align: left;">Foreign export</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>$pnC</code></td>
<td style="text-align: left;">n’th superclass selector for class C</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>T:C</code></td>
<td style="text-align: left;">Tycon for dictionary for class C</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>D:C</code></td>
<td style="text-align: left;">Data constructor for dictionary for class
C</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>NTCo:T</code></td>
<td style="text-align: left;">Coercion for newtype T to its underlying
runtime representation</td>
</tr>
</tbody>
</table>
<p>Of important note is that the Λ and λ for type-level and value-level
lambda abstraction are represented by the same symbol (<code>\</code>)
in core, which is a simplifying detail of the GHC’s implementation but a
source of some confusion when starting.</p>
<div class="sourceCode" id="cb979"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb979-1"><a href="#cb979-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- System-F Notation</span></span>
<span id="cb979-2"><a href="#cb979-2" aria-hidden="true" tabindex="-1"></a>Λ b c a<span class="op">.</span> λ (f1 <span class="op">:</span> b <span class="ot">-&gt;</span> c) (g <span class="op">:</span> a <span class="ot">-&gt;</span> b) (x1 <span class="op">:</span> a)<span class="op">.</span> f1 (g x1)</span>
<span id="cb979-3"><a href="#cb979-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb979-4"><a href="#cb979-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Haskell Core</span></span>
<span id="cb979-5"><a href="#cb979-5" aria-hidden="true" tabindex="-1"></a>\ (<span class="op">@</span> b) (<span class="op">@</span> c) (<span class="op">@</span> a) (<span class="ot">f1 ::</span> b <span class="ot">-&gt;</span> c) (<span class="ot">g ::</span> a <span class="ot">-&gt;</span> b) (<span class="ot">x1 ::</span> a) <span class="ot">-&gt;</span> f1 (g x1)</span></code></pre></div>
<p>The <code>seq</code> function has an intuitive implementation in the
Core language.</p>
<div class="sourceCode" id="cb980"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb980-1"><a href="#cb980-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">`seq`</span> y</span></code></pre></div>
<div class="sourceCode" id="cb981"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb981-1"><a href="#cb981-1" aria-hidden="true" tabindex="-1"></a><span class="kw">case</span> x <span class="kw">of</span> _ {</span>
<span id="cb981-2"><a href="#cb981-2" aria-hidden="true" tabindex="-1"></a>  __DEFAULT <span class="ot">-&gt;</span> y</span>
<span id="cb981-3"><a href="#cb981-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>One particularly notable case of the Core desugaring process is that
pattern matching on overloaded numbers implicitly translates into
equality test (i.e. <code>Eq</code>).</p>
<div class="sourceCode" id="cb982"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb982-1"><a href="#cb982-1" aria-hidden="true" tabindex="-1"></a>f <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb982-2"><a href="#cb982-2" aria-hidden="true" tabindex="-1"></a>f <span class="dv">1</span> <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb982-3"><a href="#cb982-3" aria-hidden="true" tabindex="-1"></a>f <span class="dv">2</span> <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb982-4"><a href="#cb982-4" aria-hidden="true" tabindex="-1"></a>f <span class="dv">3</span> <span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb982-5"><a href="#cb982-5" aria-hidden="true" tabindex="-1"></a>f <span class="dv">4</span> <span class="ot">=</span> <span class="dv">5</span></span>
<span id="cb982-6"><a href="#cb982-6" aria-hidden="true" tabindex="-1"></a>f _ <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb982-7"><a href="#cb982-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb982-8"><a href="#cb982-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb982-9"><a href="#cb982-9" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (<span class="dt">Eq</span> a, <span class="dt">Num</span> a, <span class="dt">Num</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb982-10"><a href="#cb982-10" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span></span>
<span id="cb982-11"><a href="#cb982-11" aria-hidden="true" tabindex="-1"></a>  \ (<span class="op">@</span> a)</span>
<span id="cb982-12"><a href="#cb982-12" aria-hidden="true" tabindex="-1"></a>    (<span class="op">@</span> b)</span>
<span id="cb982-13"><a href="#cb982-13" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span><span class="ot">dEq ::</span> <span class="dt">Eq</span> a)</span>
<span id="cb982-14"><a href="#cb982-14" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span><span class="ot">dNum ::</span> <span class="dt">Num</span> a)</span>
<span id="cb982-15"><a href="#cb982-15" aria-hidden="true" tabindex="-1"></a>    (<span class="op">$</span><span class="ot">dNum1 ::</span> <span class="dt">Num</span> b)</span>
<span id="cb982-16"><a href="#cb982-16" aria-hidden="true" tabindex="-1"></a>    (<span class="ot">ds ::</span> a) <span class="ot">-&gt;</span></span>
<span id="cb982-17"><a href="#cb982-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> <span class="op">==</span> <span class="op">$</span>dEq ds (<span class="fu">fromInteger</span> <span class="op">$</span>dNum (__integer <span class="dv">0</span>)) <span class="kw">of</span> _ {</span>
<span id="cb982-18"><a href="#cb982-18" aria-hidden="true" tabindex="-1"></a>      <span class="dt">False</span> <span class="ot">-&gt;</span></span>
<span id="cb982-19"><a href="#cb982-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> <span class="op">==</span> <span class="op">$</span>dEq ds (<span class="fu">fromInteger</span> <span class="op">$</span>dNum (__integer <span class="dv">1</span>)) <span class="kw">of</span> _ {</span>
<span id="cb982-20"><a href="#cb982-20" aria-hidden="true" tabindex="-1"></a>          <span class="dt">False</span> <span class="ot">-&gt;</span></span>
<span id="cb982-21"><a href="#cb982-21" aria-hidden="true" tabindex="-1"></a>            <span class="kw">case</span> <span class="op">==</span> <span class="op">$</span>dEq ds (<span class="fu">fromInteger</span> <span class="op">$</span>dNum (__integer <span class="dv">2</span>)) <span class="kw">of</span> _ {</span>
<span id="cb982-22"><a href="#cb982-22" aria-hidden="true" tabindex="-1"></a>              <span class="dt">False</span> <span class="ot">-&gt;</span></span>
<span id="cb982-23"><a href="#cb982-23" aria-hidden="true" tabindex="-1"></a>                <span class="kw">case</span> <span class="op">==</span> <span class="op">$</span>dEq ds (<span class="fu">fromInteger</span> <span class="op">$</span>dNum (__integer <span class="dv">3</span>)) <span class="kw">of</span> _ {</span>
<span id="cb982-24"><a href="#cb982-24" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">False</span> <span class="ot">-&gt;</span></span>
<span id="cb982-25"><a href="#cb982-25" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">case</span> <span class="op">==</span> <span class="op">$</span>dEq ds (<span class="fu">fromInteger</span> <span class="op">$</span>dNum (__integer <span class="dv">4</span>)) <span class="kw">of</span> _ {</span>
<span id="cb982-26"><a href="#cb982-26" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">False</span> <span class="ot">-&gt;</span> <span class="fu">fromInteger</span> <span class="op">$</span>dNum1 (__integer <span class="dv">0</span>);</span>
<span id="cb982-27"><a href="#cb982-27" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="fu">fromInteger</span> <span class="op">$</span>dNum1 (__integer <span class="dv">5</span>)</span>
<span id="cb982-28"><a href="#cb982-28" aria-hidden="true" tabindex="-1"></a>                    };</span>
<span id="cb982-29"><a href="#cb982-29" aria-hidden="true" tabindex="-1"></a>                  <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="fu">fromInteger</span> <span class="op">$</span>dNum1 (__integer <span class="dv">4</span>)</span>
<span id="cb982-30"><a href="#cb982-30" aria-hidden="true" tabindex="-1"></a>                };</span>
<span id="cb982-31"><a href="#cb982-31" aria-hidden="true" tabindex="-1"></a>              <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="fu">fromInteger</span> <span class="op">$</span>dNum1 (__integer <span class="dv">3</span>)</span>
<span id="cb982-32"><a href="#cb982-32" aria-hidden="true" tabindex="-1"></a>            };</span>
<span id="cb982-33"><a href="#cb982-33" aria-hidden="true" tabindex="-1"></a>          <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="fu">fromInteger</span> <span class="op">$</span>dNum1 (__integer <span class="dv">2</span>)</span>
<span id="cb982-34"><a href="#cb982-34" aria-hidden="true" tabindex="-1"></a>        };</span>
<span id="cb982-35"><a href="#cb982-35" aria-hidden="true" tabindex="-1"></a>      <span class="dt">True</span> <span class="ot">-&gt;</span> <span class="fu">fromInteger</span> <span class="op">$</span>dNum1 (__integer <span class="dv">1</span>)</span>
<span id="cb982-36"><a href="#cb982-36" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>Of course, adding a concrete type signature changes the desugar just
matching on the unboxed values.</p>
<div class="sourceCode" id="cb983"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb983-1"><a href="#cb983-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb983-2"><a href="#cb983-2" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span></span>
<span id="cb983-3"><a href="#cb983-3" aria-hidden="true" tabindex="-1"></a>  \ (<span class="ot">ds ::</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span></span>
<span id="cb983-4"><a href="#cb983-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> ds <span class="kw">of</span> _ { <span class="dt">I</span><span class="op">#</span> ds1 <span class="ot">-&gt;</span></span>
<span id="cb983-5"><a href="#cb983-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> ds1 <span class="kw">of</span> _ {</span>
<span id="cb983-6"><a href="#cb983-6" aria-hidden="true" tabindex="-1"></a>      __DEFAULT <span class="ot">-&gt;</span> <span class="dt">I</span><span class="op">#</span> <span class="dv">0</span>;</span>
<span id="cb983-7"><a href="#cb983-7" aria-hidden="true" tabindex="-1"></a>      <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="op">#</span> <span class="dv">1</span>;</span>
<span id="cb983-8"><a href="#cb983-8" aria-hidden="true" tabindex="-1"></a>      <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="op">#</span> <span class="dv">2</span>;</span>
<span id="cb983-9"><a href="#cb983-9" aria-hidden="true" tabindex="-1"></a>      <span class="dv">2</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="op">#</span> <span class="dv">3</span>;</span>
<span id="cb983-10"><a href="#cb983-10" aria-hidden="true" tabindex="-1"></a>      <span class="dv">3</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="op">#</span> <span class="dv">4</span>;</span>
<span id="cb983-11"><a href="#cb983-11" aria-hidden="true" tabindex="-1"></a>      <span class="dv">4</span> <span class="ot">-&gt;</span> <span class="dt">I</span><span class="op">#</span> <span class="dv">5</span></span>
<span id="cb983-12"><a href="#cb983-12" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb983-13"><a href="#cb983-13" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="https://github.com/ghc/ghc/blob/master/docs/core-spec/core-spec.pdf">Core
Spec</a></li>
<li><a
href="https://ghc.haskell.org/trac/ghc/wiki/Commentary/Compiler/CoreSynType">CoreSynType</a></li>
</ul>
<h2 id="inliner">Inliner</h2>
<div class="sourceCode" id="cb984"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb984-1"><a href="#cb984-1" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">0</span>  <span class="op">$</span></span>
<span id="cb984-2"><a href="#cb984-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb984-3"><a href="#cb984-3" aria-hidden="true" tabindex="-1"></a><span class="ot">($)::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb984-4"><a href="#cb984-4" aria-hidden="true" tabindex="-1"></a>f <span class="op">$</span> x <span class="ot">=</span>  f x</span></code></pre></div>
<p>Having to enter a secondary closure every time we used
<code>($)</code> would introduce an enormous overhead. Fortunately GHC
has a pass to eliminate small functions like this by simply replacing
the function call with the body of its definition at appropriate
call-sites. The compiler contains a variety of heuristics for
determining when this kind of substitution is appropriate and the
potential costs involved.</p>
<p>In addition to the automatic inliner, manual pragmas are provided for
more granular control over inlining. It’s important to note that naive
inlining quite often results in significantly worse performance and
longer compilation times.</p>
<div class="sourceCode" id="cb985"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb985-1"><a href="#cb985-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# INLINE func #-}</span></span>
<span id="cb985-2"><a href="#cb985-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# INLINABLE func #-}</span></span>
<span id="cb985-3"><a href="#cb985-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# NOINLINE func #-}</span></span></code></pre></div>
<p>For example the contrived case where we apply a binary function to
two arguments. The function body is small and instead of entering
another closure just to apply the given function, we could in fact just
inline the function application at the call site.</p>
<div class="sourceCode" id="cb986"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb986-1"><a href="#cb986-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# INLINE foo #-}</span></span>
<span id="cb986-2"><a href="#cb986-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# NOINLINE bar #-}</span></span>
<span id="cb986-3"><a href="#cb986-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb986-4"><a href="#cb986-4" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span>
<span id="cb986-5"><a href="#cb986-5" aria-hidden="true" tabindex="-1"></a>foo f x y <span class="ot">=</span> f x y</span>
<span id="cb986-6"><a href="#cb986-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb986-7"><a href="#cb986-7" aria-hidden="true" tabindex="-1"></a><span class="ot">bar ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</span>
<span id="cb986-8"><a href="#cb986-8" aria-hidden="true" tabindex="-1"></a>bar f x y <span class="ot">=</span> f x y</span>
<span id="cb986-9"><a href="#cb986-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb986-10"><a href="#cb986-10" aria-hidden="true" tabindex="-1"></a><span class="ot">test1 ::</span> <span class="dt">Int</span></span>
<span id="cb986-11"><a href="#cb986-11" aria-hidden="true" tabindex="-1"></a>test1 <span class="ot">=</span> foo (<span class="op">+</span>) <span class="dv">10</span> <span class="dv">20</span></span>
<span id="cb986-12"><a href="#cb986-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb986-13"><a href="#cb986-13" aria-hidden="true" tabindex="-1"></a><span class="ot">test2 ::</span> <span class="dt">Int</span></span>
<span id="cb986-14"><a href="#cb986-14" aria-hidden="true" tabindex="-1"></a>test2 <span class="ot">=</span> bar (<span class="op">+</span>) <span class="dv">20</span> <span class="dv">30</span></span></code></pre></div>
<p>Looking at the core, we can see that in <code>test1</code> the
function has indeed been expanded at the call site and simply performs
the addition there instead of another indirection.</p>
<div class="sourceCode" id="cb987"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb987-1"><a href="#cb987-1" aria-hidden="true" tabindex="-1"></a><span class="ot">test1 ::</span> <span class="dt">Int</span></span>
<span id="cb987-2"><a href="#cb987-2" aria-hidden="true" tabindex="-1"></a>test1 <span class="ot">=</span></span>
<span id="cb987-3"><a href="#cb987-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> {</span>
<span id="cb987-4"><a href="#cb987-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb987-5"><a href="#cb987-5" aria-hidden="true" tabindex="-1"></a>    f <span class="ot">=</span> <span class="op">+</span> <span class="op">$</span>fNumInt } <span class="kw">in</span></span>
<span id="cb987-6"><a href="#cb987-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> {</span>
<span id="cb987-7"><a href="#cb987-7" aria-hidden="true" tabindex="-1"></a><span class="ot">    x ::</span> <span class="dt">Int</span></span>
<span id="cb987-8"><a href="#cb987-8" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">=</span> <span class="dt">I</span><span class="op">#</span> <span class="dv">10</span> } <span class="kw">in</span></span>
<span id="cb987-9"><a href="#cb987-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> {</span>
<span id="cb987-10"><a href="#cb987-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    y ::</span> <span class="dt">Int</span></span>
<span id="cb987-11"><a href="#cb987-11" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">=</span> <span class="dt">I</span><span class="op">#</span> <span class="dv">20</span> } <span class="kw">in</span></span>
<span id="cb987-12"><a href="#cb987-12" aria-hidden="true" tabindex="-1"></a>  f x y</span>
<span id="cb987-13"><a href="#cb987-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb987-14"><a href="#cb987-14" aria-hidden="true" tabindex="-1"></a><span class="ot">test2 ::</span> <span class="dt">Int</span></span>
<span id="cb987-15"><a href="#cb987-15" aria-hidden="true" tabindex="-1"></a>test2 <span class="ot">=</span> bar (<span class="op">+</span> <span class="op">$</span>fNumInt) (<span class="dt">I</span><span class="op">#</span> <span class="dv">20</span>) (<span class="dt">I</span><span class="op">#</span> <span class="dv">30</span>)</span></code></pre></div>
<p>Cases marked with <code>NOINLINE</code> generally indicate that the
logic in the function is using something like
<code>unsafePerformIO</code> or some other unholy function. In these
cases naive inlining might duplicate effects at multiple call-sites
throughout the program which would be undesirable.</p>
<p>See:</p>
<ul>
<li><a
href="https://research.microsoft.com/en-us/um/people/simonpj/Papers/inlining/inline.pdf">Secrets
of the Glasgow Haskell Compiler inliner</a></li>
</ul>
<h2 id="primops">Primops</h2>
<p>GHC has many primitive operations that are intrinsics built into the
compiler. You can manually invoke these functions inside of optimised
code which allows you to drop down to the same level of performance you
can achieve in C or by hand-writing inline assembly. These functions are
intrinsics that are builtin to the compiler and operate over unboxed
machines types.</p>
<div class="sourceCode" id="cb988"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb988-1"><a href="#cb988-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(+#)        ::</span> <span class="dt">Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="op">#</span></span>
<span id="cb988-2"><a href="#cb988-2" aria-hidden="true" tabindex="-1"></a>gtChar<span class="op">#</span><span class="ot">     ::</span> <span class="dt">Char</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Char</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="op">#</span></span>
<span id="cb988-3"><a href="#cb988-3" aria-hidden="true" tabindex="-1"></a>byteSwap64<span class="op">#</span><span class="ot"> ::</span> <span class="dt">Word</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Word</span><span class="op">#</span></span></code></pre></div>
<p>Depending on the choice of code generator and CPU architecture these
instructions will map to single CPU instructions over machines.</p>
<p>See <a
href="https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html">ghc-prim</a></p>
<h2 id="simd-intrinsics">SIMD Intrinsics</h2>
<p>GHC has procedures for generating code that use SIMD vector
instructions when using the LLVM backend (<code>-fllvm</code>). For
example the following <code>&lt;8xfloat&gt;</code> and
<code>&lt;8xdouble&gt;</code> are used internally by the following
datatypes exposed by <code>ghc-prim</code>.</p>
<ul>
<li><code>FloatX8#</code></li>
<li><code>DoubleX8#</code></li>
</ul>
<p>And operations over these map to single CPU instructions that work
with the bulk values instead of single values. For instance adding two
vectors:</p>
<div class="sourceCode" id="cb989"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb989-1"><a href="#cb989-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Add two vectors element-wise.</span></span>
<span id="cb989-2"><a href="#cb989-2" aria-hidden="true" tabindex="-1"></a>plusDoubleX8<span class="op">#</span><span class="ot"> ::</span> <span class="dt">DoubleX8</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">DoubleX8</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">DoubleX8</span><span class="op">#</span></span></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb990"
data-include="src/29-ghc/simd/simd.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb990-1"><a href="#cb990-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb990-2"><a href="#cb990-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MagicHash #-}</span></span>
<span id="cb990-3"><a href="#cb990-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UnboxedTuples #-}</span></span>
<span id="cb990-4"><a href="#cb990-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -mavx #-}</span></span>
<span id="cb990-5"><a href="#cb990-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -msse #-}</span></span>
<span id="cb990-6"><a href="#cb990-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -msse2 #-}</span></span>
<span id="cb990-7"><a href="#cb990-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# OPTIONS_GHC -msse4 #-}</span></span>
<span id="cb990-8"><a href="#cb990-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb990-9"><a href="#cb990-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span></span>
<span id="cb990-10"><a href="#cb990-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Prim</span></span>
<span id="cb990-11"><a href="#cb990-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb990-12"><a href="#cb990-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FloatX4</span> <span class="ot">=</span> <span class="dt">FX4</span><span class="op">#</span> <span class="dt">FloatX4</span><span class="op">#</span></span>
<span id="cb990-13"><a href="#cb990-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb990-14"><a href="#cb990-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">FloatX4</span> <span class="kw">where</span></span>
<span id="cb990-15"><a href="#cb990-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">show</span> (<span class="dt">FX4</span><span class="op">#</span> f) <span class="ot">=</span> <span class="kw">case</span> unpackFloatX4<span class="op">#</span> f <span class="kw">of</span></span>
<span id="cb990-16"><a href="#cb990-16" aria-hidden="true" tabindex="-1"></a>    (<span class="op">#</span> a, b, c, d <span class="op">#</span>) <span class="ot">-&gt;</span> <span class="fu">show</span> (<span class="dt">F</span><span class="op">#</span> a, <span class="dt">F</span><span class="op">#</span> b, <span class="dt">F</span><span class="op">#</span> c, <span class="dt">F</span><span class="op">#</span> d)</span>
<span id="cb990-17"><a href="#cb990-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb990-18"><a href="#cb990-18" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb990-19"><a href="#cb990-19" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb990-20"><a href="#cb990-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> a <span class="ot">=</span> packFloatX4<span class="op">#</span> (<span class="op">#</span> <span class="fl">4.5</span><span class="op">#</span>, <span class="fl">7.8</span><span class="op">#</span>, <span class="fl">2.3</span><span class="op">#</span>, <span class="fl">6.5</span><span class="op">#</span> <span class="op">#</span>)</span>
<span id="cb990-21"><a href="#cb990-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> b <span class="ot">=</span> packFloatX4<span class="op">#</span> (<span class="op">#</span> <span class="fl">8.2</span><span class="op">#</span>, <span class="fl">6.3</span><span class="op">#</span>, <span class="fl">4.7</span><span class="op">#</span>, <span class="fl">9.2</span><span class="op">#</span> <span class="op">#</span>)</span>
<span id="cb990-22"><a href="#cb990-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> c <span class="ot">=</span> <span class="dt">FX4</span><span class="op">#</span> (broadcastFloatX4<span class="op">#</span> <span class="fl">1.5</span><span class="op">#</span>)</span>
<span id="cb990-23"><a href="#cb990-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (<span class="dt">FX4</span><span class="op">#</span> a)</span>
<span id="cb990-24"><a href="#cb990-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (<span class="dt">FX4</span><span class="op">#</span> (plusFloatX4<span class="op">#</span> a b))</span>
<span id="cb990-25"><a href="#cb990-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> c</span></code></pre></div>
<p>When you generate this code to LLVM you will see that GHC is indeed
allocating the values as vector types if you browse the assembly
output.</p>
<div class="sourceCode" id="cb991"><pre
class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb991-1"><a href="#cb991-1" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%XMM1_Var</span> = <span class="kw">alloca</span> &lt;<span class="dv">4</span> x <span class="dt">i32</span>&gt;, <span class="dt">i32</span> <span class="dv">1</span></span>
<span id="cb991-2"><a href="#cb991-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">store</span> &lt;<span class="dv">4</span> x <span class="dt">i32</span>&gt; <span class="kw">undef</span>, &lt;<span class="dv">4</span> x <span class="dt">i32</span>&gt;* <span class="fu">%XMM1_Var</span>, <span class="kw">align</span> <span class="dv">1</span></span></code></pre></div>
<p>Using the native SIMD instructions you can perform low-level
vectorised operations over the unboxed memory, typically found in
numerical computing problems.</p>
<p>See: <a
href="https://hackage.haskell.org/package/ghc-prim-0.5.3/docs/GHC-Prim.html#g:29">SIMD
Operations</a></p>
<h2 id="rewrite-rules">Rewrite Rules</h2>
<p>Consider the composition of two fmaps. This operation maps a function
<code>g</code> over a list <code>xs</code> and then maps a function
<code>f</code> over the resulting list. This results in two full
traversals of a list of length n.</p>
<div class="sourceCode" id="cb992"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb992-1"><a href="#cb992-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> f (<span class="fu">map</span> g xs)</span></code></pre></div>
<p>This is equivalent to the following more efficient form which applies
the composition of f and g over the list elementwise resulting in a
single iteration of the list instead. For large lists this will be
vastly more efficient.</p>
<div class="sourceCode" id="cb993"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb993-1"><a href="#cb993-1" aria-hidden="true" tabindex="-1"></a><span class="fu">map</span> (f<span class="op">.</span>g) xs</span></code></pre></div>
<p>GHC is a clever compiler and allows us to write custom rules to
transform the AST of our programs at compile time in order to do these
kind of optimisations. These are called fusion rules and many
high-performance libraries make use of them to generate more optimal
code.</p>
<p>By adding a <code>RULES</code> pragma to a module where
<code>map</code> is defined we can tell GHC to rewrite all cases of
double map to their more optimal form across <em>all</em> modules that
use this definition. Rule are applied during the optimiser pass in GHC
compilation.</p>
<div class="sourceCode" id="cb994"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb994-1"><a href="#cb994-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# RULES     &quot;map/map&quot;    forall f g xs.  map f (map g xs) = map (f.g) xs #-}</span></span></code></pre></div>
<p>It is important to note that these rewrite rules must be
syntactically valid Haskell, but GHC makes no guarantees that they are
semantically valid. One could very easily introduce a rewrite rule that
introduces subtle bugs by redefining functions nonsensically and GHC
will happily rewrite away. Be careful when doing these kind of
optimisations.</p>
<ul>
<li><a
href="https://downloads.haskell.org/~ghc/7.10.3/docs/html/users_guide/rewrite-rules.html">List
Fusion</a></li>
</ul>
<h2 id="boot-libraries">Boot Libraries</h2>
<p>GHC itself ships with a variety of libraries that are necessary to
bootstrap the compiler and compile itself.</p>
<ul>
<li><strong>array</strong> - Mutable and immutable array data
structures.</li>
<li><strong>base</strong> - The base library. See <a
href="#base">Base</a>.</li>
<li><strong>binary</strong> - Binary serialisation to ByteStrings</li>
<li><strong>bytestring</strong> - Unboxed arrays of bytes.</li>
<li><strong>Cabal</strong> - The Cabal build system.</li>
<li><strong>containers</strong> - The default data structures.</li>
<li><strong>deepseq</strong> - Deeply evaluate nested data
structures.</li>
<li><strong>directory</strong> - Directory and file traversal.</li>
<li><strong>dist-haddock</strong> - Haddock build utilities.</li>
<li><strong>filepath</strong> - File path manipulation.</li>
<li><strong>ghc-boot</strong> - Shared datatypes for GHC package
databases</li>
<li><strong>ghc-boot-th</strong> - Shared datatypes for GHC and
TemplateHaskell iserv</li>
<li><strong>ghc-compact</strong> - GHC support for compact memory
regions.</li>
<li><strong>ghc-heap</strong> - C library for Haskell GC types.</li>
<li><strong>ghci</strong> - GHCI interactive shell.</li>
<li><strong>ghc-prim</strong> - GHC builtin primitive operations.</li>
<li><strong>haskeline</strong> - Readline library.</li>
<li><strong>hpc</strong> - Code coverage reporting.</li>
<li><strong>integer-gmp</strong> - GMP integer datatypes for GHC.</li>
<li><strong>libiserv</strong> - External interpreter for Template
Haskell.</li>
<li><strong>mtl</strong> - Monad transformers library.</li>
<li><strong>parsec</strong> - Parser combinators.</li>
<li><strong>pretty</strong> - Pretty printer.</li>
<li><strong>process</strong> - Operating system process utilities.</li>
<li><strong>stm</strong> - Software transaction memory.</li>
<li><strong>template-haskell</strong> - Metaprogramming for GHC.</li>
<li><strong>terminfo</strong> - System terminal information.</li>
<li><strong>text</strong> - Unboxed arrays of Unicode characters.</li>
<li><strong>time</strong> - System time.</li>
<li><strong>transformers</strong> - Monad transformers library.</li>
<li><strong>unix</strong> - Interactions with Linux operating
system.</li>
<li><strong>xhtml</strong> - HTML generation utilities.</li>
</ul>
<h2 id="dictionaries">Dictionaries</h2>
<p>The Haskell language defines the notion of Typeclasses but is
agnostic to how they are implemented in a Haskell compiler. GHC’s
particular implementation uses a pass called the <em>dictionary passing
translation</em> part of the elaboration phase of the typechecker which
translates Core functions with typeclass constraints into implicit
parameters of which record-like structures containing the function
implementations are passed.</p>
<div class="sourceCode" id="cb995"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb995-1"><a href="#cb995-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Num</span> a <span class="kw">where</span></span>
<span id="cb995-2"><a href="#cb995-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  (+) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb995-3"><a href="#cb995-3" aria-hidden="true" tabindex="-1"></a><span class="ot">  (*) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb995-4"><a href="#cb995-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  negate ::</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>This class can be thought as the implementation equivalent to the
following parameterized record of functions.</p>
<div class="sourceCode" id="cb996"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb996-1"><a href="#cb996-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DNum</span> a <span class="ot">=</span> <span class="dt">DNum</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) (a <span class="ot">-&gt;</span> a)</span>
<span id="cb996-2"><a href="#cb996-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb996-3"><a href="#cb996-3" aria-hidden="true" tabindex="-1"></a>add (<span class="dt">DNum</span> a m n) <span class="ot">=</span> a</span>
<span id="cb996-4"><a href="#cb996-4" aria-hidden="true" tabindex="-1"></a>mul (<span class="dt">DNum</span> a m n) <span class="ot">=</span> m</span>
<span id="cb996-5"><a href="#cb996-5" aria-hidden="true" tabindex="-1"></a>neg (<span class="dt">DNum</span> a m n) <span class="ot">=</span> n</span>
<span id="cb996-6"><a href="#cb996-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb996-7"><a href="#cb996-7" aria-hidden="true" tabindex="-1"></a><span class="ot">numDInt ::</span> <span class="dt">DNum</span> <span class="dt">Int</span></span>
<span id="cb996-8"><a href="#cb996-8" aria-hidden="true" tabindex="-1"></a>numDInt <span class="ot">=</span> <span class="dt">DNum</span> plusInt timesInt negateInt</span>
<span id="cb996-9"><a href="#cb996-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb996-10"><a href="#cb996-10" aria-hidden="true" tabindex="-1"></a><span class="ot">numDFloat ::</span> <span class="dt">DNum</span> <span class="dt">Float</span></span>
<span id="cb996-11"><a href="#cb996-11" aria-hidden="true" tabindex="-1"></a>numDFloat <span class="ot">=</span> <span class="dt">DNum</span> plusFloat timesFloat negateFloat</span></code></pre></div>
<div class="sourceCode" id="cb997"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb997-1"><a href="#cb997-1" aria-hidden="true" tabindex="-1"></a><span class="op">+</span><span class="ot"> ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb997-2"><a href="#cb997-2" aria-hidden="true" tabindex="-1"></a><span class="op">+</span> <span class="ot">=</span> \ (<span class="op">@</span> a) (<span class="ot">tpl ::</span> <span class="dt">Num</span> a) <span class="ot">-&gt;</span></span>
<span id="cb997-3"><a href="#cb997-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> tpl <span class="kw">of</span> _ { <span class="dt">D</span><span class="op">:</span><span class="dt">Num</span> tpl _ _ <span class="ot">-&gt;</span> tpl }</span>
<span id="cb997-4"><a href="#cb997-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb997-5"><a href="#cb997-5" aria-hidden="true" tabindex="-1"></a><span class="op">*</span><span class="ot"> ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb997-6"><a href="#cb997-6" aria-hidden="true" tabindex="-1"></a><span class="op">*</span> <span class="ot">=</span> \ (<span class="op">@</span> a) (<span class="ot">tpl ::</span> <span class="dt">Num</span> a) <span class="ot">-&gt;</span></span>
<span id="cb997-7"><a href="#cb997-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> tpl <span class="kw">of</span> _ { <span class="dt">D</span><span class="op">:</span><span class="dt">Num</span> _ tpl _ <span class="ot">-&gt;</span> tpl }</span>
<span id="cb997-8"><a href="#cb997-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb997-9"><a href="#cb997-9" aria-hidden="true" tabindex="-1"></a><span class="fu">negate</span><span class="ot"> ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb997-10"><a href="#cb997-10" aria-hidden="true" tabindex="-1"></a><span class="fu">negate</span> <span class="ot">=</span> \ (<span class="op">@</span> a) (<span class="ot">tpl ::</span> <span class="dt">Num</span> a) <span class="ot">-&gt;</span></span>
<span id="cb997-11"><a href="#cb997-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> tpl <span class="kw">of</span> _ { <span class="dt">D</span><span class="op">:</span><span class="dt">Num</span> _ _ tpl <span class="ot">-&gt;</span> tpl }</span></code></pre></div>
<p><code>Num</code> and <code>Ord</code> have simple translations but
for monads with existential type variables in their signatures, the only
way to represent the equivalent dictionary is using
<code>RankNTypes</code>. In addition a typeclass may also include
superclasses which would be included in the typeclass dictionary and
parameterized over the same arguments and an implicit superclass
constructor function is created to pull out functions from the
superclass for the current monad.</p>
<div class="sourceCode" id="cb998"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb998-1"><a href="#cb998-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DMonad</span> m <span class="ot">=</span> <span class="dt">DMonad</span></span>
<span id="cb998-2"><a href="#cb998-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> bind   ::</span> <span class="kw">forall</span> a b<span class="op">.</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb998-3"><a href="#cb998-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> return ::</span> <span class="kw">forall</span> a<span class="op">.</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb998-4"><a href="#cb998-4" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<div class="sourceCode" id="cb999"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb999-1"><a href="#cb999-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Functor</span> t, <span class="dt">Foldable</span> t) <span class="ot">=&gt;</span> <span class="dt">Traversable</span> t <span class="kw">where</span></span>
<span id="cb999-2"><a href="#cb999-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  traverse ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</span>
<span id="cb999-3"><a href="#cb999-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">traverse</span> f <span class="ot">=</span> <span class="fu">sequenceA</span> <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre></div>
<div class="sourceCode" id="cb1000"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1000-1"><a href="#cb1000-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">DTraversable</span> t <span class="ot">=</span> <span class="dt">DTraversable</span></span>
<span id="cb1000-2"><a href="#cb1000-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> dFunctorTraversable ::</span> <span class="dt">DFunctor</span> t  <span class="co">-- superclass dictionary</span></span>
<span id="cb1000-3"><a href="#cb1000-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> dFoldableTraversable ::</span> <span class="dt">DFoldable</span> t <span class="co">-- superclass dictionary</span></span>
<span id="cb1000-4"><a href="#cb1000-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> traverse ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> t a <span class="ot">-&gt;</span> f (t b)</span>
<span id="cb1000-5"><a href="#cb1000-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Indeed this is not that far from how GHC actually implements
typeclasses. It elaborates into projection functions and data
constructors nearly identical to this, and are expanded out to a
dictionary argument for each typeclass constraint of every polymorphic
function.</p>
<h2 id="specialization">Specialization</h2>
<p>Overloading in Haskell is normally not entirely free by default,
although with an optimization called specialization it can be made to
have zero cost at specific points in the code where performance is
crucial. This is not enabled by default by virtue of the fact that GHC
is not a whole-program optimizing compiler and most optimizations ( not
all ) stop at module boundaries.</p>
<p>GHC’s method of implementing typeclasses means that explicit
dictionaries are threaded around implicitly throughout the call sites.
This is normally the most natural way to implement this functionality
since it preserves separate compilation. A function can be compiled
independently of where it is declared, not recompiled at every point in
the program where it’s called. The dictionary passing allows the caller
to thread the implementation logic for the types to the call-site where
it can then be used throughout the body of the function.</p>
<p>Of course this means that in order to get at a specific typeclass
function we need to project ( possibly multiple times ) into the
dictionary structure to pluck out the function reference. The runtime
makes this very cheap but not entirely free.</p>
<p>Many C++ compilers or whole program optimizing compilers do the
opposite however, they explicitly specialize each and every function at
the call site replacing the overloaded function with its type-specific
implementation. We can selectively enable this kind of behavior using
class specialization.</p>
<div class="sourceCode" id="cb1001"
data-include="src/29-ghc/specialize.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1001-1"><a href="#cb1001-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Specialize</span> (spec, nonspec, f) <span class="kw">where</span></span>
<span id="cb1001-2"><a href="#cb1001-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1001-3"><a href="#cb1001-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# SPECIALIZE INLINE f :: Double -&gt; Double -&gt; Double #-}</span></span>
<span id="cb1001-4"><a href="#cb1001-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1001-5"><a href="#cb1001-5" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Floating</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1001-6"><a href="#cb1001-6" aria-hidden="true" tabindex="-1"></a>f x y <span class="ot">=</span> <span class="fu">exp</span> (x <span class="op">+</span> y) <span class="op">*</span> <span class="fu">exp</span> (x <span class="op">+</span> y)</span>
<span id="cb1001-7"><a href="#cb1001-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1001-8"><a href="#cb1001-8" aria-hidden="true" tabindex="-1"></a><span class="ot">nonspec ::</span> <span class="dt">Float</span></span>
<span id="cb1001-9"><a href="#cb1001-9" aria-hidden="true" tabindex="-1"></a>nonspec <span class="ot">=</span> f (<span class="dv">10</span><span class="ot"> ::</span> <span class="dt">Float</span>) (<span class="dv">20</span><span class="ot"> ::</span> <span class="dt">Float</span>)</span>
<span id="cb1001-10"><a href="#cb1001-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1001-11"><a href="#cb1001-11" aria-hidden="true" tabindex="-1"></a><span class="ot">spec ::</span> <span class="dt">Double</span></span>
<span id="cb1001-12"><a href="#cb1001-12" aria-hidden="true" tabindex="-1"></a>spec <span class="ot">=</span> f (<span class="dv">10</span><span class="ot"> ::</span> <span class="dt">Double</span>) (<span class="dv">20</span><span class="ot"> ::</span> <span class="dt">Double</span>)</span></code></pre></div>
<p><strong>Non-specialized</strong></p>
<div class="sourceCode" id="cb1002"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1002-1"><a href="#cb1002-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Floating</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1002-2"><a href="#cb1002-2" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span></span>
<span id="cb1002-3"><a href="#cb1002-3" aria-hidden="true" tabindex="-1"></a>  \ (<span class="op">@</span> a) (<span class="op">$</span><span class="ot">dFloating ::</span> <span class="dt">Floating</span> a) (<span class="ot">eta ::</span> a) (<span class="ot">eta1 ::</span> a) <span class="ot">-&gt;</span></span>
<span id="cb1002-4"><a href="#cb1002-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> {</span>
<span id="cb1002-5"><a href="#cb1002-5" aria-hidden="true" tabindex="-1"></a><span class="ot">      a ::</span> <span class="dt">Fractional</span> a</span>
<span id="cb1002-6"><a href="#cb1002-6" aria-hidden="true" tabindex="-1"></a>      a <span class="ot">=</span> <span class="op">$</span>p1Floating <span class="op">@</span> a <span class="op">$</span>dFloating } <span class="kw">in</span></span>
<span id="cb1002-7"><a href="#cb1002-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> {</span>
<span id="cb1002-8"><a href="#cb1002-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span><span class="ot">dNum ::</span> <span class="dt">Num</span> a</span>
<span id="cb1002-9"><a href="#cb1002-9" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span>dNum <span class="ot">=</span> <span class="op">$</span>p1Fractional <span class="op">@</span> a a } <span class="kw">in</span></span>
<span id="cb1002-10"><a href="#cb1002-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span> <span class="op">@</span> a</span>
<span id="cb1002-11"><a href="#cb1002-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">$</span>dNum</span>
<span id="cb1002-12"><a href="#cb1002-12" aria-hidden="true" tabindex="-1"></a>      (<span class="fu">exp</span> <span class="op">@</span> a <span class="op">$</span>dFloating (<span class="op">+</span> <span class="op">@</span> a <span class="op">$</span>dNum eta eta1))</span>
<span id="cb1002-13"><a href="#cb1002-13" aria-hidden="true" tabindex="-1"></a>      (<span class="fu">exp</span> <span class="op">@</span> a <span class="op">$</span>dFloating (<span class="op">+</span> <span class="op">@</span> a <span class="op">$</span>dNum eta eta1))</span></code></pre></div>
<p>In the specialized version the typeclass operations placed directly
at the call site and are simply unboxed arithmetic. This will map to a
tight set of sequential CPU instructions and is very likely the same
code generated by C.</p>
<div class="sourceCode" id="cb1003"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1003-1"><a href="#cb1003-1" aria-hidden="true" tabindex="-1"></a><span class="ot">spec ::</span> <span class="dt">Double</span></span>
<span id="cb1003-2"><a href="#cb1003-2" aria-hidden="true" tabindex="-1"></a>spec <span class="ot">=</span> <span class="dt">D</span><span class="op">#</span> (<span class="op">*##</span> (expDouble<span class="op">#</span> <span class="fl">30.0</span>) (expDouble<span class="op">#</span> <span class="fl">30.0</span>))</span></code></pre></div>
<p>The non-specialized version has to project into the typeclass
dictionary (<code>$fFloatingFloat</code>) 6 times and likely go through
around 25 branches to perform the same operation.</p>
<div class="sourceCode" id="cb1004"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1004-1"><a href="#cb1004-1" aria-hidden="true" tabindex="-1"></a><span class="ot">nonspec ::</span> <span class="dt">Float</span></span>
<span id="cb1004-2"><a href="#cb1004-2" aria-hidden="true" tabindex="-1"></a>nonspec <span class="ot">=</span></span>
<span id="cb1004-3"><a href="#cb1004-3" aria-hidden="true" tabindex="-1"></a>  f <span class="op">@</span> <span class="dt">Float</span> <span class="op">$</span>fFloatingFloat (<span class="dt">F</span><span class="op">#</span> (__float <span class="fl">10.0</span>)) (<span class="dt">F</span><span class="op">#</span> (__float <span class="fl">20.0</span>))</span></code></pre></div>
<p>For a tight loop over numeric types specializing at the call site can
result in orders of magnitude performance increase. Although the cost in
compile-time can often be non-trivial and when used at many function
call-sites this can slow GHC’s simplifier pass to a crawl.</p>
<p>The best advice is profile and look for large uses of dictionary
projection in tight loops and then specialize and inline in these
places.</p>
<p>Using the <code>SPECIALISE INLINE</code> pragma can unintentionally
cause GHC to diverge if applied over a recursive function, it will try
to specialize itself infinitely.</p>
<h2 id="static-compilation">Static Compilation</h2>
<p>On Linux, Haskell programs can be compiled into a standalone
statically linked binary that includes the runtime statically linked
into it.</p>
<div class="sourceCode" id="cb1005"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1005-1"><a href="#cb1005-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc <span class="at">-O2</span> <span class="at">--make</span> <span class="at">-static</span> <span class="at">-optc-static</span> <span class="at">-optl-static</span> <span class="at">-optl-pthread</span> Example.hs</span>
<span id="cb1005-2"><a href="#cb1005-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> file Example</span>
<span id="cb1005-3"><a href="#cb1005-3" aria-hidden="true" tabindex="-1"></a><span class="ex">Example:</span> ELF 64-bit LSB executable, x86-64, version 1 <span class="er">(</span><span class="ex">GNU/Linux</span><span class="kw">)</span><span class="ex">,</span> statically linked, for GNU/Linux 2.6.32, not stripped</span>
<span id="cb1005-4"><a href="#cb1005-4" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ldd Example</span>
<span id="cb1005-5"><a href="#cb1005-5" aria-hidden="true" tabindex="-1"></a>        <span class="ex">not</span> a dynamic executable</span></code></pre></div>
<p>In addition the file size of the resulting binary can be reduced by
stripping unneeded symbols.</p>
<div class="sourceCode" id="cb1006"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1006-1"><a href="#cb1006-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> strip Example</span></code></pre></div>
<p><a href="http://upx.sourceforge.net/">upx</a> can additionally be
used to compress the size of the executable down further.</p>
<h2 id="unboxed-types">Unboxed Types</h2>
<p>The usual numerics types in Haskell can be considered to be a regular
algebraic datatype with special constructor arguments for their
underlying unboxed values. Normally unboxed types and explicit unboxing
are not used in normal code, they are wired-in to the compiler.</p>
<div class="sourceCode" id="cb1007"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1007-1"><a href="#cb1007-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Int</span> <span class="ot">=</span> <span class="dt">I</span><span class="op">#</span> <span class="dt">Int</span><span class="op">#</span></span>
<span id="cb1007-2"><a href="#cb1007-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1007-3"><a href="#cb1007-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Integer</span></span>
<span id="cb1007-4"><a href="#cb1007-4" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">S</span><span class="op">#</span> <span class="dt">Int</span><span class="op">#</span>              <span class="co">-- Small integers</span></span>
<span id="cb1007-5"><a href="#cb1007-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">J</span><span class="op">#</span> <span class="dt">Int</span><span class="op">#</span> <span class="dt">ByteArray</span><span class="op">#</span>   <span class="co">-- Large GMP integers</span></span>
<span id="cb1007-6"><a href="#cb1007-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1007-7"><a href="#cb1007-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Float</span> <span class="ot">=</span> <span class="dt">F</span><span class="op">#</span> <span class="dt">Float</span><span class="op">#</span></span></code></pre></div>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Syntax</th>
<th style="text-align: left;">Primitive Type</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>3#</code></td>
<td style="text-align: left;">GHC.Prim.Int#</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>3##</code></td>
<td style="text-align: left;">GHC.Prim.Word#</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>3.14#</code></td>
<td style="text-align: left;">GHC.Prim.Float#</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>3.14##</code></td>
<td style="text-align: left;">GHC.Prim.Double#</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>'c'#</code></td>
<td style="text-align: left;">GHC.Prim.Char#</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>"Haskell"##</code></td>
<td style="text-align: left;">GHC.Prim.Addr#</td>
</tr>
</tbody>
</table>
<p>An unboxed type has kind <code>#</code> and will never unify a type
variable of kind <code>*</code>. Intuitively a type with kind
<code>*</code> indicates a type with a uniform runtime representation
that can be used polymorphically.</p>
<ul>
<li><em>Lifted</em> - Can contain a bottom term, represented by a
pointer. ( <code>Int</code>, <code>Any</code>, <code>(,)</code> )</li>
<li><em>Unlited</em> - Cannot contain a bottom term, represented by a
value on the stack. ( <code>Int#</code>, <code>(#, #)</code> )</li>
</ul>
<div class="sourceCode" id="cb1008"
data-include="src/29-ghc/prim.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1008-1"><a href="#cb1008-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb1008-2"><a href="#cb1008-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MagicHash #-}</span></span>
<span id="cb1008-3"><a href="#cb1008-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UnboxedTuples #-}</span></span>
<span id="cb1008-4"><a href="#cb1008-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1008-5"><a href="#cb1008-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span></span>
<span id="cb1008-6"><a href="#cb1008-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Prim</span></span>
<span id="cb1008-7"><a href="#cb1008-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1008-8"><a href="#cb1008-8" aria-hidden="true" tabindex="-1"></a><span class="ot">ex1 ::</span> <span class="dt">Bool</span></span>
<span id="cb1008-9"><a href="#cb1008-9" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> isTrue<span class="op">#</span> (gtChar<span class="op">#</span> a<span class="op">#</span> b<span class="op">#</span>)</span>
<span id="cb1008-10"><a href="#cb1008-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1008-11"><a href="#cb1008-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>(<span class="dt">C</span><span class="op">#</span> a<span class="op">#</span>) <span class="ot">=</span> <span class="ch">&#39;a&#39;</span></span>
<span id="cb1008-12"><a href="#cb1008-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>(<span class="dt">C</span><span class="op">#</span> b<span class="op">#</span>) <span class="ot">=</span> <span class="ch">&#39;b&#39;</span></span>
<span id="cb1008-13"><a href="#cb1008-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1008-14"><a href="#cb1008-14" aria-hidden="true" tabindex="-1"></a><span class="ot">ex2 ::</span> <span class="dt">Int</span></span>
<span id="cb1008-15"><a href="#cb1008-15" aria-hidden="true" tabindex="-1"></a>ex2 <span class="ot">=</span> <span class="dt">I</span><span class="op">#</span> (a<span class="op">#</span> <span class="op">+#</span> b<span class="op">#</span>)</span>
<span id="cb1008-16"><a href="#cb1008-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1008-17"><a href="#cb1008-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>(<span class="dt">I</span><span class="op">#</span> a<span class="op">#</span>) <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb1008-18"><a href="#cb1008-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">!</span>(<span class="dt">I</span><span class="op">#</span> b<span class="op">#</span>) <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb1008-19"><a href="#cb1008-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1008-20"><a href="#cb1008-20" aria-hidden="true" tabindex="-1"></a><span class="ot">ex3 ::</span> <span class="dt">Int</span></span>
<span id="cb1008-21"><a href="#cb1008-21" aria-hidden="true" tabindex="-1"></a>ex3 <span class="ot">=</span> (<span class="dt">I</span><span class="op">#</span> (<span class="dv">1</span><span class="op">#</span> <span class="op">+#</span> <span class="dv">2</span><span class="op">#</span> <span class="op">*#</span> <span class="dv">3</span><span class="op">#</span> <span class="op">+#</span> <span class="dv">4</span><span class="op">#</span>))</span>
<span id="cb1008-22"><a href="#cb1008-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1008-23"><a href="#cb1008-23" aria-hidden="true" tabindex="-1"></a><span class="ot">ex4 ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb1008-24"><a href="#cb1008-24" aria-hidden="true" tabindex="-1"></a>ex4 <span class="ot">=</span> (<span class="dt">I</span><span class="op">#</span> (dataToTag<span class="op">#</span> <span class="dt">False</span>), <span class="dt">I</span><span class="op">#</span> (dataToTag<span class="op">#</span> <span class="dt">True</span>))</span></code></pre></div>
<p>The function for integer arithmetic used in the <code>Num</code>
typeclass for <code>Int</code> is just pattern matching on this type to
reveal the underlying unboxed value, performing the builtin arithmetic
and then performing the packing up into <code>Int</code> again.</p>
<div class="sourceCode" id="cb1009"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1009-1"><a href="#cb1009-1" aria-hidden="true" tabindex="-1"></a><span class="ot">plusInt ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1009-2"><a href="#cb1009-2" aria-hidden="true" tabindex="-1"></a>(<span class="dt">I</span><span class="op">#</span> x) <span class="ot">`plusInt`</span> (<span class="dt">I</span><span class="op">#</span> y) <span class="ot">=</span> <span class="dt">I</span><span class="op">#</span> (x <span class="op">+#</span> y)</span></code></pre></div>
<p>Where <code>(+#)</code> is a low level function built into GHC that
maps to intrinsic integer addition instruction for the CPU.</p>
<div class="sourceCode" id="cb1010"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1010-1"><a href="#cb1010-1" aria-hidden="true" tabindex="-1"></a><span class="ot">plusInt ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1010-2"><a href="#cb1010-2" aria-hidden="true" tabindex="-1"></a>plusInt a b <span class="ot">=</span> <span class="kw">case</span> a <span class="kw">of</span> {</span>
<span id="cb1010-3"><a href="#cb1010-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dt">I</span><span class="op">#</span> a_) <span class="ot">-&gt;</span> <span class="kw">case</span> b <span class="kw">of</span> {</span>
<span id="cb1010-4"><a href="#cb1010-4" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">I</span><span class="op">#</span> b_) <span class="ot">-&gt;</span> <span class="dt">I</span><span class="op">#</span> (<span class="op">+#</span> a_ b_);</span>
<span id="cb1010-5"><a href="#cb1010-5" aria-hidden="true" tabindex="-1"></a>    };</span>
<span id="cb1010-6"><a href="#cb1010-6" aria-hidden="true" tabindex="-1"></a>};</span></code></pre></div>
<p>Runtime values in Haskell are by default represented uniformly by a
boxed <code>StgClosure*</code> struct which itself contains several
payload values, which can themselves either be pointers to other boxed
values or to unboxed literal values that fit within the system word size
and are stored directly within the closure in memory. The layout of the
box is described by a bitmap in the header for the closure which
describes which values in the payload are either pointers or
non-pointers.</p>
<p>The <code>unpackClosure#</code> primop can be used to extract this
information at runtime by reading off the bitmap on the closure.</p>
<div class="sourceCode" id="cb1011"
data-include="src/29-ghc/closure_size.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1011-1"><a href="#cb1011-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MagicHash #-}</span></span>
<span id="cb1011-2"><a href="#cb1011-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UnboxedTuples #-}</span></span>
<span id="cb1011-3"><a href="#cb1011-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1011-4"><a href="#cb1011-4" aria-hidden="true" tabindex="-1"></a><span class="co">--{-# OPTIONS_GHC -O1 #-}</span></span>
<span id="cb1011-5"><a href="#cb1011-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1011-6"><a href="#cb1011-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb1011-7"><a href="#cb1011-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1011-8"><a href="#cb1011-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Foreign</span></span>
<span id="cb1011-9"><a href="#cb1011-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Base</span></span>
<span id="cb1011-10"><a href="#cb1011-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span></span>
<span id="cb1011-11"><a href="#cb1011-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1011-12"><a href="#cb1011-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Size</span></span>
<span id="cb1011-13"><a href="#cb1011-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Size</span></span>
<span id="cb1011-14"><a href="#cb1011-14" aria-hidden="true" tabindex="-1"></a>      {<span class="ot"> ptrs ::</span> <span class="dt">Int</span>,</span>
<span id="cb1011-15"><a href="#cb1011-15" aria-hidden="true" tabindex="-1"></a><span class="ot">        nptrs ::</span> <span class="dt">Int</span>,</span>
<span id="cb1011-16"><a href="#cb1011-16" aria-hidden="true" tabindex="-1"></a><span class="ot">        size ::</span> <span class="dt">Int</span></span>
<span id="cb1011-17"><a href="#cb1011-17" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb1011-18"><a href="#cb1011-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb1011-19"><a href="#cb1011-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1011-20"><a href="#cb1011-20" aria-hidden="true" tabindex="-1"></a><span class="ot">unsafeSizeof ::</span> a <span class="ot">-&gt;</span> <span class="dt">Size</span></span>
<span id="cb1011-21"><a href="#cb1011-21" aria-hidden="true" tabindex="-1"></a>unsafeSizeof a <span class="ot">=</span></span>
<span id="cb1011-22"><a href="#cb1011-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> unpackClosure<span class="op">#</span> a <span class="kw">of</span></span>
<span id="cb1011-23"><a href="#cb1011-23" aria-hidden="true" tabindex="-1"></a>    (<span class="op">#</span> x, ptrs, nptrs <span class="op">#</span>) <span class="ot">-&gt;</span></span>
<span id="cb1011-24"><a href="#cb1011-24" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> header <span class="ot">=</span> sizeOf (<span class="fu">undefined</span><span class="ot"> ::</span> <span class="dt">Int</span>)</span>
<span id="cb1011-25"><a href="#cb1011-25" aria-hidden="true" tabindex="-1"></a>          ptr_c <span class="ot">=</span> <span class="dt">I</span><span class="op">#</span> (sizeofArray<span class="op">#</span> ptrs)</span>
<span id="cb1011-26"><a href="#cb1011-26" aria-hidden="true" tabindex="-1"></a>          nptr_c <span class="ot">=</span> <span class="dt">I</span><span class="op">#</span> (sizeofByteArray<span class="op">#</span> nptrs) <span class="ot">`div`</span> sizeOf (<span class="fu">undefined</span><span class="ot"> ::</span> <span class="dt">Word</span>)</span>
<span id="cb1011-27"><a href="#cb1011-27" aria-hidden="true" tabindex="-1"></a>          payload <span class="ot">=</span> <span class="dt">I</span><span class="op">#</span> (sizeofArray<span class="op">#</span> ptrs <span class="op">+#</span> sizeofByteArray<span class="op">#</span> nptrs)</span>
<span id="cb1011-28"><a href="#cb1011-28" aria-hidden="true" tabindex="-1"></a>          size <span class="ot">=</span> header <span class="op">+</span> payload</span>
<span id="cb1011-29"><a href="#cb1011-29" aria-hidden="true" tabindex="-1"></a>       <span class="kw">in</span> <span class="dt">Size</span> ptr_c nptr_c size</span>
<span id="cb1011-30"><a href="#cb1011-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1011-31"><a href="#cb1011-31" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">A</span> <span class="ot">=</span> <span class="dt">A</span> <span class="ot">{-# UNPACK #-}</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb1011-32"><a href="#cb1011-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1011-33"><a href="#cb1011-33" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">B</span> <span class="ot">=</span> <span class="dt">B</span> <span class="dt">Int</span></span>
<span id="cb1011-34"><a href="#cb1011-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1011-35"><a href="#cb1011-35" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1011-36"><a href="#cb1011-36" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1011-37"><a href="#cb1011-37" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (unsafeSizeof (<span class="dt">A</span> <span class="dv">42</span>))</span>
<span id="cb1011-38"><a href="#cb1011-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> (unsafeSizeof (<span class="dt">B</span> <span class="dv">42</span>))</span></code></pre></div>
<p>For example the datatype with the <code>UNPACK</code> pragma contains
1 non-pointer and 0 pointers.</p>
<div class="sourceCode" id="cb1012"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1012-1"><a href="#cb1012-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">A</span> <span class="ot">=</span> <span class="dt">A</span> <span class="ot">{-# UNPACK #-}</span> <span class="op">!</span><span class="dt">Int</span></span>
<span id="cb1012-2"><a href="#cb1012-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Size</span> {ptrs <span class="ot">=</span> <span class="dv">0</span>, nptrs <span class="ot">=</span> <span class="dv">1</span>, size <span class="ot">=</span> <span class="dv">16</span>}</span></code></pre></div>
<p>While the default packed datatype contains 1 pointer and 0
non-pointers.</p>
<div class="sourceCode" id="cb1013"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1013-1"><a href="#cb1013-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">B</span> <span class="ot">=</span> <span class="dt">B</span> <span class="dt">Int</span></span>
<span id="cb1013-2"><a href="#cb1013-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Size</span> {ptrs <span class="ot">=</span> <span class="dv">1</span>, nptrs <span class="ot">=</span> <span class="dv">0</span>, size <span class="ot">=</span> <span class="dv">9</span>}</span></code></pre></div>
<p>The closure representation for data constructors are also “tagged” at
the runtime with the tag of the specific constructor. This is however
not a runtime type tag since there is no way to recover the type from
the tag as all constructors simply use the sequence (0, 1, 2, …). The
tag is used to discriminate cases in pattern matching. The builtin
<code>dataToTag#</code> can be used to pluck off the tag for an
arbitrary datatype. This is used in some cases when desugaring pattern
matches.</p>
<div class="sourceCode" id="cb1014"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1014-1"><a href="#cb1014-1" aria-hidden="true" tabindex="-1"></a>dataToTag<span class="op">#</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="op">#</span></span></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb1015"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1015-1"><a href="#cb1015-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- data Bool = False | True</span></span>
<span id="cb1015-2"><a href="#cb1015-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- False ~ 0</span></span>
<span id="cb1015-3"><a href="#cb1015-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- True  ~ 1</span></span>
<span id="cb1015-4"><a href="#cb1015-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1015-5"><a href="#cb1015-5" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb1015-6"><a href="#cb1015-6" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> (<span class="dt">I</span><span class="op">#</span> (dataToTag<span class="op">#</span> <span class="dt">False</span>), <span class="dt">I</span><span class="op">#</span> (dataToTag<span class="op">#</span> <span class="dt">True</span>))</span>
<span id="cb1015-7"><a href="#cb1015-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- (0, 1)</span></span>
<span id="cb1015-8"><a href="#cb1015-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1015-9"><a href="#cb1015-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- data Ordering = LT | EQ | GT</span></span>
<span id="cb1015-10"><a href="#cb1015-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- LT ~ 0</span></span>
<span id="cb1015-11"><a href="#cb1015-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- EQ ~ 1</span></span>
<span id="cb1015-12"><a href="#cb1015-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- GT ~ 2</span></span>
<span id="cb1015-13"><a href="#cb1015-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1015-14"><a href="#cb1015-14" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb1015-15"><a href="#cb1015-15" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> (<span class="dt">I</span><span class="op">#</span> (dataToTag<span class="op">#</span> <span class="dt">LT</span>), <span class="dt">I</span><span class="op">#</span> (dataToTag<span class="op">#</span> <span class="dt">EQ</span>), <span class="dt">I</span><span class="op">#</span> (dataToTag<span class="op">#</span> <span class="dt">GT</span>))</span>
<span id="cb1015-16"><a href="#cb1015-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- (0, 1, 2)</span></span>
<span id="cb1015-17"><a href="#cb1015-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1015-18"><a href="#cb1015-18" aria-hidden="true" tabindex="-1"></a><span class="co">-- data Either a b = Left a | Right b</span></span>
<span id="cb1015-19"><a href="#cb1015-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- Left ~ 0</span></span>
<span id="cb1015-20"><a href="#cb1015-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- Right ~ 1</span></span>
<span id="cb1015-21"><a href="#cb1015-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1015-22"><a href="#cb1015-22" aria-hidden="true" tabindex="-1"></a><span class="ot">c ::</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb1015-23"><a href="#cb1015-23" aria-hidden="true" tabindex="-1"></a>c <span class="ot">=</span> (<span class="dt">I</span><span class="op">#</span> (dataToTag<span class="op">#</span> (<span class="dt">Left</span> <span class="dv">0</span>)), <span class="dt">I</span><span class="op">#</span> (dataToTag<span class="op">#</span> (<span class="dt">Right</span> <span class="dv">1</span>)))</span>
<span id="cb1015-24"><a href="#cb1015-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- (0, 1)</span></span></code></pre></div>
<p>String literals included in the source code are also translated into
several primop operations. The <code>Addr#</code> type in Haskell stands
for a static contiguous buffer pre-allocated on the Haskell heap that
can hold a <code>char*</code> sequence. The operation
<code>unpackCString#</code> can scan this buffer and fold it up into a
list of Chars from inside Haskell.</p>
<div class="sourceCode" id="cb1016"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1016-1"><a href="#cb1016-1" aria-hidden="true" tabindex="-1"></a>unpackCString<span class="op">#</span><span class="ot"> ::</span> <span class="dt">Addr</span><span class="op">#</span> <span class="ot">-&gt;</span> [<span class="dt">Char</span>]</span></code></pre></div>
<p>This is done in the early frontend desugarer phase, where literals
are translated into <code>Addr#</code> inline instead of giant chain of
Cons’d characters. So our “Hello World” translates into the following
Core:</p>
<div class="sourceCode" id="cb1017"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1017-1"><a href="#cb1017-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- print &quot;Hello World&quot;</span></span>
<span id="cb1017-2"><a href="#cb1017-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> (unpackCString<span class="op">#</span> <span class="st">&quot;Hello World&quot;</span><span class="op">#</span>)</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="http://www.haskell.org/ghc/docs/papers/unboxed-values.ps.gz">Unboxed
Values as First-Class Citizens</a></li>
</ul>
<h2 id="iost">IO/ST</h2>
<p>Both the IO and the ST monad have special state in the GHC runtime
and share a very similar implementation. Both <code>ST a</code> and
<code>IO a</code> are passing around an unboxed tuple of the form:</p>
<div class="sourceCode" id="cb1018"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1018-1"><a href="#cb1018-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">#</span> token, a <span class="op">#</span>)</span></code></pre></div>
<p>The <code>RealWorld#</code> token is “deeply magical” and doesn’t
actually expand into any code when compiled, but simply threaded around
through every bind of the IO or ST monad and has several properties of
being unique and not being able to be duplicated to ensure sequential IO
actions are actually sequential. <code>unsafePerformIO</code> can
thought of as the unique operation which discards the world token and
plucks the <code>a</code> out, and is as the name implies not normally
safe.</p>
<p>The <code>PrimMonad</code> abstracts over both these monads with an
associated data family for the world token or ST thread, and can be used
to write operations that generic over both ST and IO. This is used
extensively inside of the vector package to allow vector algorithms to
be written generically either inside of IO or ST.</p>
<div class="sourceCode" id="cb1019"
data-include="src/29-ghc/io_impl.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1019-1"><a href="#cb1019-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MagicHash #-}</span></span>
<span id="cb1019-2"><a href="#cb1019-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UnboxedTuples #-}</span></span>
<span id="cb1019-3"><a href="#cb1019-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1019-4"><a href="#cb1019-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.IO</span> ( <span class="dt">IO</span>(..) )</span>
<span id="cb1019-5"><a href="#cb1019-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Prim</span> ( <span class="dt">State</span>#, <span class="dt">RealWorld</span> )</span>
<span id="cb1019-6"><a href="#cb1019-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Base</span> ( realWorld# )</span>
<span id="cb1019-7"><a href="#cb1019-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1019-8"><a href="#cb1019-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span>  <span class="dt">Monad</span> <span class="dt">IO</span>  <span class="kw">where</span></span>
<span id="cb1019-9"><a href="#cb1019-9" aria-hidden="true" tabindex="-1"></a>    m <span class="op">&gt;&gt;</span> k    <span class="ot">=</span> m <span class="op">&gt;&gt;=</span> \ _ <span class="ot">-&gt;</span> k</span>
<span id="cb1019-10"><a href="#cb1019-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>    <span class="ot">=</span> returnIO</span>
<span id="cb1019-11"><a href="#cb1019-11" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&gt;&gt;=</span>)     <span class="ot">=</span> bindIO</span>
<span id="cb1019-12"><a href="#cb1019-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fail</span> s    <span class="ot">=</span> failIO s</span>
<span id="cb1019-13"><a href="#cb1019-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1019-14"><a href="#cb1019-14" aria-hidden="true" tabindex="-1"></a><span class="ot">returnIO ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb1019-15"><a href="#cb1019-15" aria-hidden="true" tabindex="-1"></a>returnIO x <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \ s <span class="ot">-&gt;</span> (<span class="op">#</span> s, x <span class="op">#</span>)</span>
<span id="cb1019-16"><a href="#cb1019-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1019-17"><a href="#cb1019-17" aria-hidden="true" tabindex="-1"></a><span class="ot">bindIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb1019-18"><a href="#cb1019-18" aria-hidden="true" tabindex="-1"></a>bindIO (<span class="dt">IO</span> m) k <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \ s <span class="ot">-&gt;</span> <span class="kw">case</span> m s <span class="kw">of</span> (<span class="op">#</span> new_s, a <span class="op">#</span>) <span class="ot">-&gt;</span> unIO (k a) new_s</span>
<span id="cb1019-19"><a href="#cb1019-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1019-20"><a href="#cb1019-20" aria-hidden="true" tabindex="-1"></a><span class="ot">thenIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb1019-21"><a href="#cb1019-21" aria-hidden="true" tabindex="-1"></a>thenIO (<span class="dt">IO</span> m) k <span class="ot">=</span> <span class="dt">IO</span> <span class="op">$</span> \ s <span class="ot">-&gt;</span> <span class="kw">case</span> m s <span class="kw">of</span> (<span class="op">#</span> new_s, _ <span class="op">#</span>) <span class="ot">-&gt;</span> unIO k new_s</span>
<span id="cb1019-22"><a href="#cb1019-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1019-23"><a href="#cb1019-23" aria-hidden="true" tabindex="-1"></a><span class="ot">unIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (<span class="dt">State</span><span class="op">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> <span class="dt">RealWorld</span>, a <span class="op">#</span>))</span>
<span id="cb1019-24"><a href="#cb1019-24" aria-hidden="true" tabindex="-1"></a>unIO (<span class="dt">IO</span> a) <span class="ot">=</span> a</span></code></pre></div>
<div class="sourceCode" id="cb1020"
data-include="src/29-ghc/monad_prim.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1020-1"><a href="#cb1020-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MagicHash #-}</span></span>
<span id="cb1020-2"><a href="#cb1020-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UnboxedTuples #-}</span></span>
<span id="cb1020-3"><a href="#cb1020-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb1020-4"><a href="#cb1020-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1020-5"><a href="#cb1020-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.IO</span> ( <span class="dt">IO</span>(..) )</span>
<span id="cb1020-6"><a href="#cb1020-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.ST</span> ( <span class="dt">ST</span>(..) )</span>
<span id="cb1020-7"><a href="#cb1020-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Prim</span> ( <span class="dt">State</span>#, <span class="dt">RealWorld</span> )</span>
<span id="cb1020-8"><a href="#cb1020-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Base</span> ( realWorld# )</span>
<span id="cb1020-9"><a href="#cb1020-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1020-10"><a href="#cb1020-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">PrimMonad</span> m <span class="kw">where</span></span>
<span id="cb1020-11"><a href="#cb1020-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">PrimState</span> m</span>
<span id="cb1020-12"><a href="#cb1020-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  primitive ::</span> (<span class="dt">State</span><span class="op">#</span> (<span class="dt">PrimState</span> m) <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> (<span class="dt">PrimState</span> m), a <span class="op">#</span>)) <span class="ot">-&gt;</span> m a</span>
<span id="cb1020-13"><a href="#cb1020-13" aria-hidden="true" tabindex="-1"></a><span class="ot">  internal ::</span> m a <span class="ot">-&gt;</span> <span class="dt">State</span><span class="op">#</span> (<span class="dt">PrimState</span> m) <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> (<span class="dt">PrimState</span> m), a <span class="op">#</span>)</span>
<span id="cb1020-14"><a href="#cb1020-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1020-15"><a href="#cb1020-15" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">PrimMonad</span> <span class="dt">IO</span> <span class="kw">where</span></span>
<span id="cb1020-16"><a href="#cb1020-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">PrimState</span> <span class="dt">IO</span> <span class="ot">=</span> <span class="dt">RealWorld</span></span>
<span id="cb1020-17"><a href="#cb1020-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">primitive</span> <span class="ot">=</span> <span class="dt">IO</span></span>
<span id="cb1020-18"><a href="#cb1020-18" aria-hidden="true" tabindex="-1"></a>  internal (<span class="dt">IO</span> p) <span class="ot">=</span> p</span>
<span id="cb1020-19"><a href="#cb1020-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1020-20"><a href="#cb1020-20" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">PrimMonad</span> (<span class="dt">ST</span> s) <span class="kw">where</span></span>
<span id="cb1020-21"><a href="#cb1020-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">type</span> <span class="dt">PrimState</span> (<span class="dt">ST</span> s) <span class="ot">=</span> s</span>
<span id="cb1020-22"><a href="#cb1020-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">primitive</span> <span class="ot">=</span> <span class="dt">ST</span></span>
<span id="cb1020-23"><a href="#cb1020-23" aria-hidden="true" tabindex="-1"></a>  internal (<span class="dt">ST</span> p) <span class="ot">=</span> p</span></code></pre></div>
<h2 id="ghc-heap-view">ghc-heap-view</h2>
<p>Through some dark runtime magic we can actually inspect the
<code>StgClosure</code> structures at runtime using various C and Cmm
hacks to probe at the fields of the structure’s representation to the
runtime. The library <code>ghc-heap-view</code> can be used to
introspect such things, although there is really no use for this kind of
thing in everyday code it is very helpful when studying the GHC
internals to be able to inspect the runtime implementation details and
get at the raw bits underlying all Haskell types.</p>
<div class="sourceCode" id="cb1021"
data-include="src/29-ghc/heapview.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1021-1"><a href="#cb1021-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MagicHash #-}</span></span>
<span id="cb1021-2"><a href="#cb1021-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1021-3"><a href="#cb1021-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Exts</span></span>
<span id="cb1021-4"><a href="#cb1021-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.HeapView</span></span>
<span id="cb1021-5"><a href="#cb1021-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1021-6"><a href="#cb1021-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Mem</span></span>
<span id="cb1021-7"><a href="#cb1021-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1021-8"><a href="#cb1021-8" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1021-9"><a href="#cb1021-9" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1021-10"><a href="#cb1021-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Constr</span></span>
<span id="cb1021-11"><a href="#cb1021-11" aria-hidden="true" tabindex="-1"></a>  clo <span class="ot">&lt;-</span> getClosureData <span class="op">$!</span> ([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])</span>
<span id="cb1021-12"><a href="#cb1021-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> clo</span>
<span id="cb1021-13"><a href="#cb1021-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1021-14"><a href="#cb1021-14" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Thunk</span></span>
<span id="cb1021-15"><a href="#cb1021-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> thunk <span class="ot">=</span> <span class="fu">id</span> (<span class="dv">1</span><span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb1021-16"><a href="#cb1021-16" aria-hidden="true" tabindex="-1"></a>  clo <span class="ot">&lt;-</span> getClosureData thunk</span>
<span id="cb1021-17"><a href="#cb1021-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> clo</span>
<span id="cb1021-18"><a href="#cb1021-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1021-19"><a href="#cb1021-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- evaluate to WHNF</span></span>
<span id="cb1021-20"><a href="#cb1021-20" aria-hidden="true" tabindex="-1"></a>  thunk <span class="ot">`seq`</span> <span class="fu">return</span> ()</span>
<span id="cb1021-21"><a href="#cb1021-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1021-22"><a href="#cb1021-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Indirection</span></span>
<span id="cb1021-23"><a href="#cb1021-23" aria-hidden="true" tabindex="-1"></a>  clo <span class="ot">&lt;-</span> getClosureData thunk</span>
<span id="cb1021-24"><a href="#cb1021-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> clo</span>
<span id="cb1021-25"><a href="#cb1021-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1021-26"><a href="#cb1021-26" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- force garbage collection</span></span>
<span id="cb1021-27"><a href="#cb1021-27" aria-hidden="true" tabindex="-1"></a>  performGC</span>
<span id="cb1021-28"><a href="#cb1021-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1021-29"><a href="#cb1021-29" aria-hidden="true" tabindex="-1"></a>  <span class="co">-- Value</span></span>
<span id="cb1021-30"><a href="#cb1021-30" aria-hidden="true" tabindex="-1"></a>  clo <span class="ot">&lt;-</span> getClosureData thunk</span>
<span id="cb1021-31"><a href="#cb1021-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> clo</span></code></pre></div>
<p>A constructor (in this for cons constructor of list type) is
represented by a <code>CONSTR</code> closure that holds two pointers to
the head and the tail. The integer in the head argument is a static
reference to the pre-allocated number and we see a single static
reference in the SRT (static reference table).</p>
<div class="sourceCode" id="cb1022"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1022-1"><a href="#cb1022-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ConsClosure</span> {</span>
<span id="cb1022-2"><a href="#cb1022-2" aria-hidden="true" tabindex="-1"></a>  info <span class="ot">=</span> <span class="dt">StgInfoTable</span> {</span>
<span id="cb1022-3"><a href="#cb1022-3" aria-hidden="true" tabindex="-1"></a>    ptrs <span class="ot">=</span> <span class="dv">2</span>,</span>
<span id="cb1022-4"><a href="#cb1022-4" aria-hidden="true" tabindex="-1"></a>    nptrs <span class="ot">=</span> <span class="dv">0</span>,</span>
<span id="cb1022-5"><a href="#cb1022-5" aria-hidden="true" tabindex="-1"></a>    tipe <span class="ot">=</span> <span class="dt">CONSTR_2_0</span>,</span>
<span id="cb1022-6"><a href="#cb1022-6" aria-hidden="true" tabindex="-1"></a>    srtlen <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb1022-7"><a href="#cb1022-7" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb1022-8"><a href="#cb1022-8" aria-hidden="true" tabindex="-1"></a>  ptrArgs <span class="ot">=</span> [<span class="bn">0x000000000074aba8</span><span class="op">/</span><span class="dv">1</span>,<span class="bn">0x00007fca10504260</span><span class="op">/</span><span class="dv">2</span>],</span>
<span id="cb1022-9"><a href="#cb1022-9" aria-hidden="true" tabindex="-1"></a>  dataArgs <span class="ot">=</span> [],</span>
<span id="cb1022-10"><a href="#cb1022-10" aria-hidden="true" tabindex="-1"></a>  pkg <span class="ot">=</span> <span class="st">&quot;ghc-prim&quot;</span>,</span>
<span id="cb1022-11"><a href="#cb1022-11" aria-hidden="true" tabindex="-1"></a>  modl <span class="ot">=</span> <span class="st">&quot;GHC.Types&quot;</span>,</span>
<span id="cb1022-12"><a href="#cb1022-12" aria-hidden="true" tabindex="-1"></a>  name <span class="ot">=</span> <span class="st">&quot;:&quot;</span></span>
<span id="cb1022-13"><a href="#cb1022-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>We can also observe the evaluation and update of a thunk in process (
<code>id (1+1)</code> ). The initial thunk is simply a thunk type with a
pointer to the code to evaluate it to a value.</p>
<div class="sourceCode" id="cb1023"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1023-1"><a href="#cb1023-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ThunkClosure</span> {</span>
<span id="cb1023-2"><a href="#cb1023-2" aria-hidden="true" tabindex="-1"></a>  info <span class="ot">=</span> <span class="dt">StgInfoTable</span> {</span>
<span id="cb1023-3"><a href="#cb1023-3" aria-hidden="true" tabindex="-1"></a>    ptrs <span class="ot">=</span> <span class="dv">0</span>,</span>
<span id="cb1023-4"><a href="#cb1023-4" aria-hidden="true" tabindex="-1"></a>    nptrs <span class="ot">=</span> <span class="dv">0</span>,</span>
<span id="cb1023-5"><a href="#cb1023-5" aria-hidden="true" tabindex="-1"></a>    tipe <span class="ot">=</span> <span class="dt">THUNK</span>,</span>
<span id="cb1023-6"><a href="#cb1023-6" aria-hidden="true" tabindex="-1"></a>    srtlen <span class="ot">=</span> <span class="dv">9</span></span>
<span id="cb1023-7"><a href="#cb1023-7" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb1023-8"><a href="#cb1023-8" aria-hidden="true" tabindex="-1"></a>  ptrArgs <span class="ot">=</span> [],</span>
<span id="cb1023-9"><a href="#cb1023-9" aria-hidden="true" tabindex="-1"></a>  dataArgs <span class="ot">=</span> []</span>
<span id="cb1023-10"><a href="#cb1023-10" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>When forced it is then evaluated and replaced with an Indirection
closure which points at the computed value.</p>
<div class="sourceCode" id="cb1024"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1024-1"><a href="#cb1024-1" aria-hidden="true" tabindex="-1"></a><span class="dt">BlackholeClosure</span> {</span>
<span id="cb1024-2"><a href="#cb1024-2" aria-hidden="true" tabindex="-1"></a>  info <span class="ot">=</span> <span class="dt">StgInfoTable</span> {</span>
<span id="cb1024-3"><a href="#cb1024-3" aria-hidden="true" tabindex="-1"></a>    ptrs <span class="ot">=</span> <span class="dv">1</span>,</span>
<span id="cb1024-4"><a href="#cb1024-4" aria-hidden="true" tabindex="-1"></a>    nptrs <span class="ot">=</span> <span class="dv">0</span>,</span>
<span id="cb1024-5"><a href="#cb1024-5" aria-hidden="true" tabindex="-1"></a>    tipe <span class="ot">=</span> <span class="dt">BLACKHOLE</span>,</span>
<span id="cb1024-6"><a href="#cb1024-6" aria-hidden="true" tabindex="-1"></a>    srtlen <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb1024-7"><a href="#cb1024-7" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb1024-8"><a href="#cb1024-8" aria-hidden="true" tabindex="-1"></a>  indirectee <span class="ot">=</span> <span class="bn">0x00007fca10511e88</span><span class="op">/</span><span class="dv">1</span></span>
<span id="cb1024-9"><a href="#cb1024-9" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>When the copying garbage collector passes over the indirection, it
then simply replaces the indirection with a reference to the actual
computed value computed by <code>indirectee</code> so that future access
does need to chase a pointer through the indirection pointer to get the
result.</p>
<div class="sourceCode" id="cb1025"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1025-1"><a href="#cb1025-1" aria-hidden="true" tabindex="-1"></a><span class="dt">ConsClosure</span> {</span>
<span id="cb1025-2"><a href="#cb1025-2" aria-hidden="true" tabindex="-1"></a>  info <span class="ot">=</span> <span class="dt">StgInfoTable</span> {</span>
<span id="cb1025-3"><a href="#cb1025-3" aria-hidden="true" tabindex="-1"></a>    ptrs <span class="ot">=</span> <span class="dv">0</span>,</span>
<span id="cb1025-4"><a href="#cb1025-4" aria-hidden="true" tabindex="-1"></a>    nptrs <span class="ot">=</span> <span class="dv">1</span>,</span>
<span id="cb1025-5"><a href="#cb1025-5" aria-hidden="true" tabindex="-1"></a>    tipe <span class="ot">=</span> <span class="dt">CONSTR_0_1</span>,</span>
<span id="cb1025-6"><a href="#cb1025-6" aria-hidden="true" tabindex="-1"></a>    srtlen <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb1025-7"><a href="#cb1025-7" aria-hidden="true" tabindex="-1"></a>  },</span>
<span id="cb1025-8"><a href="#cb1025-8" aria-hidden="true" tabindex="-1"></a>  ptrArgs <span class="ot">=</span> [],</span>
<span id="cb1025-9"><a href="#cb1025-9" aria-hidden="true" tabindex="-1"></a>  dataArgs <span class="ot">=</span> [<span class="dv">2</span>],</span>
<span id="cb1025-10"><a href="#cb1025-10" aria-hidden="true" tabindex="-1"></a>  pkg <span class="ot">=</span> <span class="st">&quot;integer-gmp&quot;</span>,</span>
<span id="cb1025-11"><a href="#cb1025-11" aria-hidden="true" tabindex="-1"></a>  modl <span class="ot">=</span> <span class="st">&quot;GHC.Integer.Type&quot;</span>,</span>
<span id="cb1025-12"><a href="#cb1025-12" aria-hidden="true" tabindex="-1"></a>  name <span class="ot">=</span> <span class="st">&quot;S#&quot;</span></span>
<span id="cb1025-13"><a href="#cb1025-13" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<h2 id="stg">STG</h2>
<p>After being compiled into Core, a program is translated into a very
similar intermediate form known as STG ( Spineless Tagless G-Machine )
an abstract machine model that makes all laziness explicit. The
spineless indicates that function applications in the language do not
have a spine of applications of functions are collapsed into a sequence
of arguments. Currying is still present in the semantics since arity
information is stored and partially applied functions will evaluate
differently than saturated functions.</p>
<div class="sourceCode" id="cb1026"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1026-1"><a href="#cb1026-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Spine</span></span>
<span id="cb1026-2"><a href="#cb1026-2" aria-hidden="true" tabindex="-1"></a>f x y z <span class="ot">=</span> <span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">App</span> f x) y) z</span>
<span id="cb1026-3"><a href="#cb1026-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1026-4"><a href="#cb1026-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- Spineless</span></span>
<span id="cb1026-5"><a href="#cb1026-5" aria-hidden="true" tabindex="-1"></a>f x y z <span class="ot">=</span> <span class="dt">App</span> f [x, y, z]</span></code></pre></div>
<p>All let statements in STG bind a name to a <em>lambda form</em>. A
lambda form with no arguments is a thunk, while a lambda-form with
arguments indicates that a closure is to be allocated that captures the
variables explicitly mentioned.</p>
<p>Thunks themselves are either reentrant (<code>\r</code>) or updatable
(<code>\u</code>) indicating that the thunk and either yields a value to
the stack or is allocated on the heap after the update frame is
evaluated. All subsequent entries of the thunk will yield the
already-computed value without needing to redo the same work.</p>
<p>A lambda form also indicates the <em>static reference table</em> a
collection of references to static heap allocated values referred to by
the body of the function.</p>
<p>For example turning on <code>-ddump-stg</code> we can see the
expansion of the following compose function.</p>
<div class="sourceCode" id="cb1027"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1027-1"><a href="#cb1027-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Frontend</span></span>
<span id="cb1027-2"><a href="#cb1027-2" aria-hidden="true" tabindex="-1"></a>compose f g <span class="ot">=</span> \x <span class="ot">-&gt;</span> f (g x)</span></code></pre></div>
<div class="sourceCode" id="cb1028"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1028-1"><a href="#cb1028-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Core</span></span>
<span id="cb1028-2"><a href="#cb1028-2" aria-hidden="true" tabindex="-1"></a><span class="ot">compose ::</span> <span class="kw">forall</span> t t1 t2<span class="op">.</span> (t1 <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> (t2 <span class="ot">-&gt;</span> t1) <span class="ot">-&gt;</span> t2 <span class="ot">-&gt;</span> t</span>
<span id="cb1028-3"><a href="#cb1028-3" aria-hidden="true" tabindex="-1"></a>compose <span class="ot">=</span></span>
<span id="cb1028-4"><a href="#cb1028-4" aria-hidden="true" tabindex="-1"></a>  \ (<span class="op">@</span> t) (<span class="op">@</span> t1) (<span class="op">@</span> t2) (<span class="ot">f ::</span> t1 <span class="ot">-&gt;</span> t) (<span class="ot">g ::</span> t2 <span class="ot">-&gt;</span> t1) (<span class="ot">x ::</span> t2) <span class="ot">-&gt;</span></span>
<span id="cb1028-5"><a href="#cb1028-5" aria-hidden="true" tabindex="-1"></a>    f (g x)</span></code></pre></div>
<div class="sourceCode" id="cb1029"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1029-1"><a href="#cb1029-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- STG</span></span>
<span id="cb1029-2"><a href="#cb1029-2" aria-hidden="true" tabindex="-1"></a><span class="ot">compose ::</span> <span class="kw">forall</span> t t1 t2<span class="op">.</span> (t1 <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> (t2 <span class="ot">-&gt;</span> t1) <span class="ot">-&gt;</span> t2 <span class="ot">-&gt;</span> t <span class="ot">=</span></span>
<span id="cb1029-3"><a href="#cb1029-3" aria-hidden="true" tabindex="-1"></a>    \r [f g x] <span class="kw">let</span> {<span class="ot"> sat ::</span> t1 <span class="ot">=</span> \u [] g x; } <span class="kw">in</span>  f sat;</span>
<span id="cb1029-4"><a href="#cb1029-4" aria-hidden="true" tabindex="-1"></a><span class="dt">SRT</span>(compose)<span class="op">:</span> []</span></code></pre></div>
<p>For a more sophisticated example, let’s trace the compilation of the
factorial function.</p>
<div class="sourceCode" id="cb1030"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1030-1"><a href="#cb1030-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Frontend</span></span>
<span id="cb1030-2"><a href="#cb1030-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1030-3"><a href="#cb1030-3" aria-hidden="true" tabindex="-1"></a>fac a <span class="dv">0</span> <span class="ot">=</span> a</span>
<span id="cb1030-4"><a href="#cb1030-4" aria-hidden="true" tabindex="-1"></a>fac a n <span class="ot">=</span> fac (n<span class="op">*</span>a) (n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<div class="sourceCode" id="cb1031"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1031-1"><a href="#cb1031-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Core</span></span>
<span id="cb1031-2"><a href="#cb1031-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Rec</span> {</span>
<span id="cb1031-3"><a href="#cb1031-3" aria-hidden="true" tabindex="-1"></a><span class="ot">fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1031-4"><a href="#cb1031-4" aria-hidden="true" tabindex="-1"></a>fac <span class="ot">=</span></span>
<span id="cb1031-5"><a href="#cb1031-5" aria-hidden="true" tabindex="-1"></a>  \ (<span class="ot">a ::</span> <span class="dt">Int</span>) (<span class="ot">ds ::</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span></span>
<span id="cb1031-6"><a href="#cb1031-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> ds <span class="kw">of</span> wild { <span class="dt">I</span><span class="op">#</span> ds1 <span class="ot">-&gt;</span></span>
<span id="cb1031-7"><a href="#cb1031-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> ds1 <span class="kw">of</span> _ {</span>
<span id="cb1031-8"><a href="#cb1031-8" aria-hidden="true" tabindex="-1"></a>      __DEFAULT <span class="ot">-&gt;</span></span>
<span id="cb1031-9"><a href="#cb1031-9" aria-hidden="true" tabindex="-1"></a>        fac (<span class="op">*</span> <span class="op">@</span> <span class="dt">Int</span> <span class="op">$</span>fNumInt wild a) (<span class="op">-</span> <span class="op">@</span> <span class="dt">Int</span> <span class="op">$</span>fNumInt wild (<span class="dt">I</span><span class="op">#</span> <span class="dv">1</span>));</span>
<span id="cb1031-10"><a href="#cb1031-10" aria-hidden="true" tabindex="-1"></a>      <span class="dv">0</span> <span class="ot">-&gt;</span> a</span>
<span id="cb1031-11"><a href="#cb1031-11" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1031-12"><a href="#cb1031-12" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1031-13"><a href="#cb1031-13" aria-hidden="true" tabindex="-1"></a>end <span class="dt">Rec</span> }</span></code></pre></div>
<div class="sourceCode" id="cb1032"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1032-1"><a href="#cb1032-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- STG</span></span>
<span id="cb1032-2"><a href="#cb1032-2" aria-hidden="true" tabindex="-1"></a><span class="ot">fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">=</span></span>
<span id="cb1032-3"><a href="#cb1032-3" aria-hidden="true" tabindex="-1"></a>    \r srt<span class="op">:</span>(<span class="dv">0</span>,<span class="op">*</span>bitmap<span class="op">*</span>) [a ds]</span>
<span id="cb1032-4"><a href="#cb1032-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> ds <span class="kw">of</span> wild {</span>
<span id="cb1032-5"><a href="#cb1032-5" aria-hidden="true" tabindex="-1"></a>          <span class="dt">I</span><span class="op">#</span> ds1 <span class="ot">-&gt;</span></span>
<span id="cb1032-6"><a href="#cb1032-6" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> ds1 <span class="kw">of</span> _ {</span>
<span id="cb1032-7"><a href="#cb1032-7" aria-hidden="true" tabindex="-1"></a>                __DEFAULT <span class="ot">-&gt;</span></span>
<span id="cb1032-8"><a href="#cb1032-8" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> {</span>
<span id="cb1032-9"><a href="#cb1032-9" aria-hidden="true" tabindex="-1"></a><span class="ot">                      sat ::</span> <span class="dt">Int</span> <span class="ot">=</span></span>
<span id="cb1032-10"><a href="#cb1032-10" aria-hidden="true" tabindex="-1"></a>                          \u srt<span class="op">:</span>(<span class="dv">1</span>,<span class="op">*</span>bitmap<span class="op">*</span>) []</span>
<span id="cb1032-11"><a href="#cb1032-11" aria-hidden="true" tabindex="-1"></a>                              <span class="kw">let</span> {<span class="ot"> sat ::</span> <span class="dt">Int</span> <span class="ot">=</span> <span class="dt">NO_CCS</span> <span class="dt">I</span><span class="op">#!</span> [<span class="dv">1</span>]; } <span class="kw">in</span>  <span class="op">-</span> <span class="op">$</span>fNumInt wild sat; } <span class="kw">in</span></span>
<span id="cb1032-12"><a href="#cb1032-12" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">let</span> {<span class="ot"> sat ::</span> <span class="dt">Int</span> <span class="ot">=</span> \u srt<span class="op">:</span>(<span class="dv">1</span>,<span class="op">*</span>bitmap<span class="op">*</span>) [] <span class="op">*</span> <span class="op">$</span>fNumInt wild a;</span>
<span id="cb1032-13"><a href="#cb1032-13" aria-hidden="true" tabindex="-1"></a>                    } <span class="kw">in</span>  fac sat sat;</span>
<span id="cb1032-14"><a href="#cb1032-14" aria-hidden="true" tabindex="-1"></a>                <span class="dv">0</span> <span class="ot">-&gt;</span> a;</span>
<span id="cb1032-15"><a href="#cb1032-15" aria-hidden="true" tabindex="-1"></a>              };</span>
<span id="cb1032-16"><a href="#cb1032-16" aria-hidden="true" tabindex="-1"></a>        };</span>
<span id="cb1032-17"><a href="#cb1032-17" aria-hidden="true" tabindex="-1"></a><span class="dt">SRT</span>(fac)<span class="op">:</span> [fac, <span class="op">$</span>fNumInt]</span></code></pre></div>
<p>Notice that the factorial function allocates two thunks ( look for
<code>\u</code>) inside of the loop which are updated when computed. It
also includes static references to both itself (for recursion) and the
dictionary for instance of <code>Num</code> typeclass over the type
<code>Int</code>.</p>
<p>The type system of STG system consists of the following types. The
size of these types depend on the size of a <code>void*</code> pointer
on the architecture.</p>
<ul>
<li><strong>StgWord</strong> - An unsigned system integer type of word
size</li>
<li><strong>StgPtr</strong> - Basic pointer type</li>
<li><strong>StgBool</strong> - Boolean int bit flag</li>
<li><strong>StgInt</strong> - <code>Int#</code></li>
<li><strong>StgChar</strong> - <code>Char#</code></li>
<li><strong>StgFloat</strong> - <code>Float#</code></li>
<li><strong>StgDouble</strong> - <code>Double#</code></li>
<li><strong>StgAddr</strong> - <code>Addr#</code> (<code>void *</code>
pointer)</li>
<li><strong>StgStablePtr</strong> - <code>StablePtr#</code></li>
<li><strong>StgOffset</strong> - Byte offset within a closure</li>
<li><strong>StgFunPtr</strong> - Pointer to a C functions</li>
<li><strong>StgVolatilePtr</strong> - Pointer to a volatile word</li>
</ul>
<h2 id="workerwrapper">Worker/Wrapper</h2>
<p>With <code>-O2</code> turned on GHC will perform a special
optimization known as the Worker-Wrapper transformation which will split
the logic of the factorial function across two definitions, the worker
will operate over stack unboxed allocated machine integers which
compiles into a tight inner loop while the wrapper calls into the worker
and collects the end result of the loop and packages it back up into a
boxed heap value. This can often be an order of of magnitude faster than
the naive implementation which needs to pack and unpack the boxed
integers on every iteration.</p>
<div class="sourceCode" id="cb1033"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1033-1"><a href="#cb1033-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- Worker</span></span>
<span id="cb1033-2"><a href="#cb1033-2" aria-hidden="true" tabindex="-1"></a><span class="op">$</span><span class="ot">wfac ::</span> <span class="dt">Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="op">#</span> <span class="ot">=</span></span>
<span id="cb1033-3"><a href="#cb1033-3" aria-hidden="true" tabindex="-1"></a>    \r [ww ww1]</span>
<span id="cb1033-4"><a href="#cb1033-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> ww1 <span class="kw">of</span> ds {</span>
<span id="cb1033-5"><a href="#cb1033-5" aria-hidden="true" tabindex="-1"></a>          __DEFAULT <span class="ot">-&gt;</span></span>
<span id="cb1033-6"><a href="#cb1033-6" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> <span class="op">-#</span> [ds <span class="dv">1</span>] <span class="kw">of</span> sat {</span>
<span id="cb1033-7"><a href="#cb1033-7" aria-hidden="true" tabindex="-1"></a>                __DEFAULT <span class="ot">-&gt;</span></span>
<span id="cb1033-8"><a href="#cb1033-8" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">case</span> <span class="op">*#</span> [ds ww] <span class="kw">of</span> sat { __DEFAULT <span class="ot">-&gt;</span> <span class="op">$</span>wfac sat sat; };</span>
<span id="cb1033-9"><a href="#cb1033-9" aria-hidden="true" tabindex="-1"></a>              };</span>
<span id="cb1033-10"><a href="#cb1033-10" aria-hidden="true" tabindex="-1"></a>          <span class="dv">0</span> <span class="ot">-&gt;</span> ww;</span>
<span id="cb1033-11"><a href="#cb1033-11" aria-hidden="true" tabindex="-1"></a>        };</span>
<span id="cb1033-12"><a href="#cb1033-12" aria-hidden="true" tabindex="-1"></a><span class="dt">SRT</span>(<span class="op">$</span>wfac)<span class="op">:</span> []</span>
<span id="cb1033-13"><a href="#cb1033-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1033-14"><a href="#cb1033-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- Wrapper</span></span>
<span id="cb1033-15"><a href="#cb1033-15" aria-hidden="true" tabindex="-1"></a><span class="ot">fac ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">=</span></span>
<span id="cb1033-16"><a href="#cb1033-16" aria-hidden="true" tabindex="-1"></a>    \r [w w1]</span>
<span id="cb1033-17"><a href="#cb1033-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">case</span> w <span class="kw">of</span> _ {</span>
<span id="cb1033-18"><a href="#cb1033-18" aria-hidden="true" tabindex="-1"></a>          <span class="dt">I</span><span class="op">#</span> ww <span class="ot">-&gt;</span></span>
<span id="cb1033-19"><a href="#cb1033-19" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> w1 <span class="kw">of</span> _ {</span>
<span id="cb1033-20"><a href="#cb1033-20" aria-hidden="true" tabindex="-1"></a>                <span class="dt">I</span><span class="op">#</span> ww1 <span class="ot">-&gt;</span> <span class="kw">case</span> <span class="op">$</span>wfac ww ww1 <span class="kw">of</span> ww2 { __DEFAULT <span class="ot">-&gt;</span> <span class="dt">I</span><span class="op">#</span> [ww2]; };</span>
<span id="cb1033-21"><a href="#cb1033-21" aria-hidden="true" tabindex="-1"></a>              };</span>
<span id="cb1033-22"><a href="#cb1033-22" aria-hidden="true" tabindex="-1"></a>        };</span>
<span id="cb1033-23"><a href="#cb1033-23" aria-hidden="true" tabindex="-1"></a><span class="dt">SRT</span>(fac)<span class="op">:</span> []</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="https://donsbot.wordpress.com/2008/05/06/write-haskell-as-fast-as-c-exploiting-strictness-laziness-and-recursion/">Writing
Haskell as Fast as C</a></li>
</ul>
<h2 id="z-encoding">Z-Encoding</h2>
<p>The Z-encoding is Haskell’s convention for generating names that are
safely represented in the compiler target language. Simply put the
z-encoding renames many symbolic characters into special sequences of
the z character.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">String</th>
<th style="text-align: left;">Z-Encoded String</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>foo</code></td>
<td style="text-align: left;"><code>foo</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>z</code></td>
<td style="text-align: left;"><code>zz</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Z</code></td>
<td style="text-align: left;"><code>ZZ</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>()</code></td>
<td style="text-align: left;"><code>Z0T</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>(,)</code></td>
<td style="text-align: left;"><code>Z2T</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>(,,)</code></td>
<td style="text-align: left;"><code>Z3T</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>_</code></td>
<td style="text-align: left;"><code>zu</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>(</code></td>
<td style="text-align: left;"><code>ZL</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>)</code></td>
<td style="text-align: left;"><code>ZR</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>:</code></td>
<td style="text-align: left;"><code>ZC</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>#</code></td>
<td style="text-align: left;"><code>zh</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>.</code></td>
<td style="text-align: left;"><code>zi</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>(#,#)</code></td>
<td style="text-align: left;"><code>Z2H</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>(-&gt;)</code></td>
<td style="text-align: left;"><code>ZLzmzgZR</code></td>
</tr>
</tbody>
</table>
<p>In this way we don’t have to generate unique unidentifiable names for
character rich names and can simply have a straightforward way to
translate them into something unique but identifiable.</p>
<p>So for some example names from GHC generated code:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Z-Encoded String</th>
<th style="text-align: left;">Decoded String</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>ZCMain_main_closure</code></td>
<td style="text-align: left;"><code>:Main_main_closure</code></td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>base_GHCziBase_map_closure</code></td>
<td
style="text-align: left;"><code>base_GHC.Base_map_closure</code></td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>base_GHCziInt_I32zh_con_info</code></td>
<td
style="text-align: left;"><code>base_GHC.Int_I32#_con_info</code></td>
</tr>
<tr class="even">
<td
style="text-align: left;"><code>ghczmprim_GHCziTuple_Z3T_con_info</code></td>
<td
style="text-align: left;"><code>ghc-prim_GHC.Tuple_(,,)_con_in</code></td>
</tr>
<tr class="odd">
<td
style="text-align: left;"><code>ghczmprim_GHCziTypes_ZC_con_info</code></td>
<td
style="text-align: left;"><code>ghc-prim_GHC.Types_:_con_info</code></td>
</tr>
</tbody>
</table>
<h2 id="cmm">Cmm</h2>
<p>Cmm is GHC’s complex internal intermediate representation that maps
directly onto the generated code for the compiler target. Cmm code
generated from Haskell is CPS-converted, all functions never return a
value, they simply call the next frame in the continuation stack. All
evaluation of functions proceed by indirectly jumping to a code object
with its arguments placed on the stack by the caller.</p>
<p>This is drastically different than C’s evaluation model, where are
placed on the stack and a function yields a value to the stack after it
returns.</p>
<p>There are several common suffixes you’ll see used in all closures and
function names:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Symbol</th>
<th style="text-align: left;">Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>0</code></td>
<td style="text-align: left;">No argument</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>p</code></td>
<td style="text-align: left;">Garbage Collected Pointer</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>n</code></td>
<td style="text-align: left;">Word-sized non-pointer</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>l</code></td>
<td style="text-align: left;">64-bit non-pointer (long)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>v</code></td>
<td style="text-align: left;">Void</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>f</code></td>
<td style="text-align: left;">Float</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>d</code></td>
<td style="text-align: left;">Double</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>v16</code></td>
<td style="text-align: left;">16-byte vector</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>v32</code></td>
<td style="text-align: left;">32-byte vector</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>v64</code></td>
<td style="text-align: left;">64-byte vector</td>
</tr>
</tbody>
</table>
<p><strong>Cmm Registers</strong></p>
<p>There are 10 registers that described in the machine model.
<strong>Sp</strong> is the pointer to top of the stack,
<strong>SpLim</strong> is the pointer to last element in the stack.
<strong>Hp</strong> is the heap pointer, used for allocation and garbage
collection with <strong>HpLim</strong> the current heap limit.</p>
<p>The <strong>R1</strong> register always holds the active closure, and
subsequent registers are arguments passed in registers. Functions with
more than 10 values spill into memory.</p>
<ul>
<li><code>Sp</code></li>
<li><code>SpLim</code></li>
<li><code>Hp</code></li>
<li><code>HpLim</code></li>
<li><code>HpAlloc</code></li>
<li><code>R1</code></li>
<li><code>R2</code></li>
<li><code>R3</code></li>
<li><code>R4</code></li>
<li><code>R5</code></li>
<li><code>R6</code></li>
<li><code>R7</code></li>
<li><code>R8</code></li>
<li><code>R9</code></li>
<li><code>R10</code></li>
</ul>
<p><strong>Examples</strong></p>
<p>To understand Cmm it is useful to look at the code generated by the
equivalent Haskell and slowly understand the equivalence and mechanical
translation maps one to the other.</p>
<p>There are generally two parts to every Cmm definition, the
<strong>info table</strong> and the <strong>entry code</strong>. The
info table maps directly <code>StgInfoTable</code> struct and contains
various fields related to the type of the closure, its payload, and
references. The code objects are basic blocks of generated code that
correspond to the logic of the Haskell function/constructor.</p>
<p>For the simplest example consider a constant static constructor.
Simply a function which yields the Unit value. In this case the function
is simply a constructor with no payload, and is statically
allocated.</p>
<p>Lets consider a few examples to develop some intuition about the Cmm
layout for simple Haskell programs.</p>

<p>Haskell:</p>
<div class="sourceCode" id="cb1034"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1034-1"><a href="#cb1034-1" aria-hidden="true" tabindex="-1"></a>unit <span class="ot">=</span> ()</span></code></pre></div>
<p>Cmm:</p>
<div class="sourceCode" id="cb1035"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1035-1"><a href="#cb1035-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span>section <span class="st">&quot;data&quot;</span> <span class="op">{</span></span>
<span id="cb1035-2"><a href="#cb1035-2" aria-hidden="true" tabindex="-1"></a>     unit_closure<span class="op">:</span></span>
<span id="cb1035-3"><a href="#cb1035-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> <span class="op">()</span>_static_info<span class="op">;</span></span>
<span id="cb1035-4"><a href="#cb1035-4" aria-hidden="true" tabindex="-1"></a> <span class="op">}]</span></span></code></pre></div>

<p>Consider a static constructor with an argument.</p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1036"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1036-1"><a href="#cb1036-1" aria-hidden="true" tabindex="-1"></a><span class="ot">con ::</span> <span class="dt">Maybe</span> ()</span>
<span id="cb1036-2"><a href="#cb1036-2" aria-hidden="true" tabindex="-1"></a>con <span class="ot">=</span> <span class="dt">Just</span> ()</span></code></pre></div>
<p>Cmm:</p>
<div class="sourceCode" id="cb1037"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1037-1"><a href="#cb1037-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span>section <span class="st">&quot;data&quot;</span> <span class="op">{</span></span>
<span id="cb1037-2"><a href="#cb1037-2" aria-hidden="true" tabindex="-1"></a>     con_closure<span class="op">:</span></span>
<span id="cb1037-3"><a href="#cb1037-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> Just_static_info<span class="op">;</span></span>
<span id="cb1037-4"><a href="#cb1037-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> <span class="op">()</span>_closure<span class="op">+</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb1037-5"><a href="#cb1037-5" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1037-6"><a href="#cb1037-6" aria-hidden="true" tabindex="-1"></a> <span class="op">}]</span></span></code></pre></div>

<p>Consider a literal constant. This is a static value.</p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1038"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1038-1"><a href="#cb1038-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lit ::</span> <span class="dt">Int</span></span>
<span id="cb1038-2"><a href="#cb1038-2" aria-hidden="true" tabindex="-1"></a>lit <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
<p>Cmm:</p>
<div class="sourceCode" id="cb1039"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1039-1"><a href="#cb1039-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span>section <span class="st">&quot;data&quot;</span> <span class="op">{</span></span>
<span id="cb1039-2"><a href="#cb1039-2" aria-hidden="true" tabindex="-1"></a>     lit_closure<span class="op">:</span></span>
<span id="cb1039-3"><a href="#cb1039-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> I<span class="er">#_static_info;</span></span>
<span id="cb1039-4"><a href="#cb1039-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1039-5"><a href="#cb1039-5" aria-hidden="true" tabindex="-1"></a> <span class="op">}]</span></span></code></pre></div>

<p>Consider the identity function.</p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1040"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1040-1"><a href="#cb1040-1" aria-hidden="true" tabindex="-1"></a><span class="fu">id</span> x <span class="ot">=</span> x</span></code></pre></div>
<p>Cmm:</p>
<div class="sourceCode" id="cb1041"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1041-1"><a href="#cb1041-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span>section <span class="st">&quot;data&quot;</span> <span class="op">{</span></span>
<span id="cb1041-2"><a href="#cb1041-2" aria-hidden="true" tabindex="-1"></a>     id_closure<span class="op">:</span></span>
<span id="cb1041-3"><a href="#cb1041-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> id_info<span class="op">;</span></span>
<span id="cb1041-4"><a href="#cb1041-4" aria-hidden="true" tabindex="-1"></a> <span class="op">},</span></span>
<span id="cb1041-5"><a href="#cb1041-5" aria-hidden="true" tabindex="-1"></a> id_info<span class="op">()</span></span>
<span id="cb1041-6"><a href="#cb1041-6" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> label<span class="op">:</span> id_info</span>
<span id="cb1041-7"><a href="#cb1041-7" aria-hidden="true" tabindex="-1"></a>           rep<span class="op">:</span>HeapRep <span class="at">static</span> <span class="op">{</span> Fun <span class="op">{</span>arity<span class="op">:</span> <span class="dv">1</span> <span class="dt">fun_type</span><span class="op">:</span> ArgSpec <span class="dv">5</span><span class="op">}</span> <span class="op">}</span></span>
<span id="cb1041-8"><a href="#cb1041-8" aria-hidden="true" tabindex="-1"></a>         <span class="op">}</span></span>
<span id="cb1041-9"><a href="#cb1041-9" aria-hidden="true" tabindex="-1"></a>     ch1<span class="op">:</span></span>
<span id="cb1041-10"><a href="#cb1041-10" aria-hidden="true" tabindex="-1"></a>         R1 <span class="op">=</span> R2<span class="op">;</span></span>
<span id="cb1041-11"><a href="#cb1041-11" aria-hidden="true" tabindex="-1"></a>         jump stg_ap_0_fast<span class="op">;</span> <span class="co">// [R1]</span></span>
<span id="cb1041-12"><a href="#cb1041-12" aria-hidden="true" tabindex="-1"></a> <span class="op">}]</span></span></code></pre></div>

<p>Consider the constant function.</p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1042"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1042-1"><a href="#cb1042-1" aria-hidden="true" tabindex="-1"></a>constant x y <span class="ot">=</span> x</span></code></pre></div>
<p>Cmm:</p>
<div class="sourceCode" id="cb1043"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1043-1"><a href="#cb1043-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span>section <span class="st">&quot;data&quot;</span> <span class="op">{</span></span>
<span id="cb1043-2"><a href="#cb1043-2" aria-hidden="true" tabindex="-1"></a>     constant_closure<span class="op">:</span></span>
<span id="cb1043-3"><a href="#cb1043-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> constant_info<span class="op">;</span></span>
<span id="cb1043-4"><a href="#cb1043-4" aria-hidden="true" tabindex="-1"></a> <span class="op">},</span></span>
<span id="cb1043-5"><a href="#cb1043-5" aria-hidden="true" tabindex="-1"></a> constant_info<span class="op">()</span></span>
<span id="cb1043-6"><a href="#cb1043-6" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> label<span class="op">:</span> constant_info</span>
<span id="cb1043-7"><a href="#cb1043-7" aria-hidden="true" tabindex="-1"></a>           rep<span class="op">:</span>HeapRep <span class="at">static</span> <span class="op">{</span> Fun <span class="op">{</span>arity<span class="op">:</span> <span class="dv">2</span> <span class="dt">fun_type</span><span class="op">:</span> ArgSpec <span class="dv">12</span><span class="op">}</span> <span class="op">}</span></span>
<span id="cb1043-8"><a href="#cb1043-8" aria-hidden="true" tabindex="-1"></a>         <span class="op">}</span></span>
<span id="cb1043-9"><a href="#cb1043-9" aria-hidden="true" tabindex="-1"></a>     cgT<span class="op">:</span></span>
<span id="cb1043-10"><a href="#cb1043-10" aria-hidden="true" tabindex="-1"></a>         R1 <span class="op">=</span> R2<span class="op">;</span></span>
<span id="cb1043-11"><a href="#cb1043-11" aria-hidden="true" tabindex="-1"></a>         jump stg_ap_0_fast<span class="op">;</span> <span class="co">// [R1]</span></span>
<span id="cb1043-12"><a href="#cb1043-12" aria-hidden="true" tabindex="-1"></a> <span class="op">}]</span></span></code></pre></div>

<p>Consider a function where application of a function ( of unknown
arity ) occurs.</p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1044"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1044-1"><a href="#cb1044-1" aria-hidden="true" tabindex="-1"></a>compose f g x <span class="ot">=</span> f (g x)</span></code></pre></div>
<p>Cmm:</p>
<div class="sourceCode" id="cb1045"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1045-1"><a href="#cb1045-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span>section <span class="st">&quot;data&quot;</span> <span class="op">{</span></span>
<span id="cb1045-2"><a href="#cb1045-2" aria-hidden="true" tabindex="-1"></a>     compose_closure<span class="op">:</span></span>
<span id="cb1045-3"><a href="#cb1045-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> compose_info<span class="op">;</span></span>
<span id="cb1045-4"><a href="#cb1045-4" aria-hidden="true" tabindex="-1"></a> <span class="op">},</span></span>
<span id="cb1045-5"><a href="#cb1045-5" aria-hidden="true" tabindex="-1"></a> compose_info<span class="op">()</span></span>
<span id="cb1045-6"><a href="#cb1045-6" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> label<span class="op">:</span> compose_info</span>
<span id="cb1045-7"><a href="#cb1045-7" aria-hidden="true" tabindex="-1"></a>           rep<span class="op">:</span>HeapRep <span class="at">static</span> <span class="op">{</span> Fun <span class="op">{</span>arity<span class="op">:</span> <span class="dv">3</span> <span class="dt">fun_type</span><span class="op">:</span> ArgSpec <span class="dv">20</span><span class="op">}</span> <span class="op">}</span></span>
<span id="cb1045-8"><a href="#cb1045-8" aria-hidden="true" tabindex="-1"></a>         <span class="op">}</span></span>
<span id="cb1045-9"><a href="#cb1045-9" aria-hidden="true" tabindex="-1"></a>     ch9<span class="op">:</span></span>
<span id="cb1045-10"><a href="#cb1045-10" aria-hidden="true" tabindex="-1"></a>         Hp <span class="op">=</span> Hp <span class="op">+</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="cb1045-11"><a href="#cb1045-11" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> <span class="op">(</span>Hp <span class="op">&gt;</span> HpLim<span class="op">)</span> <span class="cf">goto</span> chd<span class="op">;</span></span>
<span id="cb1045-12"><a href="#cb1045-12" aria-hidden="true" tabindex="-1"></a>         I64<span class="op">[</span>Hp <span class="op">-</span> <span class="dv">24</span><span class="op">]</span> <span class="op">=</span> stg_ap_2_upd_info<span class="op">;</span></span>
<span id="cb1045-13"><a href="#cb1045-13" aria-hidden="true" tabindex="-1"></a>         I64<span class="op">[</span>Hp <span class="op">-</span> <span class="dv">8</span><span class="op">]</span> <span class="op">=</span> R3<span class="op">;</span></span>
<span id="cb1045-14"><a href="#cb1045-14" aria-hidden="true" tabindex="-1"></a>         I64<span class="op">[</span>Hp <span class="op">+</span> <span class="dv">0</span><span class="op">]</span> <span class="op">=</span> R4<span class="op">;</span></span>
<span id="cb1045-15"><a href="#cb1045-15" aria-hidden="true" tabindex="-1"></a>         R1 <span class="op">=</span> R2<span class="op">;</span></span>
<span id="cb1045-16"><a href="#cb1045-16" aria-hidden="true" tabindex="-1"></a>         R2 <span class="op">=</span> Hp <span class="op">-</span> <span class="dv">24</span><span class="op">;</span></span>
<span id="cb1045-17"><a href="#cb1045-17" aria-hidden="true" tabindex="-1"></a>         jump stg_ap_p_fast<span class="op">;</span> <span class="co">// [R1, R2]</span></span>
<span id="cb1045-18"><a href="#cb1045-18" aria-hidden="true" tabindex="-1"></a>     che<span class="op">:</span></span>
<span id="cb1045-19"><a href="#cb1045-19" aria-hidden="true" tabindex="-1"></a>         R1 <span class="op">=</span> compose_closure<span class="op">;</span></span>
<span id="cb1045-20"><a href="#cb1045-20" aria-hidden="true" tabindex="-1"></a>         jump stg_gc_fun<span class="op">;</span> <span class="co">// [R1, R4, R3, R2]</span></span>
<span id="cb1045-21"><a href="#cb1045-21" aria-hidden="true" tabindex="-1"></a>     chd<span class="op">:</span></span>
<span id="cb1045-22"><a href="#cb1045-22" aria-hidden="true" tabindex="-1"></a>         HpAlloc <span class="op">=</span> <span class="dv">32</span><span class="op">;</span></span>
<span id="cb1045-23"><a href="#cb1045-23" aria-hidden="true" tabindex="-1"></a>         <span class="cf">goto</span> che<span class="op">;</span></span>
<span id="cb1045-24"><a href="#cb1045-24" aria-hidden="true" tabindex="-1"></a> <span class="op">}]</span></span></code></pre></div>

<p>Consider a function which branches using pattern matching:</p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1046"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1046-1"><a href="#cb1046-1" aria-hidden="true" tabindex="-1"></a><span class="ot">match ::</span> <span class="dt">Either</span> a a <span class="ot">-&gt;</span> a</span>
<span id="cb1046-2"><a href="#cb1046-2" aria-hidden="true" tabindex="-1"></a>match x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></span>
<span id="cb1046-3"><a href="#cb1046-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Left</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1046-4"><a href="#cb1046-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Right</span> b <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>Cmm:</p>
<div class="sourceCode" id="cb1047"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1047-1"><a href="#cb1047-1" aria-hidden="true" tabindex="-1"></a><span class="op">[</span>section <span class="st">&quot;data&quot;</span> <span class="op">{</span></span>
<span id="cb1047-2"><a href="#cb1047-2" aria-hidden="true" tabindex="-1"></a>     match_closure<span class="op">:</span></span>
<span id="cb1047-3"><a href="#cb1047-3" aria-hidden="true" tabindex="-1"></a>         <span class="at">const</span> match_info<span class="op">;</span></span>
<span id="cb1047-4"><a href="#cb1047-4" aria-hidden="true" tabindex="-1"></a> <span class="op">},</span></span>
<span id="cb1047-5"><a href="#cb1047-5" aria-hidden="true" tabindex="-1"></a> sio_ret<span class="op">()</span></span>
<span id="cb1047-6"><a href="#cb1047-6" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> label<span class="op">:</span> sio_info</span>
<span id="cb1047-7"><a href="#cb1047-7" aria-hidden="true" tabindex="-1"></a>           rep<span class="op">:</span>StackRep <span class="op">[]</span></span>
<span id="cb1047-8"><a href="#cb1047-8" aria-hidden="true" tabindex="-1"></a>         <span class="op">}</span></span>
<span id="cb1047-9"><a href="#cb1047-9" aria-hidden="true" tabindex="-1"></a>     ciL<span class="op">:</span></span>
<span id="cb1047-10"><a href="#cb1047-10" aria-hidden="true" tabindex="-1"></a>         _ciM<span class="op">::</span>I64 <span class="op">=</span> R1 <span class="op">&amp;</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb1047-11"><a href="#cb1047-11" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> <span class="op">(</span>_ciM<span class="op">::</span>I64 <span class="op">&gt;=</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">goto</span> ciN<span class="op">;</span></span>
<span id="cb1047-12"><a href="#cb1047-12" aria-hidden="true" tabindex="-1"></a>         R1 <span class="op">=</span> I64<span class="op">[</span>R1 <span class="op">+</span> <span class="dv">7</span><span class="op">];</span></span>
<span id="cb1047-13"><a href="#cb1047-13" aria-hidden="true" tabindex="-1"></a>         Sp <span class="op">=</span> Sp <span class="op">+</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb1047-14"><a href="#cb1047-14" aria-hidden="true" tabindex="-1"></a>         jump stg_ap_0_fast<span class="op">;</span> <span class="co">// [R1]</span></span>
<span id="cb1047-15"><a href="#cb1047-15" aria-hidden="true" tabindex="-1"></a>     ciN<span class="op">:</span></span>
<span id="cb1047-16"><a href="#cb1047-16" aria-hidden="true" tabindex="-1"></a>         R1 <span class="op">=</span> I64<span class="op">[</span>R1 <span class="op">+</span> <span class="dv">6</span><span class="op">];</span></span>
<span id="cb1047-17"><a href="#cb1047-17" aria-hidden="true" tabindex="-1"></a>         Sp <span class="op">=</span> Sp <span class="op">+</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb1047-18"><a href="#cb1047-18" aria-hidden="true" tabindex="-1"></a>         jump stg_ap_0_fast<span class="op">;</span> <span class="co">// [R1]</span></span>
<span id="cb1047-19"><a href="#cb1047-19" aria-hidden="true" tabindex="-1"></a> <span class="op">},</span></span>
<span id="cb1047-20"><a href="#cb1047-20" aria-hidden="true" tabindex="-1"></a> match_info<span class="op">()</span></span>
<span id="cb1047-21"><a href="#cb1047-21" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> label<span class="op">:</span> match_info</span>
<span id="cb1047-22"><a href="#cb1047-22" aria-hidden="true" tabindex="-1"></a>           rep<span class="op">:</span>HeapRep <span class="at">static</span> <span class="op">{</span> Fun <span class="op">{</span>arity<span class="op">:</span> <span class="dv">1</span> <span class="dt">fun_type</span><span class="op">:</span> ArgSpec <span class="dv">5</span><span class="op">}</span> <span class="op">}</span></span>
<span id="cb1047-23"><a href="#cb1047-23" aria-hidden="true" tabindex="-1"></a>         <span class="op">}</span></span>
<span id="cb1047-24"><a href="#cb1047-24" aria-hidden="true" tabindex="-1"></a>     ciP<span class="op">:</span></span>
<span id="cb1047-25"><a href="#cb1047-25" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> <span class="op">(</span>Sp <span class="op">-</span> <span class="dv">8</span> <span class="op">&lt;</span> SpLim<span class="op">)</span> <span class="cf">goto</span> ciR<span class="op">;</span></span>
<span id="cb1047-26"><a href="#cb1047-26" aria-hidden="true" tabindex="-1"></a>         R1 <span class="op">=</span> R2<span class="op">;</span></span>
<span id="cb1047-27"><a href="#cb1047-27" aria-hidden="true" tabindex="-1"></a>         I64<span class="op">[</span>Sp <span class="op">-</span> <span class="dv">8</span><span class="op">]</span> <span class="op">=</span> sio_info<span class="op">;</span></span>
<span id="cb1047-28"><a href="#cb1047-28" aria-hidden="true" tabindex="-1"></a>         Sp <span class="op">=</span> Sp <span class="op">-</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb1047-29"><a href="#cb1047-29" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> <span class="op">(</span>R1 <span class="op">&amp;</span> <span class="dv">7</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">goto</span> ciU<span class="op">;</span></span>
<span id="cb1047-30"><a href="#cb1047-30" aria-hidden="true" tabindex="-1"></a>         jump I64<span class="op">[</span>R1<span class="op">];</span> <span class="co">// [R1]</span></span>
<span id="cb1047-31"><a href="#cb1047-31" aria-hidden="true" tabindex="-1"></a>     ciR<span class="op">:</span></span>
<span id="cb1047-32"><a href="#cb1047-32" aria-hidden="true" tabindex="-1"></a>         R1 <span class="op">=</span> match_closure<span class="op">;</span></span>
<span id="cb1047-33"><a href="#cb1047-33" aria-hidden="true" tabindex="-1"></a>         jump stg_gc_fun<span class="op">;</span> <span class="co">// [R1, R2]</span></span>
<span id="cb1047-34"><a href="#cb1047-34" aria-hidden="true" tabindex="-1"></a>     ciU<span class="op">:</span> jump sio_info<span class="op">;</span> <span class="co">// [R1]</span></span>
<span id="cb1047-35"><a href="#cb1047-35" aria-hidden="true" tabindex="-1"></a> <span class="op">}]</span></span></code></pre></div>

<p><strong>Macros</strong></p>
<p>Cmm itself uses many macros to stand for various constructs, many of
which are defined in an external C header file. A short reference for
the common types:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Cmm</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>C_</code></td>
<td style="text-align: left;">char</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>D_</code></td>
<td style="text-align: left;">double</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>F_</code></td>
<td style="text-align: left;">float</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>W_</code></td>
<td style="text-align: left;">word</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>P_</code></td>
<td style="text-align: left;">garbage collected pointer</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>I_</code></td>
<td style="text-align: left;">int</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>L_</code></td>
<td style="text-align: left;">long</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>FN_</code></td>
<td style="text-align: left;">function pointer (no arguments)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>EF_</code></td>
<td style="text-align: left;">extern function pointer</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>I8</code></td>
<td style="text-align: left;">8-bit integer</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>I16</code></td>
<td style="text-align: left;">16-bit integer</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>I32</code></td>
<td style="text-align: left;">32-bit integer</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>I64</code></td>
<td style="text-align: left;">64-bit integer</td>
</tr>
</tbody>
</table>
<p>Inside of Cmm logic there are several functions which are commonly
invoked:</p>
<ul>
<li><code>Sp_adj</code> - Adjusts the stack pointer.</li>
<li><code>GET_ENTRY</code> -</li>
<li><code>ENTER</code> -</li>
<li><code>jump</code> -</li>
</ul>
<div class="sourceCode" id="cb1048"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1048-1"><a href="#cb1048-1" aria-hidden="true" tabindex="-1"></a>stg_init_finish</span>
<span id="cb1048-2"><a href="#cb1048-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1048-3"><a href="#cb1048-3" aria-hidden="true" tabindex="-1"></a>  jump StgReturn<span class="op">;</span></span>
<span id="cb1048-4"><a href="#cb1048-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1048-5"><a href="#cb1048-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1048-6"><a href="#cb1048-6" aria-hidden="true" tabindex="-1"></a>stg_init</span>
<span id="cb1048-7"><a href="#cb1048-7" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1048-8"><a href="#cb1048-8" aria-hidden="true" tabindex="-1"></a>  W_ next<span class="op">;</span></span>
<span id="cb1048-9"><a href="#cb1048-9" aria-hidden="true" tabindex="-1"></a>  Sp <span class="op">=</span> W_<span class="op">[</span>BaseReg <span class="op">+</span> OFFSET_StgRegTable_rSp<span class="op">];</span></span>
<span id="cb1048-10"><a href="#cb1048-10" aria-hidden="true" tabindex="-1"></a>  next <span class="op">=</span> W_<span class="op">[</span>Sp<span class="op">];</span></span>
<span id="cb1048-11"><a href="#cb1048-11" aria-hidden="true" tabindex="-1"></a>  Sp_adj<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb1048-12"><a href="#cb1048-12" aria-hidden="true" tabindex="-1"></a>  jump next<span class="op">;</span></span>
<span id="cb1048-13"><a href="#cb1048-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb1049"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1049-1"><a href="#cb1049-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define SIZEOF_W  </span><span class="dv">8</span><span class="pp"> </span><span class="co">/* or 4 depending on platform */</span></span>
<span id="cb1049-2"><a href="#cb1049-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define WDS</span><span class="op">(</span>n<span class="op">)</span><span class="pp"> </span><span class="op">((</span>n<span class="op">)*</span>SIZEOF_W<span class="op">)</span></span>
<span id="cb1049-3"><a href="#cb1049-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define Sp</span><span class="op">(</span>n<span class="op">)</span><span class="pp">  </span>W_<span class="op">[</span>Sp<span class="pp"> </span><span class="op">+</span><span class="pp"> </span>WDS<span class="op">(</span>n<span class="op">)]</span></span>
<span id="cb1049-4"><a href="#cb1049-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#define Hp</span><span class="op">(</span>n<span class="op">)</span><span class="pp">  </span>W_<span class="op">[</span>Hp<span class="pp"> </span><span class="op">+</span><span class="pp"> </span>WDS<span class="op">(</span>n<span class="op">)]</span></span>
<span id="cb1049-5"><a href="#cb1049-5" aria-hidden="true" tabindex="-1"></a><span class="pp">#define Sp_adj</span><span class="op">(</span>n<span class="op">)</span><span class="pp"> </span>Sp<span class="pp"> </span><span class="op">=</span><span class="pp"> </span>Sp<span class="pp"> </span><span class="op">+</span><span class="pp"> </span>WDS<span class="op">(</span>n<span class="op">)</span></span>
<span id="cb1049-6"><a href="#cb1049-6" aria-hidden="true" tabindex="-1"></a><span class="pp">#define Hp_adj</span><span class="op">(</span>n<span class="op">)</span><span class="pp"> </span>Hp<span class="pp"> </span><span class="op">=</span><span class="pp"> </span>Hp<span class="pp"> </span><span class="op">+</span><span class="pp"> </span>WDS<span class="op">(</span>n<span class="op">)</span></span></code></pre></div>
<p>Many of the predefined closures (<code>stg_ap_p_fast</code>, etc) are
themselves mechanically generated and more or less share the same form (
a giant switch statement on closure type, update frame, stack
adjustment). Inside of GHC is a file named <code>GenApply.hs</code> that
generates most of these functions. For example the output for
<code>stg_ap_p_fast</code>.</p>
<div class="sourceCode" id="cb1050"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1050-1"><a href="#cb1050-1" aria-hidden="true" tabindex="-1"></a>stg_ap_p_fast</span>
<span id="cb1050-2"><a href="#cb1050-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span>   W_ info<span class="op">;</span></span>
<span id="cb1050-3"><a href="#cb1050-3" aria-hidden="true" tabindex="-1"></a>    W_ arity<span class="op">;</span></span>
<span id="cb1050-4"><a href="#cb1050-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>GETTAG<span class="op">(</span>R1<span class="op">)==</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1050-5"><a href="#cb1050-5" aria-hidden="true" tabindex="-1"></a>        Sp_adj<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb1050-6"><a href="#cb1050-6" aria-hidden="true" tabindex="-1"></a>        jump <span class="op">%</span>GET_ENTRY<span class="op">(</span>R1<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">[</span>R1<span class="op">,</span>R2<span class="op">];</span></span>
<span id="cb1050-7"><a href="#cb1050-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1050-8"><a href="#cb1050-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>Sp <span class="op">-</span> WDS<span class="op">(</span><span class="dv">2</span><span class="op">)</span> <span class="op">&lt;</span> SpLim<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1050-9"><a href="#cb1050-9" aria-hidden="true" tabindex="-1"></a>        Sp_adj<span class="op">(-</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb1050-10"><a href="#cb1050-10" aria-hidden="true" tabindex="-1"></a>        W_<span class="op">[</span>Sp<span class="op">+</span>WDS<span class="op">(</span><span class="dv">1</span><span class="op">)]</span> <span class="op">=</span> R2<span class="op">;</span></span>
<span id="cb1050-11"><a href="#cb1050-11" aria-hidden="true" tabindex="-1"></a>        Sp<span class="op">(</span><span class="dv">0</span><span class="op">)</span> <span class="op">=</span> stg_ap_p_info<span class="op">;</span></span>
<span id="cb1050-12"><a href="#cb1050-12" aria-hidden="true" tabindex="-1"></a>        jump __stg_gc_enter_1 <span class="op">[</span>R1<span class="op">];</span></span>
<span id="cb1050-13"><a href="#cb1050-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1050-14"><a href="#cb1050-14" aria-hidden="true" tabindex="-1"></a>    R1 <span class="op">=</span> UNTAG<span class="op">(</span>R1<span class="op">);</span></span>
<span id="cb1050-15"><a href="#cb1050-15" aria-hidden="true" tabindex="-1"></a>    info <span class="op">=</span> <span class="op">%</span>GET_STD_INFO<span class="op">(</span>R1<span class="op">);</span></span>
<span id="cb1050-16"><a href="#cb1050-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">switch</span> <span class="op">[</span>INVALID_OBJECT <span class="op">..</span> N_CLOSURE_TYPES<span class="op">]</span> <span class="op">(</span>TO_W_<span class="op">(%</span>INFO_TYPE<span class="op">(</span>info<span class="op">)))</span> <span class="op">{</span></span>
<span id="cb1050-17"><a href="#cb1050-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">case</span> FUN<span class="op">,</span></span>
<span id="cb1050-18"><a href="#cb1050-18" aria-hidden="true" tabindex="-1"></a>             FUN_1_0<span class="op">,</span></span>
<span id="cb1050-19"><a href="#cb1050-19" aria-hidden="true" tabindex="-1"></a>             FUN_0_1<span class="op">,</span></span>
<span id="cb1050-20"><a href="#cb1050-20" aria-hidden="true" tabindex="-1"></a>             FUN_2_0<span class="op">,</span></span>
<span id="cb1050-21"><a href="#cb1050-21" aria-hidden="true" tabindex="-1"></a>             FUN_1_1<span class="op">,</span></span>
<span id="cb1050-22"><a href="#cb1050-22" aria-hidden="true" tabindex="-1"></a>             FUN_0_2<span class="op">,</span></span>
<span id="cb1050-23"><a href="#cb1050-23" aria-hidden="true" tabindex="-1"></a>             FUN_STATIC<span class="op">:</span> <span class="op">{</span></span>
<span id="cb1050-24"><a href="#cb1050-24" aria-hidden="true" tabindex="-1"></a>            arity <span class="op">=</span> TO_W_<span class="op">(</span>StgFunInfoExtra_arity<span class="op">(%</span>GET_FUN_INFO<span class="op">(</span>R1<span class="op">)));</span></span>
<span id="cb1050-25"><a href="#cb1050-25" aria-hidden="true" tabindex="-1"></a>            ASSERT<span class="op">(</span>arity <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1050-26"><a href="#cb1050-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arity <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1050-27"><a href="#cb1050-27" aria-hidden="true" tabindex="-1"></a>                Sp_adj<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb1050-28"><a href="#cb1050-28" aria-hidden="true" tabindex="-1"></a>                R1 <span class="op">=</span> R1 <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1050-29"><a href="#cb1050-29" aria-hidden="true" tabindex="-1"></a>                jump <span class="op">%</span>GET_ENTRY<span class="op">(</span>UNTAG<span class="op">(</span>R1<span class="op">))</span> <span class="op">[</span>R1<span class="op">,</span>R2<span class="op">];</span></span>
<span id="cb1050-30"><a href="#cb1050-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1050-31"><a href="#cb1050-31" aria-hidden="true" tabindex="-1"></a>                Sp_adj<span class="op">(-</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb1050-32"><a href="#cb1050-32" aria-hidden="true" tabindex="-1"></a>                W_<span class="op">[</span>Sp<span class="op">+</span>WDS<span class="op">(</span><span class="dv">1</span><span class="op">)]</span> <span class="op">=</span> R2<span class="op">;</span></span>
<span id="cb1050-33"><a href="#cb1050-33" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>arity <span class="op">&lt;</span> <span class="dv">8</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1050-34"><a href="#cb1050-34" aria-hidden="true" tabindex="-1"></a>                  R1 <span class="op">=</span> R1 <span class="op">+</span> arity<span class="op">;</span></span>
<span id="cb1050-35"><a href="#cb1050-35" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1050-36"><a href="#cb1050-36" aria-hidden="true" tabindex="-1"></a>                BUILD_PAP<span class="op">(</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span>stg_ap_p_info<span class="op">,</span>FUN<span class="op">);</span></span>
<span id="cb1050-37"><a href="#cb1050-37" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1050-38"><a href="#cb1050-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1050-39"><a href="#cb1050-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">default</span><span class="op">:</span> <span class="op">{</span></span>
<span id="cb1050-40"><a href="#cb1050-40" aria-hidden="true" tabindex="-1"></a>            Sp_adj<span class="op">(-</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb1050-41"><a href="#cb1050-41" aria-hidden="true" tabindex="-1"></a>            W_<span class="op">[</span>Sp<span class="op">+</span>WDS<span class="op">(</span><span class="dv">1</span><span class="op">)]</span> <span class="op">=</span> R2<span class="op">;</span></span>
<span id="cb1050-42"><a href="#cb1050-42" aria-hidden="true" tabindex="-1"></a>            jump RET_LBL<span class="op">(</span>stg_ap_p<span class="op">)</span> <span class="op">[];</span></span>
<span id="cb1050-43"><a href="#cb1050-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1050-44"><a href="#cb1050-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1050-45"><a href="#cb1050-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="inline-cmm">Inline CMM</h2>
<p>Handwritten Cmm can be included in a module manually by first
compiling it through GHC into an object and then using a special FFI
invocation.</p>
<div class="sourceCode" id="cb1051"
data-include="src/29-ghc/factorial.cmm"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1051-1"><a href="#cb1051-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&quot;Cmm.h&quot;</span></span>
<span id="cb1051-2"><a href="#cb1051-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1051-3"><a href="#cb1051-3" aria-hidden="true" tabindex="-1"></a>factorial <span class="op">{</span></span>
<span id="cb1051-4"><a href="#cb1051-4" aria-hidden="true" tabindex="-1"></a>  entry<span class="op">:</span></span>
<span id="cb1051-5"><a href="#cb1051-5" aria-hidden="true" tabindex="-1"></a>      W_ n  <span class="op">;</span></span>
<span id="cb1051-6"><a href="#cb1051-6" aria-hidden="true" tabindex="-1"></a>      W_ acc<span class="op">;</span></span>
<span id="cb1051-7"><a href="#cb1051-7" aria-hidden="true" tabindex="-1"></a>      n <span class="op">=</span> R1 <span class="op">;</span></span>
<span id="cb1051-8"><a href="#cb1051-8" aria-hidden="true" tabindex="-1"></a>      acc <span class="op">=</span> n <span class="op">;</span></span>
<span id="cb1051-9"><a href="#cb1051-9" aria-hidden="true" tabindex="-1"></a>      n <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span> <span class="op">;</span></span>
<span id="cb1051-10"><a href="#cb1051-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1051-11"><a href="#cb1051-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span><span class="op">:</span></span>
<span id="cb1051-12"><a href="#cb1051-12" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">0</span> <span class="op">)</span> <span class="op">{</span></span>
<span id="cb1051-13"><a href="#cb1051-13" aria-hidden="true" tabindex="-1"></a>          <span class="cf">return</span><span class="op">(</span>acc<span class="op">);</span></span>
<span id="cb1051-14"><a href="#cb1051-14" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1051-15"><a href="#cb1051-15" aria-hidden="true" tabindex="-1"></a>          acc <span class="op">=</span> acc <span class="op">*</span> n  <span class="op">;</span></span>
<span id="cb1051-16"><a href="#cb1051-16" aria-hidden="true" tabindex="-1"></a>          n <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span> <span class="op">;</span></span>
<span id="cb1051-17"><a href="#cb1051-17" aria-hidden="true" tabindex="-1"></a>          <span class="cf">goto</span> <span class="cf">for</span> <span class="op">;</span></span>
<span id="cb1051-18"><a href="#cb1051-18" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb1051-19"><a href="#cb1051-19" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span><span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb1051-20"><a href="#cb1051-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb1052"
data-include="src/29-ghc/cmm_include.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1052-1"><a href="#cb1052-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- ghc -c factorial.cmm -o factorial.o</span></span>
<span id="cb1052-2"><a href="#cb1052-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- ghc factorial.o Example.hs -o Example</span></span>
<span id="cb1052-3"><a href="#cb1052-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1052-4"><a href="#cb1052-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MagicHash #-}</span></span>
<span id="cb1052-5"><a href="#cb1052-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UnliftedFFITypes #-}</span></span>
<span id="cb1052-6"><a href="#cb1052-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GHCForeignImportPrim #-}</span></span>
<span id="cb1052-7"><a href="#cb1052-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ForeignFunctionInterface #-}</span></span>
<span id="cb1052-8"><a href="#cb1052-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1052-9"><a href="#cb1052-9" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb1052-10"><a href="#cb1052-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1052-11"><a href="#cb1052-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Prim</span></span>
<span id="cb1052-12"><a href="#cb1052-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Word</span></span>
<span id="cb1052-13"><a href="#cb1052-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1052-14"><a href="#cb1052-14" aria-hidden="true" tabindex="-1"></a>foreign <span class="kw">import</span> prim &quot;factorial&quot; factorial_cmm  :: <span class="dt">Word</span># -&gt; <span class="dt">Word</span>#</span>
<span id="cb1052-15"><a href="#cb1052-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1052-16"><a href="#cb1052-16" aria-hidden="true" tabindex="-1"></a><span class="ot">factorial ::</span> <span class="dt">Word64</span> <span class="ot">-&gt;</span> <span class="dt">Word64</span></span>
<span id="cb1052-17"><a href="#cb1052-17" aria-hidden="true" tabindex="-1"></a>factorial (<span class="dt">W64</span><span class="op">#</span> n) <span class="ot">=</span>  <span class="dt">W64</span><span class="op">#</span> (factorial_cmm n)</span>
<span id="cb1052-18"><a href="#cb1052-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1052-19"><a href="#cb1052-19" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1052-20"><a href="#cb1052-20" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (factorial <span class="dv">5</span>)</span></code></pre></div>
<h2 id="optimisation">Optimisation</h2>
<p>GHC uses a suite of assembly optimisations to generate more optimal
code.</p>
<h4 id="tables-next-to-code">Tables Next to Code</h4>
<p>GHC will place the info table for a toplevel closure directly next to
the entry-code for the objects in memory such that the fields from the
info table can be accessed by pointer arithmetic on the function pointer
to the code itself. Not performing this optimization would involve
chasing through one more pointer to get to the info table. Given how
often info-tables are accessed using the tables-next-to-code
optimization results in a tractable speedup.</p>
<h4 id="pointer-tagging">Pointer Tagging</h4>
<p>Depending on the type of the closure involved, GHC will utilize the
last few bits in a pointer to the closure to store information that can
be read off from the bits of pointer itself before jumping into or
access the info tables. For thunks this can be information like whether
it is evaluated to WHNF or not, for constructors it contains the
constructor tag (if it fits) to avoid an info table lookup.</p>
<p>Depending on the architecture the tag bits are either the last 2 or 3
bits of a pointer.</p>
<div class="sourceCode" id="cb1053"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1053-1"><a href="#cb1053-1" aria-hidden="true" tabindex="-1"></a><span class="co">// 32 bit arch</span></span>
<span id="cb1053-2"><a href="#cb1053-2" aria-hidden="true" tabindex="-1"></a>TAG_BITS <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb1053-3"><a href="#cb1053-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1053-4"><a href="#cb1053-4" aria-hidden="true" tabindex="-1"></a><span class="co">// 64-bit arch</span></span>
<span id="cb1053-5"><a href="#cb1053-5" aria-hidden="true" tabindex="-1"></a>TAG_BITS <span class="op">=</span> <span class="dv">3</span></span></code></pre></div>
<p>These occur in Cmm most frequently via the following macro
definitions:</p>
<div class="sourceCode" id="cb1054"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1054-1"><a href="#cb1054-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define TAG_MASK </span><span class="op">((</span><span class="dv">1</span><span class="pp"> </span><span class="op">&lt;&lt;</span><span class="pp"> </span>TAG_BITS<span class="op">)</span><span class="pp"> </span><span class="op">-</span><span class="pp"> </span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb1054-2"><a href="#cb1054-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#define UNTAG</span><span class="op">(</span>p<span class="op">)</span><span class="pp"> </span><span class="op">(</span>p<span class="pp"> </span><span class="op">&amp;</span><span class="pp"> </span><span class="op">~</span>TAG_MASK<span class="op">)</span></span>
<span id="cb1054-3"><a href="#cb1054-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#define GETTAG</span><span class="op">(</span>p<span class="op">)</span><span class="pp"> </span><span class="op">(</span>p<span class="pp"> </span><span class="op">&amp;</span><span class="pp"> </span>TAG_MASK<span class="op">)</span></span></code></pre></div>
<p>So for instance in many of the precompiled functions, there will be a
test for whether the active closure <code>R1</code> is already
evaluated.</p>
<div class="sourceCode" id="cb1055"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1055-1"><a href="#cb1055-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>GETTAG<span class="op">(</span>R1<span class="op">)==</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1055-2"><a href="#cb1055-2" aria-hidden="true" tabindex="-1"></a>    Sp_adj<span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb1055-3"><a href="#cb1055-3" aria-hidden="true" tabindex="-1"></a>    jump <span class="op">%</span>GET_ENTRY<span class="op">(</span>R1<span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">[</span>R1<span class="op">,</span>R2<span class="op">];</span></span>
<span id="cb1055-4"><a href="#cb1055-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h2 id="interface-files">Interface Files</h2>
<p>During compilation GHC will produce interface files for each module
that are the binary encoding of specific symbols (functions,
typeclasses, etc) exported by that module as well as any package
dependencies it itself depends on. This is effectively the serialized
form of the ModGuts structure used internally in the compiler. The
internal structure of this file can be dumped using the
<code>--show-iface</code> flag. The precise structure changes between
versions of GHC.</p>
<div class="sourceCode" id="cb1056"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1056-1"><a href="#cb1056-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc <span class="at">--show-iface</span> let.hi</span>
<span id="cb1056-2"><a href="#cb1056-2" aria-hidden="true" tabindex="-1"></a><span class="ex">Magic:</span> Wanted 33214052,</span>
<span id="cb1056-3"><a href="#cb1056-3" aria-hidden="true" tabindex="-1"></a>       <span class="ex">got</span>    33214052</span>
<span id="cb1056-4"><a href="#cb1056-4" aria-hidden="true" tabindex="-1"></a><span class="ex">Version:</span> Wanted [7, 0, 8, 4],</span>
<span id="cb1056-5"><a href="#cb1056-5" aria-hidden="true" tabindex="-1"></a>         <span class="ex">got</span>    [7, 0, 8, 4]</span>
<span id="cb1056-6"><a href="#cb1056-6" aria-hidden="true" tabindex="-1"></a><span class="ex">Way:</span> Wanted [],</span>
<span id="cb1056-7"><a href="#cb1056-7" aria-hidden="true" tabindex="-1"></a>     <span class="ex">got</span>    []</span>
<span id="cb1056-8"><a href="#cb1056-8" aria-hidden="true" tabindex="-1"></a><span class="ex">interface</span> main:Main 7084</span>
<span id="cb1056-9"><a href="#cb1056-9" aria-hidden="true" tabindex="-1"></a>  <span class="ex">interface</span> hash: 1991c3e0edf3e849aeb53783fb616df2</span>
<span id="cb1056-10"><a href="#cb1056-10" aria-hidden="true" tabindex="-1"></a>  <span class="ex">ABI</span> hash: 0b7173fb01d2226a2e61df72371034ee</span>
<span id="cb1056-11"><a href="#cb1056-11" aria-hidden="true" tabindex="-1"></a>  <span class="ex">export-list</span> hash: 0f26147773230f50ea3b06fe20c9c66c</span>
<span id="cb1056-12"><a href="#cb1056-12" aria-hidden="true" tabindex="-1"></a>  <span class="ex">orphan</span> hash: 693e9af84d3dfcc71e640e005bdc5e2e</span>
<span id="cb1056-13"><a href="#cb1056-13" aria-hidden="true" tabindex="-1"></a>  <span class="ex">flag</span> hash: 9b3dfba8e3209c5b5c132a214b6b9bd3</span>
<span id="cb1056-14"><a href="#cb1056-14" aria-hidden="true" tabindex="-1"></a>  <span class="ex">used</span> TH splices: False</span>
<span id="cb1056-15"><a href="#cb1056-15" aria-hidden="true" tabindex="-1"></a>  <span class="ex">where</span></span>
<span id="cb1056-16"><a href="#cb1056-16" aria-hidden="true" tabindex="-1"></a><span class="ex">exports:</span></span>
<span id="cb1056-17"><a href="#cb1056-17" aria-hidden="true" tabindex="-1"></a>  <span class="ex">Main.main</span></span>
<span id="cb1056-18"><a href="#cb1056-18" aria-hidden="true" tabindex="-1"></a><span class="ex">module</span> dependencies:</span>
<span id="cb1056-19"><a href="#cb1056-19" aria-hidden="true" tabindex="-1"></a><span class="ex">package</span> dependencies: base<span class="pp">*</span> ghc-prim integer-gmp</span>
<span id="cb1056-20"><a href="#cb1056-20" aria-hidden="true" tabindex="-1"></a><span class="ex">orphans:</span> base:GHC.Base base:GHC.Float base:GHC.Real</span>
<span id="cb1056-21"><a href="#cb1056-21" aria-hidden="true" tabindex="-1"></a><span class="ex">family</span> instance modules: base:Data.Either base:Data.Monoid</span>
<span id="cb1056-22"><a href="#cb1056-22" aria-hidden="true" tabindex="-1"></a>                         <span class="ex">base:Data.Type.Equality</span> base:GHC.Generics</span>
<span id="cb1056-23"><a href="#cb1056-23" aria-hidden="true" tabindex="-1"></a><span class="ex">import</span>  <span class="at">-</span>/  base:GHC.Num 5e7786970581cacc802bf850d458a30b</span>
<span id="cb1056-24"><a href="#cb1056-24" aria-hidden="true" tabindex="-1"></a><span class="ex">import</span>  <span class="at">-</span>/  base:Prelude 74043f272d60acec1777d3461cfe5ef4</span>
<span id="cb1056-25"><a href="#cb1056-25" aria-hidden="true" tabindex="-1"></a><span class="ex">import</span>  <span class="at">-</span>/  base:System.IO cadd0efb01c47ddd8f52d750739fdbdf</span>
<span id="cb1056-26"><a href="#cb1056-26" aria-hidden="true" tabindex="-1"></a><span class="ex">import</span>  <span class="at">-</span>/  ghc-prim:GHC.Types dcba736fa3dfba12d307ab18354845d2</span>
<span id="cb1056-27"><a href="#cb1056-27" aria-hidden="true" tabindex="-1"></a><span class="ex">4cfa03293a8356d627c0c5fec26936e2</span></span>
<span id="cb1056-28"><a href="#cb1056-28" aria-hidden="true" tabindex="-1"></a>  <span class="ex">main</span> :: GHC.Types.IO <span class="er">(</span><span class="kw">)</span></span>
<span id="cb1056-29"><a href="#cb1056-29" aria-hidden="true" tabindex="-1"></a><span class="ex">vectorised</span> variables:</span>
<span id="cb1056-30"><a href="#cb1056-30" aria-hidden="true" tabindex="-1"></a><span class="ex">vectorised</span> tycons:</span>
<span id="cb1056-31"><a href="#cb1056-31" aria-hidden="true" tabindex="-1"></a><span class="ex">vectorised</span> reused tycons:</span>
<span id="cb1056-32"><a href="#cb1056-32" aria-hidden="true" tabindex="-1"></a><span class="ex">parallel</span> variables:</span>
<span id="cb1056-33"><a href="#cb1056-33" aria-hidden="true" tabindex="-1"></a><span class="ex">parallel</span> tycons:</span>
<span id="cb1056-34"><a href="#cb1056-34" aria-hidden="true" tabindex="-1"></a><span class="ex">trusted:</span> safe-inferred</span>
<span id="cb1056-35"><a href="#cb1056-35" aria-hidden="true" tabindex="-1"></a><span class="ex">require</span> own pkg trusted: False</span></code></pre></div>
<h2 id="runtime-system">Runtime System</h2>
<p>The GHC runtime system is a massive part of the compiler. It comes in
at around 70,000 lines of C and Cmm. There is simply no way to explain
most of what occurs in the runtime succinctly. There is more than three
decades worth of work that has gone into making this system and it is
quite advanced. Instead lets look at the basic structure and some core
modules.</p>
<p>The golden source of truth for all GHC internals is the GHC Wiki
Commentary written by the compiler maintainers:</p>
<p>https://gitlab.haskell.org/ghc/ghc/wikis/commentary</p>
<p>Inside the GHC source tree the runtime system spans multiple modules.
The bulk of the runtime logic is stored across the
<code>includes</code>, <code>utils</code> and <code>rts</code>
folders.</p>
<div class="sourceCode" id="cb1057"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1057-1"><a href="#cb1057-1" aria-hidden="true" tabindex="-1"></a><span class="ex">ghc-8.8.2</span></span>
<span id="cb1057-2"><a href="#cb1057-2" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> compiler</span>
<span id="cb1057-3"><a href="#cb1057-3" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> └── prelude</span>
<span id="cb1057-4"><a href="#cb1057-4" aria-hidden="true" tabindex="-1"></a><span class="ex">│</span>       └── primops.txt.pp <span class="co"># Definitions of primops</span></span>
<span id="cb1057-5"><a href="#cb1057-5" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> compiler</span>
<span id="cb1057-6"><a href="#cb1057-6" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> includes</span>
<span id="cb1057-7"><a href="#cb1057-7" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> ├── rts                <span class="co"># Public interface for RTS</span></span>
<span id="cb1057-8"><a href="#cb1057-8" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> └── stg                <span class="co"># Definitions for STG langauge</span></span>
<span id="cb1057-9"><a href="#cb1057-9" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> utils</span>
<span id="cb1057-10"><a href="#cb1057-10" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> ├── genapply           <span class="co"># Generates Cmm closure application boilerplate</span></span>
<span id="cb1057-11"><a href="#cb1057-11" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> ├── genprimopcode      <span class="co"># Generates Primop builtin operations for GHC</span></span>
<span id="cb1057-12"><a href="#cb1057-12" aria-hidden="true" tabindex="-1"></a><span class="ex">│  </span> └── deriveConstants    <span class="co"># Machine specific information about register and sizes</span></span>
<span id="cb1057-13"><a href="#cb1057-13" aria-hidden="true" tabindex="-1"></a><span class="ex">└──</span> rts</span>
<span id="cb1057-14"><a href="#cb1057-14" aria-hidden="true" tabindex="-1"></a> <span class="ex">  </span> ├── hooks</span>
<span id="cb1057-15"><a href="#cb1057-15" aria-hidden="true" tabindex="-1"></a> <span class="ex">  </span> ├── linker</span>
<span id="cb1057-16"><a href="#cb1057-16" aria-hidden="true" tabindex="-1"></a> <span class="ex">  </span> ├── posix</span>
<span id="cb1057-17"><a href="#cb1057-17" aria-hidden="true" tabindex="-1"></a> <span class="ex">  </span> ├── sm</span>
<span id="cb1057-18"><a href="#cb1057-18" aria-hidden="true" tabindex="-1"></a> <span class="ex">  </span> └── win32</span></code></pre></div>
<p>The toplevel for the runtime interface is exposed through six key
header files found in the <code>/includes</code> folder.</p>
<div class="sourceCode" id="cb1058"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1058-1"><a href="#cb1058-1" aria-hidden="true" tabindex="-1"></a><span class="ex">includes</span></span>
<span id="cb1058-2"><a href="#cb1058-2" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Cmm.h             <span class="co"># Defines Cmm types and macros</span></span>
<span id="cb1058-3"><a href="#cb1058-3" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> HsFFI.h           <span class="co"># Defines mapping between STG types and Haskell types, and FFI functions</span></span>
<span id="cb1058-4"><a href="#cb1058-4" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> MachDeps.h        <span class="co"># Defines types of of machine integer types and sizes</span></span>
<span id="cb1058-5"><a href="#cb1058-5" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Rts.h             <span class="co"># Declares everything that the GHC RTS exposes externally</span></span>
<span id="cb1058-6"><a href="#cb1058-6" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> RtsAPI.h          <span class="co"># API for invoking Haskell functions via the RTS</span></span>
<span id="cb1058-7"><a href="#cb1058-7" aria-hidden="true" tabindex="-1"></a><span class="ex">└──</span> STG.h             <span class="co"># Toplevel import for all STG types, control flow operations and memory layout</span></span></code></pre></div>
<p>The <code>stg</code> folder contains many of the macros used in the
evaluation of STG as well as the memory layout and mappings from to STG
to machine types.</p>
<div class="sourceCode" id="cb1059"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1059-1"><a href="#cb1059-1" aria-hidden="true" tabindex="-1"></a><span class="ex">include/stg</span></span>
<span id="cb1059-2"><a href="#cb1059-2" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> DLL.h                 <span class="co"># Support for Windows DLLs</span></span>
<span id="cb1059-3"><a href="#cb1059-3" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> HaskellMachRegs.h     <span class="co"># Registers used in STG code</span></span>
<span id="cb1059-4"><a href="#cb1059-4" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> MachRegs.h            <span class="co"># Registers used in STG code</span></span>
<span id="cb1059-5"><a href="#cb1059-5" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> MiscClosures.h        <span class="co"># Type definitions for layout of STG closures</span></span>
<span id="cb1059-6"><a href="#cb1059-6" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Prim.h                <span class="co"># Declarations of primops</span></span>
<span id="cb1059-7"><a href="#cb1059-7" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Regs.h                <span class="co"># Registers for STG virtual machine</span></span>
<span id="cb1059-8"><a href="#cb1059-8" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> RtsMachRegs.h         <span class="co"># Registers for STG virtual machine</span></span>
<span id="cb1059-9"><a href="#cb1059-9" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> SMP.h                 <span class="co"># Declarations for multicore memory operations</span></span>
<span id="cb1059-10"><a href="#cb1059-10" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Ticky.h               <span class="co"># Profiling tools</span></span>
<span id="cb1059-11"><a href="#cb1059-11" aria-hidden="true" tabindex="-1"></a><span class="ex">└──</span> Types.h               <span class="co"># C Declarations of types used in STG</span></span></code></pre></div>
<p>The <code>storage</code> folder contains format definitions define
that define the memory layout of closures, InfoTables, sparks, etc as
they are represented on the heap.</p>
<div class="sourceCode" id="cb1060"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1060-1"><a href="#cb1060-1" aria-hidden="true" tabindex="-1"></a><span class="ex">include/rts/storage</span></span>
<span id="cb1060-2"><a href="#cb1060-2" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Block.h               <span class="co"># Block structure for the storage manager</span></span>
<span id="cb1060-3"><a href="#cb1060-3" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> ClosureMacros.h       <span class="co"># Macros for manipulating info tables of closures</span></span>
<span id="cb1060-4"><a href="#cb1060-4" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Closures.h            <span class="co"># Type definitions for closures</span></span>
<span id="cb1060-5"><a href="#cb1060-5" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> ClosureTypes.h        <span class="co"># Definitions for closure metadata (arity, etc)</span></span>
<span id="cb1060-6"><a href="#cb1060-6" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> FunTypes.h            <span class="co"># Definitions of function argument types</span></span>
<span id="cb1060-7"><a href="#cb1060-7" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> GC.h                  <span class="co"># Type definitions for GC blocks, nursery, generations</span></span>
<span id="cb1060-8"><a href="#cb1060-8" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Heap.h                <span class="co"># Introsepction for GHC heap</span></span>
<span id="cb1060-9"><a href="#cb1060-9" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> InfoTables.h          <span class="co"># Type definitinos for function info tables</span></span>
<span id="cb1060-10"><a href="#cb1060-10" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> MBlock.h              <span class="co"># Introspection for determining if points are on the GHC heap</span></span>
<span id="cb1060-11"><a href="#cb1060-11" aria-hidden="true" tabindex="-1"></a><span class="ex">└──</span> TSO.h                 <span class="co"># Thread state objects</span></span></code></pre></div>
<p>Inside the <code>utils</code> folder of the GHC source tree are
several utilities that generate Cmm modules that GHC is compiled
against. These are boilerplate modules that define the Cmm macros in
terms of the Haskell datatypes defined in the <code>Stg</code>
definitions in the compiler.</p>
<ul>
<li><strong>genprimop</strong> - Generate the builtin primop
definitions.</li>
<li><strong>genapply</strong> - Generate the entry logic for
manipulating the stack when entering functions of various arities.</li>
<li><strong>deriveConstants</strong> - Generates the header files
containing constant values (pointer size, word sizes, etc) of the target
platform</li>
</ul>
<p>For <code>genprimop</code>, the primops are generated from a custom
domain specific langauge specified in <code>primops.txt.pp</code> which
defines the primops, their arity, commutative and associvaity properties
and the machine types they operate over. An example for integer addition
for (<code>+#</code>) looks like:</p>
<div class="sourceCode" id="cb1061"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1061-1"><a href="#cb1061-1" aria-hidden="true" tabindex="-1"></a>primtype <span class="dt">Int</span><span class="op">#</span></span>
<span id="cb1061-2"><a href="#cb1061-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1061-3"><a href="#cb1061-3" aria-hidden="true" tabindex="-1"></a>primop   <span class="dt">IntAddOp</span>    <span class="st">&quot;+#&quot;</span>    <span class="dt">Dyadic</span></span>
<span id="cb1061-4"><a href="#cb1061-4" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="op">#</span></span>
<span id="cb1061-5"><a href="#cb1061-5" aria-hidden="true" tabindex="-1"></a>   with commutable <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb1061-6"><a href="#cb1061-6" aria-hidden="true" tabindex="-1"></a>        fixity <span class="ot">=</span> <span class="kw">infixl</span> <span class="dv">6</span></span>
<span id="cb1061-7"><a href="#cb1061-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1061-8"><a href="#cb1061-8" aria-hidden="true" tabindex="-1"></a>primop   <span class="dt">IntSubOp</span>    <span class="st">&quot;-#&quot;</span>    <span class="dt">Dyadic</span>   <span class="dt">Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="op">#</span> <span class="ot">-&gt;</span> <span class="dt">Int</span><span class="op">#</span></span>
<span id="cb1061-9"><a href="#cb1061-9" aria-hidden="true" tabindex="-1"></a>   with fixity <span class="ot">=</span> <span class="kw">infixl</span> <span class="dv">6</span></span></code></pre></div>
<p>For <code>genapply</code> this generates all the Cmm definitions in
<code>Apply.cmm</code> for manipulating the stack when evaluating a
closure. For example a function of arity 2 (<code>ap</code>) is applied
to 2 pointer arguments (<code>pp</code>) we would jump to
<code>stg_ap_stk_pp</code> definition.</p>
<div class="sourceCode" id="cb1062"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1062-1"><a href="#cb1062-1" aria-hidden="true" tabindex="-1"></a>stg_ap_stk_pp</span>
<span id="cb1062-2"><a href="#cb1062-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span>   R3 <span class="op">=</span> W_<span class="op">[</span>Sp<span class="op">+</span>WDS<span class="op">(</span><span class="dv">1</span><span class="op">)];</span></span>
<span id="cb1062-3"><a href="#cb1062-3" aria-hidden="true" tabindex="-1"></a>    R2 <span class="op">=</span> W_<span class="op">[</span>Sp<span class="op">+</span>WDS<span class="op">(</span><span class="dv">0</span><span class="op">)];</span></span>
<span id="cb1062-4"><a href="#cb1062-4" aria-hidden="true" tabindex="-1"></a>    Sp_adj<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb1062-5"><a href="#cb1062-5" aria-hidden="true" tabindex="-1"></a>    jump <span class="op">%</span>GET_ENTRY<span class="op">(</span>UNTAG<span class="op">(</span>R1<span class="op">))</span> <span class="op">[</span>R1<span class="op">,</span>R2<span class="op">,</span>R3<span class="op">];</span></span>
<span id="cb1062-6"><a href="#cb1062-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The conventions for these single letters is described by the
following datatype in <code>Main.hs</code> of <code>genapply</code>:</p>
<div class="sourceCode" id="cb1063"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1063-1"><a href="#cb1063-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ArgRep</span></span>
<span id="cb1063-2"><a href="#cb1063-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">N</span>   <span class="co">-- non-ptr</span></span>
<span id="cb1063-3"><a href="#cb1063-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">P</span>   <span class="co">-- ptr</span></span>
<span id="cb1063-4"><a href="#cb1063-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">V</span>   <span class="co">-- void</span></span>
<span id="cb1063-5"><a href="#cb1063-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">F</span>   <span class="co">-- float</span></span>
<span id="cb1063-6"><a href="#cb1063-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">D</span>   <span class="co">-- double</span></span>
<span id="cb1063-7"><a href="#cb1063-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">L</span>   <span class="co">-- long (64-bit)</span></span>
<span id="cb1063-8"><a href="#cb1063-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">V16</span> <span class="co">-- 16-byte (128-bit) vectors</span></span>
<span id="cb1063-9"><a href="#cb1063-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">V32</span> <span class="co">-- 32-byte (256-bit) vectors</span></span>
<span id="cb1063-10"><a href="#cb1063-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">V64</span> <span class="co">-- 64-byte (512-bit) vectors</span></span></code></pre></div>
<p>The <code>include/rts</code> folder itself contains all the public
header files for all aspects of the runtime. Most of thes are included
in <code>Rts.h</code> toplevel import.</p>
<div class="sourceCode" id="cb1064"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1064-1"><a href="#cb1064-1" aria-hidden="true" tabindex="-1"></a><span class="ex">include/rts</span></span>
<span id="cb1064-2"><a href="#cb1064-2" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Adjustor.h            <span class="co"># Dynamically allocated code for Haskell closures to be viewed as C function pointers.</span></span>
<span id="cb1064-3"><a href="#cb1064-3" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> BlockSignals.h        <span class="co"># RTS signal handling</span></span>
<span id="cb1064-4"><a href="#cb1064-4" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Bytecodes.h           <span class="co"># Bytecode definitions for GHCi</span></span>
<span id="cb1064-5"><a href="#cb1064-5" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Config.h              <span class="co"># Runtime system settings (debug, profiling)</span></span>
<span id="cb1064-6"><a href="#cb1064-6" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Constants.h           <span class="co"># Global constants</span></span>
<span id="cb1064-7"><a href="#cb1064-7" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> EventLogFormat.h      <span class="co"># Event log for profiling</span></span>
<span id="cb1064-8"><a href="#cb1064-8" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> EventLogWriter.h      <span class="co"># Event log for profiling</span></span>
<span id="cb1064-9"><a href="#cb1064-9" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> FileLock.h            <span class="co"># Filesystem file locking</span></span>
<span id="cb1064-10"><a href="#cb1064-10" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Flags.h               <span class="co"># +RTS flag settings</span></span>
<span id="cb1064-11"><a href="#cb1064-11" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> GetTime.h             <span class="co"># System clock timers</span></span>
<span id="cb1064-12"><a href="#cb1064-12" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Globals.h             <span class="co"># Data.Typeale and GHC.Conc storage utilities</span></span>
<span id="cb1064-13"><a href="#cb1064-13" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Hpc.h                 <span class="co"># Haskell program coverage hooks</span></span>
<span id="cb1064-14"><a href="#cb1064-14" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> IOManager.h           <span class="co"># IO event loop</span></span>
<span id="cb1064-15"><a href="#cb1064-15" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Libdw.h               <span class="co"># DWARF debugging</span></span>
<span id="cb1064-16"><a href="#cb1064-16" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> LibdwPool.h           <span class="co"># DWARF debugging</span></span>
<span id="cb1064-17"><a href="#cb1064-17" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Linker.h              <span class="co"># Object linker</span></span>
<span id="cb1064-18"><a href="#cb1064-18" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Main.h                <span class="co"># Defines hs_main entry point invoked by Main.main</span></span>
<span id="cb1064-19"><a href="#cb1064-19" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Messages.h            <span class="co"># Runtime error logging</span></span>
<span id="cb1064-20"><a href="#cb1064-20" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> OSThreads.h           <span class="co"># Abstraction over operating system thread libraries</span></span>
<span id="cb1064-21"><a href="#cb1064-21" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Parallel.h            <span class="co"># Defines newSpark primitive</span></span>
<span id="cb1064-22"><a href="#cb1064-22" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> PrimFloat.h           <span class="co"># Primitive floating point operations</span></span>
<span id="cb1064-23"><a href="#cb1064-23" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Profiling.h           <span class="co"># Cost center profiling</span></span>
<span id="cb1064-24"><a href="#cb1064-24" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Signals.h             <span class="co"># RTS signal handling</span></span>
<span id="cb1064-25"><a href="#cb1064-25" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> SpinLock.h            <span class="co"># Abstraction over system spin locks</span></span>
<span id="cb1064-26"><a href="#cb1064-26" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> StableName.h          <span class="co"># Interface for GHC.StableName objects</span></span>
<span id="cb1064-27"><a href="#cb1064-27" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> StablePtr.h           <span class="co"># Interface for GHC.Stable pointers which arent collected by GC</span></span>
<span id="cb1064-28"><a href="#cb1064-28" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> StaticPtrTable.h      <span class="co"># Declarations for Static Pointer Table</span></span>
<span id="cb1064-29"><a href="#cb1064-29" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Threads.h             <span class="co"># Interface for thread scheduler</span></span>
<span id="cb1064-30"><a href="#cb1064-30" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Ticky.h               <span class="co"># Profiling counter types</span></span>
<span id="cb1064-31"><a href="#cb1064-31" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Time.h                <span class="co"># Time resolution and datatype settings for the runtime</span></span>
<span id="cb1064-32"><a href="#cb1064-32" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Timer.h               <span class="co"># Timer for profiling</span></span>
<span id="cb1064-33"><a href="#cb1064-33" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> TTY.h                 <span class="co"># POSIX tty interface</span></span>
<span id="cb1064-34"><a href="#cb1064-34" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Types.h               <span class="co"># RTS types, defines StgClosure StgInfoTable and StgTSO</span></span>
<span id="cb1064-35"><a href="#cb1064-35" aria-hidden="true" tabindex="-1"></a><span class="ex">└──</span> Utils.h               <span class="co"># Misc utilities</span></span></code></pre></div>
<p>The runtime system folder itself contains several modules which are
written in Cmm.</p>
<div class="sourceCode" id="cb1065"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1065-1"><a href="#cb1065-1" aria-hidden="true" tabindex="-1"></a><span class="ex">rts</span></span>
<span id="cb1065-2"><a href="#cb1065-2" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Apply.cmm              <span class="co"># Application of closures</span></span>
<span id="cb1065-3"><a href="#cb1065-3" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Compact.cmm            <span class="co"># Compact regions</span></span>
<span id="cb1065-4"><a href="#cb1065-4" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Exception.cmm          <span class="co"># Async exception primitives</span></span>
<span id="cb1065-5"><a href="#cb1065-5" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> HeapStackCheck.cmm     <span class="co"># Heap and Stack failure checks</span></span>
<span id="cb1065-6"><a href="#cb1065-6" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> PrimOps.cmm            <span class="co"># Array, MVar, TVar, STM primitives</span></span>
<span id="cb1065-7"><a href="#cb1065-7" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> StgMiscClosures.cmm    <span class="co"># Entry code for closure types</span></span>
<span id="cb1065-8"><a href="#cb1065-8" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> StgStartup.cmm         <span class="co"># Code for starting, stopping and restarting threads</span></span>
<span id="cb1065-9"><a href="#cb1065-9" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> StgStdThunks.cmm       <span class="co"># Introspection and field selection of thunks</span></span>
<span id="cb1065-10"><a href="#cb1065-10" aria-hidden="true" tabindex="-1"></a><span class="ex">└──</span> Updates.cmm            <span class="co"># Code up to update thunks, BlackHole handling.</span></span></code></pre></div>
<p>The core library for the garbage collector used in the runtime is
stored in the <code>sm</code> subfolder of <code>rts</code> and contains
several implementations of the garbage collectors that Haskell programs
can be compiled with.</p>
<div class="sourceCode" id="cb1066"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1066-1"><a href="#cb1066-1" aria-hidden="true" tabindex="-1"></a><span class="ex">rts/sm</span></span>
<span id="cb1066-2"><a href="#cb1066-2" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> BlockAlloc.c           <span class="co"># GC block allocator</span></span>
<span id="cb1066-3"><a href="#cb1066-3" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> CNF.c                  <span class="co"># Compact normal forms, non-GCd structures</span></span>
<span id="cb1066-4"><a href="#cb1066-4" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Compact.c              <span class="co"># Compacting garbage collector</span></span>
<span id="cb1066-5"><a href="#cb1066-5" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Evac.c                 <span class="co"># Generational garbage collector:</span></span>
<span id="cb1066-6"><a href="#cb1066-6" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> GC.c                   <span class="co"># Generational garbage collector</span></span>
<span id="cb1066-7"><a href="#cb1066-7" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> MBlock.c               <span class="co"># Architecture-dependent functions for allocations</span></span>
<span id="cb1066-8"><a href="#cb1066-8" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> NonMoving.c            <span class="co"># Low-latency garbage collector</span></span>
<span id="cb1066-9"><a href="#cb1066-9" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> NonMovingMark.c        <span class="co"># Low-latency garbage collector mark algorithm</span></span>
<span id="cb1066-10"><a href="#cb1066-10" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Sanity.c               <span class="co"># Sanity checking for heap and stack</span></span>
<span id="cb1066-11"><a href="#cb1066-11" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Scav.c                 <span class="co"># Scavenger functions for generational GC</span></span>
<span id="cb1066-12"><a href="#cb1066-12" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Storage.c              <span class="co"># GC storage manager</span></span>
<span id="cb1066-13"><a href="#cb1066-13" aria-hidden="true" tabindex="-1"></a><span class="ex">└──</span> Sweep.c                <span class="co"># Mark and sweep algorithm for block allocator</span></span></code></pre></div>
<p>The source for the whole runtime in <code>rts</code> contains 50 or
so modules. The core units of logic are described briefly below.</p>
<div class="sourceCode" id="cb1067"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1067-1"><a href="#cb1067-1" aria-hidden="true" tabindex="-1"></a><span class="ex">rts</span></span>
<span id="cb1067-2"><a href="#cb1067-2" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Arena.c                     <span class="co"># Arena datatypes for garbage collector</span></span>
<span id="cb1067-3"><a href="#cb1067-3" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> ClosureFlags.c              <span class="co"># Definitions for types of closures</span></span>
<span id="cb1067-4"><a href="#cb1067-4" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Disassembler.c              <span class="co"># Bytecode interpreter for GHCi</span></span>
<span id="cb1067-5"><a href="#cb1067-5" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Globals.c                   <span class="co"># Runtime system global variables</span></span>
<span id="cb1067-6"><a href="#cb1067-6" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Hash.c                      <span class="co"># GHCs hash table implementation</span></span>
<span id="cb1067-7"><a href="#cb1067-7" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Heap.c                      <span class="co"># GHC heap definition</span></span>
<span id="cb1067-8"><a href="#cb1067-8" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> HsFFI.c                     <span class="co"># Foreign function interface</span></span>
<span id="cb1067-9"><a href="#cb1067-9" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Interpreter.c               <span class="co"># Bytecode interpreter for GHCi</span></span>
<span id="cb1067-10"><a href="#cb1067-10" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Linker.c                    <span class="co"># Object code linker</span></span>
<span id="cb1067-11"><a href="#cb1067-11" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Printer.c                   <span class="co"># Heap value pretty printer</span></span>
<span id="cb1067-12"><a href="#cb1067-12" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Profiling.c                 <span class="co"># Entry point for profiling functions</span></span>
<span id="cb1067-13"><a href="#cb1067-13" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> RtsAPI.c                    <span class="co"># API for invoking Haskell functions via the RTS</span></span>
<span id="cb1067-14"><a href="#cb1067-14" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> RtsMain.c                   <span class="co"># Entry point for runtime system</span></span>
<span id="cb1067-15"><a href="#cb1067-15" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> RtsStartup.c                <span class="co"># Main function for a standalone Haskell program.</span></span>
<span id="cb1067-16"><a href="#cb1067-16" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> RtsSymbolInfo.c             <span class="co"># RTS symbol table handling</span></span>
<span id="cb1067-17"><a href="#cb1067-17" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> RtsSymbols.c                <span class="co"># RTS symbol definitions</span></span>
<span id="cb1067-18"><a href="#cb1067-18" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Schedule.c                  <span class="co"># Thread scheduler</span></span>
<span id="cb1067-19"><a href="#cb1067-19" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Sparks.c                    <span class="co"># Spark pools for parallel runtime</span></span>
<span id="cb1067-20"><a href="#cb1067-20" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> StgCRun.c                   <span class="co"># Entry point for running STG functions from C</span></span>
<span id="cb1067-21"><a href="#cb1067-21" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> STM.c                       <span class="co"># Software transactional memory </span></span>
<span id="cb1067-22"><a href="#cb1067-22" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Task.c                      <span class="co"># Task managerw for parallel runtime</span></span>
<span id="cb1067-23"><a href="#cb1067-23" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Threads.c                   <span class="co"># Core thread types and spawning functions</span></span>
<span id="cb1067-24"><a href="#cb1067-24" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> TopHandler.c                <span class="co"># RTS main thread handler</span></span>
<span id="cb1067-25"><a href="#cb1067-25" aria-hidden="true" tabindex="-1"></a><span class="ex">├──</span> Weak.c                      <span class="co"># Handling of weak pointers and finalisation logic</span></span>
<span id="cb1067-26"><a href="#cb1067-26" aria-hidden="true" tabindex="-1"></a><span class="ex">└──</span> WSDeque.c                   <span class="co"># Work-stealing deque data structure for parallel runtime</span></span></code></pre></div>
<p>The runtime system itself also has three different modes/ways of
operation.</p>
<ul>
<li><em>Vanilla</em> - Runtime without additional settings. Single
threaded.</li>
<li><em>Threaded</em> - Runtime linked using the <code>-threaded</code>
option.</li>
<li><em>Profiling</em> - Runtime linked using the <code>-prof</code>
option.</li>
</ul>
<p>The specific flags can be checked by passing <code>+RTS --info</code>
to a compiled binary.</p>
<div class="sourceCode" id="cb1068"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1068-1"><a href="#cb1068-1" aria-hidden="true" tabindex="-1"></a> [(<span class="st">&quot;GHC RTS&quot;</span>, <span class="st">&quot;YES&quot;</span>)</span>
<span id="cb1068-2"><a href="#cb1068-2" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;GHC version&quot;</span>, <span class="st">&quot;8.6.5&quot;</span>)</span>
<span id="cb1068-3"><a href="#cb1068-3" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;RTS way&quot;</span>, <span class="st">&quot;rts_v&quot;</span>)</span>
<span id="cb1068-4"><a href="#cb1068-4" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Build platform&quot;</span>, <span class="st">&quot;x86_64-unknown-linux&quot;</span>)</span>
<span id="cb1068-5"><a href="#cb1068-5" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Build architecture&quot;</span>, <span class="st">&quot;x86_64&quot;</span>)</span>
<span id="cb1068-6"><a href="#cb1068-6" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Build OS&quot;</span>, <span class="st">&quot;linux&quot;</span>)</span>
<span id="cb1068-7"><a href="#cb1068-7" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Build vendor&quot;</span>, <span class="st">&quot;unknown&quot;</span>)</span>
<span id="cb1068-8"><a href="#cb1068-8" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Host platform&quot;</span>, <span class="st">&quot;x86_64-unknown-linux&quot;</span>)</span>
<span id="cb1068-9"><a href="#cb1068-9" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Host architecture&quot;</span>, <span class="st">&quot;x86_64&quot;</span>)</span>
<span id="cb1068-10"><a href="#cb1068-10" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Host OS&quot;</span>, <span class="st">&quot;linux&quot;</span>)</span>
<span id="cb1068-11"><a href="#cb1068-11" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Host vendor&quot;</span>, <span class="st">&quot;unknown&quot;</span>)</span>
<span id="cb1068-12"><a href="#cb1068-12" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Target platform&quot;</span>, <span class="st">&quot;x86_64-unknown-linux&quot;</span>)</span>
<span id="cb1068-13"><a href="#cb1068-13" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Target architecture&quot;</span>, <span class="st">&quot;x86_64&quot;</span>)</span>
<span id="cb1068-14"><a href="#cb1068-14" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Target OS&quot;</span>, <span class="st">&quot;linux&quot;</span>)</span>
<span id="cb1068-15"><a href="#cb1068-15" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Target vendor&quot;</span>, <span class="st">&quot;unknown&quot;</span>)</span>
<span id="cb1068-16"><a href="#cb1068-16" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Word size&quot;</span>, <span class="st">&quot;64&quot;</span>)</span>
<span id="cb1068-17"><a href="#cb1068-17" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Compiler unregisterised&quot;</span>, <span class="st">&quot;NO&quot;</span>)</span>
<span id="cb1068-18"><a href="#cb1068-18" aria-hidden="true" tabindex="-1"></a> ,(<span class="st">&quot;Tables next to code&quot;</span>, <span class="st">&quot;YES&quot;</span>)</span>
<span id="cb1068-19"><a href="#cb1068-19" aria-hidden="true" tabindex="-1"></a> ]</span></code></pre></div>
<p>The state of the runtime can also be queried at runtime for
statistics about the heap, garbage collector and wall time. The
<code>getRTSStats</code> generates two datatypes with all the queryable
information contained in <code>RTSStats</code> and
<code>GCDetails</code>.</p>
<div class="sourceCode" id="cb1069"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1069-1"><a href="#cb1069-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Stats</span></span>
<span id="cb1069-2"><a href="#cb1069-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getRTSStats ::</span> <span class="dt">IO</span> <span class="dt">RTSStats</span></span></code></pre></div>
<hr/>
<h1 id="profiling">Profiling</h1>
<h2 id="criterion">Criterion</h2>
<p>Criterion is a statistically aware benchmarking tool. It exposes a
library which allows us to benchmark individual functions over and over
and test the distribution of timings for aberrant beahvior and
stability. These kind of tests are quite common to include in libraries
which need to test that the introduction of new logic doesn’t result in
performance regressions.</p>
<p>Criterion operates largely with the following four functions.</p>
<div class="sourceCode" id="cb1070"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1070-1"><a href="#cb1070-1" aria-hidden="true" tabindex="-1"></a><span class="ot">whnf ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Pure</span></span>
<span id="cb1070-2"><a href="#cb1070-2" aria-hidden="true" tabindex="-1"></a><span class="ot">nf ::</span> <span class="dt">NFData</span> b <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Pure</span></span>
<span id="cb1070-3"><a href="#cb1070-3" aria-hidden="true" tabindex="-1"></a><span class="ot">nfIO ::</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1070-4"><a href="#cb1070-4" aria-hidden="true" tabindex="-1"></a><span class="ot">bench ::</span> <span class="dt">Benchmarkable</span> b <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Benchmark</span></span></code></pre></div>
<p>The <code>whnf</code> function evaluates a function applied to an
argument <code>a</code> to <em>weak head normal form</em>, while
<code>nf</code> evaluates a function applied to an argument
<code>a</code> deeply to <em>normal form</em>. See <a
href="#laziness">Laziness</a>.</p>
<p>The <code>bench</code> function samples a function over and over
according to a configuration to develop a statistical distribution of
its runtime.</p>
<div class="sourceCode" id="cb1071"
data-include="src/15-testing/criterion.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1071-1"><a href="#cb1071-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Criterion.Main</span></span>
<span id="cb1071-2"><a href="#cb1071-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1071-3"><a href="#cb1071-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- Naive recursion for fibonacci numbers.</span></span>
<span id="cb1071-4"><a href="#cb1071-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fib1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1071-5"><a href="#cb1071-5" aria-hidden="true" tabindex="-1"></a>fib1 <span class="dv">0</span> <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb1071-6"><a href="#cb1071-6" aria-hidden="true" tabindex="-1"></a>fib1 <span class="dv">1</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb1071-7"><a href="#cb1071-7" aria-hidden="true" tabindex="-1"></a>fib1 n <span class="ot">=</span> fib1 (n <span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> fib1 (n <span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb1071-8"><a href="#cb1071-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1071-9"><a href="#cb1071-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- Use the De Moivre closed form for fibonacci numbers.</span></span>
<span id="cb1071-10"><a href="#cb1071-10" aria-hidden="true" tabindex="-1"></a><span class="ot">fib2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1071-11"><a href="#cb1071-11" aria-hidden="true" tabindex="-1"></a>fib2 x <span class="ot">=</span> <span class="fu">truncate</span> <span class="op">$</span> (<span class="dv">1</span> <span class="op">/</span> <span class="fu">sqrt</span> <span class="dv">5</span>) <span class="op">*</span> (phi <span class="op">^</span> x <span class="op">-</span> psi <span class="op">^</span> x)</span>
<span id="cb1071-12"><a href="#cb1071-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1071-13"><a href="#cb1071-13" aria-hidden="true" tabindex="-1"></a>    phi <span class="ot">=</span> (<span class="dv">1</span> <span class="op">+</span> <span class="fu">sqrt</span> <span class="dv">5</span>) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb1071-14"><a href="#cb1071-14" aria-hidden="true" tabindex="-1"></a>    psi <span class="ot">=</span> (<span class="dv">1</span> <span class="op">-</span> <span class="fu">sqrt</span> <span class="dv">5</span>) <span class="op">/</span> <span class="dv">2</span></span>
<span id="cb1071-15"><a href="#cb1071-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1071-16"><a href="#cb1071-16" aria-hidden="true" tabindex="-1"></a><span class="ot">suite ::</span> [<span class="dt">Benchmark</span>]</span>
<span id="cb1071-17"><a href="#cb1071-17" aria-hidden="true" tabindex="-1"></a>suite <span class="ot">=</span></span>
<span id="cb1071-18"><a href="#cb1071-18" aria-hidden="true" tabindex="-1"></a>  [ bgroup</span>
<span id="cb1071-19"><a href="#cb1071-19" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;naive&quot;</span></span>
<span id="cb1071-20"><a href="#cb1071-20" aria-hidden="true" tabindex="-1"></a>      [ bench <span class="st">&quot;fib 10&quot;</span> <span class="op">$</span> whnf fib1 <span class="dv">5</span>,</span>
<span id="cb1071-21"><a href="#cb1071-21" aria-hidden="true" tabindex="-1"></a>        bench <span class="st">&quot;fib 20&quot;</span> <span class="op">$</span> whnf fib1 <span class="dv">10</span></span>
<span id="cb1071-22"><a href="#cb1071-22" aria-hidden="true" tabindex="-1"></a>      ],</span>
<span id="cb1071-23"><a href="#cb1071-23" aria-hidden="true" tabindex="-1"></a>    bgroup</span>
<span id="cb1071-24"><a href="#cb1071-24" aria-hidden="true" tabindex="-1"></a>      <span class="st">&quot;de moivre&quot;</span></span>
<span id="cb1071-25"><a href="#cb1071-25" aria-hidden="true" tabindex="-1"></a>      [ bench <span class="st">&quot;fib 10&quot;</span> <span class="op">$</span> whnf fib2 <span class="dv">5</span>,</span>
<span id="cb1071-26"><a href="#cb1071-26" aria-hidden="true" tabindex="-1"></a>        bench <span class="st">&quot;fib 20&quot;</span> <span class="op">$</span> whnf fib2 <span class="dv">10</span></span>
<span id="cb1071-27"><a href="#cb1071-27" aria-hidden="true" tabindex="-1"></a>      ]</span>
<span id="cb1071-28"><a href="#cb1071-28" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb1071-29"><a href="#cb1071-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1071-30"><a href="#cb1071-30" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1071-31"><a href="#cb1071-31" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> defaultMain suite</span></code></pre></div>
<p>These criterion reports can be generated out to either CSV or to an
HTML file output with plots of the data.</p>
<div class="sourceCode" id="cb1072"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1072-1"><a href="#cb1072-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> runhaskell criterion<span class="op">.</span>hs</span>
<span id="cb1072-2"><a href="#cb1072-2" aria-hidden="true" tabindex="-1"></a>warming up</span>
<span id="cb1072-3"><a href="#cb1072-3" aria-hidden="true" tabindex="-1"></a>estimating clock resolution<span class="op">...</span></span>
<span id="cb1072-4"><a href="#cb1072-4" aria-hidden="true" tabindex="-1"></a>mean is <span class="fl">2.349801</span> us (<span class="dv">320001</span> iterations)</span>
<span id="cb1072-5"><a href="#cb1072-5" aria-hidden="true" tabindex="-1"></a>found <span class="dv">1788</span> outliers among <span class="dv">319999</span> samples (<span class="fl">0.6</span><span class="op">%</span>)</span>
<span id="cb1072-6"><a href="#cb1072-6" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1373</span> (<span class="fl">0.4</span><span class="op">%</span>) high severe</span>
<span id="cb1072-7"><a href="#cb1072-7" aria-hidden="true" tabindex="-1"></a>estimating cost <span class="kw">of</span> a clock call<span class="op">...</span></span>
<span id="cb1072-8"><a href="#cb1072-8" aria-hidden="true" tabindex="-1"></a>mean is <span class="fl">65.52118</span> ns (<span class="dv">23</span> iterations)</span>
<span id="cb1072-9"><a href="#cb1072-9" aria-hidden="true" tabindex="-1"></a>found <span class="dv">1</span> outliers among <span class="dv">23</span> samples (<span class="fl">4.3</span><span class="op">%</span>)</span>
<span id="cb1072-10"><a href="#cb1072-10" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span> (<span class="fl">4.3</span><span class="op">%</span>) high severe</span>
<span id="cb1072-11"><a href="#cb1072-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1072-12"><a href="#cb1072-12" aria-hidden="true" tabindex="-1"></a>benchmarking de moivre<span class="op">/</span>fib <span class="dv">20</span></span>
<span id="cb1072-13"><a href="#cb1072-13" aria-hidden="true" tabindex="-1"></a>mean<span class="op">:</span> <span class="fl">8.082639</span> us, lb <span class="fl">8.018560</span> us, ub <span class="fl">8.350159</span> us, ci <span class="fl">0.950</span></span>
<span id="cb1072-14"><a href="#cb1072-14" aria-hidden="true" tabindex="-1"></a>std dev<span class="op">:</span> <span class="fl">595.2161</span> ns, lb <span class="fl">77.46251</span> ns, ub <span class="fl">1.408784</span> us, ci <span class="fl">0.950</span></span>
<span id="cb1072-15"><a href="#cb1072-15" aria-hidden="true" tabindex="-1"></a>found <span class="dv">8</span> outliers among <span class="dv">100</span> samples (<span class="fl">8.0</span><span class="op">%</span>)</span>
<span id="cb1072-16"><a href="#cb1072-16" aria-hidden="true" tabindex="-1"></a>  <span class="dv">4</span> (<span class="fl">4.0</span><span class="op">%</span>) high mild</span>
<span id="cb1072-17"><a href="#cb1072-17" aria-hidden="true" tabindex="-1"></a>  <span class="dv">4</span> (<span class="fl">4.0</span><span class="op">%</span>) high severe</span>
<span id="cb1072-18"><a href="#cb1072-18" aria-hidden="true" tabindex="-1"></a>variance introduced by outliers<span class="op">:</span> <span class="fl">67.628</span><span class="op">%</span></span>
<span id="cb1072-19"><a href="#cb1072-19" aria-hidden="true" tabindex="-1"></a>variance is severely inflated by outliers</span></code></pre></div>
<p>To generate an HTML page containing the benchmark results plotted</p>
<div class="sourceCode" id="cb1073"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1073-1"><a href="#cb1073-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc <span class="at">-O2</span> <span class="at">--make</span> criterion.hs</span>
<span id="cb1073-2"><a href="#cb1073-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ./criterion <span class="at">-o</span> bench.html</span></code></pre></div>
<p><img src="img/criterion.png" /></p>
<h2 id="ekg">EKG</h2>
<p>EKG is a monitoring tool that can monitor various aspect of GHC’s
runtime alongside an active process. The interface for the output is
viewable within a browser interface. The monitoring process is forked
off (in a system thread) from the main process.</p>
<div class="sourceCode" id="cb1074"
data-include="src/29-ghc/ekg.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1074-1"><a href="#cb1074-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# Language OverloadedStrings #-}</span></span>
<span id="cb1074-2"><a href="#cb1074-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1074-3"><a href="#cb1074-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb1074-4"><a href="#cb1074-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Remote.Monitoring</span></span>
<span id="cb1074-5"><a href="#cb1074-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1074-6"><a href="#cb1074-6" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1074-7"><a href="#cb1074-7" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1074-8"><a href="#cb1074-8" aria-hidden="true" tabindex="-1"></a>  ekg <span class="ot">&lt;-</span> forkServer <span class="st">&quot;localhost&quot;</span> <span class="dv">8000</span></span>
<span id="cb1074-9"><a href="#cb1074-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;Started server on http://localhost:8000&quot;</span></span>
<span id="cb1074-10"><a href="#cb1074-10" aria-hidden="true" tabindex="-1"></a>  forever <span class="op">$</span> <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span> <span class="fu">putStrLn</span></span></code></pre></div>
<h2 id="rts-profiling">RTS Profiling</h2>
<p>The GHC runtime system can be asked to dump information about
allocations and percentage of wall time spent in various portions of the
runtime system.</p>
<div class="sourceCode" id="cb1075"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1075-1"><a href="#cb1075-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> <span class="op">./</span>program <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span>s</span>
<span id="cb1075-2"><a href="#cb1075-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1075-3"><a href="#cb1075-3" aria-hidden="true" tabindex="-1"></a>       <span class="dv">1</span>,<span class="dv">939</span>,<span class="dv">784</span> bytes allocated <span class="kw">in</span> the heap</span>
<span id="cb1075-4"><a href="#cb1075-4" aria-hidden="true" tabindex="-1"></a>          <span class="dv">11</span>,<span class="dv">160</span> bytes copied during <span class="dt">GC</span></span>
<span id="cb1075-5"><a href="#cb1075-5" aria-hidden="true" tabindex="-1"></a>          <span class="dv">44</span>,<span class="dv">416</span> bytes <span class="fu">maximum</span> residency (<span class="dv">2</span> sample(s))</span>
<span id="cb1075-6"><a href="#cb1075-6" aria-hidden="true" tabindex="-1"></a>          <span class="dv">21</span>,<span class="dv">120</span> bytes <span class="fu">maximum</span> slop</span>
<span id="cb1075-7"><a href="#cb1075-7" aria-hidden="true" tabindex="-1"></a>               <span class="dv">1</span> <span class="dt">MB</span> total memory <span class="kw">in</span> use (<span class="dv">0</span> <span class="dt">MB</span> lost due to fragmentation)</span>
<span id="cb1075-8"><a href="#cb1075-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1075-9"><a href="#cb1075-9" aria-hidden="true" tabindex="-1"></a>                                    <span class="dt">Tot</span> time (elapsed)  <span class="dt">Avg</span> pause  <span class="dt">Max</span> pause</span>
<span id="cb1075-10"><a href="#cb1075-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Gen</span>  <span class="dv">0</span>         <span class="dv">2</span> colls,     <span class="dv">0</span> par    <span class="fl">0.00</span>s    <span class="fl">0.00</span>s     <span class="fl">0.0000</span>s    <span class="fl">0.0000</span>s</span>
<span id="cb1075-11"><a href="#cb1075-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Gen</span>  <span class="dv">1</span>         <span class="dv">2</span> colls,     <span class="dv">0</span> par    <span class="fl">0.00</span>s    <span class="fl">0.00</span>s     <span class="fl">0.0002</span>s    <span class="fl">0.0003</span>s</span>
<span id="cb1075-12"><a href="#cb1075-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1075-13"><a href="#cb1075-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">INIT</span>    time    <span class="fl">0.00</span>s  (  <span class="fl">0.00</span>s elapsed)</span>
<span id="cb1075-14"><a href="#cb1075-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">MUT</span>     time    <span class="fl">0.00</span>s  (  <span class="fl">0.01</span>s elapsed)</span>
<span id="cb1075-15"><a href="#cb1075-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GC</span>      time    <span class="fl">0.00</span>s  (  <span class="fl">0.00</span>s elapsed)</span>
<span id="cb1075-16"><a href="#cb1075-16" aria-hidden="true" tabindex="-1"></a>  <span class="dt">EXIT</span>    time    <span class="fl">0.00</span>s  (  <span class="fl">0.00</span>s elapsed)</span>
<span id="cb1075-17"><a href="#cb1075-17" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Total</span>   time    <span class="fl">0.01</span>s  (  <span class="fl">0.01</span>s elapsed)</span>
<span id="cb1075-18"><a href="#cb1075-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1075-19"><a href="#cb1075-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">%</span><span class="dt">GC</span>     time       <span class="fl">5.0</span><span class="op">%</span>  (<span class="fl">7.1</span><span class="op">%</span> elapsed)</span>
<span id="cb1075-20"><a href="#cb1075-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1075-21"><a href="#cb1075-21" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Alloc</span> rate    <span class="dv">398</span>,<span class="dv">112</span>,<span class="dv">898</span> bytes per <span class="dt">MUT</span> second</span>
<span id="cb1075-22"><a href="#cb1075-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1075-23"><a href="#cb1075-23" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Productivity</span>  <span class="fl">91.4</span><span class="op">%</span> <span class="kw">of</span> total user, <span class="fl">128.8</span><span class="op">%</span> <span class="kw">of</span> total elapsed</span></code></pre></div>
<p>Productivity indicates the amount of time spent during execution
compared to the time spent garbage collecting. Well tuned CPU bound
programs are often in the 90-99% range of productivity range.</p>
<p>In addition individual function profiling information can be
generated by compiling the program with <code>-prof</code> flag. The
resulting information is outputted to a <code>.prof</code> file of the
same name as the module. This is useful for tracking down hotspots in
the program.</p>
<div class="sourceCode" id="cb1076"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1076-1"><a href="#cb1076-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> ghc <span class="op">-</span><span class="dt">O2</span> program<span class="op">.</span>hs <span class="op">-</span>prof <span class="op">-</span>auto<span class="op">-</span><span class="fu">all</span></span>
<span id="cb1076-2"><a href="#cb1076-2" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> <span class="op">./</span>program <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span>p</span>
<span id="cb1076-3"><a href="#cb1076-3" aria-hidden="true" tabindex="-1"></a><span class="op">$</span> cat program<span class="op">.</span>prof</span>
<span id="cb1076-4"><a href="#cb1076-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Mon</span> <span class="dt">Oct</span> <span class="dv">27</span> <span class="dv">23</span><span class="op">:</span><span class="dv">00</span> <span class="dv">2014</span> <span class="dt">Time</span> <span class="fu">and</span> <span class="dt">Allocation</span> <span class="dt">Profiling</span> <span class="dt">Report</span>  (<span class="dt">Final</span>)</span>
<span id="cb1076-5"><a href="#cb1076-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1076-6"><a href="#cb1076-6" aria-hidden="true" tabindex="-1"></a>           program <span class="op">+</span><span class="dt">RTS</span> <span class="op">-</span>p <span class="op">-</span><span class="dt">RTS</span></span>
<span id="cb1076-7"><a href="#cb1076-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1076-8"><a href="#cb1076-8" aria-hidden="true" tabindex="-1"></a>        total time  <span class="ot">=</span>        <span class="fl">0.01</span> secs   (<span class="dv">7</span> ticks <span class="op">@</span> <span class="dv">1000</span> us, <span class="dv">1</span> processor)</span>
<span id="cb1076-9"><a href="#cb1076-9" aria-hidden="true" tabindex="-1"></a>        total alloc <span class="ot">=</span>   <span class="dv">1</span>,<span class="dv">937</span>,<span class="dv">336</span> bytes  (excludes profiling overheads)</span>
<span id="cb1076-10"><a href="#cb1076-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1076-11"><a href="#cb1076-11" aria-hidden="true" tabindex="-1"></a><span class="dt">COST</span> <span class="dt">CENTRE</span> <span class="dt">MODULE</span>           <span class="op">%</span>time <span class="op">%</span>alloc</span>
<span id="cb1076-12"><a href="#cb1076-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1076-13"><a href="#cb1076-13" aria-hidden="true" tabindex="-1"></a><span class="dt">CAF</span>         <span class="dt">Main</span>             <span class="fl">100.0</span>   <span class="fl">97.2</span></span>
<span id="cb1076-14"><a href="#cb1076-14" aria-hidden="true" tabindex="-1"></a><span class="dt">CAF</span>         <span class="dt">GHC.IO.Handle.FD</span>   <span class="fl">0.0</span>    <span class="fl">1.8</span></span>
<span id="cb1076-15"><a href="#cb1076-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1076-16"><a href="#cb1076-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1076-17"><a href="#cb1076-17" aria-hidden="true" tabindex="-1"></a>                                                      individual     inherited</span>
<span id="cb1076-18"><a href="#cb1076-18" aria-hidden="true" tabindex="-1"></a><span class="dt">COST</span> <span class="dt">CENTRE</span> <span class="dt">MODULE</span>                  no<span class="op">.</span>     entries  <span class="op">%</span>time <span class="op">%</span>alloc   <span class="op">%</span>time <span class="op">%</span>alloc</span>
<span id="cb1076-19"><a href="#cb1076-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1076-20"><a href="#cb1076-20" aria-hidden="true" tabindex="-1"></a><span class="dt">MAIN</span>        <span class="dt">MAIN</span>                     <span class="dv">42</span>           <span class="dv">0</span>    <span class="fl">0.0</span>    <span class="fl">0.7</span>   <span class="fl">100.0</span>  <span class="fl">100.0</span></span>
<span id="cb1076-21"><a href="#cb1076-21" aria-hidden="true" tabindex="-1"></a> <span class="dt">CAF</span>        <span class="dt">Main</span>                     <span class="dv">83</span>           <span class="dv">0</span>  <span class="fl">100.0</span>   <span class="fl">97.2</span>   <span class="fl">100.0</span>   <span class="fl">97.2</span></span>
<span id="cb1076-22"><a href="#cb1076-22" aria-hidden="true" tabindex="-1"></a> <span class="dt">CAF</span>        <span class="dt">GHC.IO.Encoding</span>          <span class="dv">78</span>           <span class="dv">0</span>    <span class="fl">0.0</span>    <span class="fl">0.1</span>     <span class="fl">0.0</span>    <span class="fl">0.1</span></span>
<span id="cb1076-23"><a href="#cb1076-23" aria-hidden="true" tabindex="-1"></a> <span class="dt">CAF</span>        <span class="dt">GHC.IO.Handle.FD</span>         <span class="dv">77</span>           <span class="dv">0</span>    <span class="fl">0.0</span>    <span class="fl">1.8</span>     <span class="fl">0.0</span>    <span class="fl">1.8</span></span>
<span id="cb1076-24"><a href="#cb1076-24" aria-hidden="true" tabindex="-1"></a> <span class="dt">CAF</span>        <span class="dt">GHC.Conc.Signal</span>          <span class="dv">74</span>           <span class="dv">0</span>    <span class="fl">0.0</span>    <span class="fl">0.0</span>     <span class="fl">0.0</span>    <span class="fl">0.0</span></span>
<span id="cb1076-25"><a href="#cb1076-25" aria-hidden="true" tabindex="-1"></a> <span class="dt">CAF</span>        <span class="dt">GHC.IO.Encoding.Iconv</span>    <span class="dv">69</span>           <span class="dv">0</span>    <span class="fl">0.0</span>    <span class="fl">0.0</span>     <span class="fl">0.0</span>    <span class="fl">0.0</span></span>
<span id="cb1076-26"><a href="#cb1076-26" aria-hidden="true" tabindex="-1"></a> <span class="dt">CAF</span>        <span class="dt">GHC.Show</span>                 <span class="dv">60</span>           <span class="dv">0</span>    <span class="fl">0.0</span>    <span class="fl">0.0</span>     <span class="fl">0.0</span>    <span class="fl">0.0</span></span></code></pre></div>
</hr>
<h1 id="compilers">Compilers</h1>
<p>Haskell is widely regarded as being a best in class for the
construction of compilers and there are many examples of programming
languages that were bootstrapped on Haskell.</p>
<p>Compiler development largely consists of a process of transforming
one graph representation of a program or abstract syntax tree into
simpler graph representations while preserving the semantics of the
languages. Many of these operations can be written quite concisely using
Haskell’s pattern matching machinery.</p>
<p>Haskell itself also has a rich academic tradition and an enormous
number of academic papers will use Haskell as the implementation
language used to describe a typechecker, parser or other novel compiler
idea.</p>
<p>In addition the Hackage ecosystem has a wide variety of modules that
many individuals have abstracted out of their own compilers into
reusable components. These are broadly divided into several
categories:</p>
<ul>
<li><strong>Binder libraries</strong> - Libraries for manipulating
lambda calculus terms and perform capture-avoiding substitution, alpha
renaming and beta reduction.</li>
<li><strong>Name generation</strong> - Generation of fresh names for use
in compiler passes which need to generates names which don’t clash with
each other.</li>
<li><strong>Code Generators</strong> - Libraries for emitting LLVM or
other assembly representations at the end of the compiler.</li>
<li><strong>Source Generators</strong> - Libraries for emitting textual
syntax of another language used for doing source-to-source
translations.</li>
<li><strong>Graph Analysis</strong> - Libraries for doing control flow
analysis.</li>
<li><strong>Pretty Printers</strong> - Libraries for turning abstract
syntax trees into textual forms.</li>
<li><strong>Parser Generators</strong> - Libraries for generating
parsers and lexers from higher-level syntax descriptions.</li>
<li><strong>Traversal Utilities</strong> - Libraries for writing
traversal and rewrite systems across AST types.</li>
<li><strong>REPL Generators</strong> - Libraries fo building command
line interfaces for Read-Eval-Print loops.</li>
</ul>
<h2 id="unbound">Unbound</h2>
<p>Several libraries exist to mechanize the process of writing name
capture and substitution, since it is largely mechanical. Probably the
most robust is the <code>unbound</code> library. For example we can
implement the infer function for a small Hindley-Milner system over a
simple typed lambda calculus without having to write the name capture
and substitution mechanics ourselves.</p>
<div class="sourceCode" id="cb1077"
data-include="src/30-languages/unbound.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1077-1"><a href="#cb1077-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1077-2"><a href="#cb1077-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb1077-3"><a href="#cb1077-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb1077-4"><a href="#cb1077-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb1077-5"><a href="#cb1077-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb1077-6"><a href="#cb1077-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-7"><a href="#cb1077-7" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Infer</span> <span class="kw">where</span></span>
<span id="cb1077-8"><a href="#cb1077-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-9"><a href="#cb1077-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.String</span></span>
<span id="cb1077-10"><a href="#cb1077-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map</span> (<span class="dt">Map</span>)</span>
<span id="cb1077-11"><a href="#cb1077-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Error</span></span>
<span id="cb1077-12"><a href="#cb1077-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb1077-13"><a href="#cb1077-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-14"><a href="#cb1077-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Unbound.LocallyNameless</span> <span class="kw">as</span> <span class="dt">NL</span></span>
<span id="cb1077-15"><a href="#cb1077-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Unbound.LocallyNameless</span> <span class="kw">hiding</span> (<span class="dt">Subst</span>, compose)</span>
<span id="cb1077-16"><a href="#cb1077-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-17"><a href="#cb1077-17" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Type</span></span>
<span id="cb1077-18"><a href="#cb1077-18" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">TVar</span> (<span class="dt">Name</span> <span class="dt">Type</span>)</span>
<span id="cb1077-19"><a href="#cb1077-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">TArr</span> <span class="dt">Type</span> <span class="dt">Type</span></span>
<span id="cb1077-20"><a href="#cb1077-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb1077-21"><a href="#cb1077-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-22"><a href="#cb1077-22" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1077-23"><a href="#cb1077-23" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> (<span class="dt">Name</span> <span class="dt">Expr</span>)</span>
<span id="cb1077-24"><a href="#cb1077-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> (<span class="dt">Bind</span> (<span class="dt">Name</span> <span class="dt">Expr</span>) <span class="dt">Expr</span>)</span>
<span id="cb1077-25"><a href="#cb1077-25" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1077-26"><a href="#cb1077-26" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Let</span> (<span class="dt">Bind</span> (<span class="dt">Name</span> <span class="dt">Expr</span>) <span class="dt">Expr</span>)</span>
<span id="cb1077-27"><a href="#cb1077-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb1077-28"><a href="#cb1077-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-29"><a href="#cb1077-29" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(derive [&#39;<span class="dt">&#39;Type</span>, &#39;<span class="dt">&#39;Expr</span>])</span>
<span id="cb1077-30"><a href="#cb1077-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-31"><a href="#cb1077-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-32"><a href="#cb1077-32" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsString</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb1077-33"><a href="#cb1077-33" aria-hidden="true" tabindex="-1"></a>    fromString <span class="ot">=</span> <span class="dt">Var</span> <span class="op">.</span> fromString</span>
<span id="cb1077-34"><a href="#cb1077-34" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsString</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb1077-35"><a href="#cb1077-35" aria-hidden="true" tabindex="-1"></a>    fromString <span class="ot">=</span> <span class="dt">TVar</span> <span class="op">.</span> fromString</span>
<span id="cb1077-36"><a href="#cb1077-36" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Name</span> <span class="dt">Expr</span>) <span class="kw">where</span></span>
<span id="cb1077-37"><a href="#cb1077-37" aria-hidden="true" tabindex="-1"></a>    fromString <span class="ot">=</span> string2Name</span>
<span id="cb1077-38"><a href="#cb1077-38" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">IsString</span> (<span class="dt">Name</span> <span class="dt">Type</span>) <span class="kw">where</span></span>
<span id="cb1077-39"><a href="#cb1077-39" aria-hidden="true" tabindex="-1"></a>    fromString <span class="ot">=</span> string2Name</span>
<span id="cb1077-40"><a href="#cb1077-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-41"><a href="#cb1077-41" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb1077-42"><a href="#cb1077-42" aria-hidden="true" tabindex="-1"></a>    (<span class="op">==</span>) <span class="ot">=</span> eqType</span>
<span id="cb1077-43"><a href="#cb1077-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-44"><a href="#cb1077-44" aria-hidden="true" tabindex="-1"></a><span class="ot">eqType ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1077-45"><a href="#cb1077-45" aria-hidden="true" tabindex="-1"></a>eqType (<span class="dt">TVar</span> v1) (<span class="dt">TVar</span> v2) <span class="ot">=</span> v1 <span class="op">==</span> v2</span>
<span id="cb1077-46"><a href="#cb1077-46" aria-hidden="true" tabindex="-1"></a>eqType _ _ <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb1077-47"><a href="#cb1077-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-48"><a href="#cb1077-48" aria-hidden="true" tabindex="-1"></a><span class="ot">uvar ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb1077-49"><a href="#cb1077-49" aria-hidden="true" tabindex="-1"></a>uvar x <span class="ot">=</span> <span class="dt">Var</span> (s2n x)</span>
<span id="cb1077-50"><a href="#cb1077-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-51"><a href="#cb1077-51" aria-hidden="true" tabindex="-1"></a><span class="ot">tvar ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb1077-52"><a href="#cb1077-52" aria-hidden="true" tabindex="-1"></a>tvar x <span class="ot">=</span> <span class="dt">TVar</span> (s2n x)</span>
<span id="cb1077-53"><a href="#cb1077-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-54"><a href="#cb1077-54" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alpha</span> <span class="dt">Type</span></span>
<span id="cb1077-55"><a href="#cb1077-55" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alpha</span> <span class="dt">Expr</span></span>
<span id="cb1077-56"><a href="#cb1077-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-57"><a href="#cb1077-57" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NL.Subst</span> <span class="dt">Type</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb1077-58"><a href="#cb1077-58" aria-hidden="true" tabindex="-1"></a>  isvar (<span class="dt">TVar</span> v) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">SubstName</span> v)</span>
<span id="cb1077-59"><a href="#cb1077-59" aria-hidden="true" tabindex="-1"></a>  isvar _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1077-60"><a href="#cb1077-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-61"><a href="#cb1077-61" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NL.Subst</span> <span class="dt">Expr</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb1077-62"><a href="#cb1077-62" aria-hidden="true" tabindex="-1"></a>  isvar (<span class="dt">Var</span> v) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">SubstName</span> v)</span>
<span id="cb1077-63"><a href="#cb1077-63" aria-hidden="true" tabindex="-1"></a>  isvar _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1077-64"><a href="#cb1077-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-65"><a href="#cb1077-65" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NL.Subst</span> <span class="dt">Expr</span> <span class="dt">Type</span> <span class="kw">where</span></span>
<span id="cb1077-66"><a href="#cb1077-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-67"><a href="#cb1077-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-68"><a href="#cb1077-68" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TypeError</span></span>
<span id="cb1077-69"><a href="#cb1077-69" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">UnboundVariable</span> (<span class="dt">Name</span> <span class="dt">Expr</span>)</span>
<span id="cb1077-70"><a href="#cb1077-70" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">GenericTypeError</span></span>
<span id="cb1077-71"><a href="#cb1077-71" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb1077-72"><a href="#cb1077-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-73"><a href="#cb1077-73" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Error</span> <span class="dt">TypeError</span> <span class="kw">where</span></span>
<span id="cb1077-74"><a href="#cb1077-74" aria-hidden="true" tabindex="-1"></a>  noMsg <span class="ot">=</span> <span class="dt">GenericTypeError</span></span>
<span id="cb1077-75"><a href="#cb1077-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-76"><a href="#cb1077-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-77"><a href="#cb1077-77" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Env</span> <span class="ot">=</span> <span class="dt">Map</span> (<span class="dt">Name</span> <span class="dt">Expr</span>) <span class="dt">Type</span></span>
<span id="cb1077-78"><a href="#cb1077-78" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Constraint</span> <span class="ot">=</span> (<span class="dt">Type</span>, <span class="dt">Type</span>)</span>
<span id="cb1077-79"><a href="#cb1077-79" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Infer</span> <span class="ot">=</span> <span class="dt">ErrorT</span> <span class="dt">TypeError</span> <span class="dt">FreshM</span></span>
<span id="cb1077-80"><a href="#cb1077-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-81"><a href="#cb1077-81" aria-hidden="true" tabindex="-1"></a><span class="ot">empty ::</span> <span class="dt">Env</span></span>
<span id="cb1077-82"><a href="#cb1077-82" aria-hidden="true" tabindex="-1"></a>empty <span class="ot">=</span> Map.empty</span>
<span id="cb1077-83"><a href="#cb1077-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-84"><a href="#cb1077-84" aria-hidden="true" tabindex="-1"></a><span class="ot">freshtv ::</span> <span class="dt">Infer</span> <span class="dt">Type</span></span>
<span id="cb1077-85"><a href="#cb1077-85" aria-hidden="true" tabindex="-1"></a>freshtv <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1077-86"><a href="#cb1077-86" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> fresh <span class="st">&quot;_t&quot;</span></span>
<span id="cb1077-87"><a href="#cb1077-87" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">TVar</span> x</span>
<span id="cb1077-88"><a href="#cb1077-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-89"><a href="#cb1077-89" aria-hidden="true" tabindex="-1"></a><span class="ot">infer ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Infer</span> (<span class="dt">Type</span>, [<span class="dt">Constraint</span>])</span>
<span id="cb1077-90"><a href="#cb1077-90" aria-hidden="true" tabindex="-1"></a>infer env expr <span class="ot">=</span> <span class="kw">case</span> expr  <span class="kw">of</span></span>
<span id="cb1077-91"><a href="#cb1077-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-92"><a href="#cb1077-92" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Lam</span> b <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1077-93"><a href="#cb1077-93" aria-hidden="true" tabindex="-1"></a>    (n,e) <span class="ot">&lt;-</span> unbind b</span>
<span id="cb1077-94"><a href="#cb1077-94" aria-hidden="true" tabindex="-1"></a>    tv <span class="ot">&lt;-</span> freshtv</span>
<span id="cb1077-95"><a href="#cb1077-95" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> env&#39; <span class="ot">=</span> Map.insert n tv env</span>
<span id="cb1077-96"><a href="#cb1077-96" aria-hidden="true" tabindex="-1"></a>    (t, cs) <span class="ot">&lt;-</span> infer env&#39; e</span>
<span id="cb1077-97"><a href="#cb1077-97" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="dt">TArr</span> tv t, cs)</span>
<span id="cb1077-98"><a href="#cb1077-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-99"><a href="#cb1077-99" aria-hidden="true" tabindex="-1"></a>  <span class="dt">App</span> e1 e2 <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1077-100"><a href="#cb1077-100" aria-hidden="true" tabindex="-1"></a>     (t1, cs1) <span class="ot">&lt;-</span> infer env e1</span>
<span id="cb1077-101"><a href="#cb1077-101" aria-hidden="true" tabindex="-1"></a>     (t2, cs2) <span class="ot">&lt;-</span> infer env e2</span>
<span id="cb1077-102"><a href="#cb1077-102" aria-hidden="true" tabindex="-1"></a>     tv <span class="ot">&lt;-</span> freshtv</span>
<span id="cb1077-103"><a href="#cb1077-103" aria-hidden="true" tabindex="-1"></a>     <span class="fu">return</span> (tv, (t1, <span class="dt">TArr</span> t2 tv) <span class="op">:</span> cs1 <span class="op">++</span> cs2)</span>
<span id="cb1077-104"><a href="#cb1077-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-105"><a href="#cb1077-105" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Var</span> n <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1077-106"><a href="#cb1077-106" aria-hidden="true" tabindex="-1"></a>     <span class="kw">case</span> Map.lookup n env <span class="kw">of</span></span>
<span id="cb1077-107"><a href="#cb1077-107" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> throwError <span class="op">$</span> <span class="dt">UnboundVariable</span> n</span>
<span id="cb1077-108"><a href="#cb1077-108" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> t  <span class="ot">-&gt;</span> <span class="fu">return</span> (t, [])</span>
<span id="cb1077-109"><a href="#cb1077-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1077-110"><a href="#cb1077-110" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Let</span> b <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1077-111"><a href="#cb1077-111" aria-hidden="true" tabindex="-1"></a>     (n, e) <span class="ot">&lt;-</span> unbind b</span>
<span id="cb1077-112"><a href="#cb1077-112" aria-hidden="true" tabindex="-1"></a>     (tBody, csBody) <span class="ot">&lt;-</span> infer env e</span>
<span id="cb1077-113"><a href="#cb1077-113" aria-hidden="true" tabindex="-1"></a>     <span class="kw">let</span> env&#39; <span class="ot">=</span> Map.insert n tBody env</span>
<span id="cb1077-114"><a href="#cb1077-114" aria-hidden="true" tabindex="-1"></a>     (t, cs) <span class="ot">&lt;-</span> infer env&#39; e</span>
<span id="cb1077-115"><a href="#cb1077-115" aria-hidden="true" tabindex="-1"></a>     <span class="fu">return</span> (t, cs <span class="op">++</span> csBody)</span></code></pre></div>
<h2 id="unbound-generics">Unbound Generics</h2>
<p>Recently unbound was ported to use GHC.Generics instead of Template
Haskell. The API is effectively the same, so for example a simple lambda
calculus could be written as:</p>
<div class="sourceCode" id="cb1078"
data-include="src/30-languages/unbound-generics.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1078-1"><a href="#cb1078-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></span>
<span id="cb1078-2"><a href="#cb1078-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb1078-3"><a href="#cb1078-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb1078-4"><a href="#cb1078-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb1078-5"><a href="#cb1078-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb1078-6"><a href="#cb1078-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></span>
<span id="cb1078-7"><a href="#cb1078-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-8"><a href="#cb1078-8" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">LC</span> <span class="kw">where</span></span>
<span id="cb1078-9"><a href="#cb1078-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-10"><a href="#cb1078-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Unbound.Generics.LocallyNameless</span></span>
<span id="cb1078-11"><a href="#cb1078-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Unbound.Generics.LocallyNameless.Internal.Fold</span> (toListOf)</span>
<span id="cb1078-12"><a href="#cb1078-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-13"><a href="#cb1078-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Generics</span></span>
<span id="cb1078-14"><a href="#cb1078-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-15"><a href="#cb1078-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Typeable</span> (<span class="dt">Typeable</span>)</span>
<span id="cb1078-16"><a href="#cb1078-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Set</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb1078-17"><a href="#cb1078-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-18"><a href="#cb1078-18" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Reader</span> (<span class="dt">Reader</span>, runReader)</span>
<span id="cb1078-19"><a href="#cb1078-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-20"><a href="#cb1078-20" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Exp</span></span>
<span id="cb1078-21"><a href="#cb1078-21" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> (<span class="dt">Name</span> <span class="dt">Exp</span>)</span>
<span id="cb1078-22"><a href="#cb1078-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> (<span class="dt">Bind</span> (<span class="dt">Name</span> <span class="dt">Exp</span>) <span class="dt">Exp</span>)</span>
<span id="cb1078-23"><a href="#cb1078-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Exp</span> <span class="dt">Exp</span></span>
<span id="cb1078-24"><a href="#cb1078-24" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Generic</span>, <span class="dt">Typeable</span>)</span>
<span id="cb1078-25"><a href="#cb1078-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-26"><a href="#cb1078-26" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Alpha</span> <span class="dt">Exp</span></span>
<span id="cb1078-27"><a href="#cb1078-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-28"><a href="#cb1078-28" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Subst</span> <span class="dt">Exp</span> <span class="dt">Exp</span> <span class="kw">where</span></span>
<span id="cb1078-29"><a href="#cb1078-29" aria-hidden="true" tabindex="-1"></a>  isvar (<span class="dt">Var</span> x) <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">SubstName</span> x)</span>
<span id="cb1078-30"><a href="#cb1078-30" aria-hidden="true" tabindex="-1"></a>  isvar _       <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1078-31"><a href="#cb1078-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-32"><a href="#cb1078-32" aria-hidden="true" tabindex="-1"></a><span class="ot">fvSet ::</span> (<span class="dt">Alpha</span> a, <span class="dt">Typeable</span> b) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">S.Set</span> (<span class="dt">Name</span> b)</span>
<span id="cb1078-33"><a href="#cb1078-33" aria-hidden="true" tabindex="-1"></a>fvSet <span class="ot">=</span> S.fromList <span class="op">.</span> toListOf fv</span>
<span id="cb1078-34"><a href="#cb1078-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-35"><a href="#cb1078-35" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">M</span> a <span class="ot">=</span> <span class="dt">FreshM</span> a</span>
<span id="cb1078-36"><a href="#cb1078-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-37"><a href="#cb1078-37" aria-hidden="true" tabindex="-1"></a><span class="ot">(=~) ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Bool</span></span>
<span id="cb1078-38"><a href="#cb1078-38" aria-hidden="true" tabindex="-1"></a>e1 <span class="op">=~</span> e2 <span class="op">|</span> e1 <span class="ot">`aeq`</span> e2 <span class="ot">=</span> <span class="fu">return</span> <span class="dt">True</span></span>
<span id="cb1078-39"><a href="#cb1078-39" aria-hidden="true" tabindex="-1"></a>e1 <span class="op">=~</span> e2 <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1078-40"><a href="#cb1078-40" aria-hidden="true" tabindex="-1"></a>    e1&#39; <span class="ot">&lt;-</span> red e1</span>
<span id="cb1078-41"><a href="#cb1078-41" aria-hidden="true" tabindex="-1"></a>    e2&#39; <span class="ot">&lt;-</span> red e2</span>
<span id="cb1078-42"><a href="#cb1078-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> e1&#39; <span class="ot">`aeq`</span> e1 <span class="op">&amp;&amp;</span> e2&#39; <span class="ot">`aeq`</span> e2</span>
<span id="cb1078-43"><a href="#cb1078-43" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> <span class="fu">return</span> <span class="dt">False</span></span>
<span id="cb1078-44"><a href="#cb1078-44" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> e1&#39; <span class="op">=~</span> e2&#39;</span>
<span id="cb1078-45"><a href="#cb1078-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-46"><a href="#cb1078-46" aria-hidden="true" tabindex="-1"></a><span class="co">-- Reduction</span></span>
<span id="cb1078-47"><a href="#cb1078-47" aria-hidden="true" tabindex="-1"></a><span class="ot">red ::</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">M</span> <span class="dt">Exp</span></span>
<span id="cb1078-48"><a href="#cb1078-48" aria-hidden="true" tabindex="-1"></a>red (<span class="dt">App</span> e1 e2) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1078-49"><a href="#cb1078-49" aria-hidden="true" tabindex="-1"></a>  e1&#39; <span class="ot">&lt;-</span> red e1</span>
<span id="cb1078-50"><a href="#cb1078-50" aria-hidden="true" tabindex="-1"></a>  e2&#39; <span class="ot">&lt;-</span> red e2</span>
<span id="cb1078-51"><a href="#cb1078-51" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> e1&#39; <span class="kw">of</span></span>
<span id="cb1078-52"><a href="#cb1078-52" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Lam</span> bnd <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1078-53"><a href="#cb1078-53" aria-hidden="true" tabindex="-1"></a>        (x, e1&#39;&#39;) <span class="ot">&lt;-</span> unbind bnd</span>
<span id="cb1078-54"><a href="#cb1078-54" aria-hidden="true" tabindex="-1"></a>        <span class="fu">return</span> <span class="op">$</span> subst x e2&#39; e1&#39;&#39;</span>
<span id="cb1078-55"><a href="#cb1078-55" aria-hidden="true" tabindex="-1"></a>    <span class="fu">otherwise</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">App</span> e1&#39; e2&#39;</span>
<span id="cb1078-56"><a href="#cb1078-56" aria-hidden="true" tabindex="-1"></a>red (<span class="dt">Lam</span> bnd) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1078-57"><a href="#cb1078-57" aria-hidden="true" tabindex="-1"></a>   (x, e) <span class="ot">&lt;-</span> unbind bnd</span>
<span id="cb1078-58"><a href="#cb1078-58" aria-hidden="true" tabindex="-1"></a>   e&#39; <span class="ot">&lt;-</span> red e</span>
<span id="cb1078-59"><a href="#cb1078-59" aria-hidden="true" tabindex="-1"></a>   <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb1078-60"><a href="#cb1078-60" aria-hidden="true" tabindex="-1"></a>     <span class="dt">App</span> e1 (<span class="dt">Var</span> y) <span class="op">|</span> y <span class="op">==</span> x <span class="op">&amp;&amp;</span> x <span class="ot">`S.notMember`</span> fvSet e1 <span class="ot">-&gt;</span> <span class="fu">return</span> e1</span>
<span id="cb1078-61"><a href="#cb1078-61" aria-hidden="true" tabindex="-1"></a>     <span class="fu">otherwise</span> <span class="ot">-&gt;</span> <span class="fu">return</span> (<span class="dt">Lam</span> (bind x e&#39;))</span>
<span id="cb1078-62"><a href="#cb1078-62" aria-hidden="true" tabindex="-1"></a>red (<span class="dt">Var</span> x) <span class="ot">=</span> <span class="fu">return</span> <span class="op">$</span> (<span class="dt">Var</span> x)</span>
<span id="cb1078-63"><a href="#cb1078-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-64"><a href="#cb1078-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-65"><a href="#cb1078-65" aria-hidden="true" tabindex="-1"></a><span class="ot">x ::</span> <span class="dt">Name</span> <span class="dt">Exp</span></span>
<span id="cb1078-66"><a href="#cb1078-66" aria-hidden="true" tabindex="-1"></a>x <span class="ot">=</span> string2Name <span class="st">&quot;x&quot;</span></span>
<span id="cb1078-67"><a href="#cb1078-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-68"><a href="#cb1078-68" aria-hidden="true" tabindex="-1"></a><span class="ot">y ::</span> <span class="dt">Name</span> <span class="dt">Exp</span></span>
<span id="cb1078-69"><a href="#cb1078-69" aria-hidden="true" tabindex="-1"></a>y <span class="ot">=</span> string2Name <span class="st">&quot;y&quot;</span></span>
<span id="cb1078-70"><a href="#cb1078-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-71"><a href="#cb1078-71" aria-hidden="true" tabindex="-1"></a><span class="ot">z ::</span> <span class="dt">Name</span> <span class="dt">Exp</span></span>
<span id="cb1078-72"><a href="#cb1078-72" aria-hidden="true" tabindex="-1"></a>z <span class="ot">=</span> string2Name <span class="st">&quot;z&quot;</span></span>
<span id="cb1078-73"><a href="#cb1078-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-74"><a href="#cb1078-74" aria-hidden="true" tabindex="-1"></a><span class="ot">s ::</span> <span class="dt">Name</span> <span class="dt">Exp</span></span>
<span id="cb1078-75"><a href="#cb1078-75" aria-hidden="true" tabindex="-1"></a>s <span class="ot">=</span> string2Name <span class="st">&quot;s&quot;</span></span>
<span id="cb1078-76"><a href="#cb1078-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-77"><a href="#cb1078-77" aria-hidden="true" tabindex="-1"></a><span class="ot">lam ::</span> <span class="dt">Name</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span> <span class="ot">-&gt;</span> <span class="dt">Exp</span></span>
<span id="cb1078-78"><a href="#cb1078-78" aria-hidden="true" tabindex="-1"></a>lam x y <span class="ot">=</span> <span class="dt">Lam</span> (bind x y)</span>
<span id="cb1078-79"><a href="#cb1078-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-80"><a href="#cb1078-80" aria-hidden="true" tabindex="-1"></a>zero  <span class="ot">=</span> lam s (lam z (<span class="dt">Var</span> z))</span>
<span id="cb1078-81"><a href="#cb1078-81" aria-hidden="true" tabindex="-1"></a>one   <span class="ot">=</span> lam s (lam z (<span class="dt">App</span> (<span class="dt">Var</span> s) (<span class="dt">Var</span> z)))</span>
<span id="cb1078-82"><a href="#cb1078-82" aria-hidden="true" tabindex="-1"></a>two   <span class="ot">=</span> lam s (lam z (<span class="dt">App</span> (<span class="dt">Var</span> s) (<span class="dt">App</span> (<span class="dt">Var</span> s) (<span class="dt">Var</span> z))))</span>
<span id="cb1078-83"><a href="#cb1078-83" aria-hidden="true" tabindex="-1"></a>three <span class="ot">=</span> lam s (lam z (<span class="dt">App</span> (<span class="dt">Var</span> s) (<span class="dt">App</span> (<span class="dt">Var</span> s) (<span class="dt">App</span> (<span class="dt">Var</span> s) (<span class="dt">Var</span> z)))))</span>
<span id="cb1078-84"><a href="#cb1078-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-85"><a href="#cb1078-85" aria-hidden="true" tabindex="-1"></a>plus <span class="ot">=</span> lam x (lam y (lam s (lam z (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> x) (<span class="dt">Var</span> s)) (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> y) (<span class="dt">Var</span> s)) (<span class="dt">Var</span> z))))))</span>
<span id="cb1078-86"><a href="#cb1078-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-87"><a href="#cb1078-87" aria-hidden="true" tabindex="-1"></a>true <span class="ot">=</span> lam x (lam y (<span class="dt">Var</span> x))</span>
<span id="cb1078-88"><a href="#cb1078-88" aria-hidden="true" tabindex="-1"></a>false <span class="ot">=</span> lam x (lam y (<span class="dt">Var</span> y))</span>
<span id="cb1078-89"><a href="#cb1078-89" aria-hidden="true" tabindex="-1"></a>if_ x y z <span class="ot">=</span> (<span class="dt">App</span> (<span class="dt">App</span> x y) z)</span>
<span id="cb1078-90"><a href="#cb1078-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1078-91"><a href="#cb1078-91" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1078-92"><a href="#cb1078-92" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1078-93"><a href="#cb1078-93" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> lam x (<span class="dt">Var</span> x) <span class="ot">`aeq`</span> lam y (<span class="dt">Var</span> y)</span>
<span id="cb1078-94"><a href="#cb1078-94" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="fu">not</span> (lam x (<span class="dt">Var</span> y) <span class="ot">`aeq`</span> lam x (<span class="dt">Var</span> x))</span>
<span id="cb1078-95"><a href="#cb1078-95" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> lam x (<span class="dt">App</span> (lam y (<span class="dt">Var</span> x)) (lam y (<span class="dt">Var</span> y))) <span class="op">=~</span> (lam y (<span class="dt">Var</span> y))</span>
<span id="cb1078-96"><a href="#cb1078-96" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> lam x (<span class="dt">App</span> (<span class="dt">Var</span> y) (<span class="dt">Var</span> x)) <span class="op">=~</span> <span class="dt">Var</span> y</span>
<span id="cb1078-97"><a href="#cb1078-97" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> if_ true (<span class="dt">Var</span> x) (<span class="dt">Var</span> y) <span class="op">=~</span> <span class="dt">Var</span> x</span>
<span id="cb1078-98"><a href="#cb1078-98" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> if_ false (<span class="dt">Var</span> x) (<span class="dt">Var</span> y) <span class="op">=~</span> <span class="dt">Var</span> y</span>
<span id="cb1078-99"><a href="#cb1078-99" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> <span class="dt">App</span> (<span class="dt">App</span> plus one) two <span class="op">=~</span> three</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="https://github.com/lambdageek/unbound-generics">unbound-generics</a></li>
</ul>
<h2 id="pretty-printers">Pretty Printers</h2>
<p>Pretty is the first Wadler-Leijen style combinator library, it
exposes a simple set of primitives to print Haskell datatypes to legacy
strings programmatically. You probably don’t want to use this library
but it inspired most of the ones that followed after. There are many
many many pretty printing libraries for Haskell.</p>
<p><strong>Wadler-Leijen Style</strong></p>
<ul>
<li>pretty</li>
<li>wl-pprint</li>
<li>wl-pprint-text</li>
<li>wl-pprint-ansiterm</li>
<li>wl-pprint-terminfo</li>
<li>wl-pprint-annotated</li>
<li>wl-pprint-console</li>
<li>ansi-pretty</li>
<li>ansi-terminal</li>
<li>ansi-wl-pprint</li>
</ul>
<p><strong>Modern</strong></p>
<ul>
<li>prettyprinter</li>
<li>prettyprinter-ansi-terminal</li>
<li>prettyprinter-compat-annotated-wl-pprint</li>
<li>prettyprinter-compat-ansi-wl-pprint</li>
<li>prettyprinter-compat-wl-pprint</li>
<li>prettyprinter-convert-ansi-wl-pprint</li>
</ul>
<p><strong>Specialised</strong></p>
<ul>
<li>layout</li>
<li>aeson-pretty</li>
</ul>
<p>These days it is best to avoid the pretty printer and use the
standard <code>prettyprinter</code> library which subsumes most of the
features of these previous libraries under one modern uniform API.</p>
<h2 id="prettyprinter">prettyprinter</h2>
<p>Pretty printer is a printer combinator library which allows us to
write typeclasses over datatypes to render them to strings with
arbitrary formatting. These kind of libraries show up everywhere where
the default <code>Show</code> instance is insufficient for
rendering.</p>
<p>The base interface to these libraries is exposed as a
<code>Pretty</code> class which monoidally composes a variety of
documents together. The Monoid append operation simply concatenates two
documents while a variety of higher level combinators add additional
string elements into the language.</p>
<p>The <code>Pretty</code> class maps an arbitrary value into a
<code>Doc</code> type which is annotated with the renderer.</p>
<div class="sourceCode" id="cb1079"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1079-1"><a href="#cb1079-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Doc</span> ann</span>
<span id="cb1079-2"><a href="#cb1079-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1079-3"><a href="#cb1079-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Pretty</span> a <span class="kw">where</span></span>
<span id="cb1079-4"><a href="#cb1079-4" aria-hidden="true" tabindex="-1"></a><span class="ot">  pretty ::</span> a <span class="ot">-&gt;</span> <span class="dt">Doc</span> ann</span>
<span id="cb1079-5"><a href="#cb1079-5" aria-hidden="true" tabindex="-1"></a><span class="ot">  prettyList ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Doc</span> ann</span></code></pre></div>
<p>The <code>Doc</code> type can then be rendered to any number of
strings type means of a layout algorithm. The builtin methods are
<code>Compact</code>, <code>Smart</code> and <code>Pretty</code>.</p>
<div class="sourceCode" id="cb1080"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1080-1"><a href="#cb1080-1" aria-hidden="true" tabindex="-1"></a><span class="ot">viaShow ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Doc</span> ann</span>
<span id="cb1080-2"><a href="#cb1080-2" aria-hidden="true" tabindex="-1"></a><span class="ot">layoutPretty ::</span> <span class="dt">LayoutOptions</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span> ann <span class="ot">-&gt;</span> <span class="dt">SimpleDocStream</span> ann</span>
<span id="cb1080-3"><a href="#cb1080-3" aria-hidden="true" tabindex="-1"></a><span class="ot">renderStrict ::</span> <span class="dt">SimpleDocStream</span> ann <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb1080-4"><a href="#cb1080-4" aria-hidden="true" tabindex="-1"></a><span class="ot">putDoc ::</span> <span class="dt">Doc</span> ann <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
<p>The common combinators are shown below,</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Combinator</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>&lt;&gt;</code></td>
<td style="text-align: left;">Concatenation</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;+&gt;</code></td>
<td style="text-align: left;">Spaced concatenation</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>nest</code></td>
<td style="text-align: left;">Nested a document with whitespace</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>group</code></td>
<td style="text-align: left;">Lays out on a line by removing line
breaks</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>align</code></td>
<td style="text-align: left;">Lays out with the nesting level at the
current column</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>hang</code></td>
<td style="text-align: left;">Lays out with the nesting level relative
to the first line</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>indent</code></td>
<td style="text-align: left;">Increases indentation by a given
count</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>list</code></td>
<td style="text-align: left;">Lays out a given list with braces and
commas.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>tupled</code></td>
<td style="text-align: left;">Lays out a given list with parens and
commas.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>hsep</code></td>
<td style="text-align: left;">Concatenates list of docs horizontally
with a separator</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>hcat</code></td>
<td style="text-align: left;">Concatenates list of docs
horizontally</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>vcat</code></td>
<td style="text-align: left;">Concatenates list of docs vertically</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>puncutate</code></td>
<td style="text-align: left;">Appends a given doc to all elements of a
list of docs</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>parens</code></td>
<td style="text-align: left;">Surrounds with parentheses</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>dquotes</code></td>
<td style="text-align: left;">Surrounds with double quotes</td>
</tr>
</tbody>
</table>
<p>For example the common pretty printed form of the lambda calculus
<code>k</code> combinator is:</p>
<div class="sourceCode" id="cb1081"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1081-1"><a href="#cb1081-1" aria-hidden="true" tabindex="-1"></a>\f g x <span class="op">.</span> (f (g x))</span></code></pre></div>
<p>The prettyprinter library can be used to pretty print nested data
structures in a more human readable form for any type that implements
<code>Show</code>. For example a dump of the structure for the AST of SK
combinator with <code>ppShow</code>.</p>
<div class="sourceCode" id="cb1082"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1082-1"><a href="#cb1082-1" aria-hidden="true" tabindex="-1"></a><span class="dt">App</span></span>
<span id="cb1082-2"><a href="#cb1082-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Lam</span></span>
<span id="cb1082-3"><a href="#cb1082-3" aria-hidden="true" tabindex="-1"></a>     <span class="st">&quot;f&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;g&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;g&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))))))</span>
<span id="cb1082-4"><a href="#cb1082-4" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)))</span></code></pre></div>
<p>A full example of pretty printing the lambda calculus is shown below.
This uses a custom <code>Pretty</code> class to pass an integral value
which indicates the depth of the lambda expression. Alternatively the
builtin <code>Pretty</code> class could be used for simpler
datatypes.</p>
<div class="sourceCode" id="cb1083"
data-include="src/30-languages/pretty.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1083-1"><a href="#cb1083-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb1083-2"><a href="#cb1083-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-3"><a href="#cb1083-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text.Prettyprint.Doc</span> <span class="kw">hiding</span> (<span class="dt">Pretty</span>)</span>
<span id="cb1083-4"><a href="#cb1083-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text.Prettyprint.Doc.Render.Terminal</span></span>
<span id="cb1083-5"><a href="#cb1083-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-6"><a href="#cb1083-6" aria-hidden="true" tabindex="-1"></a><span class="ot">parensIf ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Doc</span> a <span class="ot">-&gt;</span> <span class="dt">Doc</span> a</span>
<span id="cb1083-7"><a href="#cb1083-7" aria-hidden="true" tabindex="-1"></a>parensIf <span class="dt">True</span> <span class="ot">=</span> parens</span>
<span id="cb1083-8"><a href="#cb1083-8" aria-hidden="true" tabindex="-1"></a>parensIf <span class="dt">False</span> <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb1083-9"><a href="#cb1083-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-10"><a href="#cb1083-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Name</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb1083-11"><a href="#cb1083-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-12"><a href="#cb1083-12" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1083-13"><a href="#cb1083-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Var</span> <span class="dt">String</span></span>
<span id="cb1083-14"><a href="#cb1083-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lit</span> <span class="dt">Ground</span></span>
<span id="cb1083-15"><a href="#cb1083-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">App</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span>
<span id="cb1083-16"><a href="#cb1083-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Lam</span> <span class="dt">Name</span> <span class="dt">Expr</span></span>
<span id="cb1083-17"><a href="#cb1083-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb1083-18"><a href="#cb1083-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-19"><a href="#cb1083-19" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Ground</span></span>
<span id="cb1083-20"><a href="#cb1083-20" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">LInt</span> <span class="dt">Int</span></span>
<span id="cb1083-21"><a href="#cb1083-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">LBool</span> <span class="dt">Bool</span></span>
<span id="cb1083-22"><a href="#cb1083-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb1083-23"><a href="#cb1083-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-24"><a href="#cb1083-24" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Pretty</span> p <span class="kw">where</span></span>
<span id="cb1083-25"><a href="#cb1083-25" aria-hidden="true" tabindex="-1"></a><span class="ot">  ppr ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> p <span class="ot">-&gt;</span> <span class="dt">Doc</span> <span class="dt">AnsiStyle</span></span>
<span id="cb1083-26"><a href="#cb1083-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-27"><a href="#cb1083-27" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">String</span> <span class="kw">where</span></span>
<span id="cb1083-28"><a href="#cb1083-28" aria-hidden="true" tabindex="-1"></a>  ppr _ <span class="ot">=</span> pretty</span>
<span id="cb1083-29"><a href="#cb1083-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-30"><a href="#cb1083-30" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Pretty</span> (<span class="dt">Doc</span> <span class="dt">AnsiStyle</span>) <span class="kw">where</span></span>
<span id="cb1083-31"><a href="#cb1083-31" aria-hidden="true" tabindex="-1"></a>  ppr _ <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb1083-32"><a href="#cb1083-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-33"><a href="#cb1083-33" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb1083-34"><a href="#cb1083-34" aria-hidden="true" tabindex="-1"></a>  ppr _ (<span class="dt">Var</span> x) <span class="ot">=</span> pretty x</span>
<span id="cb1083-35"><a href="#cb1083-35" aria-hidden="true" tabindex="-1"></a>  ppr _ (<span class="dt">Lit</span> (<span class="dt">LInt</span> a)) <span class="ot">=</span> pretty (<span class="fu">show</span> a)</span>
<span id="cb1083-36"><a href="#cb1083-36" aria-hidden="true" tabindex="-1"></a>  ppr _ (<span class="dt">Lit</span> (<span class="dt">LBool</span> b)) <span class="ot">=</span> pretty (<span class="fu">show</span> b)</span>
<span id="cb1083-37"><a href="#cb1083-37" aria-hidden="true" tabindex="-1"></a>  ppr p e<span class="op">@</span>(<span class="dt">App</span> _ _) <span class="ot">=</span></span>
<span id="cb1083-38"><a href="#cb1083-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (f, xs) <span class="ot">=</span> viewApp e</span>
<span id="cb1083-39"><a href="#cb1083-39" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> <span class="kw">let</span> args <span class="ot">=</span> sep <span class="op">$</span> <span class="fu">map</span> (ppr (p <span class="op">+</span> <span class="dv">1</span>)) xs</span>
<span id="cb1083-40"><a href="#cb1083-40" aria-hidden="true" tabindex="-1"></a>         <span class="kw">in</span> parensIf (p <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">$</span> ppr p f <span class="op">&lt;+&gt;</span> args</span>
<span id="cb1083-41"><a href="#cb1083-41" aria-hidden="true" tabindex="-1"></a>  ppr p e<span class="op">@</span>(<span class="dt">Lam</span> _ _) <span class="ot">=</span></span>
<span id="cb1083-42"><a href="#cb1083-42" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> body <span class="ot">=</span> ppr (p <span class="op">+</span> <span class="dv">1</span>) (viewBody e)</span>
<span id="cb1083-43"><a href="#cb1083-43" aria-hidden="true" tabindex="-1"></a>     <span class="kw">in</span> <span class="kw">let</span> vars <span class="ot">=</span> <span class="fu">map</span> (ppr <span class="dv">0</span>) (viewVars e)</span>
<span id="cb1083-44"><a href="#cb1083-44" aria-hidden="true" tabindex="-1"></a>         <span class="kw">in</span> parensIf (p <span class="op">&gt;</span> <span class="dv">0</span>) <span class="op">$</span> pretty <span class="ch">&#39;\\&#39;</span> <span class="op">&lt;&gt;</span> hsep vars <span class="op">&lt;+&gt;</span> pretty <span class="st">&quot;.&quot;</span> <span class="op">&lt;+&gt;</span> body</span>
<span id="cb1083-45"><a href="#cb1083-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-46"><a href="#cb1083-46" aria-hidden="true" tabindex="-1"></a><span class="ot">viewVars ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]</span>
<span id="cb1083-47"><a href="#cb1083-47" aria-hidden="true" tabindex="-1"></a>viewVars (<span class="dt">Lam</span> n a) <span class="ot">=</span> n <span class="op">:</span> viewVars a</span>
<span id="cb1083-48"><a href="#cb1083-48" aria-hidden="true" tabindex="-1"></a>viewVars _ <span class="ot">=</span> []</span>
<span id="cb1083-49"><a href="#cb1083-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-50"><a href="#cb1083-50" aria-hidden="true" tabindex="-1"></a><span class="ot">viewBody ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb1083-51"><a href="#cb1083-51" aria-hidden="true" tabindex="-1"></a>viewBody (<span class="dt">Lam</span> _ a) <span class="ot">=</span> viewBody a</span>
<span id="cb1083-52"><a href="#cb1083-52" aria-hidden="true" tabindex="-1"></a>viewBody x <span class="ot">=</span> x</span>
<span id="cb1083-53"><a href="#cb1083-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-54"><a href="#cb1083-54" aria-hidden="true" tabindex="-1"></a><span class="ot">viewApp ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> (<span class="dt">Expr</span>, [<span class="dt">Expr</span>])</span>
<span id="cb1083-55"><a href="#cb1083-55" aria-hidden="true" tabindex="-1"></a>viewApp (<span class="dt">App</span> e1 e2) <span class="ot">=</span> go e1 [e2]</span>
<span id="cb1083-56"><a href="#cb1083-56" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1083-57"><a href="#cb1083-57" aria-hidden="true" tabindex="-1"></a>    go (<span class="dt">App</span> a b) xs <span class="ot">=</span> go a (b <span class="op">:</span> xs)</span>
<span id="cb1083-58"><a href="#cb1083-58" aria-hidden="true" tabindex="-1"></a>    go f xs <span class="ot">=</span> (f, xs)</span>
<span id="cb1083-59"><a href="#cb1083-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-60"><a href="#cb1083-60" aria-hidden="true" tabindex="-1"></a><span class="ot">ppexpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1083-61"><a href="#cb1083-61" aria-hidden="true" tabindex="-1"></a>ppexpr <span class="ot">=</span> render <span class="op">.</span> ppr <span class="dv">0</span></span>
<span id="cb1083-62"><a href="#cb1083-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-63"><a href="#cb1083-63" aria-hidden="true" tabindex="-1"></a><span class="ot">render ::</span> <span class="dt">Pretty</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1083-64"><a href="#cb1083-64" aria-hidden="true" tabindex="-1"></a>render a <span class="ot">=</span> putDoc (ppr <span class="dv">0</span> a)</span>
<span id="cb1083-65"><a href="#cb1083-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-66"><a href="#cb1083-66" aria-hidden="true" tabindex="-1"></a>s , k,<span class="ot"> example ::</span> <span class="dt">Expr</span></span>
<span id="cb1083-67"><a href="#cb1083-67" aria-hidden="true" tabindex="-1"></a>s <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;f&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;g&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;f&quot;</span>) (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">&quot;g&quot;</span>) (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>)))))</span>
<span id="cb1083-68"><a href="#cb1083-68" aria-hidden="true" tabindex="-1"></a>k <span class="ot">=</span> <span class="dt">Lam</span> <span class="st">&quot;x&quot;</span> (<span class="dt">Lam</span> <span class="st">&quot;y&quot;</span> (<span class="dt">Var</span> <span class="st">&quot;x&quot;</span>))</span>
<span id="cb1083-69"><a href="#cb1083-69" aria-hidden="true" tabindex="-1"></a>example <span class="ot">=</span> <span class="dt">App</span> s k</span>
<span id="cb1083-70"><a href="#cb1083-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1083-71"><a href="#cb1083-71" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1083-72"><a href="#cb1083-72" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> render s</span></code></pre></div>
<h2 id="pretty-simple">pretty-simple</h2>
<p>pretty-simple is a Haskell library that renders Show instances in a
prettier way. It exposes functions which are drop in replacements for
show and print.</p>
<div class="sourceCode" id="cb1084"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1084-1"><a href="#cb1084-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pPrint ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m ()</span>
<span id="cb1084-2"><a href="#cb1084-2" aria-hidden="true" tabindex="-1"></a><span class="ot">pShow ::</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Text</span></span>
<span id="cb1084-3"><a href="#cb1084-3" aria-hidden="true" tabindex="-1"></a><span class="ot">pPrintNoColor ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>A simple example is shown below.</p>
<div class="sourceCode" id="cb1085"
data-include="src/30-languages/prettysimple.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1085-1"><a href="#cb1085-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Pretty.Simple</span></span>
<span id="cb1085-2"><a href="#cb1085-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1085-3"><a href="#cb1085-3" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1085-4"><a href="#cb1085-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1085-5"><a href="#cb1085-5" aria-hidden="true" tabindex="-1"></a>  pPrint [<span class="dv">1</span> <span class="op">..</span> <span class="dv">25</span>]</span>
<span id="cb1085-6"><a href="#cb1085-6" aria-hidden="true" tabindex="-1"></a>  pPrint [<span class="dt">Just</span> (<span class="dv">1</span>, <span class="st">&quot;hello&quot;</span>)]</span></code></pre></div>
<p>Pretty-simple can be used as the default GHCi printer as shown in the
<a href="#ghci.conf">.ghci.conf</a> section.</p>
<h2 id="haskeline">Haskeline</h2>
<p>Haskeline is a Haskell library exposing cross-platform readline. It
provides a monad which can take user input from the command line and
allow the user to edit and go back forth on a line of input as well
simple tab completion.</p>
<div class="sourceCode" id="cb1086"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1086-1"><a href="#cb1086-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">InputT</span> m a</span>
<span id="cb1086-2"><a href="#cb1086-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1086-3"><a href="#cb1086-3" aria-hidden="true" tabindex="-1"></a><span class="ot">runInputT ::</span> <span class="dt">Settings</span> <span class="dt">IO</span> <span class="ot">-&gt;</span> <span class="dt">InputT</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb1086-4"><a href="#cb1086-4" aria-hidden="true" tabindex="-1"></a><span class="ot">getInputLine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">InputT</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">String</span>)</span>
<span id="cb1086-5"><a href="#cb1086-5" aria-hidden="true" tabindex="-1"></a><span class="ot">outputStrLn ::</span> <span class="dt">MonadIO</span> m <span class="ot">=&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">InputT</span> m ()</span></code></pre></div>
<p>A simple example of usage is shown below:</p>
<div class="sourceCode" id="cb1087"
data-include="src/30-languages/haskelline.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1087-1"><a href="#cb1087-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span></span>
<span id="cb1087-2"><a href="#cb1087-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Console.Haskeline</span></span>
<span id="cb1087-3"><a href="#cb1087-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1087-4"><a href="#cb1087-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Repl</span> a <span class="ot">=</span> <span class="dt">InputT</span> <span class="dt">IO</span> a</span>
<span id="cb1087-5"><a href="#cb1087-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1087-6"><a href="#cb1087-6" aria-hidden="true" tabindex="-1"></a><span class="ot">process ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1087-7"><a href="#cb1087-7" aria-hidden="true" tabindex="-1"></a>process <span class="ot">=</span> <span class="fu">putStrLn</span></span>
<span id="cb1087-8"><a href="#cb1087-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1087-9"><a href="#cb1087-9" aria-hidden="true" tabindex="-1"></a><span class="ot">repl ::</span> <span class="dt">Repl</span> ()</span>
<span id="cb1087-10"><a href="#cb1087-10" aria-hidden="true" tabindex="-1"></a>repl <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1087-11"><a href="#cb1087-11" aria-hidden="true" tabindex="-1"></a>  minput <span class="ot">&lt;-</span> getInputLine <span class="st">&quot;Repl&gt; &quot;</span></span>
<span id="cb1087-12"><a href="#cb1087-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> minput <span class="kw">of</span></span>
<span id="cb1087-13"><a href="#cb1087-13" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> outputStrLn <span class="st">&quot;Goodbye.&quot;</span></span>
<span id="cb1087-14"><a href="#cb1087-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> input <span class="ot">-&gt;</span> (liftIO <span class="op">$</span> process input) <span class="op">&gt;&gt;</span> repl</span>
<span id="cb1087-15"><a href="#cb1087-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1087-16"><a href="#cb1087-16" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1087-17"><a href="#cb1087-17" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> runInputT defaultSettings repl</span></code></pre></div>
<h2 id="repline">Repline</h2>
<p>Certain sets of tasks in building command line REPL interfaces are so
common that is becomes useful to abstract them out into a library. While
haskeline provides a sensible lower-level API for interfacing with GNU
readline, it is somewhat tedious to implement tab completion logic and
common command logic over and over. To that end Repline assists in
building interactive shells that resemble GHCi’s default behavior.</p>
<div class="sourceCode" id="cb1088"
data-include="src/30-languages/repline.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1088-1"><a href="#cb1088-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb1088-2"><a href="#cb1088-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1088-3"><a href="#cb1088-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span></span>
<span id="cb1088-4"><a href="#cb1088-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (isPrefixOf)</span>
<span id="cb1088-5"><a href="#cb1088-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Console.Repline</span></span>
<span id="cb1088-6"><a href="#cb1088-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Process</span> (callCommand)</span>
<span id="cb1088-7"><a href="#cb1088-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1088-8"><a href="#cb1088-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Repl</span> a <span class="ot">=</span> <span class="dt">HaskelineT</span> <span class="dt">IO</span> a</span>
<span id="cb1088-9"><a href="#cb1088-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1088-10"><a href="#cb1088-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- Evaluation : handle each line user inputs</span></span>
<span id="cb1088-11"><a href="#cb1088-11" aria-hidden="true" tabindex="-1"></a><span class="ot">cmd ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Repl</span> ()</span>
<span id="cb1088-12"><a href="#cb1088-12" aria-hidden="true" tabindex="-1"></a>cmd input <span class="ot">=</span> liftIO <span class="op">$</span> <span class="fu">print</span> input</span>
<span id="cb1088-13"><a href="#cb1088-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1088-14"><a href="#cb1088-14" aria-hidden="true" tabindex="-1"></a><span class="co">-- Tab Completion: return a completion for partial words entered</span></span>
<span id="cb1088-15"><a href="#cb1088-15" aria-hidden="true" tabindex="-1"></a><span class="ot">completer ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">WordCompleter</span> m</span>
<span id="cb1088-16"><a href="#cb1088-16" aria-hidden="true" tabindex="-1"></a>completer n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1088-17"><a href="#cb1088-17" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> names <span class="ot">=</span> [<span class="st">&quot;kirk&quot;</span>, <span class="st">&quot;spock&quot;</span>, <span class="st">&quot;mccoy&quot;</span>]</span>
<span id="cb1088-18"><a href="#cb1088-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="fu">filter</span> (isPrefixOf n) names</span>
<span id="cb1088-19"><a href="#cb1088-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1088-20"><a href="#cb1088-20" aria-hidden="true" tabindex="-1"></a><span class="co">-- Commands</span></span>
<span id="cb1088-21"><a href="#cb1088-21" aria-hidden="true" tabindex="-1"></a><span class="ot">help ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Repl</span> ()</span>
<span id="cb1088-22"><a href="#cb1088-22" aria-hidden="true" tabindex="-1"></a>help args <span class="ot">=</span> liftIO <span class="op">$</span> <span class="fu">print</span> <span class="op">$</span> <span class="st">&quot;Help: &quot;</span> <span class="op">++</span> <span class="fu">show</span> args</span>
<span id="cb1088-23"><a href="#cb1088-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1088-24"><a href="#cb1088-24" aria-hidden="true" tabindex="-1"></a><span class="ot">say ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Repl</span> ()</span>
<span id="cb1088-25"><a href="#cb1088-25" aria-hidden="true" tabindex="-1"></a>say args <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1088-26"><a href="#cb1088-26" aria-hidden="true" tabindex="-1"></a>  _ <span class="ot">&lt;-</span> liftIO <span class="op">$</span> callCommand <span class="op">$</span> <span class="st">&quot;cowsay&quot;</span> <span class="op">++</span> <span class="st">&quot; &quot;</span> <span class="op">++</span> (<span class="fu">unwords</span> args)</span>
<span id="cb1088-27"><a href="#cb1088-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ()</span>
<span id="cb1088-28"><a href="#cb1088-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1088-29"><a href="#cb1088-29" aria-hidden="true" tabindex="-1"></a><span class="ot">options ::</span> [(<span class="dt">String</span>, [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">Repl</span> ())]</span>
<span id="cb1088-30"><a href="#cb1088-30" aria-hidden="true" tabindex="-1"></a>options <span class="ot">=</span></span>
<span id="cb1088-31"><a href="#cb1088-31" aria-hidden="true" tabindex="-1"></a>  [ (<span class="st">&quot;help&quot;</span>, help), <span class="co">-- :help</span></span>
<span id="cb1088-32"><a href="#cb1088-32" aria-hidden="true" tabindex="-1"></a>    (<span class="st">&quot;say&quot;</span>, say) <span class="co">-- :say</span></span>
<span id="cb1088-33"><a href="#cb1088-33" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb1088-34"><a href="#cb1088-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1088-35"><a href="#cb1088-35" aria-hidden="true" tabindex="-1"></a><span class="ot">ini ::</span> <span class="dt">Repl</span> ()</span>
<span id="cb1088-36"><a href="#cb1088-36" aria-hidden="true" tabindex="-1"></a>ini <span class="ot">=</span> liftIO <span class="op">$</span> <span class="fu">putStrLn</span> <span class="st">&quot;Welcome!&quot;</span></span>
<span id="cb1088-37"><a href="#cb1088-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1088-38"><a href="#cb1088-38" aria-hidden="true" tabindex="-1"></a><span class="ot">repl ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1088-39"><a href="#cb1088-39" aria-hidden="true" tabindex="-1"></a>repl <span class="ot">=</span> evalRepl (<span class="fu">pure</span> <span class="st">&quot;&gt;&gt;&gt; &quot;</span>) cmd options <span class="dt">Nothing</span> (<span class="dt">Word</span> completer) ini</span>
<span id="cb1088-40"><a href="#cb1088-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1088-41"><a href="#cb1088-41" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1088-42"><a href="#cb1088-42" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> repl</span></code></pre></div>
<p>Trying it out. (<code>&lt;TAB&gt;</code> indicates a user keypress
)</p>
<div class="sourceCode" id="cb1089"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1089-1"><a href="#cb1089-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> cabal run simple</span>
<span id="cb1089-2"><a href="#cb1089-2" aria-hidden="true" tabindex="-1"></a><span class="ex">Welcome!</span></span>
<span id="cb1089-3"><a href="#cb1089-3" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> <span class="op">&lt;</span>TAB<span class="op">&gt;</span></span>
<span id="cb1089-4"><a href="#cb1089-4" aria-hidden="true" tabindex="-1"></a><span class="ex">kirk</span> spock mccoy</span>
<span id="cb1089-5"><a href="#cb1089-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1089-6"><a href="#cb1089-6" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> k<span class="op">&lt;</span>TAB<span class="op">&gt;</span></span>
<span id="cb1089-7"><a href="#cb1089-7" aria-hidden="true" tabindex="-1"></a><span class="ex">kirk</span></span>
<span id="cb1089-8"><a href="#cb1089-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1089-9"><a href="#cb1089-9" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> spam</span>
<span id="cb1089-10"><a href="#cb1089-10" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;spam&quot;</span></span>
<span id="cb1089-11"><a href="#cb1089-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1089-12"><a href="#cb1089-12" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;&gt;&gt;</span> :say <span class="ex">Hello</span> Haskell</span>
<span id="cb1089-13"><a href="#cb1089-13" aria-hidden="true" tabindex="-1"></a> <span class="ex">_______________</span></span>
<span id="cb1089-14"><a href="#cb1089-14" aria-hidden="true" tabindex="-1"></a><span class="op">&lt;</span> Hello <span class="ex">Haskell</span> <span class="op">&gt;</span></span>
<span id="cb1089-15"><a href="#cb1089-15" aria-hidden="true" tabindex="-1"></a> <span class="ex">---------------</span></span>
<span id="cb1089-16"><a href="#cb1089-16" aria-hidden="true" tabindex="-1"></a>        <span class="ex">\ </span>  ^__^</span>
<span id="cb1089-17"><a href="#cb1089-17" aria-hidden="true" tabindex="-1"></a>         <span class="ex">\ </span> <span class="er">(</span><span class="ex">oo</span><span class="kw">)</span><span class="ex">\_______</span></span>
<span id="cb1089-18"><a href="#cb1089-18" aria-hidden="true" tabindex="-1"></a>            <span class="kw">(</span><span class="ex">__</span><span class="kw">)</span><span class="ex">\ </span>      <span class="er">)</span><span class="ex">\/</span><span class="dt">\</span></span>
<span id="cb1089-19"><a href="#cb1089-19" aria-hidden="true" tabindex="-1"></a>                <span class="kw">||</span><span class="ex">----w</span> <span class="kw">|</span></span>
<span id="cb1089-20"><a href="#cb1089-20" aria-hidden="true" tabindex="-1"></a>                <span class="kw">||</span>     <span class="kw">||</span></span></code></pre></div>
<p>See:</p>
<ul>
<li><a href="https://github.com/sdiehl/repline">repline</a></li>
</ul>
<h2 id="llvm">LLVM</h2>
<p>Haskell has a rich set of LLVM bindings that can generate LLVM and
JIT dynamic code from inside of the Haskell runtime. This is especially
useful for building custom programming languages and compilers which
need native performance. The llvm-hs library is the de-facto standard
for compiler construction in Haskell.</p>
<p>We can link effectively to the LLVM bindings which provide an
efficient JIT which can generate fast code from runtime. These can serve
as the backend to an interpreter, generating fast SIMD operations for
linear algebra, or compiling dataflow representations of neural networks
into code as fast as C from dynamic descriptions of logic in
Haskell.</p>
<p>The llvm-hs library is split across two modules:</p>
<ul>
<li><code>llvm-hs-pure</code> - Pure Haskell datatypes</li>
<li><code>llvm-hs</code> - Bindings to C++ framework for optimisation
and JIT</li>
</ul>
<p>The <code>llvm-hs</code> bindings allow us to construct LLVM abstract
syntax tree by manipulating a variety of Haskell datatypes. These
datatypes all can be serialised to the C++ bindings to construct the
LLVM module’s syntax tree.</p>
<div class="sourceCode" id="cb1090"
data-include="src/30-languages/llvm-hs.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1090-1"><a href="#cb1090-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Except</span></span>
<span id="cb1090-2"><a href="#cb1090-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">BS</span></span>
<span id="cb1090-3"><a href="#cb1090-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">LLVM.AST</span></span>
<span id="cb1090-4"><a href="#cb1090-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">LLVM.AST</span> <span class="kw">as</span> <span class="dt">AST</span></span>
<span id="cb1090-5"><a href="#cb1090-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">LLVM.AST.Global</span></span>
<span id="cb1090-6"><a href="#cb1090-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">LLVM.Context</span></span>
<span id="cb1090-7"><a href="#cb1090-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">LLVM.Module</span></span>
<span id="cb1090-8"><a href="#cb1090-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1090-9"><a href="#cb1090-9" aria-hidden="true" tabindex="-1"></a><span class="ot">int ::</span> <span class="dt">Type</span></span>
<span id="cb1090-10"><a href="#cb1090-10" aria-hidden="true" tabindex="-1"></a>int <span class="ot">=</span> <span class="dt">IntegerType</span> <span class="dv">32</span></span>
<span id="cb1090-11"><a href="#cb1090-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1090-12"><a href="#cb1090-12" aria-hidden="true" tabindex="-1"></a><span class="ot">defAdd ::</span> <span class="dt">Definition</span></span>
<span id="cb1090-13"><a href="#cb1090-13" aria-hidden="true" tabindex="-1"></a>defAdd <span class="ot">=</span></span>
<span id="cb1090-14"><a href="#cb1090-14" aria-hidden="true" tabindex="-1"></a>  <span class="dt">GlobalDefinition</span></span>
<span id="cb1090-15"><a href="#cb1090-15" aria-hidden="true" tabindex="-1"></a>    functionDefaults</span>
<span id="cb1090-16"><a href="#cb1090-16" aria-hidden="true" tabindex="-1"></a>      { name <span class="ot">=</span> <span class="dt">Name</span> <span class="st">&quot;add&quot;</span>,</span>
<span id="cb1090-17"><a href="#cb1090-17" aria-hidden="true" tabindex="-1"></a>        parameters <span class="ot">=</span></span>
<span id="cb1090-18"><a href="#cb1090-18" aria-hidden="true" tabindex="-1"></a>          ( [ <span class="dt">Parameter</span> int (<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>) [],</span>
<span id="cb1090-19"><a href="#cb1090-19" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Parameter</span> int (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>) []</span>
<span id="cb1090-20"><a href="#cb1090-20" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb1090-21"><a href="#cb1090-21" aria-hidden="true" tabindex="-1"></a>            <span class="dt">False</span></span>
<span id="cb1090-22"><a href="#cb1090-22" aria-hidden="true" tabindex="-1"></a>          ),</span>
<span id="cb1090-23"><a href="#cb1090-23" aria-hidden="true" tabindex="-1"></a>        returnType <span class="ot">=</span> int,</span>
<span id="cb1090-24"><a href="#cb1090-24" aria-hidden="true" tabindex="-1"></a>        basicBlocks <span class="ot">=</span> [body]</span>
<span id="cb1090-25"><a href="#cb1090-25" aria-hidden="true" tabindex="-1"></a>      }</span>
<span id="cb1090-26"><a href="#cb1090-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1090-27"><a href="#cb1090-27" aria-hidden="true" tabindex="-1"></a>    body <span class="ot">=</span></span>
<span id="cb1090-28"><a href="#cb1090-28" aria-hidden="true" tabindex="-1"></a>      <span class="dt">BasicBlock</span></span>
<span id="cb1090-29"><a href="#cb1090-29" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Name</span> <span class="st">&quot;entry&quot;</span>)</span>
<span id="cb1090-30"><a href="#cb1090-30" aria-hidden="true" tabindex="-1"></a>        [ <span class="dt">Name</span> <span class="st">&quot;result&quot;</span></span>
<span id="cb1090-31"><a href="#cb1090-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">:=</span> <span class="dt">Add</span></span>
<span id="cb1090-32"><a href="#cb1090-32" aria-hidden="true" tabindex="-1"></a>              <span class="dt">False</span> <span class="co">-- no signed wrap</span></span>
<span id="cb1090-33"><a href="#cb1090-33" aria-hidden="true" tabindex="-1"></a>              <span class="dt">False</span> <span class="co">-- no unsigned wrap</span></span>
<span id="cb1090-34"><a href="#cb1090-34" aria-hidden="true" tabindex="-1"></a>              (<span class="dt">LocalReference</span> int (<span class="dt">Name</span> <span class="st">&quot;a&quot;</span>))</span>
<span id="cb1090-35"><a href="#cb1090-35" aria-hidden="true" tabindex="-1"></a>              (<span class="dt">LocalReference</span> int (<span class="dt">Name</span> <span class="st">&quot;b&quot;</span>))</span>
<span id="cb1090-36"><a href="#cb1090-36" aria-hidden="true" tabindex="-1"></a>              []</span>
<span id="cb1090-37"><a href="#cb1090-37" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb1090-38"><a href="#cb1090-38" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Do</span> <span class="op">$</span> <span class="dt">Ret</span> (<span class="dt">Just</span> (<span class="dt">LocalReference</span> int (<span class="dt">Name</span> <span class="st">&quot;result&quot;</span>))) [])</span>
<span id="cb1090-39"><a href="#cb1090-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1090-40"><a href="#cb1090-40" aria-hidden="true" tabindex="-1"></a><span class="ot">module_ ::</span> <span class="dt">AST.Module</span></span>
<span id="cb1090-41"><a href="#cb1090-41" aria-hidden="true" tabindex="-1"></a>module_ <span class="ot">=</span></span>
<span id="cb1090-42"><a href="#cb1090-42" aria-hidden="true" tabindex="-1"></a>  defaultModule</span>
<span id="cb1090-43"><a href="#cb1090-43" aria-hidden="true" tabindex="-1"></a>    { moduleName <span class="ot">=</span> <span class="st">&quot;basic&quot;</span>,</span>
<span id="cb1090-44"><a href="#cb1090-44" aria-hidden="true" tabindex="-1"></a>      moduleDefinitions <span class="ot">=</span> [defAdd]</span>
<span id="cb1090-45"><a href="#cb1090-45" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb1090-46"><a href="#cb1090-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1090-47"><a href="#cb1090-47" aria-hidden="true" tabindex="-1"></a><span class="ot">toLLVM ::</span> <span class="dt">AST.Module</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb1090-48"><a href="#cb1090-48" aria-hidden="true" tabindex="-1"></a>toLLVM <span class="fu">mod</span> <span class="ot">=</span> withContext <span class="op">$</span> \ctx <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1090-49"><a href="#cb1090-49" aria-hidden="true" tabindex="-1"></a>  llvm <span class="ot">&lt;-</span> withModuleFromAST ctx <span class="fu">mod</span> moduleLLVMAssembly</span>
<span id="cb1090-50"><a href="#cb1090-50" aria-hidden="true" tabindex="-1"></a>  BS.putStrLn llvm</span>
<span id="cb1090-51"><a href="#cb1090-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1090-52"><a href="#cb1090-52" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1090-53"><a href="#cb1090-53" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> toLLVM module_</span></code></pre></div>
<p>This will generate the following LLVM module which can be pretty
printed out:</p>
<div class="sourceCode" id="cb1091"><pre
class="sourceCode llvm"><code class="sourceCode llvm"><span id="cb1091-1"><a href="#cb1091-1" aria-hidden="true" tabindex="-1"></a><span class="co">; ModuleID = &#39;basic&#39;</span></span>
<span id="cb1091-2"><a href="#cb1091-2" aria-hidden="true" tabindex="-1"></a>source_filename = <span class="st">&quot;&lt;string&gt;&quot;</span></span>
<span id="cb1091-3"><a href="#cb1091-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1091-4"><a href="#cb1091-4" aria-hidden="true" tabindex="-1"></a><span class="kw">define</span> <span class="dt">i32</span> <span class="fu">@add</span>(<span class="dt">i32</span> <span class="fu">%a</span>, <span class="dt">i32</span> <span class="fu">%b</span>) {</span>
<span id="cb1091-5"><a href="#cb1091-5" aria-hidden="true" tabindex="-1"></a><span class="fu">entry:</span></span>
<span id="cb1091-6"><a href="#cb1091-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">%result</span> = <span class="kw">add</span> <span class="dt">i32</span> <span class="fu">%a</span>, <span class="fu">%b</span></span>
<span id="cb1091-7"><a href="#cb1091-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">ret</span> <span class="dt">i32</span> <span class="fu">%result</span></span>
<span id="cb1091-8"><a href="#cb1091-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>An alternative interface uses an IRBuilder monad which interactively
constructs up the LLVM AST using monadic combinators.</p>
<div class="sourceCode" id="cb1092"
data-include="src/30-languages/llvm-irbuilder.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1092-1"><a href="#cb1092-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span></span>
<span id="cb1092-2"><a href="#cb1092-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE RecursiveDo #-}</span></span>
<span id="cb1092-3"><a href="#cb1092-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1092-4"><a href="#cb1092-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb1092-5"><a href="#cb1092-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1092-6"><a href="#cb1092-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Text.Lazy.IO</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb1092-7"><a href="#cb1092-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">LLVM.AST</span> <span class="kw">hiding</span> (function)</span>
<span id="cb1092-8"><a href="#cb1092-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">LLVM.AST.Constant</span> <span class="kw">as</span> <span class="dt">C</span></span>
<span id="cb1092-9"><a href="#cb1092-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">LLVM.AST.Float</span> <span class="kw">as</span> <span class="dt">F</span></span>
<span id="cb1092-10"><a href="#cb1092-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">LLVM.AST.IntegerPredicate</span> <span class="kw">as</span> <span class="dt">P</span></span>
<span id="cb1092-11"><a href="#cb1092-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">LLVM.AST.Type</span> <span class="kw">as</span> <span class="dt">AST</span></span>
<span id="cb1092-12"><a href="#cb1092-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">LLVM.IRBuilder.Instruction</span></span>
<span id="cb1092-13"><a href="#cb1092-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">LLVM.IRBuilder.Module</span></span>
<span id="cb1092-14"><a href="#cb1092-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">LLVM.IRBuilder.Monad</span></span>
<span id="cb1092-15"><a href="#cb1092-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1092-16"><a href="#cb1092-16" aria-hidden="true" tabindex="-1"></a><span class="ot">simple ::</span> <span class="dt">Module</span></span>
<span id="cb1092-17"><a href="#cb1092-17" aria-hidden="true" tabindex="-1"></a>simple <span class="ot">=</span> buildModule <span class="st">&quot;exampleModule&quot;</span> <span class="op">$</span> mdo</span>
<span id="cb1092-18"><a href="#cb1092-18" aria-hidden="true" tabindex="-1"></a>  function <span class="st">&quot;f&quot;</span> [(AST.i32, <span class="st">&quot;a&quot;</span>)] AST.i32 <span class="op">$</span> \[a] <span class="ot">-&gt;</span> mdo</span>
<span id="cb1092-19"><a href="#cb1092-19" aria-hidden="true" tabindex="-1"></a>    _entry <span class="ot">&lt;-</span> block <span class="ot">`named`</span> <span class="st">&quot;entry&quot;</span></span>
<span id="cb1092-20"><a href="#cb1092-20" aria-hidden="true" tabindex="-1"></a>    cond <span class="ot">&lt;-</span> icmp <span class="dt">P.EQ</span> a (<span class="dt">ConstantOperand</span> (<span class="dt">C.Int</span> <span class="dv">32</span> <span class="dv">0</span>))</span>
<span id="cb1092-21"><a href="#cb1092-21" aria-hidden="true" tabindex="-1"></a>    condBr cond ifThen ifElse</span>
<span id="cb1092-22"><a href="#cb1092-22" aria-hidden="true" tabindex="-1"></a>    ifThen <span class="ot">&lt;-</span> block</span>
<span id="cb1092-23"><a href="#cb1092-23" aria-hidden="true" tabindex="-1"></a>    trVal <span class="ot">&lt;-</span> add a (<span class="dt">ConstantOperand</span> (<span class="dt">C.Int</span> <span class="dv">32</span> <span class="dv">0</span>))</span>
<span id="cb1092-24"><a href="#cb1092-24" aria-hidden="true" tabindex="-1"></a>    br ifExit</span>
<span id="cb1092-25"><a href="#cb1092-25" aria-hidden="true" tabindex="-1"></a>    ifElse <span class="ot">&lt;-</span> block <span class="ot">`named`</span> <span class="st">&quot;if.else&quot;</span></span>
<span id="cb1092-26"><a href="#cb1092-26" aria-hidden="true" tabindex="-1"></a>    flVal <span class="ot">&lt;-</span> add a (<span class="dt">ConstantOperand</span> (<span class="dt">C.Int</span> <span class="dv">32</span> <span class="dv">0</span>))</span>
<span id="cb1092-27"><a href="#cb1092-27" aria-hidden="true" tabindex="-1"></a>    br ifExit</span>
<span id="cb1092-28"><a href="#cb1092-28" aria-hidden="true" tabindex="-1"></a>    ifExit <span class="ot">&lt;-</span> block <span class="ot">`named`</span> <span class="st">&quot;if.exit&quot;</span></span>
<span id="cb1092-29"><a href="#cb1092-29" aria-hidden="true" tabindex="-1"></a>    r <span class="ot">&lt;-</span> phi [(trVal, ifThen), (flVal, ifElse)]</span>
<span id="cb1092-30"><a href="#cb1092-30" aria-hidden="true" tabindex="-1"></a>    ret r</span>
<span id="cb1092-31"><a href="#cb1092-31" aria-hidden="true" tabindex="-1"></a>  function <span class="st">&quot;plus&quot;</span> [(AST.i32, <span class="st">&quot;x&quot;</span>), (AST.i32, <span class="st">&quot;y&quot;</span>)] AST.i32 <span class="op">$</span> \[x, y] <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1092-32"><a href="#cb1092-32" aria-hidden="true" tabindex="-1"></a>    _entry <span class="ot">&lt;-</span> block <span class="ot">`named`</span> <span class="st">&quot;entry2&quot;</span></span>
<span id="cb1092-33"><a href="#cb1092-33" aria-hidden="true" tabindex="-1"></a>    r <span class="ot">&lt;-</span> add x y</span>
<span id="cb1092-34"><a href="#cb1092-34" aria-hidden="true" tabindex="-1"></a>    ret r</span>
<span id="cb1092-35"><a href="#cb1092-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1092-36"><a href="#cb1092-36" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1092-37"><a href="#cb1092-37" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> simple</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="https://hackage.haskell.org/package/llvm-hs">llvm-hs</a></li>
<li><a
href="https://hackage.haskell.org/package/llvm-hs-pure">llvm-hs-pure</a></li>
<li><a
href="https://github.com/llvm-hs/llvm-hs-examples">llvm-hs-examples</a></li>
<li><a href="http://www.stephendiehl.com/llvm">Kaleidoscope
Tutorial</a></li>
<li><a href="https://github.com/llvm-hs">llvm-hs Github</a></li>
</ul>
</hr>
<h1 id="template-haskell">Template Haskell</h1>
<h2 id="metaprogramming">Metaprogramming</h2>
<p>Template Haskell is a very powerful set of abstractions, some might
say <strong>too</strong> powerful. It effectively allows us to run
arbitrary code at compile-time to generate other Haskell code. You can
some absolutely crazy things, like going off and reading from the
filesystem or doing network calls that informs how your code compiles
leading to non-deterministic builds.</p>
<p>While in some extreme cases TH is useful, some discretion is required
when using this in production setting. TemplateHaskell can cause your
build times to grow without bound, force you to manually sort all
definitions your modules, and generally produce unmaintainable code. If
you find yourself falling back on metaprogramming ask yourself, what in
my abstractions has failed me such that my only option is to <em>write
code that writes code</em>.</p>
<div class="alert alert-danger">
<p>Consideration should be used before enabling TemplateHaskell.
Consider an idiomatic solution first.</p>
</div>
<h2 id="quasiquotation">Quasiquotation</h2>
<p>Quasiquotation allows us to express “quoted” blocks of syntax that
need not necessarily be the syntax of the host language, but unlike just
writing a giant string it is instead parsed into some AST datatype in
the host language. Notably values from the host languages can be
injected into the custom language via user-definable logic allowing
information to flow between the two languages.</p>
<p>In practice quasiquotation can be used to implement custom domain
specific languages or integrate with other general languages entirely
via code-generation.</p>
<p>We’ve already seen how to write a Parsec parser, now let’s write a
quasiquoter for it.</p>
<div class="sourceCode" id="cb1093"
data-include="src/31-template-haskell/Quasiquote.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1093-1"><a href="#cb1093-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb1093-2"><a href="#cb1093-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1093-3"><a href="#cb1093-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-4"><a href="#cb1093-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Quasiquote</span> <span class="kw">where</span></span>
<span id="cb1093-5"><a href="#cb1093-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-6"><a href="#cb1093-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb1093-7"><a href="#cb1093-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH.Syntax</span></span>
<span id="cb1093-8"><a href="#cb1093-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH.Quote</span></span>
<span id="cb1093-9"><a href="#cb1093-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-10"><a href="#cb1093-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec</span></span>
<span id="cb1093-11"><a href="#cb1093-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec.String</span> (<span class="dt">Parser</span>)</span>
<span id="cb1093-12"><a href="#cb1093-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec.Language</span> (emptyDef)</span>
<span id="cb1093-13"><a href="#cb1093-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-14"><a href="#cb1093-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Parsec.Expr</span> <span class="kw">as</span> <span class="dt">Ex</span></span>
<span id="cb1093-15"><a href="#cb1093-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Parsec.Token</span> <span class="kw">as</span> <span class="dt">Tok</span></span>
<span id="cb1093-16"><a href="#cb1093-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-17"><a href="#cb1093-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Identity</span></span>
<span id="cb1093-18"><a href="#cb1093-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-19"><a href="#cb1093-19" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1093-20"><a href="#cb1093-20" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Tr</span></span>
<span id="cb1093-21"><a href="#cb1093-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Fl</span></span>
<span id="cb1093-22"><a href="#cb1093-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Zero</span></span>
<span id="cb1093-23"><a href="#cb1093-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Succ</span> <span class="dt">Expr</span></span>
<span id="cb1093-24"><a href="#cb1093-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Pred</span> <span class="dt">Expr</span></span>
<span id="cb1093-25"><a href="#cb1093-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb1093-26"><a href="#cb1093-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-27"><a href="#cb1093-27" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Lift</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb1093-28"><a href="#cb1093-28" aria-hidden="true" tabindex="-1"></a>  lift <span class="dt">Tr</span>         <span class="ot">=</span> [<span class="op">|</span> <span class="dt">Tr</span> <span class="op">|</span>]</span>
<span id="cb1093-29"><a href="#cb1093-29" aria-hidden="true" tabindex="-1"></a>  lift <span class="dt">Fl</span>         <span class="ot">=</span> [<span class="op">|</span> <span class="dt">Tr</span> <span class="op">|</span>]</span>
<span id="cb1093-30"><a href="#cb1093-30" aria-hidden="true" tabindex="-1"></a>  lift <span class="dt">Zero</span>       <span class="ot">=</span> [<span class="op">|</span> <span class="dt">Zero</span> <span class="op">|</span>]</span>
<span id="cb1093-31"><a href="#cb1093-31" aria-hidden="true" tabindex="-1"></a>  lift (<span class="dt">Succ</span> a)   <span class="ot">=</span> [<span class="op">|</span> <span class="dt">Succ</span> a <span class="op">|</span>]</span>
<span id="cb1093-32"><a href="#cb1093-32" aria-hidden="true" tabindex="-1"></a>  lift (<span class="dt">Pred</span> a)   <span class="ot">=</span> [<span class="op">|</span> <span class="dt">Pred</span> a <span class="op">|</span>]</span>
<span id="cb1093-33"><a href="#cb1093-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-34"><a href="#cb1093-34" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Op</span> <span class="ot">=</span> <span class="dt">Ex.Operator</span> <span class="dt">String</span> () <span class="dt">Identity</span></span>
<span id="cb1093-35"><a href="#cb1093-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-36"><a href="#cb1093-36" aria-hidden="true" tabindex="-1"></a><span class="ot">lexer ::</span> <span class="dt">Tok.TokenParser</span> ()</span>
<span id="cb1093-37"><a href="#cb1093-37" aria-hidden="true" tabindex="-1"></a>lexer <span class="ot">=</span> Tok.makeTokenParser emptyDef</span>
<span id="cb1093-38"><a href="#cb1093-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-39"><a href="#cb1093-39" aria-hidden="true" tabindex="-1"></a><span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb1093-40"><a href="#cb1093-40" aria-hidden="true" tabindex="-1"></a>parens <span class="ot">=</span> Tok.parens lexer</span>
<span id="cb1093-41"><a href="#cb1093-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-42"><a href="#cb1093-42" aria-hidden="true" tabindex="-1"></a><span class="ot">reserved ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()</span>
<span id="cb1093-43"><a href="#cb1093-43" aria-hidden="true" tabindex="-1"></a>reserved <span class="ot">=</span> Tok.reserved lexer</span>
<span id="cb1093-44"><a href="#cb1093-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-45"><a href="#cb1093-45" aria-hidden="true" tabindex="-1"></a><span class="ot">semiSep ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]</span>
<span id="cb1093-46"><a href="#cb1093-46" aria-hidden="true" tabindex="-1"></a>semiSep <span class="ot">=</span> Tok.semiSep lexer</span>
<span id="cb1093-47"><a href="#cb1093-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-48"><a href="#cb1093-48" aria-hidden="true" tabindex="-1"></a><span class="ot">reservedOp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()</span>
<span id="cb1093-49"><a href="#cb1093-49" aria-hidden="true" tabindex="-1"></a>reservedOp <span class="ot">=</span> Tok.reservedOp lexer</span>
<span id="cb1093-50"><a href="#cb1093-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-51"><a href="#cb1093-51" aria-hidden="true" tabindex="-1"></a><span class="ot">prefixOp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Op</span> a</span>
<span id="cb1093-52"><a href="#cb1093-52" aria-hidden="true" tabindex="-1"></a>prefixOp x f <span class="ot">=</span> <span class="dt">Ex.Prefix</span> (reservedOp x <span class="op">&gt;&gt;</span> <span class="fu">return</span> f)</span>
<span id="cb1093-53"><a href="#cb1093-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-54"><a href="#cb1093-54" aria-hidden="true" tabindex="-1"></a><span class="ot">table ::</span> [[<span class="dt">Op</span> <span class="dt">Expr</span>]]</span>
<span id="cb1093-55"><a href="#cb1093-55" aria-hidden="true" tabindex="-1"></a>table <span class="ot">=</span> [</span>
<span id="cb1093-56"><a href="#cb1093-56" aria-hidden="true" tabindex="-1"></a>    [ prefixOp <span class="st">&quot;succ&quot;</span> <span class="dt">Succ</span></span>
<span id="cb1093-57"><a href="#cb1093-57" aria-hidden="true" tabindex="-1"></a>    , prefixOp <span class="st">&quot;pred&quot;</span> <span class="dt">Pred</span></span>
<span id="cb1093-58"><a href="#cb1093-58" aria-hidden="true" tabindex="-1"></a>    ]</span>
<span id="cb1093-59"><a href="#cb1093-59" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb1093-60"><a href="#cb1093-60" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-61"><a href="#cb1093-61" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb1093-62"><a href="#cb1093-62" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> Ex.buildExpressionParser table factor</span>
<span id="cb1093-63"><a href="#cb1093-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-64"><a href="#cb1093-64" aria-hidden="true" tabindex="-1"></a>true, false,<span class="ot"> zero ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb1093-65"><a href="#cb1093-65" aria-hidden="true" tabindex="-1"></a>true  <span class="ot">=</span> reserved <span class="st">&quot;true&quot;</span> <span class="op">&gt;&gt;</span> <span class="fu">return</span> <span class="dt">Tr</span></span>
<span id="cb1093-66"><a href="#cb1093-66" aria-hidden="true" tabindex="-1"></a>false <span class="ot">=</span> reserved <span class="st">&quot;false&quot;</span> <span class="op">&gt;&gt;</span> <span class="fu">return</span> <span class="dt">Fl</span></span>
<span id="cb1093-67"><a href="#cb1093-67" aria-hidden="true" tabindex="-1"></a>zero  <span class="ot">=</span> reservedOp <span class="st">&quot;0&quot;</span> <span class="op">&gt;&gt;</span> <span class="fu">return</span> <span class="dt">Zero</span></span>
<span id="cb1093-68"><a href="#cb1093-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-69"><a href="#cb1093-69" aria-hidden="true" tabindex="-1"></a><span class="ot">factor ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb1093-70"><a href="#cb1093-70" aria-hidden="true" tabindex="-1"></a>factor <span class="ot">=</span></span>
<span id="cb1093-71"><a href="#cb1093-71" aria-hidden="true" tabindex="-1"></a>      true</span>
<span id="cb1093-72"><a href="#cb1093-72" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;|&gt;</span> false</span>
<span id="cb1093-73"><a href="#cb1093-73" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;|&gt;</span> zero</span>
<span id="cb1093-74"><a href="#cb1093-74" aria-hidden="true" tabindex="-1"></a>  <span class="op">&lt;|&gt;</span> parens expr</span>
<span id="cb1093-75"><a href="#cb1093-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-76"><a href="#cb1093-76" aria-hidden="true" tabindex="-1"></a><span class="ot">contents ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb1093-77"><a href="#cb1093-77" aria-hidden="true" tabindex="-1"></a>contents p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1093-78"><a href="#cb1093-78" aria-hidden="true" tabindex="-1"></a>  Tok.whiteSpace lexer</span>
<span id="cb1093-79"><a href="#cb1093-79" aria-hidden="true" tabindex="-1"></a>  r <span class="ot">&lt;-</span> p</span>
<span id="cb1093-80"><a href="#cb1093-80" aria-hidden="true" tabindex="-1"></a>  eof</span>
<span id="cb1093-81"><a href="#cb1093-81" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> r</span>
<span id="cb1093-82"><a href="#cb1093-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-83"><a href="#cb1093-83" aria-hidden="true" tabindex="-1"></a><span class="ot">toplevel ::</span> <span class="dt">Parser</span> [<span class="dt">Expr</span>]</span>
<span id="cb1093-84"><a href="#cb1093-84" aria-hidden="true" tabindex="-1"></a>toplevel <span class="ot">=</span> semiSep expr</span>
<span id="cb1093-85"><a href="#cb1093-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-86"><a href="#cb1093-86" aria-hidden="true" tabindex="-1"></a><span class="ot">parseExpr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> <span class="dt">Expr</span></span>
<span id="cb1093-87"><a href="#cb1093-87" aria-hidden="true" tabindex="-1"></a>parseExpr s <span class="ot">=</span> parse (contents expr) <span class="st">&quot;&lt;stdin&gt;&quot;</span> s</span>
<span id="cb1093-88"><a href="#cb1093-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-89"><a href="#cb1093-89" aria-hidden="true" tabindex="-1"></a><span class="ot">parseToplevel ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> [<span class="dt">Expr</span>]</span>
<span id="cb1093-90"><a href="#cb1093-90" aria-hidden="true" tabindex="-1"></a>parseToplevel s <span class="ot">=</span> parse (contents toplevel) <span class="st">&quot;&lt;stdin&gt;&quot;</span> s</span>
<span id="cb1093-91"><a href="#cb1093-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-92"><a href="#cb1093-92" aria-hidden="true" tabindex="-1"></a><span class="ot">calcExpr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb1093-93"><a href="#cb1093-93" aria-hidden="true" tabindex="-1"></a>calcExpr str <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1093-94"><a href="#cb1093-94" aria-hidden="true" tabindex="-1"></a>  filename <span class="ot">&lt;-</span> loc_filename <span class="ot">`fmap`</span> location</span>
<span id="cb1093-95"><a href="#cb1093-95" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> parse (contents expr) filename str <span class="kw">of</span></span>
<span id="cb1093-96"><a href="#cb1093-96" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="fu">error</span> (<span class="fu">show</span> err)</span>
<span id="cb1093-97"><a href="#cb1093-97" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> tag <span class="ot">-&gt;</span> [<span class="op">|</span> tag <span class="op">|</span>]</span>
<span id="cb1093-98"><a href="#cb1093-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1093-99"><a href="#cb1093-99" aria-hidden="true" tabindex="-1"></a><span class="ot">calc ::</span> <span class="dt">QuasiQuoter</span></span>
<span id="cb1093-100"><a href="#cb1093-100" aria-hidden="true" tabindex="-1"></a>calc <span class="ot">=</span> <span class="dt">QuasiQuoter</span> calcExpr err err err</span>
<span id="cb1093-101"><a href="#cb1093-101" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> err <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;Only defined for values&quot;</span></span></code></pre></div>
<p>Testing it out:</p>
<div class="sourceCode" id="cb1094"
data-include="src/31-template-haskell/quasiquote_use.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1094-1"><a href="#cb1094-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb1094-2"><a href="#cb1094-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1094-3"><a href="#cb1094-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Quasiquote</span></span>
<span id="cb1094-4"><a href="#cb1094-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1094-5"><a href="#cb1094-5" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Expr</span></span>
<span id="cb1094-6"><a href="#cb1094-6" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> [calc|true|]</span>
<span id="cb1094-7"><a href="#cb1094-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Tr</span></span>
<span id="cb1094-8"><a href="#cb1094-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1094-9"><a href="#cb1094-9" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">Expr</span></span>
<span id="cb1094-10"><a href="#cb1094-10" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> [calc|succ (succ 0)|]</span>
<span id="cb1094-11"><a href="#cb1094-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- Succ (Succ Zero)</span></span>
<span id="cb1094-12"><a href="#cb1094-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1094-13"><a href="#cb1094-13" aria-hidden="true" tabindex="-1"></a><span class="ot">c ::</span> <span class="dt">Expr</span></span>
<span id="cb1094-14"><a href="#cb1094-14" aria-hidden="true" tabindex="-1"></a>c <span class="ot">=</span> [calc|pred (succ 0)|]</span>
<span id="cb1094-15"><a href="#cb1094-15" aria-hidden="true" tabindex="-1"></a><span class="co">-- Pred (Succ Zero)</span></span></code></pre></div>
<p>One extremely important feature is the ability to preserve position
information so that errors in the embedded language can be traced back
to the line of the host syntax.</p>
<h2 id="language-c-quote">language-c-quote</h2>
<p>Of course since we can provide an arbitrary parser for the quoted
expression, one might consider embedding the AST of another language
entirely. For example C or CUDA C.</p>
<div class="sourceCode" id="cb1095"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1095-1"><a href="#cb1095-1" aria-hidden="true" tabindex="-1"></a><span class="ot">hello ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">C.Func</span></span>
<span id="cb1095-2"><a href="#cb1095-2" aria-hidden="true" tabindex="-1"></a>hello msg <span class="ot">=</span> [cfun|</span>
<span id="cb1095-3"><a href="#cb1095-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1095-4"><a href="#cb1095-4" aria-hidden="true" tabindex="-1"></a>int main(int argc, const char *argv[])</span>
<span id="cb1095-5"><a href="#cb1095-5" aria-hidden="true" tabindex="-1"></a>{</span>
<span id="cb1095-6"><a href="#cb1095-6" aria-hidden="true" tabindex="-1"></a>    printf($msg);</span>
<span id="cb1095-7"><a href="#cb1095-7" aria-hidden="true" tabindex="-1"></a>    return 0;</span>
<span id="cb1095-8"><a href="#cb1095-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1095-9"><a href="#cb1095-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1095-10"><a href="#cb1095-10" aria-hidden="true" tabindex="-1"></a>|]</span></code></pre></div>
<p>Evaluating this we get back an AST representation of the quoted C
program which we can manipulate or print back out to textual C code
using <code>ppr</code> function.</p>
<div class="sourceCode" id="cb1096"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1096-1"><a href="#cb1096-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Func</span></span>
<span id="cb1096-2"><a href="#cb1096-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">DeclSpec</span> [] [] (<span class="dt">Tint</span> <span class="dt">Nothing</span>))</span>
<span id="cb1096-3"><a href="#cb1096-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Id</span> <span class="st">&quot;main&quot;</span>)</span>
<span id="cb1096-4"><a href="#cb1096-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">DeclRoot</span></span>
<span id="cb1096-5"><a href="#cb1096-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Params</span></span>
<span id="cb1096-6"><a href="#cb1096-6" aria-hidden="true" tabindex="-1"></a>     [ <span class="dt">Param</span> (<span class="dt">Just</span> (<span class="dt">Id</span> <span class="st">&quot;argc&quot;</span>)) (<span class="dt">DeclSpec</span> [] [] (<span class="dt">Tint</span> <span class="dt">Nothing</span>)) <span class="dt">DeclRoot</span></span>
<span id="cb1096-7"><a href="#cb1096-7" aria-hidden="true" tabindex="-1"></a>     , <span class="dt">Param</span></span>
<span id="cb1096-8"><a href="#cb1096-8" aria-hidden="true" tabindex="-1"></a>         (<span class="dt">Just</span> (<span class="dt">Id</span> <span class="st">&quot;argv&quot;</span>))</span>
<span id="cb1096-9"><a href="#cb1096-9" aria-hidden="true" tabindex="-1"></a>         (<span class="dt">DeclSpec</span> [] [ <span class="dt">Tconst</span> ] (<span class="dt">Tchar</span> <span class="dt">Nothing</span>))</span>
<span id="cb1096-10"><a href="#cb1096-10" aria-hidden="true" tabindex="-1"></a>         (<span class="dt">Array</span> [] <span class="dt">NoArraySize</span> (<span class="dt">Ptr</span> [] <span class="dt">DeclRoot</span>))</span>
<span id="cb1096-11"><a href="#cb1096-11" aria-hidden="true" tabindex="-1"></a>     ]</span>
<span id="cb1096-12"><a href="#cb1096-12" aria-hidden="true" tabindex="-1"></a>     <span class="dt">False</span>)</span>
<span id="cb1096-13"><a href="#cb1096-13" aria-hidden="true" tabindex="-1"></a>  [ <span class="dt">BlockStm</span></span>
<span id="cb1096-14"><a href="#cb1096-14" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Exp</span></span>
<span id="cb1096-15"><a href="#cb1096-15" aria-hidden="true" tabindex="-1"></a>         (<span class="dt">Just</span></span>
<span id="cb1096-16"><a href="#cb1096-16" aria-hidden="true" tabindex="-1"></a>            (<span class="dt">FnCall</span></span>
<span id="cb1096-17"><a href="#cb1096-17" aria-hidden="true" tabindex="-1"></a>               (<span class="dt">Var</span> (<span class="dt">Id</span> <span class="st">&quot;printf&quot;</span>))</span>
<span id="cb1096-18"><a href="#cb1096-18" aria-hidden="true" tabindex="-1"></a>               [ <span class="dt">Const</span> (<span class="dt">StringConst</span> [ <span class="st">&quot;\&quot;Hello Haskell!\&quot;&quot;</span> ] <span class="st">&quot;Hello Haskell!&quot;</span>)</span>
<span id="cb1096-19"><a href="#cb1096-19" aria-hidden="true" tabindex="-1"></a>               ])))</span>
<span id="cb1096-20"><a href="#cb1096-20" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">BlockStm</span> (<span class="dt">Return</span> (<span class="dt">Just</span> (<span class="dt">Const</span> (<span class="dt">IntConst</span> <span class="st">&quot;0&quot;</span> <span class="dt">Signed</span> <span class="dv">0</span>))))</span>
<span id="cb1096-21"><a href="#cb1096-21" aria-hidden="true" tabindex="-1"></a>  ]</span></code></pre></div>
<p>In this example we just spliced in the anti-quoted Haskell string in
the printf statement, but we can pass many other values to and from the
quoted expressions including identifiers, numbers, and other quoted
expressions which implement the <code>Lift</code> type class.</p>
<h2 id="gpu-kernels">GPU Kernels</h2>
<p>For example now if we wanted programmatically generate the source for
a CUDA kernel to run on a GPU we can switch over the CUDA C dialect to
emit the C code.</p>
<div class="sourceCode" id="cb1097"
data-include="src/31-template-haskell/cquote.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1097-1"><a href="#cb1097-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb1097-2"><a href="#cb1097-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1097-3"><a href="#cb1097-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-4"><a href="#cb1097-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Language.C.Quote.CUDA</span> <span class="kw">as</span> <span class="dt">Cuda</span></span>
<span id="cb1097-5"><a href="#cb1097-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Language.C.Syntax</span> <span class="kw">as</span> <span class="dt">C</span></span>
<span id="cb1097-6"><a href="#cb1097-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.PrettyPrint.Mainland</span></span>
<span id="cb1097-7"><a href="#cb1097-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.PrettyPrint.Mainland.Class</span> (<span class="dt">Pretty</span> (..))</span>
<span id="cb1097-8"><a href="#cb1097-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-9"><a href="#cb1097-9" aria-hidden="true" tabindex="-1"></a><span class="ot">cuda_fun ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">C.Func</span></span>
<span id="cb1097-10"><a href="#cb1097-10" aria-hidden="true" tabindex="-1"></a>cuda_fun fn n a <span class="ot">=</span></span>
<span id="cb1097-11"><a href="#cb1097-11" aria-hidden="true" tabindex="-1"></a>  [Cuda.cfun<span class="op">|</span></span>
<span id="cb1097-12"><a href="#cb1097-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-13"><a href="#cb1097-13" aria-hidden="true" tabindex="-1"></a>__global__ void <span class="op">$</span>id<span class="op">:</span>fn (float <span class="op">*</span>x, float <span class="op">*</span>y) {</span>
<span id="cb1097-14"><a href="#cb1097-14" aria-hidden="true" tabindex="-1"></a>  int i <span class="ot">=</span> blockIdx<span class="op">.</span>x<span class="op">*</span>blockDim<span class="op">.</span>x <span class="op">+</span> threadIdx<span class="op">.</span>x;</span>
<span id="cb1097-15"><a href="#cb1097-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> ( i<span class="op">&lt;$</span>n ) { y[i] <span class="ot">=</span> <span class="op">$</span>a<span class="op">*</span>x[i] <span class="op">+</span> y[i]; }</span>
<span id="cb1097-16"><a href="#cb1097-16" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1097-17"><a href="#cb1097-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-18"><a href="#cb1097-18" aria-hidden="true" tabindex="-1"></a><span class="op">|</span>]</span>
<span id="cb1097-19"><a href="#cb1097-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-20"><a href="#cb1097-20" aria-hidden="true" tabindex="-1"></a><span class="ot">cuda_driver ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">C.Func</span></span>
<span id="cb1097-21"><a href="#cb1097-21" aria-hidden="true" tabindex="-1"></a>cuda_driver fn n <span class="ot">=</span></span>
<span id="cb1097-22"><a href="#cb1097-22" aria-hidden="true" tabindex="-1"></a>  [Cuda.cfun<span class="op">|</span></span>
<span id="cb1097-23"><a href="#cb1097-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-24"><a href="#cb1097-24" aria-hidden="true" tabindex="-1"></a>void driver (float <span class="op">*</span>x, float <span class="op">*</span>y) {</span>
<span id="cb1097-25"><a href="#cb1097-25" aria-hidden="true" tabindex="-1"></a>  float <span class="op">*</span>d_x, <span class="op">*</span>d_y;</span>
<span id="cb1097-26"><a href="#cb1097-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-27"><a href="#cb1097-27" aria-hidden="true" tabindex="-1"></a>  cudaMalloc(<span class="op">&amp;</span>d_x, <span class="op">$</span>n<span class="op">*</span>sizeof(float));</span>
<span id="cb1097-28"><a href="#cb1097-28" aria-hidden="true" tabindex="-1"></a>  cudaMalloc(<span class="op">&amp;</span>d_y, <span class="op">$</span>n<span class="op">*</span>sizeof(float));</span>
<span id="cb1097-29"><a href="#cb1097-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-30"><a href="#cb1097-30" aria-hidden="true" tabindex="-1"></a>  cudaMemcpy(d_x, x, <span class="op">$</span>n, cudaMemcpyHostToDevice);</span>
<span id="cb1097-31"><a href="#cb1097-31" aria-hidden="true" tabindex="-1"></a>  cudaMemcpy(d_y, y, <span class="op">$</span>n, cudaMemcpyHostToDevice);</span>
<span id="cb1097-32"><a href="#cb1097-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-33"><a href="#cb1097-33" aria-hidden="true" tabindex="-1"></a>  <span class="op">$</span>id<span class="op">:</span>fn<span class="op">&lt;&lt;&lt;</span>(<span class="op">$</span>n<span class="op">+</span><span class="dv">255</span>)<span class="op">/</span><span class="dv">256</span>, <span class="dv">256</span><span class="op">&gt;&gt;&gt;</span>(d_x, d_y);</span>
<span id="cb1097-34"><a href="#cb1097-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-35"><a href="#cb1097-35" aria-hidden="true" tabindex="-1"></a>  cudaFree(d_x);</span>
<span id="cb1097-36"><a href="#cb1097-36" aria-hidden="true" tabindex="-1"></a>  cudaFree(d_y);</span>
<span id="cb1097-37"><a href="#cb1097-37" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="dv">0</span>;</span>
<span id="cb1097-38"><a href="#cb1097-38" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1097-39"><a href="#cb1097-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-40"><a href="#cb1097-40" aria-hidden="true" tabindex="-1"></a><span class="op">|</span>]</span>
<span id="cb1097-41"><a href="#cb1097-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-42"><a href="#cb1097-42" aria-hidden="true" tabindex="-1"></a><span class="ot">makeKernel ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Float</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">C.Func</span>]</span>
<span id="cb1097-43"><a href="#cb1097-43" aria-hidden="true" tabindex="-1"></a>makeKernel fn a n <span class="ot">=</span></span>
<span id="cb1097-44"><a href="#cb1097-44" aria-hidden="true" tabindex="-1"></a>  [ cuda_fun fn n a,</span>
<span id="cb1097-45"><a href="#cb1097-45" aria-hidden="true" tabindex="-1"></a>    cuda_driver fn n</span>
<span id="cb1097-46"><a href="#cb1097-46" aria-hidden="true" tabindex="-1"></a>  ]</span>
<span id="cb1097-47"><a href="#cb1097-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1097-48"><a href="#cb1097-48" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1097-49"><a href="#cb1097-49" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1097-50"><a href="#cb1097-50" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> ker <span class="ot">=</span> makeKernel <span class="st">&quot;saxpy&quot;</span> <span class="dv">2</span> <span class="dv">65536</span></span>
<span id="cb1097-51"><a href="#cb1097-51" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mapM_</span> (putDocLn <span class="op">.</span> ppr) ker</span></code></pre></div>
<p>Running this we generate:</p>
<div class="sourceCode" id="cb1098"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1098-1"><a href="#cb1098-1" aria-hidden="true" tabindex="-1"></a>__global__ <span class="dt">void</span> saxpy<span class="op">(</span><span class="dt">float</span><span class="op">*</span> x<span class="op">,</span> <span class="dt">float</span><span class="op">*</span> y<span class="op">)</span></span>
<span id="cb1098-2"><a href="#cb1098-2" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1098-3"><a href="#cb1098-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i <span class="op">=</span> blockIdx<span class="op">.</span>x <span class="op">*</span> blockDim<span class="op">.</span>x <span class="op">+</span> threadIdx<span class="op">.</span>x<span class="op">;</span></span>
<span id="cb1098-4"><a href="#cb1098-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1098-5"><a href="#cb1098-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">65536</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1098-6"><a href="#cb1098-6" aria-hidden="true" tabindex="-1"></a>        y<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="fl">2.0</span> <span class="op">*</span> x<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> y<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1098-7"><a href="#cb1098-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1098-8"><a href="#cb1098-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1098-9"><a href="#cb1098-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> driver<span class="op">(</span><span class="dt">float</span><span class="op">*</span> x<span class="op">,</span> <span class="dt">float</span><span class="op">*</span> y<span class="op">)</span></span>
<span id="cb1098-10"><a href="#cb1098-10" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb1098-11"><a href="#cb1098-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">float</span><span class="op">*</span> d_x<span class="op">,</span> <span class="op">*</span> d_y<span class="op">;</span></span>
<span id="cb1098-12"><a href="#cb1098-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1098-13"><a href="#cb1098-13" aria-hidden="true" tabindex="-1"></a>    cudaMalloc<span class="op">(&amp;</span>d_x<span class="op">,</span> <span class="dv">65536</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">float</span><span class="op">));</span></span>
<span id="cb1098-14"><a href="#cb1098-14" aria-hidden="true" tabindex="-1"></a>    cudaMalloc<span class="op">(&amp;</span>d_y<span class="op">,</span> <span class="dv">65536</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">float</span><span class="op">));</span></span>
<span id="cb1098-15"><a href="#cb1098-15" aria-hidden="true" tabindex="-1"></a>    cudaMemcpy<span class="op">(</span>d_x<span class="op">,</span> x<span class="op">,</span> <span class="dv">65536</span><span class="op">,</span> cudaMemcpyHostToDevice<span class="op">);</span></span>
<span id="cb1098-16"><a href="#cb1098-16" aria-hidden="true" tabindex="-1"></a>    cudaMemcpy<span class="op">(</span>d_y<span class="op">,</span> y<span class="op">,</span> <span class="dv">65536</span><span class="op">,</span> cudaMemcpyHostToDevice<span class="op">);</span></span>
<span id="cb1098-17"><a href="#cb1098-17" aria-hidden="true" tabindex="-1"></a>    saxpy<span class="op">&lt;&lt;&lt;(</span><span class="dv">65536</span> <span class="op">+</span> <span class="dv">255</span><span class="op">)</span> <span class="op">/</span> <span class="dv">256</span><span class="op">,</span> <span class="dv">256</span><span class="op">&gt;&gt;&gt;(</span>d_x<span class="op">,</span> d_y<span class="op">);</span></span>
<span id="cb1098-18"><a href="#cb1098-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1098-19"><a href="#cb1098-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Pipe the resulting output through NVidia CUDA Compiler with
<code>nvcc -ptx -c</code> to get the PTX associated with the outputted
code.</p>
<h2 id="template-haskell-1">Template Haskell</h2>
<p>Of course the most useful case of quasiquotation is the ability to
procedurally generate Haskell code itself from inside of Haskell. The
<code>template-haskell</code> framework provides four entry points for
the quotation to generate various types of Haskell declarations and
expressions.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Quasiquoted</th>
<th style="text-align: left;">Class</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>Q Exp</code></td>
<td style="text-align: left;"><code>[e| ... |]</code></td>
<td style="text-align: left;">expression</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Q Pat</code></td>
<td style="text-align: left;"><code>[p| ... |]</code></td>
<td style="text-align: left;">pattern</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>Q Type</code></td>
<td style="text-align: left;"><code>[t| ... |]</code></td>
<td style="text-align: left;">type</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>Q [Dec]</code></td>
<td style="text-align: left;"><code>[d| ... |]</code></td>
<td style="text-align: left;">declaration</td>
</tr>
</tbody>
</table>
<div class="sourceCode" id="cb1099"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1099-1"><a href="#cb1099-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">QuasiQuoter</span> <span class="ot">=</span> <span class="dt">QuasiQuoter</span></span>
<span id="cb1099-2"><a href="#cb1099-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> quoteExp  ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb1099-3"><a href="#cb1099-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> quotePat  ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Pat</span></span>
<span id="cb1099-4"><a href="#cb1099-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> quoteType ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Type</span></span>
<span id="cb1099-5"><a href="#cb1099-5" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> quoteDec  ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]</span>
<span id="cb1099-6"><a href="#cb1099-6" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The logic evaluating, splicing, and introspecting compile-time values
is embedded within the Q monad, which has a <code>runQ</code> which can
be used to evaluate its context. These functions of this monad is deeply
embedded in the implementation of GHC.</p>
<div class="sourceCode" id="cb1100"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1100-1"><a href="#cb1100-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runQ ::</span> <span class="dt">Quasi</span> m <span class="ot">=&gt;</span> <span class="dt">Q</span> a <span class="ot">-&gt;</span> m a</span>
<span id="cb1100-2"><a href="#cb1100-2" aria-hidden="true" tabindex="-1"></a><span class="ot">runIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> a</span></code></pre></div>
<p>Just as before, TemplateHaskell provides the ability to lift Haskell
values into the their AST quantities within the quoted expression using
the Lift type class.</p>
<div class="sourceCode" id="cb1101"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1101-1"><a href="#cb1101-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Lift</span> t <span class="kw">where</span></span>
<span id="cb1101-2"><a href="#cb1101-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  lift ::</span> t <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb1101-3"><a href="#cb1101-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1101-4"><a href="#cb1101-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Lift</span> <span class="dt">Integer</span> <span class="kw">where</span></span>
<span id="cb1101-5"><a href="#cb1101-5" aria-hidden="true" tabindex="-1"></a>  lift x <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">LitE</span> (<span class="dt">IntegerL</span> x))</span>
<span id="cb1101-6"><a href="#cb1101-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1101-7"><a href="#cb1101-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Lift</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb1101-8"><a href="#cb1101-8" aria-hidden="true" tabindex="-1"></a>  lift x<span class="ot">=</span> <span class="fu">return</span> (<span class="dt">LitE</span> (<span class="dt">IntegerL</span> (<span class="fu">fromIntegral</span> x)))</span>
<span id="cb1101-9"><a href="#cb1101-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1101-10"><a href="#cb1101-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Lift</span> <span class="dt">Char</span> <span class="kw">where</span></span>
<span id="cb1101-11"><a href="#cb1101-11" aria-hidden="true" tabindex="-1"></a>  lift x <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">LitE</span> (<span class="dt">CharL</span> x))</span>
<span id="cb1101-12"><a href="#cb1101-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1101-13"><a href="#cb1101-13" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Lift</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb1101-14"><a href="#cb1101-14" aria-hidden="true" tabindex="-1"></a>  lift <span class="dt">True</span>  <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">ConE</span> trueName)</span>
<span id="cb1101-15"><a href="#cb1101-15" aria-hidden="true" tabindex="-1"></a>  lift <span class="dt">False</span> <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">ConE</span> falseName)</span>
<span id="cb1101-16"><a href="#cb1101-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1101-17"><a href="#cb1101-17" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Lift</span> a <span class="ot">=&gt;</span> <span class="dt">Lift</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span></span>
<span id="cb1101-18"><a href="#cb1101-18" aria-hidden="true" tabindex="-1"></a>  lift <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">ConE</span> nothingName)</span>
<span id="cb1101-19"><a href="#cb1101-19" aria-hidden="true" tabindex="-1"></a>  lift (<span class="dt">Just</span> x) <span class="ot">=</span> liftM (<span class="dt">ConE</span> justName <span class="ot">`AppE`</span>) (lift x)</span>
<span id="cb1101-20"><a href="#cb1101-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1101-21"><a href="#cb1101-21" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Lift</span> a <span class="ot">=&gt;</span> <span class="dt">Lift</span> [a] <span class="kw">where</span></span>
<span id="cb1101-22"><a href="#cb1101-22" aria-hidden="true" tabindex="-1"></a>  lift xs <span class="ot">=</span> <span class="kw">do</span> { xs&#39; <span class="ot">&lt;-</span> <span class="fu">mapM</span> lift xs; <span class="fu">return</span> (<span class="dt">ListE</span> xs&#39;) }</span></code></pre></div>
<p>In many cases Template Haskell can be used interactively to explore
the AST form of various Haskell syntax.</p>
<div class="sourceCode" id="cb1102"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1102-1"><a href="#cb1102-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> runQ [e| \x -&gt; x |]</span>
<span id="cb1102-2"><a href="#cb1102-2" aria-hidden="true" tabindex="-1"></a><span class="dt">LamE</span> [<span class="dt">VarP</span> x_2] (<span class="dt">VarE</span> x_2)</span>
<span id="cb1102-3"><a href="#cb1102-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1102-4"><a href="#cb1102-4" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> runQ [d| data Nat = Z | S Nat |]</span>
<span id="cb1102-5"><a href="#cb1102-5" aria-hidden="true" tabindex="-1"></a>[<span class="dt">DataD</span> [] <span class="dt">Nat_0</span> [] [<span class="dt">NormalC</span> <span class="dt">Z_2</span> [],<span class="dt">NormalC</span> <span class="dt">S_1</span> [(<span class="dt">NotStrict</span>,<span class="dt">ConT</span> <span class="dt">Nat_0</span>)]] []]</span>
<span id="cb1102-6"><a href="#cb1102-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1102-7"><a href="#cb1102-7" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> runQ [p| S (S Z)|]</span>
<span id="cb1102-8"><a href="#cb1102-8" aria-hidden="true" tabindex="-1"></a><span class="dt">ConP</span> <span class="dt">Singleton.S</span> [<span class="dt">ConP</span> <span class="dt">Singleton.S</span> [<span class="dt">ConP</span> <span class="dt">Singleton.Z</span> []]]</span>
<span id="cb1102-9"><a href="#cb1102-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1102-10"><a href="#cb1102-10" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> runQ [t| Int -&gt; [Int] |]</span>
<span id="cb1102-11"><a href="#cb1102-11" aria-hidden="true" tabindex="-1"></a><span class="dt">AppT</span> (<span class="dt">AppT</span> <span class="dt">ArrowT</span> (<span class="dt">ConT</span> <span class="dt">GHC.Types.Int</span>)) (<span class="dt">AppT</span> <span class="dt">ListT</span> (<span class="dt">ConT</span> <span class="dt">GHC.Types.Int</span>))</span>
<span id="cb1102-12"><a href="#cb1102-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1102-13"><a href="#cb1102-13" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="kw">let</span> g <span class="ot">=</span> <span class="op">$</span>(runQ [<span class="op">|</span> \x <span class="ot">-&gt;</span> x <span class="op">|</span>])</span>
<span id="cb1102-14"><a href="#cb1102-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1102-15"><a href="#cb1102-15" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> g <span class="dv">3</span></span>
<span id="cb1102-16"><a href="#cb1102-16" aria-hidden="true" tabindex="-1"></a><span class="dv">3</span></span></code></pre></div>
<p>Using <a
href="http://hackage.haskell.org/package/template-haskell-2.4.0.0/docs/Language-Haskell-TH-Syntax.html#t:Dec">Language.Haskell.TH</a>
we can piece together Haskell AST element by element but subject to our
own custom logic to generate the code. This can be somewhat painful
though as the source-language (called <code>HsSyn</code>) to Haskell is
enormous, consisting of around 100 nodes in its AST many of which are
dependent on the state of language pragmas.</p>
<div class="sourceCode" id="cb1103"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1103-1"><a href="#cb1103-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- builds the function (f = \(a,b) -&gt; a)</span></span>
<span id="cb1103-2"><a href="#cb1103-2" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]</span>
<span id="cb1103-3"><a href="#cb1103-3" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1103-4"><a href="#cb1103-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> f <span class="ot">=</span> mkName <span class="st">&quot;f&quot;</span></span>
<span id="cb1103-5"><a href="#cb1103-5" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> newName <span class="st">&quot;a&quot;</span></span>
<span id="cb1103-6"><a href="#cb1103-6" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> newName <span class="st">&quot;b&quot;</span></span>
<span id="cb1103-7"><a href="#cb1103-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> [ <span class="dt">FunD</span> f [ <span class="dt">Clause</span> [<span class="dt">TupP</span> [<span class="dt">VarP</span> a, <span class="dt">VarP</span> b]] (<span class="dt">NormalB</span> (<span class="dt">VarE</span> a)) [] ] ]</span></code></pre></div>
<div class="sourceCode" id="cb1104"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1104-1"><a href="#cb1104-1" aria-hidden="true" tabindex="-1"></a><span class="ot">my_id ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb1104-2"><a href="#cb1104-2" aria-hidden="true" tabindex="-1"></a>my_id x <span class="ot">=</span> <span class="op">$</span>( [<span class="op">|</span> x <span class="op">|</span>] )</span>
<span id="cb1104-3"><a href="#cb1104-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1104-4"><a href="#cb1104-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> (my_id <span class="st">&quot;Hello Haskell!&quot;</span>)</span></code></pre></div>
<p>As a debugging tool it is useful to be able to dump the reified
information out for a given symbol interactively, to do so there is a
simple little hack.</p>
<div class="sourceCode" id="cb1105"
data-include="src/31-template-haskell/template_info.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1105-1"><a href="#cb1105-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb1105-2"><a href="#cb1105-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1105-3"><a href="#cb1105-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1105-4"><a href="#cb1105-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb1105-5"><a href="#cb1105-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Show.Pretty</span> (ppShow)</span>
<span id="cb1105-6"><a href="#cb1105-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1105-7"><a href="#cb1105-7" aria-hidden="true" tabindex="-1"></a><span class="ot">introspect ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb1105-8"><a href="#cb1105-8" aria-hidden="true" tabindex="-1"></a>introspect n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1105-9"><a href="#cb1105-9" aria-hidden="true" tabindex="-1"></a>  t <span class="ot">&lt;-</span> reify n</span>
<span id="cb1105-10"><a href="#cb1105-10" aria-hidden="true" tabindex="-1"></a>  runIO <span class="op">$</span> <span class="fu">putStrLn</span> <span class="op">$</span> ppShow t</span>
<span id="cb1105-11"><a href="#cb1105-11" aria-hidden="true" tabindex="-1"></a>  [<span class="op">|</span><span class="fu">return</span> ()<span class="op">|</span>]</span></code></pre></div>
<div class="sourceCode" id="cb1106"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1106-1"><a href="#cb1106-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">$</span>(introspect &#39;id)</span>
<span id="cb1106-2"><a href="#cb1106-2" aria-hidden="true" tabindex="-1"></a><span class="dt">VarI</span></span>
<span id="cb1106-3"><a href="#cb1106-3" aria-hidden="true" tabindex="-1"></a>  GHC.Base.id</span>
<span id="cb1106-4"><a href="#cb1106-4" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">ForallT</span></span>
<span id="cb1106-5"><a href="#cb1106-5" aria-hidden="true" tabindex="-1"></a>     [ <span class="dt">PlainTV</span> a_1627405383 ]</span>
<span id="cb1106-6"><a href="#cb1106-6" aria-hidden="true" tabindex="-1"></a>     []</span>
<span id="cb1106-7"><a href="#cb1106-7" aria-hidden="true" tabindex="-1"></a>     (<span class="dt">AppT</span> (<span class="dt">AppT</span> <span class="dt">ArrowT</span> (<span class="dt">VarT</span> a_1627405383)) (<span class="dt">VarT</span> a_1627405383)))</span>
<span id="cb1106-8"><a href="#cb1106-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span>
<span id="cb1106-9"><a href="#cb1106-9" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Fixity</span> <span class="dv">9</span> <span class="dt">InfixL</span>)</span>
<span id="cb1106-10"><a href="#cb1106-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1106-11"><a href="#cb1106-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1106-12"><a href="#cb1106-12" aria-hidden="true" tabindex="-1"></a>λ<span class="op">:</span> <span class="op">$</span>(introspect &#39;<span class="dt">&#39;Maybe</span>)</span>
<span id="cb1106-13"><a href="#cb1106-13" aria-hidden="true" tabindex="-1"></a><span class="dt">TyConI</span></span>
<span id="cb1106-14"><a href="#cb1106-14" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">DataD</span></span>
<span id="cb1106-15"><a href="#cb1106-15" aria-hidden="true" tabindex="-1"></a>     []</span>
<span id="cb1106-16"><a href="#cb1106-16" aria-hidden="true" tabindex="-1"></a>     <span class="dt">Data.Maybe.Maybe</span></span>
<span id="cb1106-17"><a href="#cb1106-17" aria-hidden="true" tabindex="-1"></a>     [ <span class="dt">PlainTV</span> a_1627399528 ]</span>
<span id="cb1106-18"><a href="#cb1106-18" aria-hidden="true" tabindex="-1"></a>     [ <span class="dt">NormalC</span> <span class="dt">Data.Maybe.Nothing</span> []</span>
<span id="cb1106-19"><a href="#cb1106-19" aria-hidden="true" tabindex="-1"></a>     , <span class="dt">NormalC</span> <span class="dt">Data.Maybe.Just</span> [ ( <span class="dt">NotStrict</span> , <span class="dt">VarT</span> a_1627399528 ) ]</span>
<span id="cb1106-20"><a href="#cb1106-20" aria-hidden="true" tabindex="-1"></a>     ]</span>
<span id="cb1106-21"><a href="#cb1106-21" aria-hidden="true" tabindex="-1"></a>     [])</span></code></pre></div>
<div class="sourceCode" id="cb1107"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1107-1"><a href="#cb1107-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb1107-2"><a href="#cb1107-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1107-3"><a href="#cb1107-3" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1107-4"><a href="#cb1107-4" aria-hidden="true" tabindex="-1"></a>foo x <span class="ot">=</span> x <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb1107-5"><a href="#cb1107-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1107-6"><a href="#cb1107-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bar</span></span>
<span id="cb1107-7"><a href="#cb1107-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1107-8"><a href="#cb1107-8" aria-hidden="true" tabindex="-1"></a><span class="ot">fooInfo ::</span> <span class="dt">InfoQ</span></span>
<span id="cb1107-9"><a href="#cb1107-9" aria-hidden="true" tabindex="-1"></a>fooInfo <span class="ot">=</span> reify &#39;foo</span>
<span id="cb1107-10"><a href="#cb1107-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1107-11"><a href="#cb1107-11" aria-hidden="true" tabindex="-1"></a><span class="ot">barInfo ::</span> <span class="dt">InfoQ</span></span>
<span id="cb1107-12"><a href="#cb1107-12" aria-hidden="true" tabindex="-1"></a>barInfo <span class="ot">=</span> reify &#39;<span class="dt">&#39;Bar</span></span></code></pre></div>
<div class="sourceCode" id="cb1108"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1108-1"><a href="#cb1108-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>( [d| data T = T1 | T2 |] )</span>
<span id="cb1108-2"><a href="#cb1108-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1108-3"><a href="#cb1108-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">print</span> [<span class="dt">T1</span>, <span class="dt">T2</span>]</span></code></pre></div>
<p>Splices are indicated by <code>$(f)</code> syntax for the expression
level and at the toplevel simply by invocation of the template Haskell
function. Running GHC with <code>-ddump-splices</code> shows our code
being spliced in at the specific location in the AST at
compile-time.</p>
<div class="sourceCode" id="cb1109"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1109-1"><a href="#cb1109-1" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>(f)</span>
<span id="cb1109-2"><a href="#cb1109-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1109-3"><a href="#cb1109-3" aria-hidden="true" tabindex="-1"></a>template_haskell_show<span class="op">.</span>hs<span class="op">:</span><span class="dv">1</span><span class="op">:</span><span class="dv">1</span><span class="op">:</span> <span class="dt">Splicing</span> declarations</span>
<span id="cb1109-4"><a href="#cb1109-4" aria-hidden="true" tabindex="-1"></a>    f</span>
<span id="cb1109-5"><a href="#cb1109-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">======&gt;</span></span>
<span id="cb1109-6"><a href="#cb1109-6" aria-hidden="true" tabindex="-1"></a>    template_haskell_show<span class="op">.</span>hs<span class="op">:</span><span class="dv">8</span><span class="op">:</span><span class="dv">3</span><span class="op">-</span><span class="dv">10</span></span>
<span id="cb1109-7"><a href="#cb1109-7" aria-hidden="true" tabindex="-1"></a>    f (a_a5bd, b_a5be) <span class="ot">=</span> a_a5bd</span></code></pre></div>
<div class="sourceCode" id="cb1110"
data-include="src/31-template-haskell/Splice.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1110-1"><a href="#cb1110-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb1110-2"><a href="#cb1110-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1110-3"><a href="#cb1110-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1110-4"><a href="#cb1110-4" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Splice</span> <span class="kw">where</span></span>
<span id="cb1110-5"><a href="#cb1110-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1110-6"><a href="#cb1110-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb1110-7"><a href="#cb1110-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH.Syntax</span></span>
<span id="cb1110-8"><a href="#cb1110-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1110-9"><a href="#cb1110-9" aria-hidden="true" tabindex="-1"></a><span class="ot">spliceF ::</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]</span>
<span id="cb1110-10"><a href="#cb1110-10" aria-hidden="true" tabindex="-1"></a>spliceF <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1110-11"><a href="#cb1110-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> f <span class="ot">=</span> mkName <span class="st">&quot;f&quot;</span></span>
<span id="cb1110-12"><a href="#cb1110-12" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> newName <span class="st">&quot;a&quot;</span></span>
<span id="cb1110-13"><a href="#cb1110-13" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> newName <span class="st">&quot;b&quot;</span></span>
<span id="cb1110-14"><a href="#cb1110-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> [ <span class="dt">FunD</span> f [ <span class="dt">Clause</span> [<span class="dt">VarP</span> a, <span class="dt">VarP</span> b] (<span class="dt">NormalB</span> (<span class="dt">VarE</span> a)) [] ] ]</span>
<span id="cb1110-15"><a href="#cb1110-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1110-16"><a href="#cb1110-16" aria-hidden="true" tabindex="-1"></a><span class="ot">spliceG ::</span> <span class="dt">Lift</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]</span>
<span id="cb1110-17"><a href="#cb1110-17" aria-hidden="true" tabindex="-1"></a>spliceG n <span class="ot">=</span> runQ [d| g a = n |]</span></code></pre></div>
<div class="sourceCode" id="cb1111"
data-include="src/31-template-haskell/Insert.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1111-1"><a href="#cb1111-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1111-2"><a href="#cb1111-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1111-3"><a href="#cb1111-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Splice</span></span>
<span id="cb1111-4"><a href="#cb1111-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1111-5"><a href="#cb1111-5" aria-hidden="true" tabindex="-1"></a>spliceF</span>
<span id="cb1111-6"><a href="#cb1111-6" aria-hidden="true" tabindex="-1"></a>spliceG <span class="st">&quot;argument&quot;</span></span>
<span id="cb1111-7"><a href="#cb1111-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1111-8"><a href="#cb1111-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1111-9"><a href="#cb1111-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> f <span class="dv">1</span> <span class="dv">2</span></span>
<span id="cb1111-10"><a href="#cb1111-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> <span class="op">$</span> g ()</span></code></pre></div>
<p>At the point of the splice all variables and types used must be in
scope, so it must appear after their declarations in the module. As a
result we often have to mentally topologically sort our code when using
TemplateHaskell such that declarations are defined in order.</p>
<p>See: <a
href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH.html#t:Exp">Template
Haskell AST</a></p>
<h2 id="antiquotation">Antiquotation</h2>
<p>Extending our quasiquotation from above now that we have
TemplateHaskell machinery we can implement the same class of logic that
it uses to pass Haskell values in and pull Haskell values out via
pattern matching on templated expressions.</p>
<div class="sourceCode" id="cb1112"
data-include="src/31-template-haskell/Antiquote.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1112-1"><a href="#cb1112-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb1112-2"><a href="#cb1112-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1112-3"><a href="#cb1112-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DeriveDataTypeable #-}</span></span>
<span id="cb1112-4"><a href="#cb1112-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-5"><a href="#cb1112-5" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Antiquote</span> <span class="kw">where</span></span>
<span id="cb1112-6"><a href="#cb1112-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-7"><a href="#cb1112-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Generics</span></span>
<span id="cb1112-8"><a href="#cb1112-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb1112-9"><a href="#cb1112-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH.Quote</span></span>
<span id="cb1112-10"><a href="#cb1112-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-11"><a href="#cb1112-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec</span></span>
<span id="cb1112-12"><a href="#cb1112-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec.String</span> (<span class="dt">Parser</span>)</span>
<span id="cb1112-13"><a href="#cb1112-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Parsec.Language</span> (emptyDef)</span>
<span id="cb1112-14"><a href="#cb1112-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-15"><a href="#cb1112-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Parsec.Expr</span> <span class="kw">as</span> <span class="dt">Ex</span></span>
<span id="cb1112-16"><a href="#cb1112-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Text.Parsec.Token</span> <span class="kw">as</span> <span class="dt">Tok</span></span>
<span id="cb1112-17"><a href="#cb1112-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-18"><a href="#cb1112-18" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Expr</span></span>
<span id="cb1112-19"><a href="#cb1112-19" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Tr</span></span>
<span id="cb1112-20"><a href="#cb1112-20" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Fl</span></span>
<span id="cb1112-21"><a href="#cb1112-21" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Zero</span></span>
<span id="cb1112-22"><a href="#cb1112-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Succ</span> <span class="dt">Expr</span></span>
<span id="cb1112-23"><a href="#cb1112-23" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Pred</span> <span class="dt">Expr</span></span>
<span id="cb1112-24"><a href="#cb1112-24" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Antiquote</span> <span class="dt">String</span></span>
<span id="cb1112-25"><a href="#cb1112-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Data</span>, <span class="dt">Typeable</span>)</span>
<span id="cb1112-26"><a href="#cb1112-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-27"><a href="#cb1112-27" aria-hidden="true" tabindex="-1"></a><span class="ot">lexer ::</span> <span class="dt">Tok.TokenParser</span> ()</span>
<span id="cb1112-28"><a href="#cb1112-28" aria-hidden="true" tabindex="-1"></a>lexer <span class="ot">=</span> Tok.makeTokenParser emptyDef</span>
<span id="cb1112-29"><a href="#cb1112-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-30"><a href="#cb1112-30" aria-hidden="true" tabindex="-1"></a><span class="ot">parens ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb1112-31"><a href="#cb1112-31" aria-hidden="true" tabindex="-1"></a>parens <span class="ot">=</span> Tok.parens lexer</span>
<span id="cb1112-32"><a href="#cb1112-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-33"><a href="#cb1112-33" aria-hidden="true" tabindex="-1"></a><span class="ot">reserved ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()</span>
<span id="cb1112-34"><a href="#cb1112-34" aria-hidden="true" tabindex="-1"></a>reserved <span class="ot">=</span> Tok.reserved lexer</span>
<span id="cb1112-35"><a href="#cb1112-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-36"><a href="#cb1112-36" aria-hidden="true" tabindex="-1"></a><span class="ot">identifier ::</span> <span class="dt">Parser</span> <span class="dt">String</span></span>
<span id="cb1112-37"><a href="#cb1112-37" aria-hidden="true" tabindex="-1"></a>identifier <span class="ot">=</span> Tok.identifier lexer</span>
<span id="cb1112-38"><a href="#cb1112-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-39"><a href="#cb1112-39" aria-hidden="true" tabindex="-1"></a><span class="ot">semiSep ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]</span>
<span id="cb1112-40"><a href="#cb1112-40" aria-hidden="true" tabindex="-1"></a>semiSep <span class="ot">=</span> Tok.semiSep lexer</span>
<span id="cb1112-41"><a href="#cb1112-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-42"><a href="#cb1112-42" aria-hidden="true" tabindex="-1"></a><span class="ot">reservedOp ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> ()</span>
<span id="cb1112-43"><a href="#cb1112-43" aria-hidden="true" tabindex="-1"></a>reservedOp <span class="ot">=</span> Tok.reservedOp lexer</span>
<span id="cb1112-44"><a href="#cb1112-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-45"><a href="#cb1112-45" aria-hidden="true" tabindex="-1"></a>oper s f assoc <span class="ot">=</span> <span class="dt">Ex.Prefix</span> (reservedOp s <span class="op">&gt;&gt;</span> <span class="fu">return</span> f)</span>
<span id="cb1112-46"><a href="#cb1112-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-47"><a href="#cb1112-47" aria-hidden="true" tabindex="-1"></a>table <span class="ot">=</span> [ oper <span class="st">&quot;succ&quot;</span> <span class="dt">Succ</span> <span class="dt">Ex.AssocLeft</span></span>
<span id="cb1112-48"><a href="#cb1112-48" aria-hidden="true" tabindex="-1"></a>        , oper <span class="st">&quot;pred&quot;</span> <span class="dt">Pred</span> <span class="dt">Ex.AssocLeft</span></span>
<span id="cb1112-49"><a href="#cb1112-49" aria-hidden="true" tabindex="-1"></a>        ]</span>
<span id="cb1112-50"><a href="#cb1112-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-51"><a href="#cb1112-51" aria-hidden="true" tabindex="-1"></a><span class="ot">expr ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb1112-52"><a href="#cb1112-52" aria-hidden="true" tabindex="-1"></a>expr <span class="ot">=</span> Ex.buildExpressionParser [table] factor</span>
<span id="cb1112-53"><a href="#cb1112-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-54"><a href="#cb1112-54" aria-hidden="true" tabindex="-1"></a>true, false,<span class="ot"> zero ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb1112-55"><a href="#cb1112-55" aria-hidden="true" tabindex="-1"></a>true  <span class="ot">=</span> reserved <span class="st">&quot;true&quot;</span> <span class="op">&gt;&gt;</span> <span class="fu">return</span> <span class="dt">Tr</span></span>
<span id="cb1112-56"><a href="#cb1112-56" aria-hidden="true" tabindex="-1"></a>false <span class="ot">=</span> reserved <span class="st">&quot;false&quot;</span> <span class="op">&gt;&gt;</span> <span class="fu">return</span> <span class="dt">Fl</span></span>
<span id="cb1112-57"><a href="#cb1112-57" aria-hidden="true" tabindex="-1"></a>zero  <span class="ot">=</span> reservedOp <span class="st">&quot;0&quot;</span> <span class="op">&gt;&gt;</span> <span class="fu">return</span> <span class="dt">Zero</span></span>
<span id="cb1112-58"><a href="#cb1112-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-59"><a href="#cb1112-59" aria-hidden="true" tabindex="-1"></a><span class="ot">antiquote ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb1112-60"><a href="#cb1112-60" aria-hidden="true" tabindex="-1"></a>antiquote <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1112-61"><a href="#cb1112-61" aria-hidden="true" tabindex="-1"></a>  char <span class="ch">&#39;$&#39;</span></span>
<span id="cb1112-62"><a href="#cb1112-62" aria-hidden="true" tabindex="-1"></a>  var <span class="ot">&lt;-</span> identifier</span>
<span id="cb1112-63"><a href="#cb1112-63" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> <span class="dt">Antiquote</span> var</span>
<span id="cb1112-64"><a href="#cb1112-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-65"><a href="#cb1112-65" aria-hidden="true" tabindex="-1"></a><span class="ot">factor ::</span> <span class="dt">Parser</span> <span class="dt">Expr</span></span>
<span id="cb1112-66"><a href="#cb1112-66" aria-hidden="true" tabindex="-1"></a>factor <span class="ot">=</span> true</span>
<span id="cb1112-67"><a href="#cb1112-67" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;|&gt;</span> false</span>
<span id="cb1112-68"><a href="#cb1112-68" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;|&gt;</span> zero</span>
<span id="cb1112-69"><a href="#cb1112-69" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;|&gt;</span> antiquote</span>
<span id="cb1112-70"><a href="#cb1112-70" aria-hidden="true" tabindex="-1"></a>      <span class="op">&lt;|&gt;</span> parens expr</span>
<span id="cb1112-71"><a href="#cb1112-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-72"><a href="#cb1112-72" aria-hidden="true" tabindex="-1"></a><span class="ot">contents ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> a</span>
<span id="cb1112-73"><a href="#cb1112-73" aria-hidden="true" tabindex="-1"></a>contents p <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1112-74"><a href="#cb1112-74" aria-hidden="true" tabindex="-1"></a>  Tok.whiteSpace lexer</span>
<span id="cb1112-75"><a href="#cb1112-75" aria-hidden="true" tabindex="-1"></a>  r <span class="ot">&lt;-</span> p</span>
<span id="cb1112-76"><a href="#cb1112-76" aria-hidden="true" tabindex="-1"></a>  eof</span>
<span id="cb1112-77"><a href="#cb1112-77" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> r</span>
<span id="cb1112-78"><a href="#cb1112-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-79"><a href="#cb1112-79" aria-hidden="true" tabindex="-1"></a><span class="ot">parseExpr ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> <span class="dt">Expr</span></span>
<span id="cb1112-80"><a href="#cb1112-80" aria-hidden="true" tabindex="-1"></a>parseExpr s <span class="ot">=</span> parse (contents expr) <span class="st">&quot;&lt;stdin&gt;&quot;</span> s</span>
<span id="cb1112-81"><a href="#cb1112-81" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-82"><a href="#cb1112-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-83"><a href="#cb1112-83" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Expressible</span> a <span class="kw">where</span></span>
<span id="cb1112-84"><a href="#cb1112-84" aria-hidden="true" tabindex="-1"></a><span class="ot">  express ::</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb1112-85"><a href="#cb1112-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-86"><a href="#cb1112-86" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Expressible</span> <span class="dt">Expr</span> <span class="kw">where</span></span>
<span id="cb1112-87"><a href="#cb1112-87" aria-hidden="true" tabindex="-1"></a>  express <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb1112-88"><a href="#cb1112-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-89"><a href="#cb1112-89" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Expressible</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb1112-90"><a href="#cb1112-90" aria-hidden="true" tabindex="-1"></a>  express <span class="dt">True</span> <span class="ot">=</span> <span class="dt">Tr</span></span>
<span id="cb1112-91"><a href="#cb1112-91" aria-hidden="true" tabindex="-1"></a>  express <span class="dt">False</span> <span class="ot">=</span> <span class="dt">Fl</span></span>
<span id="cb1112-92"><a href="#cb1112-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-93"><a href="#cb1112-93" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Expressible</span> <span class="dt">Integer</span> <span class="kw">where</span></span>
<span id="cb1112-94"><a href="#cb1112-94" aria-hidden="true" tabindex="-1"></a>  express <span class="dv">0</span> <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb1112-95"><a href="#cb1112-95" aria-hidden="true" tabindex="-1"></a>  express n <span class="ot">=</span> <span class="dt">Succ</span> (express (n <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb1112-96"><a href="#cb1112-96" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-97"><a href="#cb1112-97" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-98"><a href="#cb1112-98" aria-hidden="true" tabindex="-1"></a><span class="ot">exprE ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Exp</span></span>
<span id="cb1112-99"><a href="#cb1112-99" aria-hidden="true" tabindex="-1"></a>exprE s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1112-100"><a href="#cb1112-100" aria-hidden="true" tabindex="-1"></a>  filename <span class="ot">&lt;-</span> loc_filename <span class="ot">`fmap`</span> location</span>
<span id="cb1112-101"><a href="#cb1112-101" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> parse (contents expr) filename s <span class="kw">of</span></span>
<span id="cb1112-102"><a href="#cb1112-102" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="fu">error</span> (<span class="fu">show</span> err)</span>
<span id="cb1112-103"><a href="#cb1112-103" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> <span class="fu">exp</span> <span class="ot">-&gt;</span> dataToExpQ (<span class="fu">const</span> <span class="dt">Nothing</span> <span class="ot">`extQ`</span> antiExpr) <span class="fu">exp</span></span>
<span id="cb1112-104"><a href="#cb1112-104" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-105"><a href="#cb1112-105" aria-hidden="true" tabindex="-1"></a><span class="ot">exprP ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> <span class="dt">Pat</span></span>
<span id="cb1112-106"><a href="#cb1112-106" aria-hidden="true" tabindex="-1"></a>exprP s <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1112-107"><a href="#cb1112-107" aria-hidden="true" tabindex="-1"></a>  filename <span class="ot">&lt;-</span> loc_filename <span class="ot">`fmap`</span> location</span>
<span id="cb1112-108"><a href="#cb1112-108" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> parse (contents expr) filename s <span class="kw">of</span></span>
<span id="cb1112-109"><a href="#cb1112-109" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="fu">error</span> (<span class="fu">show</span> err)</span>
<span id="cb1112-110"><a href="#cb1112-110" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Right</span> <span class="fu">exp</span> <span class="ot">-&gt;</span> dataToPatQ (<span class="fu">const</span> <span class="dt">Nothing</span> <span class="ot">`extQ`</span> antiExprPat) <span class="fu">exp</span></span>
<span id="cb1112-111"><a href="#cb1112-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-112"><a href="#cb1112-112" aria-hidden="true" tabindex="-1"></a><span class="co">-- antiquote RHS</span></span>
<span id="cb1112-113"><a href="#cb1112-113" aria-hidden="true" tabindex="-1"></a><span class="ot">antiExpr ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> <span class="dt">Exp</span>)</span>
<span id="cb1112-114"><a href="#cb1112-114" aria-hidden="true" tabindex="-1"></a>antiExpr (<span class="dt">Antiquote</span> v) <span class="ot">=</span> <span class="dt">Just</span> embed</span>
<span id="cb1112-115"><a href="#cb1112-115" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> embed <span class="ot">=</span> [<span class="op">|</span> express <span class="op">$</span>(varE (mkName v)) <span class="op">|</span>]</span>
<span id="cb1112-116"><a href="#cb1112-116" aria-hidden="true" tabindex="-1"></a>antiExpr _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1112-117"><a href="#cb1112-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-118"><a href="#cb1112-118" aria-hidden="true" tabindex="-1"></a><span class="co">-- antiquote LHS</span></span>
<span id="cb1112-119"><a href="#cb1112-119" aria-hidden="true" tabindex="-1"></a><span class="ot">antiExprPat ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Q</span> <span class="dt">Pat</span>)</span>
<span id="cb1112-120"><a href="#cb1112-120" aria-hidden="true" tabindex="-1"></a>antiExprPat (<span class="dt">Antiquote</span> v) <span class="ot">=</span> <span class="dt">Just</span> <span class="op">$</span> varP (mkName v)</span>
<span id="cb1112-121"><a href="#cb1112-121" aria-hidden="true" tabindex="-1"></a>antiExprPat _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1112-122"><a href="#cb1112-122" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1112-123"><a href="#cb1112-123" aria-hidden="true" tabindex="-1"></a><span class="ot">mini ::</span> <span class="dt">QuasiQuoter</span></span>
<span id="cb1112-124"><a href="#cb1112-124" aria-hidden="true" tabindex="-1"></a>mini <span class="ot">=</span> <span class="dt">QuasiQuoter</span> exprE exprP <span class="fu">undefined</span> <span class="fu">undefined</span></span></code></pre></div>
<div class="sourceCode" id="cb1113"
data-include="src/31-template-haskell/use_antiquote.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1113-1"><a href="#cb1113-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb1113-2"><a href="#cb1113-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1113-3"><a href="#cb1113-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Antiquote</span></span>
<span id="cb1113-4"><a href="#cb1113-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1113-5"><a href="#cb1113-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- extract</span></span>
<span id="cb1113-6"><a href="#cb1113-6" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb1113-7"><a href="#cb1113-7" aria-hidden="true" tabindex="-1"></a>a [mini|succ $x|] <span class="ot">=</span> x</span>
<span id="cb1113-8"><a href="#cb1113-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1113-9"><a href="#cb1113-9" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">Expr</span> <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb1113-10"><a href="#cb1113-10" aria-hidden="true" tabindex="-1"></a>b [mini|succ $x|] <span class="ot">=</span> [mini|pred $x|]</span>
<span id="cb1113-11"><a href="#cb1113-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1113-12"><a href="#cb1113-12" aria-hidden="true" tabindex="-1"></a><span class="ot">c ::</span> <span class="dt">Expressible</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Expr</span></span>
<span id="cb1113-13"><a href="#cb1113-13" aria-hidden="true" tabindex="-1"></a>c x <span class="ot">=</span> [mini|succ $x|]</span>
<span id="cb1113-14"><a href="#cb1113-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1113-15"><a href="#cb1113-15" aria-hidden="true" tabindex="-1"></a><span class="ot">d ::</span> <span class="dt">Expr</span></span>
<span id="cb1113-16"><a href="#cb1113-16" aria-hidden="true" tabindex="-1"></a>d <span class="ot">=</span> c (<span class="dv">8</span><span class="ot"> ::</span> <span class="dt">Integer</span>)</span>
<span id="cb1113-17"><a href="#cb1113-17" aria-hidden="true" tabindex="-1"></a><span class="co">-- Succ (Succ (Succ (Succ (Succ (Succ (Succ (Succ Zero)))))))</span></span>
<span id="cb1113-18"><a href="#cb1113-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1113-19"><a href="#cb1113-19" aria-hidden="true" tabindex="-1"></a><span class="ot">e ::</span> <span class="dt">Expr</span></span>
<span id="cb1113-20"><a href="#cb1113-20" aria-hidden="true" tabindex="-1"></a>e <span class="ot">=</span> c <span class="dt">True</span></span>
<span id="cb1113-21"><a href="#cb1113-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- Succ Tr</span></span></code></pre></div>
<h2 id="templated-type-families">Templated Type Families</h2>
<p>Just like at the value-level we can construct type-level
constructions by piecing together their AST.</p>
<div class="sourceCode" id="cb1114"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1114-1"><a href="#cb1114-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Type</span>          <span class="dt">AST</span></span>
<span id="cb1114-2"><a href="#cb1114-2" aria-hidden="true" tabindex="-1"></a><span class="co">----------    ----------</span></span>
<span id="cb1114-3"><a href="#cb1114-3" aria-hidden="true" tabindex="-1"></a>t1 <span class="ot">-&gt;</span> t2      <span class="dt">ArrowT</span> <span class="ot">`AppT`</span> t2 <span class="ot">`AppT`</span> t2</span>
<span id="cb1114-4"><a href="#cb1114-4" aria-hidden="true" tabindex="-1"></a>[t]           <span class="dt">ListT</span> <span class="ot">`AppT`</span> t</span>
<span id="cb1114-5"><a href="#cb1114-5" aria-hidden="true" tabindex="-1"></a>(t1,t2)       <span class="dt">TupleT</span> <span class="dv">2</span> <span class="ot">`AppT`</span> t1 <span class="ot">`AppT`</span> t2</span></code></pre></div>
<p>For example consider that type-level arithmetic is still somewhat
incomplete in GHC 7.6, but there often cases where the span of typelevel
numbers is not full set of integers but is instead some bounded set of
numbers. We can instead define operations with a type-family instead of
using an inductive definition ( which often requires manual proofs ) and
simply enumerates the entire domain of arguments to the type-family and
maps them to some result computed at compile-time.</p>
<p>For example the modulus operator would be non-trivial to implement at
type-level but instead we can use the <code>enumFamily</code> function
to splice in type-family which simply enumerates all possible pairs of
numbers up to a desired depth.</p>
<div class="sourceCode" id="cb1115"
data-include="src/31-template-haskell/EnumFamily.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1115-1"><a href="#cb1115-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">EnumFamily</span> <span class="kw">where</span></span>
<span id="cb1115-2"><a href="#cb1115-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb1115-3"><a href="#cb1115-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1115-4"><a href="#cb1115-4" aria-hidden="true" tabindex="-1"></a><span class="ot">enumFamily ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>)</span>
<span id="cb1115-5"><a href="#cb1115-5" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> <span class="dt">Name</span></span>
<span id="cb1115-6"><a href="#cb1115-6" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> <span class="dt">Integer</span></span>
<span id="cb1115-7"><a href="#cb1115-7" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]</span>
<span id="cb1115-8"><a href="#cb1115-8" aria-hidden="true" tabindex="-1"></a>enumFamily f bop upper <span class="ot">=</span> <span class="fu">return</span> decls</span>
<span id="cb1115-9"><a href="#cb1115-9" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb1115-10"><a href="#cb1115-10" aria-hidden="true" tabindex="-1"></a>    decls <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1115-11"><a href="#cb1115-11" aria-hidden="true" tabindex="-1"></a>      i <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>upper]</span>
<span id="cb1115-12"><a href="#cb1115-12" aria-hidden="true" tabindex="-1"></a>      j <span class="ot">&lt;-</span> [<span class="dv">2</span><span class="op">..</span>upper]</span>
<span id="cb1115-13"><a href="#cb1115-13" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> <span class="op">$</span> <span class="dt">TySynInstD</span> bop (rhs i j)</span>
<span id="cb1115-14"><a href="#cb1115-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1115-15"><a href="#cb1115-15" aria-hidden="true" tabindex="-1"></a>    rhs i j <span class="ot">=</span> <span class="dt">TySynEqn</span></span>
<span id="cb1115-16"><a href="#cb1115-16" aria-hidden="true" tabindex="-1"></a>      [<span class="dt">LitT</span> (<span class="dt">NumTyLit</span> i), <span class="dt">LitT</span> (<span class="dt">NumTyLit</span> j)]</span>
<span id="cb1115-17"><a href="#cb1115-17" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">LitT</span> (<span class="dt">NumTyLit</span> (i <span class="ot">`f`</span> j)))</span></code></pre></div>
<div class="sourceCode" id="cb1116"
data-include="src/31-template-haskell/enum_family_splice.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1116-1"><a href="#cb1116-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb1116-2"><a href="#cb1116-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1116-3"><a href="#cb1116-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb1116-4"><a href="#cb1116-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1116-5"><a href="#cb1116-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Proxy</span></span>
<span id="cb1116-6"><a href="#cb1116-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">EnumFamily</span></span>
<span id="cb1116-7"><a href="#cb1116-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.TypeLits</span> <span class="kw">hiding</span> (<span class="dt">Mod</span>)</span>
<span id="cb1116-8"><a href="#cb1116-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1116-9"><a href="#cb1116-9" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Mod</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb1116-10"><a href="#cb1116-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1116-11"><a href="#cb1116-11" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Add</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb1116-12"><a href="#cb1116-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1116-13"><a href="#cb1116-13" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="kw">family</span> <span class="dt">Pow</span> (<span class="ot">m ::</span> <span class="dt">Nat</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span></span>
<span id="cb1116-14"><a href="#cb1116-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1116-15"><a href="#cb1116-15" aria-hidden="true" tabindex="-1"></a>enumFamily <span class="fu">mod</span> &#39;<span class="dt">&#39;Mod</span> <span class="dv">10</span></span>
<span id="cb1116-16"><a href="#cb1116-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1116-17"><a href="#cb1116-17" aria-hidden="true" tabindex="-1"></a>enumFamily (<span class="op">+</span>) &#39;<span class="dt">&#39;Add</span> <span class="dv">10</span></span>
<span id="cb1116-18"><a href="#cb1116-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1116-19"><a href="#cb1116-19" aria-hidden="true" tabindex="-1"></a>enumFamily (<span class="op">^</span>) &#39;<span class="dt">&#39;Pow</span> <span class="dv">10</span></span>
<span id="cb1116-20"><a href="#cb1116-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1116-21"><a href="#cb1116-21" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">Integer</span></span>
<span id="cb1116-22"><a href="#cb1116-22" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Mod</span> <span class="dv">6</span> <span class="dv">4</span>))</span>
<span id="cb1116-23"><a href="#cb1116-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1116-24"><a href="#cb1116-24" aria-hidden="true" tabindex="-1"></a><span class="co">-- 2</span></span>
<span id="cb1116-25"><a href="#cb1116-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1116-26"><a href="#cb1116-26" aria-hidden="true" tabindex="-1"></a><span class="ot">b ::</span> <span class="dt">Integer</span></span>
<span id="cb1116-27"><a href="#cb1116-27" aria-hidden="true" tabindex="-1"></a>b <span class="ot">=</span> natVal (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Pow</span> <span class="dv">3</span> (<span class="dt">Mod</span> <span class="dv">6</span> <span class="dv">4</span>)))</span>
<span id="cb1116-28"><a href="#cb1116-28" aria-hidden="true" tabindex="-1"></a><span class="co">-- 9</span></span>
<span id="cb1116-29"><a href="#cb1116-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1116-30"><a href="#cb1116-30" aria-hidden="true" tabindex="-1"></a><span class="co">--    enumFamily mod &#39;&#39;Mod 3</span></span>
<span id="cb1116-31"><a href="#cb1116-31" aria-hidden="true" tabindex="-1"></a><span class="co">--  ======&gt;</span></span>
<span id="cb1116-32"><a href="#cb1116-32" aria-hidden="true" tabindex="-1"></a><span class="co">--    template_typelevel_splice.hs:7:1-14</span></span>
<span id="cb1116-33"><a href="#cb1116-33" aria-hidden="true" tabindex="-1"></a><span class="co">--    type instance Mod 2 1 = 0</span></span>
<span id="cb1116-34"><a href="#cb1116-34" aria-hidden="true" tabindex="-1"></a><span class="co">--    type instance Mod 2 2 = 0</span></span>
<span id="cb1116-35"><a href="#cb1116-35" aria-hidden="true" tabindex="-1"></a><span class="co">--    type instance Mod 2 3 = 2</span></span>
<span id="cb1116-36"><a href="#cb1116-36" aria-hidden="true" tabindex="-1"></a><span class="co">--    type instance Mod 3 1 = 0</span></span>
<span id="cb1116-37"><a href="#cb1116-37" aria-hidden="true" tabindex="-1"></a><span class="co">--    type instance Mod 3 2 = 1</span></span>
<span id="cb1116-38"><a href="#cb1116-38" aria-hidden="true" tabindex="-1"></a><span class="co">--    type instance Mod 3 3 = 0</span></span>
<span id="cb1116-39"><a href="#cb1116-39" aria-hidden="true" tabindex="-1"></a><span class="co">--    ...</span></span></code></pre></div>
<p>In practice GHC seems fine with enormous type-family declarations
although compile-time may increase a bit as a result.</p>
<p>The singletons library also provides a way to automate this process
by letting us write seemingly value-level declarations inside of a
quasiquoter and then promoting the logic to the type-level. For example
if we wanted to write a value-level and type-level map function for our
HList this would normally involve quite a bit of boilerplate, now it can
stated very concisely.</p>
<div class="sourceCode" id="cb1117"
data-include="src/31-template-haskell/singleton_promote.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1117-1"><a href="#cb1117-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE DataKinds #-}</span></span>
<span id="cb1117-2"><a href="#cb1117-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb1117-3"><a href="#cb1117-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb1117-4"><a href="#cb1117-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GADTs #-}</span></span>
<span id="cb1117-5"><a href="#cb1117-5" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE KindSignatures #-}</span></span>
<span id="cb1117-6"><a href="#cb1117-6" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb1117-7"><a href="#cb1117-7" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb1117-8"><a href="#cb1117-8" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE StandaloneDeriving #-}</span></span>
<span id="cb1117-9"><a href="#cb1117-9" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1117-10"><a href="#cb1117-10" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></span>
<span id="cb1117-11"><a href="#cb1117-11" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb1117-12"><a href="#cb1117-12" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></span>
<span id="cb1117-13"><a href="#cb1117-13" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE UndecidableInstances #-}</span></span>
<span id="cb1117-14"><a href="#cb1117-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1117-15"><a href="#cb1117-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Singletons</span></span>
<span id="cb1117-16"><a href="#cb1117-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Singletons.TH</span></span>
<span id="cb1117-17"><a href="#cb1117-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1117-18"><a href="#cb1117-18" aria-hidden="true" tabindex="-1"></a><span class="op">$</span>( promote</span>
<span id="cb1117-19"><a href="#cb1117-19" aria-hidden="true" tabindex="-1"></a>     [d|</span>
<span id="cb1117-20"><a href="#cb1117-20" aria-hidden="true" tabindex="-1"></a>       map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span>
<span id="cb1117-21"><a href="#cb1117-21" aria-hidden="true" tabindex="-1"></a>       map _ [] = []</span>
<span id="cb1117-22"><a href="#cb1117-22" aria-hidden="true" tabindex="-1"></a>       map f (x : xs) = f x : map f xs</span>
<span id="cb1117-23"><a href="#cb1117-23" aria-hidden="true" tabindex="-1"></a>       |]</span>
<span id="cb1117-24"><a href="#cb1117-24" aria-hidden="true" tabindex="-1"></a> )</span>
<span id="cb1117-25"><a href="#cb1117-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1117-26"><a href="#cb1117-26" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:::</span></span>
<span id="cb1117-27"><a href="#cb1117-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1117-28"><a href="#cb1117-28" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">HList</span> (<span class="ot">ts ::</span> [<span class="op">*</span>]) <span class="kw">where</span></span>
<span id="cb1117-29"><a href="#cb1117-29" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nil</span><span class="ot"> ::</span> <span class="dt">HList</span> &#39;[]</span>
<span id="cb1117-30"><a href="#cb1117-30" aria-hidden="true" tabindex="-1"></a><span class="ot">  (:::) ::</span> t <span class="ot">-&gt;</span> <span class="dt">HList</span> ts <span class="ot">-&gt;</span> <span class="dt">HList</span> (t &#39;<span class="op">:</span> ts)</span>
<span id="cb1117-31"><a href="#cb1117-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1117-32"><a href="#cb1117-32" aria-hidden="true" tabindex="-1"></a><span class="co">-- TypeLevel</span></span>
<span id="cb1117-33"><a href="#cb1117-33" aria-hidden="true" tabindex="-1"></a><span class="co">-- MapJust :: [*] -&gt; [Maybe *]</span></span>
<span id="cb1117-34"><a href="#cb1117-34" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">MapJust</span> xs <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">Maybe</span> xs</span>
<span id="cb1117-35"><a href="#cb1117-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1117-36"><a href="#cb1117-36" aria-hidden="true" tabindex="-1"></a><span class="co">-- Value Level</span></span>
<span id="cb1117-37"><a href="#cb1117-37" aria-hidden="true" tabindex="-1"></a><span class="co">-- mapJust :: [a] -&gt; [Maybe a]</span></span>
<span id="cb1117-38"><a href="#cb1117-38" aria-hidden="true" tabindex="-1"></a><span class="ot">mapJust ::</span> <span class="dt">HList</span> xs <span class="ot">-&gt;</span> <span class="dt">HList</span> (<span class="dt">MapJust</span> xs)</span>
<span id="cb1117-39"><a href="#cb1117-39" aria-hidden="true" tabindex="-1"></a>mapJust <span class="dt">Nil</span> <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb1117-40"><a href="#cb1117-40" aria-hidden="true" tabindex="-1"></a>mapJust (x <span class="op">:::</span> xs) <span class="ot">=</span> <span class="dt">Just</span> x <span class="op">:::</span> mapJust xs</span>
<span id="cb1117-41"><a href="#cb1117-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1117-42"><a href="#cb1117-42" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">A</span> <span class="ot">=</span> [<span class="dt">Bool</span>, <span class="dt">String</span>, <span class="dt">Double</span>, ()]</span>
<span id="cb1117-43"><a href="#cb1117-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1117-44"><a href="#cb1117-44" aria-hidden="true" tabindex="-1"></a><span class="ot">a ::</span> <span class="dt">HList</span> <span class="dt">A</span></span>
<span id="cb1117-45"><a href="#cb1117-45" aria-hidden="true" tabindex="-1"></a>a <span class="ot">=</span> <span class="dt">True</span> <span class="op">:::</span> <span class="st">&quot;foo&quot;</span> <span class="op">:::</span> <span class="fl">3.14</span> <span class="op">:::</span> () <span class="op">:::</span> <span class="dt">Nil</span></span>
<span id="cb1117-46"><a href="#cb1117-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1117-47"><a href="#cb1117-47" aria-hidden="true" tabindex="-1"></a><span class="ot">example1 ::</span> <span class="dt">HList</span> (<span class="dt">MapJust</span> <span class="dt">A</span>)</span>
<span id="cb1117-48"><a href="#cb1117-48" aria-hidden="true" tabindex="-1"></a>example1 <span class="ot">=</span> mapJust a</span>
<span id="cb1117-49"><a href="#cb1117-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1117-50"><a href="#cb1117-50" aria-hidden="true" tabindex="-1"></a><span class="co">-- example1 reduces to example2 when expanded</span></span>
<span id="cb1117-51"><a href="#cb1117-51" aria-hidden="true" tabindex="-1"></a><span class="ot">example2 ::</span> <span class="dt">HList</span> [<span class="dt">Maybe</span> <span class="dt">Bool</span>, <span class="dt">Maybe</span> <span class="dt">String</span>, <span class="dt">Maybe</span> <span class="dt">Double</span>, <span class="dt">Maybe</span> ()]</span>
<span id="cb1117-52"><a href="#cb1117-52" aria-hidden="true" tabindex="-1"></a>example2 <span class="ot">=</span> <span class="dt">Just</span> <span class="dt">True</span> <span class="op">:::</span> <span class="dt">Just</span> <span class="st">&quot;foo&quot;</span> <span class="op">:::</span> <span class="dt">Just</span> <span class="fl">3.14</span> <span class="op">:::</span> <span class="dt">Just</span> () <span class="op">:::</span> <span class="dt">Nil</span></span></code></pre></div>
<h2 id="templated-type-classes">Templated Type Classes</h2>
<p>Probably the most common use of Template Haskell is the automatic
generation of type-class instances. Consider if we wanted to write a
simple Pretty printing class for a flat data structure that derived the
ppr method in terms of the names of the constructors in the AST we could
write a simple instance.</p>
<div class="sourceCode" id="cb1118"
data-include="src/31-template-haskell/Class.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1118-1"><a href="#cb1118-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb1118-2"><a href="#cb1118-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1118-3"><a href="#cb1118-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb1118-4"><a href="#cb1118-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb1118-5"><a href="#cb1118-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1118-6"><a href="#cb1118-6" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Class</span> <span class="kw">where</span></span>
<span id="cb1118-7"><a href="#cb1118-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1118-8"><a href="#cb1118-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH</span></span>
<span id="cb1118-9"><a href="#cb1118-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1118-10"><a href="#cb1118-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Pretty</span> a <span class="kw">where</span></span>
<span id="cb1118-11"><a href="#cb1118-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  ppr ::</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb1118-12"><a href="#cb1118-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1118-13"><a href="#cb1118-13" aria-hidden="true" tabindex="-1"></a><span class="ot">normalCons ::</span> <span class="dt">Con</span> <span class="ot">-&gt;</span> <span class="dt">Name</span></span>
<span id="cb1118-14"><a href="#cb1118-14" aria-hidden="true" tabindex="-1"></a>normalCons (<span class="dt">NormalC</span> n _) <span class="ot">=</span> n</span>
<span id="cb1118-15"><a href="#cb1118-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1118-16"><a href="#cb1118-16" aria-hidden="true" tabindex="-1"></a><span class="ot">getCons ::</span> <span class="dt">Info</span> <span class="ot">-&gt;</span> [<span class="dt">Name</span>]</span>
<span id="cb1118-17"><a href="#cb1118-17" aria-hidden="true" tabindex="-1"></a>getCons cons <span class="ot">=</span> <span class="kw">case</span> cons <span class="kw">of</span></span>
<span id="cb1118-18"><a href="#cb1118-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">TyConI</span> (<span class="dt">DataD</span>    _ _ _ tcons _) <span class="ot">-&gt;</span> <span class="fu">map</span> normalCons tcons</span>
<span id="cb1118-19"><a href="#cb1118-19" aria-hidden="true" tabindex="-1"></a>    con <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="op">$</span> <span class="st">&quot;Can&#39;t derive for:&quot;</span> <span class="op">++</span> (<span class="fu">show</span> con)</span>
<span id="cb1118-20"><a href="#cb1118-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1118-21"><a href="#cb1118-21" aria-hidden="true" tabindex="-1"></a><span class="ot">pretty ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Q</span> [<span class="dt">Dec</span>]</span>
<span id="cb1118-22"><a href="#cb1118-22" aria-hidden="true" tabindex="-1"></a>pretty dt <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1118-23"><a href="#cb1118-23" aria-hidden="true" tabindex="-1"></a>  info <span class="ot">&lt;-</span> reify dt</span>
<span id="cb1118-24"><a href="#cb1118-24" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> cls <span class="ot">&lt;-</span> lookupTypeName <span class="st">&quot;Pretty&quot;</span></span>
<span id="cb1118-25"><a href="#cb1118-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> datatypeStr <span class="ot">=</span> nameBase dt</span>
<span id="cb1118-26"><a href="#cb1118-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> cons <span class="ot">=</span> getCons info</span>
<span id="cb1118-27"><a href="#cb1118-27" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> dtype <span class="ot">=</span> mkName (datatypeStr)</span>
<span id="cb1118-28"><a href="#cb1118-28" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> mkInstance xs <span class="ot">=</span></span>
<span id="cb1118-29"><a href="#cb1118-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">InstanceD</span></span>
<span id="cb1118-30"><a href="#cb1118-30" aria-hidden="true" tabindex="-1"></a>        []                              <span class="co">-- Context</span></span>
<span id="cb1118-31"><a href="#cb1118-31" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">AppT</span></span>
<span id="cb1118-32"><a href="#cb1118-32" aria-hidden="true" tabindex="-1"></a>          (<span class="dt">ConT</span> cls)                    <span class="co">-- Instance</span></span>
<span id="cb1118-33"><a href="#cb1118-33" aria-hidden="true" tabindex="-1"></a>          (<span class="dt">ConT</span> dtype))                 <span class="co">-- Head</span></span>
<span id="cb1118-34"><a href="#cb1118-34" aria-hidden="true" tabindex="-1"></a>        [(<span class="dt">FunD</span> (mkName <span class="st">&quot;ppr&quot;</span>) xs)]      <span class="co">-- Methods</span></span>
<span id="cb1118-35"><a href="#cb1118-35" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> methods <span class="ot">=</span> <span class="fu">map</span> cases cons</span>
<span id="cb1118-36"><a href="#cb1118-36" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> <span class="op">$</span> [mkInstance methods]</span>
<span id="cb1118-37"><a href="#cb1118-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1118-38"><a href="#cb1118-38" aria-hidden="true" tabindex="-1"></a><span class="co">-- Pattern matches on the ``ppr`` method</span></span>
<span id="cb1118-39"><a href="#cb1118-39" aria-hidden="true" tabindex="-1"></a><span class="ot">cases ::</span> <span class="dt">Name</span> <span class="ot">-&gt;</span> <span class="dt">Clause</span></span>
<span id="cb1118-40"><a href="#cb1118-40" aria-hidden="true" tabindex="-1"></a>cases a <span class="ot">=</span> <span class="dt">Clause</span> [<span class="dt">ConP</span> a []] (<span class="dt">NormalB</span> (<span class="dt">LitE</span> (<span class="dt">StringL</span> (nameBase a)))) []</span></code></pre></div>
<p>In a separate file invoke the pretty instance at the toplevel, and
with <code>--ddump-splice</code> if we want to view the spliced class
instance.</p>
<div class="sourceCode" id="cb1119"
data-include="src/31-template-haskell/splice_class.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1119-1"><a href="#cb1119-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb1119-2"><a href="#cb1119-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1119-3"><a href="#cb1119-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1119-4"><a href="#cb1119-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Class</span></span>
<span id="cb1119-5"><a href="#cb1119-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1119-6"><a href="#cb1119-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PlatonicSolid</span></span>
<span id="cb1119-7"><a href="#cb1119-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=</span> <span class="dt">Tetrahedron</span></span>
<span id="cb1119-8"><a href="#cb1119-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Cube</span></span>
<span id="cb1119-9"><a href="#cb1119-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Octahedron</span></span>
<span id="cb1119-10"><a href="#cb1119-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Dodecahedron</span></span>
<span id="cb1119-11"><a href="#cb1119-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="dt">Icosahedron</span></span>
<span id="cb1119-12"><a href="#cb1119-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1119-13"><a href="#cb1119-13" aria-hidden="true" tabindex="-1"></a>pretty &#39;<span class="dt">&#39;PlatonicSolid</span></span>
<span id="cb1119-14"><a href="#cb1119-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1119-15"><a href="#cb1119-15" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1119-16"><a href="#cb1119-16" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1119-17"><a href="#cb1119-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> (ppr <span class="dt">Octahedron</span>)</span>
<span id="cb1119-18"><a href="#cb1119-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> (ppr <span class="dt">Dodecahedron</span>)</span></code></pre></div>
<h2 id="multiline-strings">Multiline Strings</h2>
<p>Haskell has no language support for multiline string literals,
although we can emulate this by using a quasiquoter. The resulting
String literal is then converted using toString into whatever result
type is desired.</p>
<div class="sourceCode" id="cb1120"
data-include="src/31-template-haskell/Multiline.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1120-1"><a href="#cb1120-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1120-2"><a href="#cb1120-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1120-3"><a href="#cb1120-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Multiline</span> (s) <span class="kw">where</span></span>
<span id="cb1120-4"><a href="#cb1120-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1120-5"><a href="#cb1120-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.String</span></span>
<span id="cb1120-6"><a href="#cb1120-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Language.Haskell.TH.Quote</span></span>
<span id="cb1120-7"><a href="#cb1120-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1120-8"><a href="#cb1120-8" aria-hidden="true" tabindex="-1"></a><span class="ot">s ::</span> <span class="dt">QuasiQuoter</span></span>
<span id="cb1120-9"><a href="#cb1120-9" aria-hidden="true" tabindex="-1"></a>s <span class="ot">=</span> <span class="dt">QuasiQuoter</span></span>
<span id="cb1120-10"><a href="#cb1120-10" aria-hidden="true" tabindex="-1"></a>  { quoteExp  <span class="ot">=</span> (\a <span class="ot">-&gt;</span> [<span class="op">|</span>fromString a<span class="op">|</span>]) <span class="op">.</span> trim</span>
<span id="cb1120-11"><a href="#cb1120-11" aria-hidden="true" tabindex="-1"></a>  , quotePat  <span class="ot">=</span> \_ <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="st">&quot;illegal raw string QuasiQuote&quot;</span></span>
<span id="cb1120-12"><a href="#cb1120-12" aria-hidden="true" tabindex="-1"></a>  , quoteType <span class="ot">=</span> \_ <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="st">&quot;illegal raw string QuasiQuote&quot;</span></span>
<span id="cb1120-13"><a href="#cb1120-13" aria-hidden="true" tabindex="-1"></a>  , quoteDec  <span class="ot">=</span> \_ <span class="ot">-&gt;</span> <span class="fu">fail</span> <span class="st">&quot;illegal raw string QuasiQuote&quot;</span></span>
<span id="cb1120-14"><a href="#cb1120-14" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1120-15"><a href="#cb1120-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1120-16"><a href="#cb1120-16" aria-hidden="true" tabindex="-1"></a><span class="ot">trim ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb1120-17"><a href="#cb1120-17" aria-hidden="true" tabindex="-1"></a>trim (<span class="ch">&#39;\n&#39;</span><span class="op">:</span>xs) <span class="ot">=</span> xs</span>
<span id="cb1120-18"><a href="#cb1120-18" aria-hidden="true" tabindex="-1"></a>trim xs <span class="ot">=</span> xs</span></code></pre></div>
<p>In a separate module we can then enable Quasiquotes and embed the
string.</p>
<div class="sourceCode" id="cb1121"
data-include="src/31-template-haskell/multiline_example.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1121-1"><a href="#cb1121-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE QuasiQuotes #-}</span></span>
<span id="cb1121-2"><a href="#cb1121-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1121-3"><a href="#cb1121-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Multiline</span> (s)</span>
<span id="cb1121-4"><a href="#cb1121-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">T</span></span>
<span id="cb1121-5"><a href="#cb1121-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1121-6"><a href="#cb1121-6" aria-hidden="true" tabindex="-1"></a><span class="ot">foo ::</span> <span class="dt">T.Text</span></span>
<span id="cb1121-7"><a href="#cb1121-7" aria-hidden="true" tabindex="-1"></a>foo <span class="ot">=</span> [s|</span>
<span id="cb1121-8"><a href="#cb1121-8" aria-hidden="true" tabindex="-1"></a>This</span>
<span id="cb1121-9"><a href="#cb1121-9" aria-hidden="true" tabindex="-1"></a>is</span>
<span id="cb1121-10"><a href="#cb1121-10" aria-hidden="true" tabindex="-1"></a>my</span>
<span id="cb1121-11"><a href="#cb1121-11" aria-hidden="true" tabindex="-1"></a>multiline</span>
<span id="cb1121-12"><a href="#cb1121-12" aria-hidden="true" tabindex="-1"></a>string</span>
<span id="cb1121-13"><a href="#cb1121-13" aria-hidden="true" tabindex="-1"></a>|]</span></code></pre></div>
<h2 id="path-files">Path Files</h2>
<p>Oftentimes it is necessary to embed the specific Git version hash of
a build inside the executable. Using git-embed the compiler will
effectively shell out to the command line to retrieve the version
information of the CWD Git repository and use Template Haskell to define
embed this information at compile-time. This is often useful for
embedding in <code>--version</code> information in the command line
interface to your program or service.</p>
<p>This example also makes use of the Cabal <code>Paths_pkgname</code>
module during compile time which contains which contains several
functions for querying target paths and included data files for the
Cabal project. This can be included in the <code>exposed-modules</code>
of a package to be accessed directly by the project, otherwise it is
placed automatically in <code>other-modules</code>.</p>
<div class="sourceCode" id="cb1122"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1122-1"><a href="#cb1122-1" aria-hidden="true" tabindex="-1"></a><span class="ot">version ::</span> <span class="dt">Version</span></span>
<span id="cb1122-2"><a href="#cb1122-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getBinDir ::</span> <span class="dt">IO</span> <span class="dt">FilePath</span> </span>
<span id="cb1122-3"><a href="#cb1122-3" aria-hidden="true" tabindex="-1"></a><span class="ot">getLibDir ::</span> <span class="dt">IO</span> <span class="dt">FilePath</span> </span>
<span id="cb1122-4"><a href="#cb1122-4" aria-hidden="true" tabindex="-1"></a><span class="ot">getDataDir ::</span> <span class="dt">IO</span> <span class="dt">FilePath</span></span>
<span id="cb1122-5"><a href="#cb1122-5" aria-hidden="true" tabindex="-1"></a><span class="ot">getLibexecDir ::</span> <span class="dt">IO</span> <span class="dt">FilePath</span></span>
<span id="cb1122-6"><a href="#cb1122-6" aria-hidden="true" tabindex="-1"></a><span class="ot">getSysconfDir ::</span> <span class="dt">IO</span> <span class="dt">FilePath</span></span>
<span id="cb1122-7"><a href="#cb1122-7" aria-hidden="true" tabindex="-1"></a><span class="ot">getDataFileName ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">FilePath</span></span></code></pre></div>
<p>An example of usage to query the Git metadata into the compiled
binary of a project using the <code>git-embed</code> package:</p>
<div class="sourceCode" id="cb1123"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1123-1"><a href="#cb1123-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TemplateHaskell #-}</span></span>
<span id="cb1123-2"><a href="#cb1123-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1123-3"><a href="#cb1123-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Git.Embed</span></span>
<span id="cb1123-4"><a href="#cb1123-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Version</span></span>
<span id="cb1123-5"><a href="#cb1123-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Paths_myprog</span></span>
<span id="cb1123-6"><a href="#cb1123-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1123-7"><a href="#cb1123-7" aria-hidden="true" tabindex="-1"></a><span class="ot">gitRev ::</span> <span class="dt">String</span></span>
<span id="cb1123-8"><a href="#cb1123-8" aria-hidden="true" tabindex="-1"></a>gitRev <span class="ot">=</span> <span class="op">$</span>(embedGitShortRevision)</span>
<span id="cb1123-9"><a href="#cb1123-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1123-10"><a href="#cb1123-10" aria-hidden="true" tabindex="-1"></a><span class="ot">gitBranch ::</span> <span class="dt">String</span></span>
<span id="cb1123-11"><a href="#cb1123-11" aria-hidden="true" tabindex="-1"></a>gitBranch <span class="ot">=</span> <span class="op">$</span>(embedGitBranch)</span>
<span id="cb1123-12"><a href="#cb1123-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1123-13"><a href="#cb1123-13" aria-hidden="true" tabindex="-1"></a><span class="ot">ver ::</span> <span class="dt">String</span></span>
<span id="cb1123-14"><a href="#cb1123-14" aria-hidden="true" tabindex="-1"></a>ver <span class="ot">=</span> showVersion Paths_myprog.version</span></code></pre></div>
<hr/>
<h1 id="categories">Categories</h1>
<h2 id="do-i-need-to-learn-category-theory">Do I need to Learn Category
Theory?</h2>
<p>Short answer: <b>No</b>. Most of the ideas of category theory aren’t
really applicable to writing Haskell.</p>
<p>The long answer: It is not strictly necessary to learn, but so few
things in life are. Learning new topics and ways of thinking about
problems only enrich your thinking and give you new ways of thinking
about code and abstractions. Category theory is never going to help you
write a web application better, but it may give you insights into
problems that are algebraic in nature. A tiny group of Haskellers
espouse philosophies about it being an inspiration for certain
abstractions, but most do not.</p>
<p>Some understanding of abstract algebra, and conventions for
discussing algebraic structures and equational reasoning with laws are
essential to modern Haskell and we will discuss these leading up to some
basic category theory.</p>
<h2 id="abstract-algebra">Abstract Algebra</h2>
<p>Algebraic theory taught at higher levels generalises notions of
arithmetic to operate over more generic structures than simple numbers.
These structures are called <strong>sets</strong> and are a very broad
notion of generic ways of describing groups of mathematical objects that
can be equated and grouped. Over these sets we can define ways of
combining and operating over elements of the set. These generalised
notions of arithmetic are described in terms of and
<strong>operations</strong>. Operations which take elements of a set to
the same set are said to be <strong>closed</strong> in the set. When
discussing operations we use the conventions:</p>
<ul>
<li><strong>Properties</strong> - Predicates attached to values and
operations over a set.</li>
<li><strong>Binary Operations</strong> - Operations which map two
elements.</li>
<li><strong>Unary Operations</strong> - Operations which map a single
element.</li>
<li><strong>Constants</strong> - Specific values with specific
properties in a set.</li>
<li><strong>Relations</strong> - Pairings of elements in a set.</li>
</ul>
<p>Binary operations are generalisations of operations like
multiplication and addition. That map two elements of a set to another
element of a set. Unary operations map an element of a set to a single
element of a set. Ternary operations map three elements. Higher-level
operations are usually not given specific names.</p>
<p>Constants are specific elements of the set, that generalise values
like 0 and 1 which have specific laws in relation to the operations
defined over the set.</p>
<p>Certain properties show up so frequently we typically refer to their
properties by an algebraic term. These terms are drawn from an
equivalent abstract algebra concept. Several of the common algebraic
laws are defined in the table below.</p>

<p><strong>Associativity</strong></p>
<p>Equations:</p>
<p><span
class="math display"><em>a</em> × (<em>b</em> × <em>c</em>) = (<em>a</em> × <em>b</em>) × <em>c</em></span></p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1124"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1124-1"><a href="#cb1124-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">`op`</span> (b <span class="ot">`op`</span> c) <span class="ot">=</span> (a <span class="ot">`op`</span> b) <span class="ot">`op`</span> c</span></code></pre></div>
<p>Haskell Predicate:</p>
<div class="sourceCode" id="cb1125"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1125-1"><a href="#cb1125-1" aria-hidden="true" tabindex="-1"></a><span class="ot">associative ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1125-2"><a href="#cb1125-2" aria-hidden="true" tabindex="-1"></a>associative op x y z  <span class="ot">=</span>  (x <span class="ot">`op`</span> y) <span class="ot">`op`</span> z <span class="op">==</span> x <span class="ot">`op`</span> (y <span class="ot">`op`</span> z)</span></code></pre></div>

<p><strong>Commutativity</strong></p>
<p>Equations:</p>
<p><span
class="math display"><em>a</em> × <em>b</em> = <em>b</em> × <em>a</em></span></p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1126"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1126-1"><a href="#cb1126-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">`op`</span> b <span class="ot">=</span> b <span class="ot">`op`</span> a</span></code></pre></div>
<p>Haskell Predicates:</p>
<div class="sourceCode" id="cb1127"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1127-1"><a href="#cb1127-1" aria-hidden="true" tabindex="-1"></a><span class="ot">commutative ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1127-2"><a href="#cb1127-2" aria-hidden="true" tabindex="-1"></a>commutative op x y  <span class="ot">=</span>  x <span class="ot">`op`</span> y <span class="op">==</span> y <span class="ot">`op`</span> x</span></code></pre></div>

<p><strong>Units</strong></p>
<p>Equations:</p>
<p><span
class="math display"><em>a</em> × <em>e</em> = <em>a</em></span></p>
<p><span
class="math display"><em>e</em> × <em>a</em> = <em>a</em></span></p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1128"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1128-1"><a href="#cb1128-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">`op`</span> e <span class="ot">=</span> a</span>
<span id="cb1128-2"><a href="#cb1128-2" aria-hidden="true" tabindex="-1"></a>e <span class="ot">`op`</span> a <span class="ot">=</span> a</span></code></pre></div>
<p>Haskell Predicates:</p>
<div class="sourceCode" id="cb1129"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1129-1"><a href="#cb1129-1" aria-hidden="true" tabindex="-1"></a><span class="ot">leftIdentity ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1129-2"><a href="#cb1129-2" aria-hidden="true" tabindex="-1"></a>leftIdentity op y x  <span class="ot">=</span>  y <span class="ot">`op`</span> x <span class="op">==</span> x</span>
<span id="cb1129-3"><a href="#cb1129-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1129-4"><a href="#cb1129-4" aria-hidden="true" tabindex="-1"></a><span class="ot">rightIdentity ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1129-5"><a href="#cb1129-5" aria-hidden="true" tabindex="-1"></a>rightIdentity op y x  <span class="ot">=</span>  x <span class="ot">`op`</span> y <span class="op">==</span> x</span>
<span id="cb1129-6"><a href="#cb1129-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1129-7"><a href="#cb1129-7" aria-hidden="true" tabindex="-1"></a><span class="ot">identity ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1129-8"><a href="#cb1129-8" aria-hidden="true" tabindex="-1"></a>identity op x y  <span class="ot">=</span>  leftIdentity op x y <span class="op">&amp;&amp;</span>  rightIdentity op x y</span></code></pre></div>

<p><strong>Inversion</strong></p>
<p>Equations:</p>
<p><span
class="math display"><em>a</em><sup>−1</sup> × <em>a</em> = <em>e</em></span></p>
<p><span
class="math display"><em>a</em> × <em>a</em><sup>−1</sup> = <em>e</em></span></p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1130"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1130-1"><a href="#cb1130-1" aria-hidden="true" tabindex="-1"></a>(inv a) <span class="ot">`op`</span> a <span class="ot">=</span> e</span>
<span id="cb1130-2"><a href="#cb1130-2" aria-hidden="true" tabindex="-1"></a>a <span class="ot">`op`</span> (inv a) <span class="ot">=</span> e</span></code></pre></div>
<p>Haskell Predicates:</p>
<div class="sourceCode" id="cb1131"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1131-1"><a href="#cb1131-1" aria-hidden="true" tabindex="-1"></a><span class="ot">leftInverse ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1131-2"><a href="#cb1131-2" aria-hidden="true" tabindex="-1"></a>leftInverse op inv y x  <span class="ot">=</span>  inv x <span class="ot">`op`</span> x <span class="op">==</span> y</span>
<span id="cb1131-3"><a href="#cb1131-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1131-4"><a href="#cb1131-4" aria-hidden="true" tabindex="-1"></a><span class="ot">rightInverse ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1131-5"><a href="#cb1131-5" aria-hidden="true" tabindex="-1"></a>rightInverse op inv y x  <span class="ot">=</span>  x <span class="ot">`op`</span> inv x <span class="op">==</span> y</span>
<span id="cb1131-6"><a href="#cb1131-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1131-7"><a href="#cb1131-7" aria-hidden="true" tabindex="-1"></a><span class="ot">inverse ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1131-8"><a href="#cb1131-8" aria-hidden="true" tabindex="-1"></a>inverse op inv y x  <span class="ot">=</span>  leftInverse op inv y x <span class="op">&amp;&amp;</span> rightInverse op inv y x</span></code></pre></div>

<p><strong>Zeros</strong></p>
<p>Equations:</p>
<p><span class="math display"><em>a</em> × 0 = 0</span></p>
<p><span class="math display">0 × <em>a</em> = 0</span></p>
<p>Haskell</p>
<div class="sourceCode" id="cb1132"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1132-1"><a href="#cb1132-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">`op`</span> e <span class="ot">=</span> e</span>
<span id="cb1132-2"><a href="#cb1132-2" aria-hidden="true" tabindex="-1"></a>e <span class="ot">`op`</span> a <span class="ot">=</span> e</span></code></pre></div>
<p>Haskell Predicates:</p>
<div class="sourceCode" id="cb1133"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1133-1"><a href="#cb1133-1" aria-hidden="true" tabindex="-1"></a><span class="ot">leftZero ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1133-2"><a href="#cb1133-2" aria-hidden="true" tabindex="-1"></a>leftZero  <span class="ot">=</span>  <span class="fu">flip</span> <span class="op">.</span> rightIdentity</span>
<span id="cb1133-3"><a href="#cb1133-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1133-4"><a href="#cb1133-4" aria-hidden="true" tabindex="-1"></a><span class="ot">rightZero ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1133-5"><a href="#cb1133-5" aria-hidden="true" tabindex="-1"></a>rightZero  <span class="ot">=</span>  <span class="fu">flip</span> <span class="op">.</span> leftIdentity</span>
<span id="cb1133-6"><a href="#cb1133-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1133-7"><a href="#cb1133-7" aria-hidden="true" tabindex="-1"></a><span class="ot">zero ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1133-8"><a href="#cb1133-8" aria-hidden="true" tabindex="-1"></a>zero op x y  <span class="ot">=</span>  leftZero op x y  <span class="op">&amp;&amp;</span>  rightZero op x y</span></code></pre></div>

<p><strong>Linearity</strong></p>
<p>Equations:</p>
<p><span
class="math display"><em>f</em>(<em>x</em> + <em>y</em>) = <em>f</em>(<em>x</em>) + <em>f</em>(<em>y</em>)</span></p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1134"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1134-1"><a href="#cb1134-1" aria-hidden="true" tabindex="-1"></a>f (x <span class="ot">`op`</span> y) <span class="ot">=</span> f x <span class="ot">`op`</span> f y</span></code></pre></div>
<p>Haskell Predicates:</p>
<div class="sourceCode" id="cb1135"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1135-1"><a href="#cb1135-1" aria-hidden="true" tabindex="-1"></a><span class="ot">linear ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1135-2"><a href="#cb1135-2" aria-hidden="true" tabindex="-1"></a>linear f (<span class="op">#</span>) x y <span class="ot">=</span> f (x <span class="op">#</span> y) <span class="op">==</span> ((f x) <span class="op">#</span> (f y))</span></code></pre></div>

<p><strong>Idempotency</strong></p>
<p>Equations:</p>
<p><span
class="math display"><em>f</em>(<em>f</em>(<em>x</em>)) = <em>f</em>(<em>x</em>)</span></p>
<div class="sourceCode" id="cb1136"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1136-1"><a href="#cb1136-1" aria-hidden="true" tabindex="-1"></a>f (f x) <span class="ot">=</span> f x</span></code></pre></div>
<p>Haskell Predicates:</p>
<div class="sourceCode" id="cb1137"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1137-1"><a href="#cb1137-1" aria-hidden="true" tabindex="-1"></a><span class="ot">idempotent ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1137-2"><a href="#cb1137-2" aria-hidden="true" tabindex="-1"></a>idempotent f x <span class="ot">=</span> f (f x)</span></code></pre></div>

<p><strong>Distributivity</strong></p>
<p>Equations:</p>
<p><span
class="math display"><em>a</em> × (<em>b</em> + <em>c</em>) = (<em>a</em> × <em>b</em>) + (<em>a</em> × <em>c</em>)</span></p>
<p><span
class="math display">(<em>b</em> + <em>c</em>) × <em>a</em> = (<em>b</em> × <em>a</em>) + (<em>c</em> × <em>a</em>)</span></p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1138"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1138-1"><a href="#cb1138-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">`f`</span> (b <span class="ot">`g`</span> c) <span class="ot">=</span> (a <span class="ot">`f`</span> b) <span class="ot">`g`</span> (a <span class="ot">`f`</span> c)</span>
<span id="cb1138-2"><a href="#cb1138-2" aria-hidden="true" tabindex="-1"></a>(b <span class="ot">`g`</span> c) <span class="ot">`f`</span> a <span class="ot">=</span> (b <span class="ot">`f`</span> a) <span class="ot">`g`</span> (c <span class="ot">`f`</span> a)</span></code></pre></div>
<p>Haskell Predicates:</p>
<div class="sourceCode" id="cb1139"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1139-1"><a href="#cb1139-1" aria-hidden="true" tabindex="-1"></a><span class="ot">leftDistributive ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1139-2"><a href="#cb1139-2" aria-hidden="true" tabindex="-1"></a>leftDistributive ( <span class="op">#</span> ) op x y z  <span class="ot">=</span>  (y <span class="ot">`op`</span> z) <span class="op">#</span> x <span class="op">==</span> (y <span class="op">#</span> x) <span class="ot">`op`</span> (z <span class="op">#</span> x)</span>
<span id="cb1139-3"><a href="#cb1139-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1139-4"><a href="#cb1139-4" aria-hidden="true" tabindex="-1"></a><span class="ot">rightDistributive ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1139-5"><a href="#cb1139-5" aria-hidden="true" tabindex="-1"></a>rightDistributive ( <span class="op">#</span> ) op x y z  <span class="ot">=</span>  x <span class="op">#</span> (y <span class="ot">`op`</span> z) <span class="op">==</span> (x <span class="op">#</span> y) <span class="ot">`op`</span> (x <span class="op">#</span> z)</span>
<span id="cb1139-6"><a href="#cb1139-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1139-7"><a href="#cb1139-7" aria-hidden="true" tabindex="-1"></a><span class="ot">distributivity ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1139-8"><a href="#cb1139-8" aria-hidden="true" tabindex="-1"></a>distributivity op op&#39; x y z <span class="ot">=</span> op (op&#39; x y) z <span class="op">==</span> op&#39; (op x z) (op y z)</span>
<span id="cb1139-9"><a href="#cb1139-9" aria-hidden="true" tabindex="-1"></a>                           <span class="op">&amp;&amp;</span> op x (op&#39; y z) <span class="op">==</span> op&#39; (op x y) (op x z)</span></code></pre></div>

<p><strong>Anticommutativity</strong></p>
<p>Equations:</p>
<p><span
class="math display"><em>a</em> × <em>b</em> = (<em>b</em> × <em>a</em>)<sup>−1</sup></span></p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1140"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1140-1"><a href="#cb1140-1" aria-hidden="true" tabindex="-1"></a>a <span class="ot">`op`</span> b <span class="ot">=</span> inv (b <span class="ot">`op`</span> a)</span></code></pre></div>
<p>Haskell Predicates:</p>
<div class="sourceCode" id="cb1141"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1141-1"><a href="#cb1141-1" aria-hidden="true" tabindex="-1"></a><span class="ot">anticommutative ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1141-2"><a href="#cb1141-2" aria-hidden="true" tabindex="-1"></a>anticommutative inv op x y  <span class="ot">=</span>  x <span class="ot">`op`</span> y <span class="op">==</span> inv (y <span class="ot">`op`</span> x)</span></code></pre></div>

<p><strong>Homomorphisms</strong></p>
<p>Equations:</p>
<p><span
class="math display"><em>f</em>(<em>x</em> × <em>y</em>) = <em>f</em>(<em>x</em>) + <em>f</em>(<em>y</em>)</span></p>
<p>Haskell:</p>
<div class="sourceCode" id="cb1142"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1142-1"><a href="#cb1142-1" aria-hidden="true" tabindex="-1"></a>f (a <span class="ot">`op0`</span> b) <span class="ot">=</span> (f a) <span class="ot">`op1`</span> (f b)</span></code></pre></div>
<p>Haskell Predicates:</p>
<div class="sourceCode" id="cb1143"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1143-1"><a href="#cb1143-1" aria-hidden="true" tabindex="-1"></a><span class="ot">homomorphism ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span></span>
<span id="cb1143-2"><a href="#cb1143-2" aria-hidden="true" tabindex="-1"></a>   (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb1143-3"><a href="#cb1143-3" aria-hidden="true" tabindex="-1"></a>homomorphism f op0 op1 x y  <span class="ot">=</span>  f (x <span class="ot">`op0`</span> y) <span class="op">==</span> f x <span class="ot">`op1`</span> f y</span></code></pre></div>

<p>Combinations of these properties over multiple functions gives rise
to higher order systems of relations that occur over and over again
throughout functional programming, and once we recognize them we can
abstract over them. For instance a monoid is a combination of a unit and
a single associative operation over a set of values.</p>
<p>You will often see this notation in tuple form. Where a set
<code>S</code> (called the <strong>carrier</strong>) will be enriched
with a variety of operations and elements that are closed over that set.
For example a semigroup is a set equipped with an associative closed
binary operation. If you add an identity element <code>e</code> to the
semigroup you get a monoid.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Structure</th>
<th style="text-align: left;">Notation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Semigroup</td>
<td style="text-align: left;"><span
class="math inline">(<em>S</em>, •)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">Monoid</td>
<td style="text-align: left;"><span
class="math inline">(<em>S</em>, •, <em>e</em>)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">Monad</td>
<td style="text-align: left;"><span
class="math inline">(<em>S</em>, <em>μ</em>, <em>η</em>)</span></td>
</tr>
</tbody>
</table>
<h2 id="categories-1">Categories</h2>
<p>The most basic structure is a category which is an algebraic
structure of objects (<code>Obj</code>) and morphisms (<code>Hom</code>)
with the structure that morphisms compose associatively and the
existence of an identity morphism for each object. A category is defined
entirely in terms of its:</p>
<ul>
<li><strong>Elements</strong></li>
<li><strong>Morphisms</strong></li>
<li><strong>Composition Operation</strong></li>
</ul>
<p>A morphism <span class="math inline"><em>f</em></span> written as
<span class="math inline"><em>f</em> : <em>x</em> → <em>y</em></span> an
abstraction on the algebraic notion of homomorphisms. It is an arrow
between two objects in a category <span
class="math inline"><em>x</em></span> and <span
class="math inline"><em>y</em></span> called the <strong>domain</strong>
and <strong>codomain</strong> respectively. The set of all morphisms
between two given elements <span class="math inline"><em>x</em></span>
and <span class="math inline"><em>y</em></span> is called the
<strong>hom-set</strong> and written <span
class="math inline">Hom(<em>x</em>, <em>y</em>)</span>.</p>
<p>In Haskell, with kind polymorphism enabled we can write down the
general category parameterized by a type variable “c” for category. This
is the instance <code>Hask</code> the category of Haskell types with
functions between types as morphisms.</p>
<div class="sourceCode" id="cb1144"
data-include="src/33-categories/categories.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1144-1"><a href="#cb1144-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE PolyKinds #-}</span></span>
<span id="cb1144-2"><a href="#cb1144-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb1144-3"><a href="#cb1144-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></span>
<span id="cb1144-4"><a href="#cb1144-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1144-5"><a href="#cb1144-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((.), id)</span>
<span id="cb1144-6"><a href="#cb1144-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1144-7"><a href="#cb1144-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Morphisms</span></span>
<span id="cb1144-8"><a href="#cb1144-8" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (a <span class="op">~&gt;</span> b) c <span class="ot">=</span> c a b</span>
<span id="cb1144-9"><a href="#cb1144-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1144-10"><a href="#cb1144-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> (<span class="ot">c ::</span> k <span class="ot">-&gt;</span> k <span class="ot">-&gt;</span> <span class="op">*</span>) <span class="kw">where</span></span>
<span id="cb1144-11"><a href="#cb1144-11" aria-hidden="true" tabindex="-1"></a><span class="ot">  id ::</span> (a <span class="op">~&gt;</span> a) c</span>
<span id="cb1144-12"><a href="#cb1144-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  (.) ::</span> (y <span class="op">~&gt;</span> z) c <span class="ot">-&gt;</span> (x <span class="op">~&gt;</span> y) c <span class="ot">-&gt;</span> (x <span class="op">~&gt;</span> z) c</span>
<span id="cb1144-13"><a href="#cb1144-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1144-14"><a href="#cb1144-14" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Hask</span> <span class="ot">=</span> (<span class="ot">-&gt;</span>)</span>
<span id="cb1144-15"><a href="#cb1144-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1144-16"><a href="#cb1144-16" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Hask</span> <span class="kw">where</span></span>
<span id="cb1144-17"><a href="#cb1144-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> x <span class="ot">=</span> x</span>
<span id="cb1144-18"><a href="#cb1144-18" aria-hidden="true" tabindex="-1"></a>  (f <span class="op">.</span> g) x <span class="ot">=</span> f (g x)</span></code></pre></div>
<p>Categories are interesting since they exhibit various composition
properties and ways in which various elements in the category can be
composed and rewritten while preserving several invariants about the
program.</p>
<p>Some annoying curmudgeons will sometimes pit nicks about this not
being a “real category” because all Haskell values are potentially
inhabited by a bottom type which violates several rules of composition.
This is mostly silly nit-picking and for the sake of discussion we’ll
consider “ideal Haskell” which does not have this property.</p>
<h2 id="isomorphisms">Isomorphisms</h2>
<p>Two objects of a category are said to be isomorphic if we can
construct a morphism with 2-sided inverse that takes the structure of an
object to another form and back to itself when inverted.</p>
<div class="sourceCode" id="cb1145"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1145-1"><a href="#cb1145-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f  ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb1145-2"><a href="#cb1145-2" aria-hidden="true" tabindex="-1"></a><span class="ot">f&#39; ::</span> b <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Such that:</p>
<div class="sourceCode" id="cb1146"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1146-1"><a href="#cb1146-1" aria-hidden="true" tabindex="-1"></a>f  <span class="op">.</span> f&#39; <span class="ot">=</span> <span class="fu">id</span></span>
<span id="cb1146-2"><a href="#cb1146-2" aria-hidden="true" tabindex="-1"></a>f&#39; <span class="op">.</span> f  <span class="ot">=</span> <span class="fu">id</span></span></code></pre></div>
<p>For example the types <code>Either () a</code> and
<code>Maybe a</code> are isomorphic.</p>
<div class="sourceCode" id="cb1147"
data-include="src/33-categories/iso.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1147-1"><a href="#cb1147-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span></span>
<span id="cb1147-2"><a href="#cb1147-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1147-3"><a href="#cb1147-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Iso</span> a b <span class="ot">=</span> <span class="dt">Iso</span> {<span class="ot"> to ::</span> a <span class="ot">-&gt;</span> b,<span class="ot"> from ::</span> b <span class="ot">-&gt;</span> a }</span>
<span id="cb1147-4"><a href="#cb1147-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1147-5"><a href="#cb1147-5" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> () a</span>
<span id="cb1147-6"><a href="#cb1147-6" aria-hidden="true" tabindex="-1"></a>f (<span class="dt">Just</span> a) <span class="ot">=</span> <span class="dt">Right</span> a</span>
<span id="cb1147-7"><a href="#cb1147-7" aria-hidden="true" tabindex="-1"></a>f <span class="dt">Nothing</span>  <span class="ot">=</span> <span class="dt">Left</span> ()</span>
<span id="cb1147-8"><a href="#cb1147-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1147-9"><a href="#cb1147-9" aria-hidden="true" tabindex="-1"></a><span class="ot">f&#39; ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Either</span> () a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb1147-10"><a href="#cb1147-10" aria-hidden="true" tabindex="-1"></a>f&#39; (<span class="dt">Left</span> _)  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1147-11"><a href="#cb1147-11" aria-hidden="true" tabindex="-1"></a>f&#39; (<span class="dt">Right</span> a) <span class="ot">=</span> <span class="dt">Just</span> a</span>
<span id="cb1147-12"><a href="#cb1147-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1147-13"><a href="#cb1147-13" aria-hidden="true" tabindex="-1"></a><span class="ot">iso ::</span> <span class="dt">Iso</span> (<span class="dt">Maybe</span> a) (<span class="dt">Either</span> () a)</span>
<span id="cb1147-14"><a href="#cb1147-14" aria-hidden="true" tabindex="-1"></a>iso <span class="ot">=</span> <span class="dt">Iso</span> f f&#39;</span>
<span id="cb1147-15"><a href="#cb1147-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1147-16"><a href="#cb1147-16" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">V</span> <span class="ot">=</span> <span class="dt">V</span> <span class="kw">deriving</span> <span class="dt">Eq</span></span>
<span id="cb1147-17"><a href="#cb1147-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1147-18"><a href="#cb1147-18" aria-hidden="true" tabindex="-1"></a>ex1 <span class="ot">=</span> f  (f&#39; (<span class="dt">Right</span> <span class="dt">V</span>)) <span class="op">==</span> <span class="dt">Right</span> <span class="dt">V</span></span>
<span id="cb1147-19"><a href="#cb1147-19" aria-hidden="true" tabindex="-1"></a>ex2 <span class="ot">=</span> f&#39; (f  (<span class="dt">Just</span> <span class="dt">V</span>))  <span class="op">==</span> <span class="dt">Just</span> <span class="dt">V</span></span></code></pre></div>
<div class="sourceCode" id="cb1148"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1148-1"><a href="#cb1148-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Iso</span> a b <span class="ot">=</span> <span class="dt">Iso</span> {<span class="ot"> to ::</span> a <span class="ot">-&gt;</span> b,<span class="ot"> from ::</span> b <span class="ot">-&gt;</span> a }</span>
<span id="cb1148-2"><a href="#cb1148-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1148-3"><a href="#cb1148-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Iso</span> <span class="kw">where</span></span>
<span id="cb1148-4"><a href="#cb1148-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="ot">=</span> <span class="dt">Iso</span> <span class="fu">id</span> <span class="fu">id</span></span>
<span id="cb1148-5"><a href="#cb1148-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Iso</span> f f&#39;) <span class="op">.</span> (<span class="dt">Iso</span> g g&#39;) <span class="ot">=</span> <span class="dt">Iso</span> (f <span class="op">.</span> g) (g&#39; <span class="op">.</span> f&#39;)</span></code></pre></div>
<h2 id="duality">Duality</h2>
<p>One of the central ideas is the notion of duality, that reversing
some internal structure yields a new structure with a “mirror” set of
theorems. The dual of a category reverse the direction of the morphisms
forming the category C<sup>Op</sup>.</p>
<div class="sourceCode" id="cb1149"
data-include="src/33-categories/dual.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1149-1"><a href="#cb1149-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span></span>
<span id="cb1149-2"><a href="#cb1149-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((.), id)</span>
<span id="cb1149-3"><a href="#cb1149-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1149-4"><a href="#cb1149-4" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Op</span> a b <span class="ot">=</span> <span class="dt">Op</span> (b <span class="ot">-&gt;</span> a)</span>
<span id="cb1149-5"><a href="#cb1149-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1149-6"><a href="#cb1149-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Category</span> <span class="dt">Op</span> <span class="kw">where</span></span>
<span id="cb1149-7"><a href="#cb1149-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="ot">=</span> <span class="dt">Op</span> <span class="fu">id</span></span>
<span id="cb1149-8"><a href="#cb1149-8" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">Op</span> f) <span class="op">.</span> (<span class="dt">Op</span> g) <span class="ot">=</span> <span class="dt">Op</span> (g <span class="op">.</span> f)</span></code></pre></div>
<p>See:</p>
<ul>
<li><a
href="http://blog.ezyang.com/2012/10/duality-for-haskellers/">Duality
for Haskellers</a></li>
</ul>
<h2 id="functors">Functors</h2>
<p>Functors are mappings between the objects and morphisms of categories
that preserve identities and composition.</p>
<div class="sourceCode" id="cb1150"
data-include="src/33-categories/functors.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1150-1"><a href="#cb1150-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb1150-2"><a href="#cb1150-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></span>
<span id="cb1150-3"><a href="#cb1150-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1150-4"><a href="#cb1150-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span></span>
<span id="cb1150-5"><a href="#cb1150-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (<span class="dt">Functor</span>, fmap, id)</span>
<span id="cb1150-6"><a href="#cb1150-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1150-7"><a href="#cb1150-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Category</span> c, <span class="dt">Category</span> d) <span class="ot">=&gt;</span> <span class="dt">Functor</span> c d t <span class="kw">where</span></span>
<span id="cb1150-8"><a href="#cb1150-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  fmap ::</span> c a b <span class="ot">-&gt;</span> d (t a) (t b)</span>
<span id="cb1150-9"><a href="#cb1150-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1150-10"><a href="#cb1150-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Hask</span> <span class="ot">=</span> (<span class="ot">-&gt;</span>)</span>
<span id="cb1150-11"><a href="#cb1150-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1150-12"><a href="#cb1150-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Hask</span> <span class="dt">Hask</span> [] <span class="kw">where</span></span>
<span id="cb1150-13"><a href="#cb1150-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f [] <span class="ot">=</span> []</span>
<span id="cb1150-14"><a href="#cb1150-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fmap</span> f (x <span class="op">:</span> xs) <span class="ot">=</span> f x <span class="op">:</span> (<span class="fu">fmap</span> f xs)</span></code></pre></div>
<div class="sourceCode" id="cb1151"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1151-1"><a href="#cb1151-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> <span class="fu">id</span> ≡ <span class="fu">id</span></span>
<span id="cb1151-2"><a href="#cb1151-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (a <span class="op">.</span> b) ≡ (<span class="fu">fmap</span> a) <span class="op">.</span> (<span class="fu">fmap</span> b)</span></code></pre></div>
<h2 id="natural-transformations">Natural Transformations</h2>
<p>Natural transformations are mappings between functors that are
invariant under interchange of morphism composition order.</p>
<div class="sourceCode" id="cb1152"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1152-1"><a href="#cb1152-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Nat</span> f g <span class="ot">=</span> <span class="kw">forall</span> a<span class="op">.</span> f a <span class="ot">-&gt;</span> g a</span></code></pre></div>
<p>Such that for a natural transformation <code>h</code> we have:</p>
<div class="sourceCode" id="cb1153"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1153-1"><a href="#cb1153-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f <span class="op">.</span> h ≡ h <span class="op">.</span> <span class="fu">fmap</span> f</span></code></pre></div>
<p>The simplest example is between (<code>f = List</code>) and
(<code>g = Maybe</code>) types.</p>
<div class="sourceCode" id="cb1154"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1154-1"><a href="#cb1154-1" aria-hidden="true" tabindex="-1"></a><span class="ot">headMay ::</span> <span class="kw">forall</span> a<span class="op">.</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb1154-2"><a href="#cb1154-2" aria-hidden="true" tabindex="-1"></a>headMay []     <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1154-3"><a href="#cb1154-3" aria-hidden="true" tabindex="-1"></a>headMay (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="dt">Just</span> x</span></code></pre></div>
<p>Regardless of how we chase <code>safeHead</code>, we end up with the
same result.</p>
<div class="sourceCode" id="cb1155"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1155-1"><a href="#cb1155-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (headMay xs) ≡ headMay (<span class="fu">fmap</span> f xs)</span></code></pre></div>
<div class="sourceCode" id="cb1156"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1156-1"><a href="#cb1156-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (headMay [])</span>
<span id="cb1156-2"><a href="#cb1156-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="fu">fmap</span> f <span class="dt">Nothing</span></span>
<span id="cb1156-3"><a href="#cb1156-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1156-4"><a href="#cb1156-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1156-5"><a href="#cb1156-5" aria-hidden="true" tabindex="-1"></a>headMay (<span class="fu">fmap</span> f [])</span>
<span id="cb1156-6"><a href="#cb1156-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> headMay []</span>
<span id="cb1156-7"><a href="#cb1156-7" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<div class="sourceCode" id="cb1157"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1157-1"><a href="#cb1157-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> f (headMay (x<span class="op">:</span>xs))</span>
<span id="cb1157-2"><a href="#cb1157-2" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="fu">fmap</span> f (<span class="dt">Just</span> x)</span>
<span id="cb1157-3"><a href="#cb1157-3" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Just</span> (f x)</span>
<span id="cb1157-4"><a href="#cb1157-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1157-5"><a href="#cb1157-5" aria-hidden="true" tabindex="-1"></a>headMay (<span class="fu">fmap</span> f (x<span class="op">:</span>xs))</span>
<span id="cb1157-6"><a href="#cb1157-6" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> headMay [f x]</span>
<span id="cb1157-7"><a href="#cb1157-7" aria-hidden="true" tabindex="-1"></a><span class="ot">=</span> <span class="dt">Just</span> (f x)</span></code></pre></div>
<p>Or consider the Functor <code>(-&gt;)</code>.</p>
<div class="sourceCode" id="cb1158"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1158-1"><a href="#cb1158-1" aria-hidden="true" tabindex="-1"></a><span class="ot">f ::</span> (<span class="dt">Functor</span> t)</span>
<span id="cb1158-2"><a href="#cb1158-2" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (<span class="ot">-&gt;</span>) a b</span>
<span id="cb1158-3"><a href="#cb1158-3" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (t a) (t b)</span>
<span id="cb1158-4"><a href="#cb1158-4" aria-hidden="true" tabindex="-1"></a>f <span class="ot">=</span> <span class="fu">fmap</span></span>
<span id="cb1158-5"><a href="#cb1158-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1158-6"><a href="#cb1158-6" aria-hidden="true" tabindex="-1"></a><span class="ot">g ::</span> (b <span class="ot">-&gt;</span> c)</span>
<span id="cb1158-7"><a href="#cb1158-7" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) a b</span>
<span id="cb1158-8"><a href="#cb1158-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) a c</span>
<span id="cb1158-9"><a href="#cb1158-9" aria-hidden="true" tabindex="-1"></a>g <span class="ot">=</span> (<span class="op">.</span>)</span>
<span id="cb1158-10"><a href="#cb1158-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1158-11"><a href="#cb1158-11" aria-hidden="true" tabindex="-1"></a><span class="ot">c ::</span> (<span class="dt">Functor</span> t)</span>
<span id="cb1158-12"><a href="#cb1158-12" aria-hidden="true" tabindex="-1"></a>  <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> c)</span>
<span id="cb1158-13"><a href="#cb1158-13" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (t a) (t b)</span>
<span id="cb1158-14"><a href="#cb1158-14" aria-hidden="true" tabindex="-1"></a>  <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (t a) (t c)</span>
<span id="cb1158-15"><a href="#cb1158-15" aria-hidden="true" tabindex="-1"></a>c <span class="ot">=</span> f <span class="op">.</span> g</span></code></pre></div>
<div class="sourceCode" id="cb1159"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1159-1"><a href="#cb1159-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">.</span> g x <span class="ot">=</span> c x <span class="op">.</span> g</span></code></pre></div>
<p>A lot of the expressive power of Haskell types comes from the
interesting fact that, with a few caveats, polymorphic Haskell functions
are natural transformations.</p>
<p>See: <a
href="http://blog.sigfpe.com/2008/05/you-could-have-defined-natural.html">You
Could Have Defined Natural Transformations</a></p>
<h2 id="kleisli-category">Kleisli Category</h2>
<p>Kleisli composition (i.e. Kleisli Fish) is defined to be:</p>
<div class="sourceCode" id="cb1160"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1160-1"><a href="#cb1160-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;=&gt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m c</span>
<span id="cb1160-2"><a href="#cb1160-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> g ≡ \x <span class="ot">-&gt;</span> f x <span class="op">&gt;&gt;=</span> g</span>
<span id="cb1160-3"><a href="#cb1160-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1160-4"><a href="#cb1160-4" aria-hidden="true" tabindex="-1"></a><span class="ot">(&lt;=&lt;) ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m c</span>
<span id="cb1160-5"><a href="#cb1160-5" aria-hidden="true" tabindex="-1"></a>(<span class="op">&lt;=&lt;</span>) <span class="ot">=</span> <span class="fu">flip</span> (<span class="op">&gt;=&gt;</span>)</span></code></pre></div>
<p>The monad laws stated in terms of the Kleisli category of a monad
<code>m</code> are stated much more symmetrically as one associativity
law and two identity laws.</p>
<div class="sourceCode" id="cb1161"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1161-1"><a href="#cb1161-1" aria-hidden="true" tabindex="-1"></a>(f <span class="op">&gt;=&gt;</span> g) <span class="op">&gt;=&gt;</span> h ≡ f <span class="op">&gt;=&gt;</span> (g <span class="op">&gt;=&gt;</span> h)</span>
<span id="cb1161-2"><a href="#cb1161-2" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> <span class="op">&gt;=&gt;</span> f ≡ f</span>
<span id="cb1161-3"><a href="#cb1161-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> <span class="fu">return</span> ≡  f</span></code></pre></div>
<p>Stated simply that the monad laws above are just the category laws in
the Kleisli category.</p>
<div class="sourceCode" id="cb1162"
data-include="src/33-categories/kleisli.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1162-1"><a href="#cb1162-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeOperators #-}</span></span>
<span id="cb1162-2"><a href="#cb1162-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE ExplicitForAll #-}</span></span>
<span id="cb1162-3"><a href="#cb1162-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1162-4"><a href="#cb1162-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb1162-5"><a href="#cb1162-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Category</span></span>
<span id="cb1162-6"><a href="#cb1162-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((.))</span>
<span id="cb1162-7"><a href="#cb1162-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1162-8"><a href="#cb1162-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- Kleisli category</span></span>
<span id="cb1162-9"><a href="#cb1162-9" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Kleisli</span> m a b <span class="ot">=</span> <span class="dt">K</span> (a <span class="ot">-&gt;</span> m b)</span>
<span id="cb1162-10"><a href="#cb1162-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1162-11"><a href="#cb1162-11" aria-hidden="true" tabindex="-1"></a><span class="co">-- Kleisli morphisms ( a -&gt; m b )</span></span>
<span id="cb1162-12"><a href="#cb1162-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> (a <span class="op">:~&gt;</span> b) m <span class="ot">=</span> <span class="dt">Kleisli</span> m a b</span>
<span id="cb1162-13"><a href="#cb1162-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1162-14"><a href="#cb1162-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Category</span> (<span class="dt">Kleisli</span> m) <span class="kw">where</span></span>
<span id="cb1162-15"><a href="#cb1162-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span>            <span class="ot">=</span> <span class="dt">K</span> <span class="fu">return</span></span>
<span id="cb1162-16"><a href="#cb1162-16" aria-hidden="true" tabindex="-1"></a>  (<span class="dt">K</span> f) <span class="op">.</span> (<span class="dt">K</span> g) <span class="ot">=</span> <span class="dt">K</span> (f <span class="op">&lt;=&lt;</span> g)</span>
<span id="cb1162-17"><a href="#cb1162-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1162-18"><a href="#cb1162-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1162-19"><a href="#cb1162-19" aria-hidden="true" tabindex="-1"></a><span class="ot">just ::</span> (a <span class="op">:~&gt;</span> a) <span class="dt">Maybe</span></span>
<span id="cb1162-20"><a href="#cb1162-20" aria-hidden="true" tabindex="-1"></a>just <span class="ot">=</span> <span class="dt">K</span> <span class="dt">Just</span></span>
<span id="cb1162-21"><a href="#cb1162-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1162-22"><a href="#cb1162-22" aria-hidden="true" tabindex="-1"></a><span class="ot">left ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="op">:~&gt;</span> b) <span class="dt">Maybe</span> <span class="ot">-&gt;</span> (a <span class="op">:~&gt;</span> b) <span class="dt">Maybe</span></span>
<span id="cb1162-23"><a href="#cb1162-23" aria-hidden="true" tabindex="-1"></a>left f <span class="ot">=</span> just <span class="op">.</span> f</span>
<span id="cb1162-24"><a href="#cb1162-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1162-25"><a href="#cb1162-25" aria-hidden="true" tabindex="-1"></a><span class="ot">right ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="op">:~&gt;</span> b) <span class="dt">Maybe</span> <span class="ot">-&gt;</span> (a <span class="op">:~&gt;</span> b) <span class="dt">Maybe</span></span>
<span id="cb1162-26"><a href="#cb1162-26" aria-hidden="true" tabindex="-1"></a>right f <span class="ot">=</span> f <span class="op">.</span> just</span></code></pre></div>
<p>For example, <code>Just</code> is just an identity morphism in the
Kleisli category of the <code>Maybe</code> monad.</p>
<div class="sourceCode" id="cb1163"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1163-1"><a href="#cb1163-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> <span class="op">&gt;=&gt;</span> f ≡ f</span>
<span id="cb1163-2"><a href="#cb1163-2" aria-hidden="true" tabindex="-1"></a>f <span class="op">&gt;=&gt;</span> <span class="dt">Just</span> ≡ f</span></code></pre></div>
<h2 id="monoidal-categories">Monoidal Categories</h2>
<p>On top of the basic category structure there are other higher-level
objects that can be constructed that enrich the category with additional
operations.</p>
<ul>
<li>A <strong>bifunctor</strong> is a functor whose domain is the
product of two categories.</li>
<li>A <strong>monoidal category</strong> is a category which has a
tensor product and a unit object.</li>
<li>A <strong>braided monoidal category</strong> is a category which has
tensor product and an operation <code>braid</code> which swaps elements
in the tensor product.</li>
<li>A <strong>cartesian monoidal category</strong> is a is a monoidal
category with, binary product, and diagonal.</li>
<li>A <strong>cartesian closed category</strong> has is a monoidal
category with a terminal object, binary products and exponential
objects.</li>
</ul>
<div class="sourceCode" id="cb1164"
data-include="src/33-categories/monoidal.hs"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1164-1"><a href="#cb1164-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></span>
<span id="cb1164-2"><a href="#cb1164-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb1164-3"><a href="#cb1164-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span></span>
<span id="cb1164-4"><a href="#cb1164-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1164-5"><a href="#cb1164-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((.))</span>
<span id="cb1164-6"><a href="#cb1164-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1164-7"><a href="#cb1164-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> k <span class="kw">where</span></span>
<span id="cb1164-8"><a href="#cb1164-8" aria-hidden="true" tabindex="-1"></a><span class="ot">  id ::</span> k a a</span>
<span id="cb1164-9"><a href="#cb1164-9" aria-hidden="true" tabindex="-1"></a><span class="ot">  (.) ::</span> k b c <span class="ot">-&gt;</span> k a b <span class="ot">-&gt;</span> k a c</span>
<span id="cb1164-10"><a href="#cb1164-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1164-11"><a href="#cb1164-11" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Category</span> k <span class="ot">=&gt;</span> <span class="dt">Bifunctor</span> k p <span class="kw">where</span></span>
<span id="cb1164-12"><a href="#cb1164-12" aria-hidden="true" tabindex="-1"></a><span class="ot">  bimap ::</span> k a b <span class="ot">-&gt;</span> k a&#39; b&#39; <span class="ot">-&gt;</span> k (p a a&#39;) (p b b&#39;)</span>
<span id="cb1164-13"><a href="#cb1164-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1164-14"><a href="#cb1164-14" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Bifunctor</span> k p <span class="ot">=&gt;</span> <span class="dt">Associative</span> k p <span class="kw">where</span></span>
<span id="cb1164-15"><a href="#cb1164-15" aria-hidden="true" tabindex="-1"></a><span class="ot">  associate ::</span> k (p (p a b) c) (p a (p b c))</span>
<span id="cb1164-16"><a href="#cb1164-16" aria-hidden="true" tabindex="-1"></a><span class="ot">  coassociate ::</span> k (p a (p b c)) (p (p a b) c)</span>
<span id="cb1164-17"><a href="#cb1164-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1164-18"><a href="#cb1164-18" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Associative</span> k p <span class="ot">=&gt;</span> <span class="dt">Monoidal</span> k p i <span class="op">|</span> k p <span class="ot">-&gt;</span> i <span class="kw">where</span></span>
<span id="cb1164-19"><a href="#cb1164-19" aria-hidden="true" tabindex="-1"></a><span class="ot">  idl ::</span> k (p i a) a</span>
<span id="cb1164-20"><a href="#cb1164-20" aria-hidden="true" tabindex="-1"></a><span class="ot">  idr ::</span> k (p a i) a</span>
<span id="cb1164-21"><a href="#cb1164-21" aria-hidden="true" tabindex="-1"></a><span class="ot">  coidl ::</span> k a (p i a)</span>
<span id="cb1164-22"><a href="#cb1164-22" aria-hidden="true" tabindex="-1"></a><span class="ot">  coidr ::</span> k a (p a i)</span>
<span id="cb1164-23"><a href="#cb1164-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1164-24"><a href="#cb1164-24" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Braided</span> k p <span class="kw">where</span></span>
<span id="cb1164-25"><a href="#cb1164-25" aria-hidden="true" tabindex="-1"></a><span class="ot">  braid ::</span> k (p a b) (p b a)</span>
<span id="cb1164-26"><a href="#cb1164-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1164-27"><a href="#cb1164-27" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Monoidal</span> k prod i, <span class="dt">Braided</span> k prod) <span class="ot">=&gt;</span> <span class="dt">Cartesian</span> k prod i <span class="op">|</span> k <span class="ot">-&gt;</span> prod i <span class="kw">where</span></span>
<span id="cb1164-28"><a href="#cb1164-28" aria-hidden="true" tabindex="-1"></a><span class="ot">  fst ::</span> k (prod a b) a</span>
<span id="cb1164-29"><a href="#cb1164-29" aria-hidden="true" tabindex="-1"></a><span class="ot">  snd ::</span> k (prod a b) b</span>
<span id="cb1164-30"><a href="#cb1164-30" aria-hidden="true" tabindex="-1"></a><span class="ot">  diag ::</span> k a (prod a a)</span>
<span id="cb1164-31"><a href="#cb1164-31" aria-hidden="true" tabindex="-1"></a><span class="ot">  (&amp;&amp;&amp;) ::</span> k a b <span class="ot">-&gt;</span> k a c <span class="ot">-&gt;</span> k a (prod b c)</span>
<span id="cb1164-32"><a href="#cb1164-32" aria-hidden="true" tabindex="-1"></a>  f <span class="op">&amp;&amp;&amp;</span> g <span class="ot">=</span> (f <span class="ot">`bimap`</span> g) <span class="op">.</span> diag</span>
<span id="cb1164-33"><a href="#cb1164-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1164-34"><a href="#cb1164-34" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Cartesian</span> k p i <span class="ot">=&gt;</span> <span class="dt">CCC</span> k p i e <span class="op">|</span> k <span class="ot">-&gt;</span> p i e <span class="kw">where</span></span>
<span id="cb1164-35"><a href="#cb1164-35" aria-hidden="true" tabindex="-1"></a><span class="ot">  apply ::</span> k (p (e a b) a) b</span>
<span id="cb1164-36"><a href="#cb1164-36" aria-hidden="true" tabindex="-1"></a><span class="ot">  curry ::</span> k (p a b) c <span class="ot">-&gt;</span> k a (e b c)</span>
<span id="cb1164-37"><a href="#cb1164-37" aria-hidden="true" tabindex="-1"></a><span class="ot">  uncurry ::</span> k a (e b c) <span class="ot">-&gt;</span> k (p a b) c</span></code></pre></div>
<p>An example of this tower is is the <code>Hask</code> with
<code>(-&gt;)</code> as exponential, <code>(,)</code> as product and
<code>()</code> as unit object.</p>
<div class="sourceCode" id="cb1165"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1165-1"><a href="#cb1165-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Hask</span> <span class="ot">=</span> (<span class="ot">-&gt;</span>)</span>
<span id="cb1165-2"><a href="#cb1165-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1165-3"><a href="#cb1165-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Category</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb1165-4"><a href="#cb1165-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">id</span> <span class="ot">=</span> Prelude.id</span>
<span id="cb1165-5"><a href="#cb1165-5" aria-hidden="true" tabindex="-1"></a>  (<span class="op">.</span>) <span class="ot">=</span> (<span class="op">Prelude..</span>)</span>
<span id="cb1165-6"><a href="#cb1165-6" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1165-7"><a href="#cb1165-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Bifunctor</span> (<span class="ot">-&gt;</span>) (,) <span class="kw">where</span></span>
<span id="cb1165-8"><a href="#cb1165-8" aria-hidden="true" tabindex="-1"></a>  bimap f g <span class="ot">=</span> \(a,b) <span class="ot">-&gt;</span> (f a,g b)</span>
<span id="cb1165-9"><a href="#cb1165-9" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1165-10"><a href="#cb1165-10" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Associative</span> (<span class="ot">-&gt;</span>) (,) <span class="kw">where</span></span>
<span id="cb1165-11"><a href="#cb1165-11" aria-hidden="true" tabindex="-1"></a>  associate ((a,b),c) <span class="ot">=</span> (a,(b,c))</span>
<span id="cb1165-12"><a href="#cb1165-12" aria-hidden="true" tabindex="-1"></a>  coassociate (a,(b,c)) <span class="ot">=</span> ((a,b),c)</span>
<span id="cb1165-13"><a href="#cb1165-13" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1165-14"><a href="#cb1165-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monoidal</span> (<span class="ot">-&gt;</span>) (,) () <span class="kw">where</span></span>
<span id="cb1165-15"><a href="#cb1165-15" aria-hidden="true" tabindex="-1"></a>  idl ((),a) <span class="ot">=</span> a</span>
<span id="cb1165-16"><a href="#cb1165-16" aria-hidden="true" tabindex="-1"></a>  idr (a,()) <span class="ot">=</span> a</span>
<span id="cb1165-17"><a href="#cb1165-17" aria-hidden="true" tabindex="-1"></a>  coidl a <span class="ot">=</span> ((),a)</span>
<span id="cb1165-18"><a href="#cb1165-18" aria-hidden="true" tabindex="-1"></a>  coidr a <span class="ot">=</span> (a,())</span>
<span id="cb1165-19"><a href="#cb1165-19" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1165-20"><a href="#cb1165-20" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Braided</span> (<span class="ot">-&gt;</span>) (,) <span class="kw">where</span></span>
<span id="cb1165-21"><a href="#cb1165-21" aria-hidden="true" tabindex="-1"></a>  braid (a,b) <span class="ot">=</span> (b,a)</span>
<span id="cb1165-22"><a href="#cb1165-22" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1165-23"><a href="#cb1165-23" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Cartesian</span> (<span class="ot">-&gt;</span>) (,) () <span class="kw">where</span></span>
<span id="cb1165-24"><a href="#cb1165-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fst</span> <span class="ot">=</span> Prelude.fst</span>
<span id="cb1165-25"><a href="#cb1165-25" aria-hidden="true" tabindex="-1"></a>  <span class="fu">snd</span> <span class="ot">=</span> Prelude.snd</span>
<span id="cb1165-26"><a href="#cb1165-26" aria-hidden="true" tabindex="-1"></a>  diag x <span class="ot">=</span> (x,x)</span>
<span id="cb1165-27"><a href="#cb1165-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1165-28"><a href="#cb1165-28" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">CCC</span> (<span class="ot">-&gt;</span>) (,) () (<span class="ot">-&gt;</span>) <span class="kw">where</span></span>
<span id="cb1165-29"><a href="#cb1165-29" aria-hidden="true" tabindex="-1"></a>  apply (f,a) <span class="ot">=</span> f a</span>
<span id="cb1165-30"><a href="#cb1165-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">curry</span> <span class="ot">=</span> Prelude.curry</span>
<span id="cb1165-31"><a href="#cb1165-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">uncurry</span> <span class="ot">=</span> Prelude.uncurry</span></code></pre></div>
<h2 id="further-resources">Further Resources</h2>
<p>Category theory is an entire branch of mathematics that should be
studeid independently of Haskell and programming. The classic text is
“Category Theory” by Awodey. This text assumes a undergraduate level
mathematics background.</p>
<ul>
<li><a
href="http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182">Category
Theory, Awodey</a></li>
</ul>
<p>For a programming perspective there are several lectures and
functional programming oriented resources:</p>
<ul>
<li><a href="https://github.com/hmemcpy/milewski-ctfp-pdf">Category
Theory for Programmers PDF</a></li>
<li><a
href="https://www.youtube.com/watch?v=I8LbkfSSR58&amp;list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_">Category
Theory for Programmers Lectures</a></li>
<li><a href="https://www.youtube.com/watch?v=ZKmodCApZwk">Category
Theory Foundations</a></li>
</ul>
<hr/>
<h1 id="source-code">Source Code</h1>
<p>All code is available from this Github repository. This code is
dedicated to the public domain. You can copy, modify, distribute and
perform the work, even for commercial purposes, all without asking
permission.</p>
<p><strong>https://github.com/sdiehl/wiwinwlh</strong></p>
<p>Chapters:</p>
<ul>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/01-basics/">01-basics/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/02-monads/">02-monads/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/03-monad-transformers/">03-monad-transformers/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/04-extensions/">04-extensions/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/05-laziness/">05-laziness/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/06-prelude/">06-prelude/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/07-text-bytestring/">07-text-bytestring/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/08-applicatives/">08-applicatives/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/09-errors/">09-errors/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/10-advanced-monads/">10-advanced-monads/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/11-quantification/">11-quantification/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/12-gadts/">12-gadts/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/13-lambda-calculus/">13-lambda-calculus/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/14-interpreters/">14-interpreters/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/15-testing/">15-testing/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/16-type-families/">16-type-families/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/17-promotion/">17-promotion/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/18-generics/">18-generics/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/19-numbers/">19-numbers/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/20-data-structures/">20-data-structures/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/21-ffi/">21-ffi/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/22-concurrency/">22-concurrency/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/23-graphics/">23-graphics/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/24-parsing/">24-parsing/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/25-streaming/">25-streaming/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/26-data-formats/">26-data-formats/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/27-web/">27-web/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/28-databases/">28-databases/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/29-ghc/">29-ghc/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/30-languages/">30-languages/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/31-template-haskell/">31-template-haskell/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/32-cryptography">32-cryptography/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/33-categories/">33-categories/</a></li>
<li><a
href="https://github.com/sdiehl/wiwinwlh/tree/master/src/34-time/">34-time/</a></li>
</ul>
      </div>
    </div>

    <script src="https://code.jquery.com/jquery.js"></script>
    <script src="js/nav.js"></script>
  </body>
</html>
